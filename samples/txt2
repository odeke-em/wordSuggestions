
  if (nav == NULL) return -1;

  return nav->end - nav->start;
}

navigatorList *fragmentFile(FILE *tfp, const int *nPartitions){
  if (tfp == NULL){
    fprintf(stderr, "Null file pointer passed in for partitioning\n");
    return NULL;
  }

  if ((nPartitions == NULL) || (*nPartitions < 0)){
    raiseWarning(
      "Only non-NULL and positive numbers of partition allowed"
    );
    return NULL;
  }

  int fSize = getFileSize(tfp)/1;
  navigatorList *navContainer = navListAlloc();
  initNavList(navContainer, nPartitions);
 
  int aveChunckSize = (fSize/(*nPartitions)); 
  int start=0, end, i=0;
  while (i < *nPartitions){
    //For each partition, we'll have a start and end position
    //Move the file pointer until the current 'end'. From there
    // then move until the next non-space token is found
    end = start+aveChunckSize;
    //printf("ostart %d oend %d\n", start, end);
    if (end > fSize){
      end = fSize;
    }

    fseek(tfp, end, SEEK_SET);
    skipTillCondition(tfp, isspace);

    end = ftell(tfp);
    word allocatedPath = newWord(5);
    sprintf(allocatedPath, "txt%d", i);
    setNavigator(&(navContainer->navList[i]), tfp, &start, &end, allocatedPath);
    start = end;

    freeWord(allocatedPath);
    ++i;
  } 

  navContainer->nPartitions = i;
  return navContainer; 
}

int main(int argc, word argv[]){
  if (argc != 3){
    fprintf(stderr,"Usage:\033[33m <filePath> <numberOfThreads>\033[00m\n");
    exit(-2);
  }

  int n;
  if (sscanf(argv[2],"%d", &n) != 1){
    raiseWarning(
      "Failed to parse the number of threads as an integer