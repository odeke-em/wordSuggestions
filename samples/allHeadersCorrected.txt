[92mEstimated wordCount 358453 Dict size: 2509171[00m
ThresholdMatch percentage: 0.65
copyright  {
	copyright :: -1000
 }
c free  {
	free :: -1000
 }
software  {
	software :: -1000
 }
foundation  {
	foundation :: -1000
 }
inc  {
	incut :: 4
	incus :: 4
	incur :: 4
	incog :: 4
	incle :: 4
	incuse :: 3
	incurs :: 3
	incult :: 3
	income :: 3
	incogs :: 3
	inches :: 3
	inched :: 3
	incest :: 3
	incept :: 3
	incede :: 3
	incave :: 3
	incase :: 3
	incage :: 3
	uncia :: 3
	unci :: 4
	nick :: 3
	nice :: 3
	inch :: 5
	ins :: 3
	ink :: 3
	in :: 4
 }
this  {
	this :: -1000
 }
file  {
	file :: -1000
 }
is  {
	is :: -1000
 }
part  {
	part :: -1000
 }
of  {
	of :: -1000
 }
the  {
	the :: -1000
 }
gnu  {
	goe :: -1000
 }
c library  {
	library :: -1000
 }
the gnu c library is free software you  {
	    you :: -1000
      }
can  {
	can :: -1000
 }
redistribute  {
	redistribute :: -1000
 }
it  {
	it :: -1000
 }
and  {
	and :: -1000
 }
or  {
	or :: -1000
 }
modify  {
	modify :: -1000
 }
it under  {
	under :: -1000
 }
the terms  {
	terms :: -1000
 }
of the gnu lesser  {
	lesser :: -1000
  }
general  {
	general :: -1000
 }
public  {
	public :: -1000
 }
license  {
	license :: -1000
 }
as  {
	as :: -1000
 }
published  {
	published :: -1000
 }
by  {
	by :: -1000
 }
the free software foundation either  {
	either :: -1000
   }
version  {
	version :: -1000
 }
of the license or at  {
	  at :: -1000
   }
your  {
	your :: -1000
 }
option  {
	option :: -1000
 }
any  {
	any :: -1000
 }
later  {
	later :: -1000
 }
version the gnu c library is distributed  {
	distributed :: -1000
     }
in the hope  {
	hope :: -1000
 }
that  {
	that :: -1000
 }
it will  {
	will :: -1000
 }
be  {
	be :: -1000
 }
useful  {
	useful :: -1000
 }
but  {
	but :: -1000
 }
without  {
	without :: -1000
 }
any warranty  {
	warranty :: -1000
 }
without even  {
	even :: -1000
 }
the implied  {
	implied :: -1000
 }
warranty of merchantability  {
	merchantability :: -1000
 }
or fitness  {
	fitness :: -1000
 }
for  {
	for :: -1000
 }
a particular  {
	particular :: -1000
 }
purpose  {
	purpose :: -1000
 }
see  {
	see :: -1000
 }
the gnu lesser general public license for more  {
	   more :: -1000
      }
details  {
	details :: -1000
 }
you should  {
	should :: -1000
 }
have  {
	have :: -1000
 }
received  {
	received :: -1000
 }
a copy of the gnu lesser general public license along  {
	    along :: -1000
        }
with the gnu c library if  {
	   if :: -1000
    }
not  {
	not :: -1000
 }
write  {
	write :: -1000
 }
to  {
	to :: -1000
 }
the free software foundation inc temple  {
	temple :: -1000
    }
place  {
	place :: -1000
 }
suite  {
	suite :: -1000
 }
boston  {
	boston :: -1000
 }
ma  {
	ma :: -1000
 }
usa  {
	usnea :: 3
	usage :: 4
	urase :: 3
	unais :: 3
	ulans :: 3
	ukase :: 3
	udals :: 3
	uvas :: 4
	utas :: 4
	ursa :: 3
	upas :: 4
	usance :: 3
	usager :: 3
	usably :: 3
	usable :: 3
	uva :: 3
	uta :: 3
	use :: 3
	sau :: 3
	us :: 4
	as :: 3
 }
iso  {
	irons :: 3
	ikons :: 3
	idols :: 3
	icons :: 3
	ions :: 3
	gios :: 3
	bios :: 3
	psoai :: 3
	isomer :: 3
	isohel :: 3
	isobar :: 3
	ois :: 3
	ism :: 3
	ish :: 3
	ios :: 4
	dso :: 3
	os :: 3
	is :: 4
	io :: 3
 }
iec  {
	ids :: -1000
 }
asynchronous  {
	asynchronous :: -1000
 }
input  {
	input :: -1000
 }
and output  {
	output :: -1000
 }
ifndef  {
	finder :: 7
 }
aio  {
	diota :: 3
	azoic :: 3
	biota :: 3
	axoid :: 3
	avoid :: 3
	aroid :: 3
	aloin :: 3
	aioli :: 3
	aboil :: 3
	viola :: 3
	naoi :: 3
	jiao :: 3
	ciao :: 3
	agio :: 3
	rioja :: 3
	gio :: 3
	azo :: 3
	bio :: 3
	avo :: 3
	ait :: 3
	ais :: 3
	air :: 3
	ain :: 3
	aim :: 3
	ail :: 3
	aid :: 3
	ago :: 3
	ado :: 3
	abo :: 3
	oi :: 3
	ao :: 3
	ai :: 4
 }
h define  {
	define :: -1000
 }
aio h include  {
	include :: -1000
 }
features  {
	specialnesses :: -1000
 }
h include fcntl  {
 }
h include signal  {
	signal :: -1000
 }
h include time  {
	time :: -1000
 }
h include sys  {
	tis :: -1000
 }
types  {
	types :: -1000
 }
h begin  {
	begin :: -1000
 }
decls  {
	duels :: 6
	duces :: 6
	dices :: 6
	declaims :: 6
	dells :: 7
	delis :: 6
	delfs :: 6
	deils :: 7
	decks :: 7
	decal :: 6
	deals :: 7
	daces :: 6
	cells :: 6
	ceils :: 6
	declass :: 7
	declaws :: 7
	declaw :: 6
	dels :: 6
 }
asynchronous i o control  {
	control :: -1000
  }
block  {
	block :: -1000
 }
struct  {
	scruto :: 7
	scrunt :: 8
	strunts :: 7
	strunted :: 7
	thrust :: 7
	strictly :: 7
	strumatic :: 7
	struts :: 7
	strunt :: 9
	struck :: 8
	strout :: 8
	strict :: 9
	sturt :: 7
	strut :: 9
	straucht :: 7
	structure :: 7
	stricture :: 7
 }
aiocb  {
	amoebic :: 6
 }
int  {
	intuse :: 3
	intros :: 3
	intomb :: 3
	intoed :: 3
	inters :: 3
	intake :: 3
	inust :: 3
	intro :: 4
	intis :: 3
	intil :: 3
	inter :: 4
	inset :: 3
	input :: 3
	inlet :: 3
	ingot :: 3
	inert :: 3
	inept :: 3
	incut :: 3
	inapt :: 3
	entia :: 3
	antis :: 3
	antic :: 3
	until :: 3
	untie :: 3
	unit :: 3
	snit :: 3
	nits :: 3
	nite :: 3
	knit :: 3
	into :: 5
	inti :: 4
	inte :: 5
	anti :: 4
	ontic :: 3
	tin :: 3
	nit :: 4
	ins :: 3
	ink :: 3
	ant :: 3
	it :: 3
	in :: 4
 }
aio fildes  {
	silted :: 7
	filasse :: 7
	siloed :: 7
	silked :: 7
	sidles :: 7
	files :: 8
	filed :: 8
	felid :: 7
	mildest :: 8
	mildews :: 7
	mildens :: 7
	fiddles :: 8
	fiddleys :: 7
	fiddlers :: 7
	gilders :: 7
	wilders :: 7
	wildest :: 8
	flixes :: 7
	fisted :: 7
	fished :: 7
	rifles :: 7
	filose :: 7
	filmed :: 8
	filles :: 8
	filled :: 7
	filets :: 8
	filers :: 8
	fiends :: 7
	fields :: 9
	fidges :: 8
	fiddle :: 7
	folders :: 7
	felids :: 9
	tildes :: 9
	tilde :: 7
	elides :: 7
	sild :: 7
	slide :: 7
	siled :: 7
	sidle :: 7
	fils :: 7
	file :: 7
	eild :: 7
	slides :: 7
	glides :: 7
	finders :: 7
	filmers :: 7
 }
file desriptor  {
	depurators :: 11
	disruptor :: 14
	disrupter :: 13
	desorption :: 11
	descriptor :: 11
	postrider :: 11
	distorter :: 11
	repositor :: 11
	depositor :: 12
	predictors :: 12
	depositors :: 11
	disruptors :: 12
	disrupters :: 11
	depilators :: 11
	predictor :: 11
 }
int aio lio  {
	viols :: 3
	viola :: 3
	viol :: 4
	silo :: 3
	oily :: 3
	oils :: 3
	milo :: 3
	loti :: 3
	loir :: 3
	loin :: 3
	loci :: 3
	lobi :: 3
	lion :: 5
	lino :: 4
	kilo :: 3
	idol :: 3
	filo :: 3
	diol :: 4
	lionet :: 3
	looie :: 3
	oli :: 3
	oil :: 4
	loo :: 3
	lit :: 3
	lis :: 3
	lip :: 3
	lig :: 3
	lie :: 3
	lid :: 3
	lib :: 3
	gio :: 3
	bio :: 3
	livor :: 3
	litho :: 3
	lirot :: 3
	lions :: 4
	linos :: 3
	lingo :: 3
	limos :: 3
	limbo :: 3
	lidos :: 3
	oi :: 3
	lo :: 3
	li :: 4
 }
opcode  {
	opcode :: -1000
 }
operation  {
	operation :: -1000
 }
to be performed  {
	performed :: -1000
 }
int aio reqprio  {
 }
request  {
	request :: -1000
 }
priority  {
	priority :: -1000
 }
offset  {
	offset :: -1000
 }
volatile  {
	volatile :: -1000
 }
void  {
	void :: -1000
 }
aio buf  {
	bumfs :: 3
	buffy :: 3
	buffo :: 3
	buffi :: 3
	fubs :: 3
	bumf :: 4
	bufo :: 5
	buff :: 4
	fub :: 4
	buy :: 3
	but :: 3
	bus :: 3
	bur :: 3
	bun :: 3
	bum :: 3
	bug :: 3
	bud :: 3
	auf :: 3
 }
location  {
	location :: -1000
 }
of buffer  {
	buffer :: -1000
 }
size  {
	size :: -1000
 }
t aio nbytes  {
	yentes :: 7
 }
length  {
	length :: -1000
 }
of transfer  {
	transfer :: -1000
 }
struct sigevent  {
	signee :: 10
	steeving :: 11
	virements :: 10
	misevents :: 11
	servient :: 10
	misevent :: 12
 }
aio sigevent signal number  {
	number :: -1000
  }
and value  {
	value :: -1000
 }
internal  {
	internal :: -1000
 }
members  {
	members :: -1000
 }
struct aiocb next  {
	next :: -1000
 }
prio int abs  {
	abs :: -1000
 }
prio int policy  {
	policy :: -1000
 }
int error  {
	error :: -1000
 }
code  {
	code :: -1000
 }
ssize  {
	seizes :: 8
	seizors :: 6
	seizers :: 7
	seis :: 6
	sizes :: 6
	seize :: 6
	seise :: 6
 }
t return  {
	return :: -1000
 }
value ifndef use file offset off t aio offset file offset char  {
	       char :: -1000
          }
pad  {
	pad :: -1000
 }
sizeof  {
	size :: 8
	sizer :: 7
	sized :: 7
 }
off t sizeof off t else  {
	 else :: -1000
    }
off t aio offset file offset endif  {
	reemerges :: -1000
     }
char unused  {
	unused :: -1000
 }
the same  {
	same :: -1000
 }
for the bit  {
	bit :: -1000
 }
offsets  {
	offsets :: -1000
 }
please  {
	please :: -1000
 }
note  {
	note :: -1000
 }
that the members aio fildes to return value have to be the same in aiocb and aiocb ifdef  {
	            fifed :: 6
                }
use largefile  {
	miscomputations :: -1000
 }
struct aiocb int aio fildes file desriptor int aio lio opcode operation to be performed int aio reqprio request priority offset volatile void aio buf location of buffer size t aio nbytes length of transfer struct sigevent aio sigevent signal number and value internal members struct aiocb next prio int abs prio int policy int error code ssize t return value off t aio offset file offset char unused endif ifdef use gnu to customize  {
	                                                                    detest :: -1000
                                                                         }
the implementation  {
	implementation :: -1000
 }
one  {
	one :: -1000
 }
can use the following  {
	following :: -1000
  }
struct this implementation follows  {
	follows :: -1000
  }
the one in irix  {
	irid :: 5
  }
struct aioinit  {
 }
int aio threads  {
	threads :: -1000
 }
maximal  {
	maximal :: -1000
 }
number of threads int aio num number of expected  {
	expected :: -1000
       }
simultanious  {
	simultaneous :: 20
	simultaneously :: 17
	simulations :: 15
	sublimations :: 15
	stimulations :: 15
 }
requests  {
	requests :: -1000
 }
int aio locks  {
	locks :: -1000
 }
not used  {
	used :: -1000
 }
int aio usedba  {
	subdean :: 7
	useably :: 7
	used :: 8
 }
not used int aio debug  {
	debug :: -1000
   }
not used int aio numusers  {
	numerous :: 10
	humuses :: 10
   }
not used int aio idle  {
	idle :: -1000
   }
time number of seconds  {
	seconds :: -1000
  }
before  {
	before :: -1000
 }
idle thread terminates  {
	terminates :: -1000
 }
int aio reserved  {
	reserved :: -1000
 }
endif return values  {
	values :: -1000
 }
of cancelation  {
	cancelation :: -1000
 }
function  {
	function :: -1000
 }
enum  {
	neum :: 6
	neums :: 5
	neume :: 5
 }
aio canceled  {
	playrooms :: -1000
 }
define aio canceled aio canceled aio notcanceled  {
     }
define aio notcanceled aio notcanceled aio alldone  {
	allonge :: 9
     }
define aio alldone aio alldone operation codes  {
	 codes :: -1000
     }
for aio lio opcode enum lio read  {
	  read :: -1000
     }
define lio read lio read lio write define lio write lio write lio nop  {
	        copen :: 3
	         porn :: 3
	         pony :: 3
	         pons :: 3
	         pong :: 3
	         pone :: 3
	         pond :: 3
	         noup :: 4
	         nope :: 5
	         noop :: 3
	        noups :: 3
	        nopes :: 4
	        nopal :: 4
	       nopals :: 3
	        napoo :: 3
	          wop :: 3
	          top :: 3
	          sop :: 3
	          pop :: 3
	          noy :: 3
	          now :: 3
	          not :: 3
	          nos :: 3
	          nor :: 3
	          nom :: 3
	          noh :: 3
	          nog :: 3
	          nod :: 3
	          nob :: 3
	          nip :: 3
	          nep :: 3
	          nap :: 3
	          mop :: 3
	          lop :: 3
	          kop :: 3
	          hop :: 3
	          fop :: 3
	          dop :: 3
	          cop :: 3
	          bop :: 3
	           po :: 3
	           no :: 4
            }
define lio nop lio nop synchronization  {
	synchronization :: -1000
    }
options  {
	options :: -1000
 }
for lio listio  {
	instil :: 7
	postil :: 7
	vitriols :: 7
	distill :: 7
	pistil :: 8
	distil :: 8
	mislit :: 7
	listing :: 8
	linties :: 7
	lost :: 7
	list :: 7
	violist :: 7
	mistily :: 7
	mistico :: 7
 }
function enum lio wait  {
	wait :: -1000
  }
define lio wait lio wait lio nowait  {
	atwain :: 7
	townie :: 7
	  nowt :: 7
	 noway :: 7
     }
define lio nowait lio nowait allow  {
	allow :: -1000
    }
user  {
	user :: -1000
 }
to specify  {
	specify :: -1000
 }
optimization  {
	optimization :: -1000
 }
ifdef use gnu extern  {
	extern :: -1000
  }
void aio init  {
	instil :: 5
	inwit :: 5
	intis :: 5
	intil :: 5
	unit :: 5
	snit :: 5
	knit :: 5
	inti :: 6
	inia :: 5
 }
const  {
	construed :: 6
	construer :: 6
	constable :: 6
	count :: 6
	coset :: 6
	coost :: 6
	conus :: 6
	contr :: 6
	conks :: 6
	cones :: 6
	coast :: 7
	canst :: 7
	canso :: 6
	tonics :: 6
	tocsin :: 6
	creston :: 6
	contuse :: 6
	contras :: 6
	consult :: 7
	consort :: 6
	consist :: 6
	consent :: 6
	congest :: 6
	confits :: 6
	confest :: 6
	conatus :: 7
	consulta :: 6
	construe :: 7
	constate :: 6
	nonstick :: 6
	counts :: 7
	contos :: 6
	contes :: 7
	consul :: 6
	cenotes :: 6
	centos :: 6
	tons :: 7
	cots :: 7
	cost :: 6
	cons :: 8
	cantos :: 6
	coasting :: 6
	con :: 6
 }
struct aioinit init throw  {
	throw :: -1000
  }
nonnull  {
 }
endif ifndef use file offset enqueue  {
    }
read request for given  {
	given :: -1000
  }
number of bytes  {
	cites :: -1000
 }
and the given priority extern int aio read struct aiocb aiocbp  {
         }
throw nonnull enqueue write request for given number of bytes and the given priority extern int aio write struct aiocb aiocbp throw nonnull initiate  {
	               initiate :: -1000
                      }
list of i o requests extern int lio listio int mode  {
	      mode :: -1000
         }
struct aiocb const list restrict  {
	restrict :: -1000
   }
arr  {
	arr :: -1000
 }
int nent  {
	munt :: -1000
 }
struct sigevent restrict sig throw nonnull retrieve  {
	retrieve :: -1000
     }
error status  {
	status :: -1000
 }
associated  {
	associated :: -1000
 }
with aiocbp extern int aio error const struct aiocb aiocbp throw nonnull return status associated with aiocbp extern ssize t aio return struct aiocb aiocbp throw nonnull try  {
	                        try :: -1000
                          }
to cancel asynchronous i o requests outstanding  {
	outstanding :: -1000
     }
against  {
	against :: -1000
 }
file descriptor  {
	descriptor :: -1000
 }
fildes extern int aio cancel int fildes struct aiocb aiocbp throw suspend  {
	    suspend :: -1000
          }
calling  {
	calling :: -1000
 }
thread until  {
	until :: -1000
 }
at least  {
	least :: -1000
 }
one of the asynchronous i o operations  {
	operations :: -1000
     }
referenced  {
	referenced :: -1000
 }
by list has  {
	has :: -1000
 }
completed  {
	completed :: -1000
 }
this function is a cancellation  {
	cancellation :: -1000
   }
point  {
	point :: -1000
 }
and therefore  {
	therefore :: -1000
 }
not marked  {
	marked :: -1000
 }
with throw extern int aio suspend const struct aiocb const list int nent const struct timespec  {
	       pipestem :: 10
	        tumesce :: 10
	      timescale :: 10
              }
restrict timeout  {
	timeout :: -1000
 }
nonnull force  {
	force :: -1000
 }
all operations associated with file desriptor described  {
	described :: -1000
     }
by aio fildes member of aiocbp extern int aio fsync  {
        }
int operation struct aiocb aiocbp throw nonnull else ifdef redirect  {
	 redirect :: -1000
        }
nth  {
	nth :: -1000
 }
extern int redirect nth aio read struct aiocb aiocbp aio read nonnull extern int redirect nth aio write struct aiocb aiocbp aio write nonnull extern int redirect nth lio listio int mode struct aiocb const list restrict arr int nent struct sigevent restrict sig lio listio nonnull extern int redirect nth aio error const struct aiocb aiocbp aio error nonnull extern ssize t redirect nth aio return struct aiocb aiocbp aio return nonnull extern int redirect nth aio cancel int fildes struct aiocb aiocbp aio cancel extern int redirect nth aio suspend const struct aiocb const list int nent const struct timespec restrict timeout aio suspend nonnull extern int redirect nth aio fsync int operation struct aiocb aiocbp aio fsync nonnull else define aio read aio read define aio write aio write define lio listio lio listio define aio error aio error define aio return aio return define aio cancel aio cancel define aio suspend aio suspend define aio fsync aio fsync endif endif ifdef use largefile extern int aio read struct aiocb aiocbp throw nonnull extern int aio write struct aiocb aiocbp throw nonnull extern int lio listio int mode struct aiocb const list restrict arr int nent struct sigevent restrict sig throw nonnull extern int aio error const struct aiocb aiocbp throw nonnull extern ssize t aio return struct aiocb aiocbp throw nonnull extern int aio cancel int fildes struct aiocb aiocbp throw extern int aio suspend const struct aiocb const list int nent const struct timespec restrict timeout throw nonnull extern int aio fsync int operation struct aiocb aiocbp throw nonnull endif end decls endif aio h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef aliases  {
	                                                                                                                                                                                                                                                                                                                                                                                                              aliases :: -1000
                                                                                                                                                                                                                                                                                                                                                                                                                    }
h define aliases h include features h include sys types h begin decls structure  {
	    structure :: -1000
            }
to represent  {
	represent :: -1000
 }
one entry  {
	noncelebrations :: -1000
 }
of the alias data  {
	data :: -1000
  }
base  {
	base :: -1000
 }
struct aliasent  {
	aliases :: 10
	alias :: 10
	alkanets :: 10
	almandites :: 10
	alienates :: 10
	pleasant :: 10
	nailset :: 10
 }
char alias name  {
	name :: -1000
 }
size t alias members len char alias members int alias local  {
	     local :: -1000
         }
open  {
	open :: -1000
 }
alias data base files  {
	files :: -1000
  }
extern void setaliasent  {
	retaliates :: 15
	retaliate :: 14
 }
void throw close  {
	close :: -1000
 }
alias data base files extern void endaliasent  {
     }
void throw get  {
	get :: -1000
 }
the next entry from  {
	from :: -1000
  }
the alias data base extern struct aliasent getaliasent  {
	gelatinate :: 14
	retaliates :: 15
	retaliate :: 14
      }
void throw get the next entry from the alias data base and put  {
	         put :: -1000
           }
it in result  {
	result :: -1000
 }
buf extern int getaliasent r struct aliasent restrict result buf char restrict buffer size t buflen  {
	          butle :: 7
	          bugle :: 7
              }
struct aliasent restrict result throw get alias entry corresponding  {
	corresponding :: -1000
       }
to name extern struct aliasent getaliasbyname  {
    }
const char name throw get alias entry corresponding to name and put it in result buf extern int getaliasbyname r const char restrict name struct aliasent restrict result buf char restrict buffer size t buflen struct aliasent restrict result throw end decls endif aliases h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef alloca  {
	                                                                                                                                                                          allopatric :: 7
	                                                                                                                                                                          allopathic :: 7
	                                                                                                                                                                           allowance :: 8
	                                                                                                                                                                             alloxan :: 8
	                                                                                                                                                                             allodia :: 7
	                                                                                                                                                                             allobar :: 8
	                                                                                                                                                                          allowances :: 7
	                                                                                                                                                                          allowanced :: 7
	                                                                                                                                                                          allocators :: 7
	                                                                                                                                                                          allocating :: 8
	                                                                                                                                                                          allocation :: 7
	                                                                                                                                                                            alloxans :: 7
	                                                                                                                                                                            allosaur :: 7
	                                                                                                                                                                            allopath :: 7
	                                                                                                                                                                            allogamy :: 7
	                                                                                                                                                                            allobars :: 7
	                                                                                                                                                                          allochiria :: 7
	                                                                                                                                                                           allocator :: 8
	                                                                                                                                                                           allocates :: 9
	                                                                                                                                                                           allocated :: 9
	                                                                                                                                                                           allocable :: 7
	                                                                                                                                                                             cloacal :: 8
                                                                                                                                                                                   }
h define alloca h include features h define need  {
	    need :: -1000
       }
size t include stddef  {
	stede :: 7
	stedd :: 7
	stade :: 7
	sted :: 7
  }
h begin decls remove  {
	remove :: -1000
  }
any previous  {
	previous :: -1000
 }
definitions  {
	definitions :: -1000
 }
undef  {
	synthetases :: -1000
 }
alloca allocate  {
	reglued :: -1000
 }
a block that will be freed  {
	freed :: -1000
    }
when  {
	when :: -1000
 }
the calling function exits  {
	pincering :: -1000
  }
extern void alloca size t size throw ifdef gnuc  {
	    gods :: -1000
       }
define alloca size builtin  {
	built :: 9
	quiltings :: 9
	quilting :: 10
	building :: 10
	boulting :: 9
	buildings :: 9
  }
alloca size endif gcc  {
  }
end decls endif alloca h ifndef a out gnu h define a out gnu h include bits  {
	            bits :: -1000
               }
a out h define gnu exec  {
	 exec :: -1000
    }
macros  {
	macros :: -1000
 }
struct exec unsigned  {
	unsigned :: -1000
 }
long  {
	long :: -1000
 }
a info  {
	info :: -1000
 }
use macros n magic  {
	magic :: -1000
  }
etc  {
	ess :: -1000
 }
for access  {
	access :: -1000
 }
unsigned int a text  {
	text :: -1000
  }
length of text in bytes unsigned int a data length of data in bytes unsigned int a bss  {
	             boss :: 3
	             bass :: 3
	              ess :: 3
	              bus :: 3
	              bos :: 3
	              bis :: 3
	              ass :: 3
	              bas :: 3
                }
length of uninitialized  {
 }
data area  {
	area :: -1000
 }
for file in bytes unsigned int a syms  {
	   sync :: -1000
      }
length of symbol  {
	symbol :: -1000
 }
table  {
	table :: -1000
 }
data in file in bytes unsigned int a entry start  {
	    start :: -1000
        }
address  {
	address :: -1000
 }
unsigned int a trsize  {
	assizer :: 7
	resized :: 7
	braizes :: 7
	fritzes :: 8
	triose :: 7
	resize :: 8
	resite :: 7
	zestier :: 7
	tries :: 7
	resit :: 7
  }
length of relocation  {
	relocation :: -1000
 }
info for text in bytes unsigned int a drsize  {
	 assized :: 7
	 assizer :: 7
	  dorize :: 8
	  dorise :: 7
	 resized :: 9
	 braizes :: 7
	drizzles :: 7
	  desire :: 8
	 unsized :: 7
	  resize :: 8
	  reside :: 7
	 dorizes :: 9
	   resid :: 7
	 desirer :: 7
	iodizers :: 7
       }
length of relocation info for data in bytes enum machine  {
	  machine :: -1000
        }
type m oldsun  {
	oldens :: 7
	olds :: 8
 }
m m m sparc  {
	soras :: -1000
  }
m m mips  {
	zips :: 5
	yips :: 5
	tips :: 5
	sips :: 5
	simp :: 5
	rips :: 5
	pips :: 5
	nips :: 5
	mops :: 5
	miss :: 5
	mirs :: 5
	mils :: 5
	migs :: 5
	mids :: 5
	mibs :: 5
	maps :: 5
	lips :: 5
	kips :: 5
	imps :: 6
	hips :: 5
	gips :: 5
	dips :: 5
	sip :: 5
	mis :: 5
 }
m mips define n magic exec exec a info xffff  {
        }
define n machtype  {
	yachtmen :: 10
	yachtsmen :: 10
 }
exec enum machine type exec a info xff define n flags  {
	     flags :: -1000
         }
exec exec a info xff define n set info exec magic type flags exec a info magic xffff int type xff flags xff define n set magic exec magic exec a info exec a info xffff magic xffff define n set machtype exec machtype exec a info exec a info xff ffff  {
                                                  }
int machtype xff define n set flags exec flags exec a info exec a info x ffffff  {
               }
flags xff code indicating  {
	indicating :: -1000
  }
object  {
	object :: -1000
 }
file or impure  {
	impure :: -1000
 }
executable  {
	executable :: -1000
 }
define omagic  {
	celestes :: -1000
 }
code indicating pure  {
	pure :: -1000
 }
executable define nmagic  {
	aminic :: 7
	imagine :: 7
	agamic :: 7
	coaming :: 7
 }
code indicating demand  {
	demand :: -1000
 }
paged  {
	paged :: -1000
 }
executable define zmagic  {
	agamic :: 7
 }
this indicates  {
	indicates :: -1000
 }
a demand paged executable with the header  {
	header :: -1000
     }
in the text the first  {
	first :: -1000
   }
page is unmapped  {
	unmapped :: -1000
 }
to help  {
	help :: -1000
 }
trap  {
	trap :: -1000
 }
null  {
	null :: -1000
 }
pointer  {
	pointer :: -1000
 }
references  {
	references :: -1000
 }
define qmagic  {
	agamic :: 7
 }
code indicating core  {
	core :: -1000
 }
file define cmagic  {
	agamic :: 7
	cadmic :: 7
 }
define n trsize a a a trsize define n drsize a a a drsize define n symsize  {
               }
a a a syms define n badmag  {
	yorkie :: -1000
     }
x n magic x omagic n magic x nmagic n magic x zmagic n magic x qmagic define n hdroff  {
	             shroff :: 8
	            shroffs :: 7
	           shroffed :: 8
                  }
x sizeof struct exec define n txtoff  {
     }
x n magic x zmagic n hdroff x sizeof struct exec n magic x qmagic sizeof struct exec define n datoff  {
	                dato :: 8
                   }
x n txtoff x x a text define n treloff  {
	  trefoil :: 9
        }
x n datoff x x a data define n dreloff  {
        }
x n treloff x n trsize x define n symoff  {
        }
x n dreloff x n drsize x define n stroff  {
	 sleekens :: -1000
        }
x n symoff x n symsize x address of text segment  {
	   segment :: -1000
         }
in memory  {
	memory :: -1000
 }
after  {
	after :: -1000
 }
it is loaded  {
	loaded :: -1000
 }
define n txtaddr  {
 }
x n magic x qmagic address of data segment in memory after it is loaded define segment size define n segment round  {
	                round :: -1000
                    }
x x segment size segment size define n txtendaddr  {
       }
x n txtaddr x x a text define n dataddr  {
	climbings :: -1000
        }
x n magic x omagic n txtendaddr x n segment round n txtendaddr x define n bssaddr  {
               }
x n dataddr x x a data if defined  {
	 defined :: -1000
       }
n nlist  {
	glisten :: 7
	glint :: 6
	flint :: 6
	elint :: 6
	clint :: 6
	flints :: 7
	clints :: 7
	elastin :: 6
	elints :: 7
	slit :: 6
	slipt :: 6
	nits :: 6
	nils :: 6
	slinter :: 6
	plinths :: 6
	neist :: 7
 }
declared  {
	declared :: -1000
 }
struct nlist union  {
	union :: -1000
 }
char n name struct nlist n next long n strx  {
	     tech :: -1000
        }
n un unsigned char n type char n other  {
	   other :: -1000
       }
short  {
	short :: -1000
 }
n desc unsigned long n value endif no n nlist declared define n undf  {
	    functions :: -1000
            }
define n abs define n text define n data define n bss define n fn  {
	           fon :: 2
	           fin :: 2
	           fen :: 2
	           fan :: 2
	             f :: 2
             }
define n ext define n type define n stab  {
	    stab :: -1000
       }
define n indr  {
	indraft :: 5
	inured :: 5
	indri :: 6
	indris :: 5
	indoor :: 5
	indart :: 5
	inbred :: 5
 }
xa  {
	zax :: 2
	wax :: 2
	tax :: 2
	sax :: 2
	rax :: 2
	pax :: 2
	max :: 2
	lax :: 2
	fax :: 2
	ax :: 2
 }
define n seta x absolute  {
	absolute :: -1000
   }
set element  {
	element :: -1000
 }
symbol define n sett  {
	sett :: -1000
  }
x text set element symbol define n setd  {
	   rust :: -1000
      }
x data set element symbol define n setb  {
	severalfold :: -1000
      }
x a bss set element symbol define n setv  {
	   stove :: 5
	   stive :: 5
	    vets :: 6
	    vest :: 5
	   stave :: 5
	    seta :: 5
	     vet :: 5
	     set :: 6
       }
x c pointer to set vector  {
	vector :: -1000
    }
in data area if defined n relocation info declared this structure describes  {
	  describes :: -1000
          }
a single  {
	single :: -1000
 }
relocation to be performed the text relocation section  {
	section :: -1000
      }
of the file is a vector of these  {
	  these :: -1000
      }
structures  {
	structures :: -1000
 }
all of which  {
	which :: -1000
 }
apply  {
	apply :: -1000
 }
to the text section likewise  {
	likewise :: -1000
   }
the data relocation section applies  {
	applies :: -1000
   }
to the data section struct relocation info int r address unsigned int r symbolnum  {
	    symbolism :: 11
	       symbol :: 11
            }
unsigned int r pcrel  {
	peril :: 6
	purely :: 6
  }
unsigned int r length unsigned int r extern unsigned int r pad endif no n relocation info declared endif a out gnu h hierarchial  {
	         hierarchically :: 16
	           hierarchical :: 18
	               hierarch :: 14
	            hierarchize :: 14
	            hierarchies :: 14
	             hierarchal :: 17
	             hierarchic :: 15
                      }
argument  {
	argument :: -1000
 }
parsing  {
	parsing :: -1000
 }
layered  {
	layered :: -1000
 }
over  {
	over :: -1000
 }
getopt  {
	gatepost :: 7
	petto :: 7
 }
copyright c free software foundation inc this file is part of the gnu c library written  {
	        written :: -1000
              }
by miles  {
	miles :: -1000
 }
bader  {
	apter :: -1000
 }
miles gnu ai mit  {
	mitres :: 3
	mitred :: 3
	mitral :: 3
	mither :: 3
	miters :: 3
	time :: 3
	timb :: 3
	muti :: 4
	moit :: 3
	mixt :: 4
	mity :: 5
	mitt :: 4
	mite :: 5
	mist :: 4
	mint :: 4
	milt :: 4
	motif :: 3
	mitts :: 3
	mitre :: 4
	mitis :: 3
	mites :: 4
	miter :: 4
	misty :: 3
	mists :: 3
	mitch :: 4
	mirth :: 3
	minty :: 3
	mints :: 3
	milty :: 3
	milts :: 3
	might :: 3
	midst :: 3
	metis :: 3
	metif :: 3
	metic :: 3
	matin :: 3
	zit :: 3
	wit :: 3
	tit :: 3
	sit :: 3
	rit :: 3
	pit :: 3
	nit :: 3
	miz :: 3
	mix :: 3
	mis :: 3
	mir :: 3
	mil :: 3
	mig :: 3
	mid :: 3
	mib :: 3
	met :: 3
	mat :: 3
	lit :: 3
	kit :: 3
	hit :: 3
	git :: 3
	fit :: 3
	dit :: 3
	cit :: 3
	bit :: 3
	ait :: 3
	 ti :: 3
	 mi :: 4
  }
edu  {
	due :: -1000
 }
the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef argp  {
	                                                                                                                   grapy :: 5
	                                                                                                                   grape :: 5
                                                                                                                       }
h define argp h include stdio  {
	styloid :: 6
	tedious :: 6
	stridor :: 6
	modist :: 6
	todies :: 6
	codist :: 6
	steroid :: 6
	studio :: 6
	stolid :: 6
	strid :: 6
	stoic :: 6
	staid :: 6
	sodic :: 6
    }
h include ctype  {
	crypt :: 6
	clype :: 7
	etypic :: 7
	clypes :: 6
	clypei :: 6
	clyped :: 6
 }
h include getopt h include limits  {
	limits :: -1000
    }
h define need error t include errno  {
	droner :: 6
	kroner :: 6
	ironer :: 6
	   err :: 6
     }
h ifndef const define const const endif ifndef throw define throw endif ifndef nth define nth fct  {
	             est :: -1000
               }
fct throw endif ifndef attribute  {
	attribute :: -1000
   }
this feature is available  {
	available :: -1000
  }
in gcc versions  {
	versions :: -1000
 }
and later if gnuc gnuc gnuc minor  {
	 minor :: -1000
     }
strict  {
	strict :: -1000
 }
ansi  {
	assign :: 5
	basin :: 5
	antis :: 6
	anise :: 5
	anils :: 5
	arsino :: 5
	arsine :: 5
	anvils :: 5
	antics :: 5
	unais :: 5
	snail :: 5
	sasin :: 5
	anti :: 5
	anis :: 6
	ains :: 5
	ins :: 5
	ani :: 5
	ais :: 5
 }
define attribute spec empty  {
	empty :: -1000
  }
endif the protected  {
	protected :: -1000
 }
variants  {
	variants :: -1000
 }
of format  {
	format :: -1000
 }
and printf  {
	karri :: -1000
 }
attributes  {
	attributes :: -1000
 }
are accepted  {
	accepted :: -1000
 }
by gcc versions effectively  {
	effectively :: -1000
  }
and later if gnuc gnuc gnuc minor strict ansi define format format define printf printf endif endif gcc and later have restrict c compilers  {
	              compilers :: -1000
                      }
have restrict and configure  {
	configure :: -1000
  }
may  {
	may :: -1000
 }
have defined restrict ifndef restrict if gnuc gnuc gnuc minor if defined restrict l stdc  {
             }
version define restrict restrict else define restrict endif endif endif ifndef error t defined typedef  {
	         typed :: 9
             }
int error t define error t defined endif ifdef cplusplus  {
        }
extern c endif a description  {
	description :: -1000
   }
of a particular option a pointer to an array  {
	   array :: -1000
       }
of these is passed  {
	passed :: -1000
  }
in the options field  {
	sweetfish :: -1000
  }
of an argp structure each  {
	each :: -1000
   }
option entry can correspond to one long option and or one short option more names  {
	         names :: -1000
             }
for the same option can be added  {
	helloed :: -1000
     }
by following an entry in an option array with options having  {
	    having :: -1000
         }
the option alias flag set struct argp option the long option name for more than  {
	          than :: -1000
             }
one name for the same option you can use following options with the option alias flag set const char name what  {
	                what :: -1000
                   }
key  {
	key :: -1000
 }
is returned  {
	returned :: -1000
 }
for this option if and printable  {
	printable :: -1000
    }
then  {
	then :: -1000
 }
it s also  {
	also :: -1000
 }
accepted as a short option int key if non null this is the name of the argument associated with this option which is required  {
	               required :: -1000
                      }
unless  {
	unless :: -1000
 }
the option arg optional  {
	optional :: -1000
  }
flag is set const char arg option flags int flags the doc  {
	        doc :: -1000
          }
string  {
	string :: -1000
 }
for this option if both  {
	both :: -1000
   }
name and key are this string will be printed  {
	 printed :: -1000
       }
outdented  {
	outjested :: 12
	outdebated :: 11
	demounted :: 11
	outhunted :: 11
	outdanced :: 11
	outredden :: 11
	detonated :: 11
 }
from the normal  {
	normal :: -1000
 }
option column  {
	column :: -1000
 }
making  {
	making :: -1000
 }
it useful as a group  {
	group :: -1000
   }
header it will be the first thing  {
	 thing :: -1000
     }
printed in its  {
	its :: -1000
 }
group in this usage  {
	usage :: -1000
  }
it s conventional  {
	conventional :: -1000
 }
to end the string with a const char doc the group this option is in in a long help message  {
	            message :: -1000
                  }
options are sorted  {
	sorted :: -1000
 }
alphabetically  {
	alphabetically :: -1000
 }
within  {
	within :: -1000
 }
each group and the groups  {
	groups :: -1000
   }
presented  {
	presented :: -1000
 }
in the order  {
	pater :: -1000
 }
n m every  {
	uplanders :: -1000
 }
entry in an options array with if this field will inherit  {
	   inherit :: -1000
         }
the group number of the previous entry or zero  {
	    zero :: -1000
       }
if it s the first one unless its a group header name and key both in which case  {
	             case :: -1000
                }
the previous entry is the default  {
	default :: -1000
    }
automagic  {
	autogamy :: 11
	autogamic :: 16
	autogamies :: 12
	automan :: 11
	automating :: 12
	automatics :: 13
	axiomatic :: 11
	automatic :: 14
 }
options such  {
	tech :: -1000
 }
as help are put into  {
	into :: -1000
   }
group int group the argument associated with this option is optional define option arg optional x this option isn  {
	              zins :: 3
	              yins :: 3
	              wins :: 3
	              vins :: 3
	              tins :: 3
	              sins :: 3
	              sink :: 3
	              sing :: 3
	              sine :: 3
	              sind :: 3
	              rins :: 3
	              pins :: 3
	              lins :: 3
	              kins :: 3
	              jins :: 3
	              ions :: 4
	              hins :: 3
	              gins :: 3
	              fins :: 3
	              dins :: 3
	              bins :: 3
	              ains :: 3
	               sin :: 4
	               nis :: 3
	               ism :: 3
	               ish :: 3
	               ion :: 3
	               ins :: 4
	               inn :: 3
	                ns :: 3
	                is :: 4
	                in :: 3
                 }
t displayed  {
	displayed :: -1000
 }
in any help messages  {
	messages :: -1000
  }
define option hidden  {
	hidden :: -1000
 }
x this option is an alias for the closest  {
	 closest :: -1000
       }
previous non alias option this means  {
	means :: -1000
    }
that it will be displayed in the same help entry and will inherit fields  {
	       fields :: -1000
            }
other than name and key from the aliased  {
	alidades :: 9
	aliases :: 10
	  alias :: 10
	alcades :: 9
	alcaides :: 9
      }
option define option alias x this option isn t actually  {
	 actually :: -1000
        }
an option and so should be ignored  {
	ignored :: -1000
     }
by the actual option parser  {
	parser :: -1000
   }
but rather  {
	rather :: -1000
 }
an arbitrary  {
	arbitrary :: -1000
 }
piece  {
	piece :: -1000
 }
of documentation  {
	documentation :: -1000
 }
that should be displayed in much  {
	volumists :: -1000
    }
the same manner  {
	manner :: -1000
 }
as the options if this flag is set then the option name field is displayed unmodified  {
	     unmodified :: -1000
              }
e g no prefix  {
	prefix :: -1000
  }
is added at the left  {
	left :: -1000
   }
margin  {
	margin :: -1000
 }
where  {
	where :: -1000
 }
a short option would  {
	would :: -1000
  }
normally  {
	normally :: -1000
 }
be displayed and the documentation string in the normal place for purposes  {
	   purposes :: -1000
          }
of sorting  {
	sorting :: -1000
 }
any leading  {
	leading :: -1000
 }
whitespace  {
	whitebeams :: 12
	whitefaces :: 13
	whitecap :: 12
	whitecaps :: 13
	whiteface :: 12
 }
and punctuation  {
	punctuation :: -1000
 }
is ignored except  {
	except :: -1000
 }
that if the first non whitespace character  {
	character :: -1000
     }
is not this entry is displayed after all options and option doc entries  {
	     entries :: -1000
           }
with a leading in the same group define option doc x this option shouldn  {
	       should :: 12
	  shouldering :: 9
	     shoulder :: 10
	     shouldst :: 9
            }
t be included  {
	included :: -1000
 }
in long usage messages but is still  {
	 still :: -1000
     }
included in help messages this is mainly  {
	mainly :: -1000
     }
intended  {
	intended :: -1000
 }
for options that are completely  {
	completely :: -1000
   }
documented  {
	documented :: -1000
 }
in an argp s args  {
	grasp :: 5
	argus :: 6
	argues :: 5
	argots :: 5
	argons :: 5
	argols :: 5
	argles :: 5
	argils :: 5
	rags :: 6
	gars :: 5
	ergs :: 5
	arts :: 5
	arks :: 5
	arfs :: 5
	ares :: 5
	 ars :: 5
   }
doc field in which case including  {
	including :: -1000
    }
the option in the generic  {
	generic :: -1000
   }
usage list would be redundant  {
	redundant :: -1000
   }
for instance  {
	instance :: -1000
 }
if args doc is foo  {
	backtrack :: -1000
   }
bar  {
	bar :: -1000
 }
n x blah  {
	huddles :: -1000
 }
and the x option s purpose is to distinguish  {
	distinguish :: -1000
       }
these two  {
	two :: -1000
 }
cases  {
	cases :: -1000
 }
x should probably  {
	probably :: -1000
 }
be marked option no usage define option no usage x struct argp fwd  {
	         fid :: 3
	         fed :: 3
	         fad :: 3
           }
declare this type struct argp state  {
	state :: -1000
    }
struct argp child  {
	child :: -1000
 }
the type of a pointer to an argp parsing function typedef error t argp parser t int key char arg struct argp state state what to return for unrecognized  {
	                unrecognized :: -1000
                           }
keys  {
	keys :: -1000
 }
for special  {
	special :: -1000
 }
argp key keys such returns  {
	returns :: -1000
   }
will simply  {
	simply :: -1000
 }
be ignored for user keys this error will be turned  {
	   turned :: -1000
        }
into einval  {
	silvan :: 7
	silvae :: 7
	xenial :: 7
	pinwale :: 7
	pineals :: 7
	genial :: 7
	nerval :: 7
	pineal :: 8
	penial :: 7
	denial :: 7
	alevin :: 7
	andvile :: 7
	tineal :: 8
	ventail :: 7
	menial :: 7
	vinal :: 7
	vineal :: 10
	venial :: 9
	veinal :: 8
	naively :: 7
	linear :: 7
	lineal :: 8
	lienal :: 7
 }
if the call to argp parse is such that errors  {
	   errors :: -1000
        }
are propagated  {
	sharkskin :: -1000
 }
back  {
	back :: -1000
 }
to the user instead  {
	instead :: -1000
  }
of exiting  {
	exiting :: -1000
 }
returning  {
	returning :: -1000
 }
einval itself  {
	itself :: -1000
 }
would result in an immediate  {
	immediate :: -1000
   }
stop  {
	stop :: -1000
 }
to parsing in all cases define argp err unknown  {
	 unknown :: -1000
       }
e big  {
	big :: -1000
 }
hurd  {
	hurds :: 7
	hurled :: 5
	hurdle :: 6
	hurden :: 6
	hurdles :: 5
	hurdies :: 5
	turd :: 5
	surd :: 5
	nurd :: 5
	hurt :: 5
	hurl :: 5
	hued :: 5
	herd :: 5
	hard :: 5
	curd :: 5
	burd :: 5
	purdah :: 5
 }
should never  {
	never :: -1000
 }
need e big xxx  {
  }
special values for the key argument to an argument parsing function argp err unknown should be returned if they  {
	              they :: -1000
                 }
aren  {
	frena :: 6
	avenir :: 5
	crena :: 6
	crane :: 5
	arena :: 6
	arenas :: 5
	urena :: 6
	wren :: 5
	earn :: 5
	bren :: 5
	arew :: 5
	aret :: 5
	ares :: 5
	areg :: 5
	amen :: 5
	agen :: 5
	arenous :: 5
	urenas :: 5
	are :: 6
	ane :: 5
 }
t understood  {
	understood :: -1000
 }
the sequence  {
	sequence :: -1000
 }
of keys to a parsing function is either where each uppercased  {
	uppercased :: -1000
         }
word  {
	word :: -1000
 }
should be prefixed  {
	prefixed :: -1000
 }
by argp key and opt is a user key init opt no args end success  {
	       success :: -1000
             }
no non option arguments  {
	arguments :: -1000
  }
at all or init opt arg end success all non option args parsed  {
	      parsed :: -1000
           }
or init opt arg success some  {
	 some :: -1000
    }
non option arg unrecognized the third  {
	third :: -1000
    }
case is where every parser returned argp key unknown for an argument in which case parsing stops  {
	           stops :: -1000
               }
at that argument returning the unparsed  {
	unraised :: 12
	unerased :: 11
	unmarked :: 10
	unparadise :: 10
	uplanders :: 10
	unhasped :: 11
	unharmed :: 10
	unhalsed :: 10
	unspared :: 12
	unversed :: 10
	unsoaped :: 10
	uncarted :: 10
	unpursed :: 12
	unvaried :: 10
	unprayed :: 11
	unshared :: 10
	unshaped :: 10
	undraped :: 10
	undrapes :: 11
	unpalsied :: 10
	unpurse :: 10
	unpoised :: 10
	unpared :: 12
	unseared :: 10
	unsapped :: 11
	unpraised :: 10
	upraised :: 11
	unpackers :: 10
	unbarked :: 10
	unbarbed :: 10
	undersea :: 11
	undrape :: 10
	unhorsed :: 10
	unpathed :: 10
	unparted :: 13
	unpaired :: 12
	unpacked :: 10
	underseal :: 10
	underlaps :: 10
	underpays :: 10
	underpass :: 10
	unwarmed :: 10
	unwarped :: 12
	unreaped :: 10
	unsprayed :: 10
    }
arguments to the caller  {
	caller :: -1000
  }
of argp parse if requested  {
	requested :: -1000
   }
or stopping  {
	stopping :: -1000
 }
with an error message if not if an error occurs  {
	   occurs :: -1000
        }
either detected  {
	detected :: -1000
 }
by argp or because  {
	because :: -1000
  }
the parsing function returned an error value then the parser is called  {
	  outraging :: -1000
          }
with argp key error and no further  {
	further :: -1000
     }
calls  {
	calls :: -1000
 }
are made  {
	made :: -1000
 }
this is not an option at all but rather a command  {
	   command :: -1000
         }
line  {
	line :: -1000
 }
argument if a parser receiving  {
	receiving :: -1000
   }
this key returns success the fact  {
	 fact :: -1000
    }
is recorded  {
	recorded :: -1000
 }
and the argp key no args case won  {
	    won :: -1000
      }
t be used however  {
	however :: -1000
  }
if while  {
	while :: -1000
 }
processing  {
	processing :: -1000
 }
the argument a parser function decrements  {
	decrements :: -1000
    }
the next field of the state it s passed the option won t be considered  {
	    considered :: -1000
             }
processed  {
	processed :: -1000
 }
this is to allow you to actually modify the argument perhaps  {
	   perhaps :: -1000
         }
into an option and have it processed again define argp key arg there are remaining  {
	     remaining :: -1000
             }
arguments not parsed by any parser which may be found starting  {
	  starting :: -1000
         }
at state argv  {
	gravy :: 5
	grave :: 5
 }
state next if success is returned but state next left untouched  {
	 untouched :: -1000
         }
it s assumed  {
	assumed :: -1000
 }
that all arguments were  {
	were :: -1000
  }
consume  {
	strapontin :: -1000
 }
otherwise  {
	otherwise :: -1000
 }
the parser should adjust  {
	adjust :: -1000
  }
state next to reflect  {
	reflect :: -1000
  }
any arguments consumed  {
	consumed :: -1000
 }
define argp key args x there are no more command line arguments at all define argp key end x because it s common  {
	                common :: -1000
                     }
to want  {
	want :: -1000
 }
to do some special processing if there aren t any non option args user parsers  {
	       parsers :: -1000
             }
are called with this key if they didn  {
	  dined :: 5
	 dirndl :: 5
	   didy :: 5
	   dido :: 5
	    nid :: 5
	    did :: 6
      }
t successfully  {
	successfully :: -1000
 }
process any non option arguments called just  {
	  just :: -1000
     }
before argp key end where more general validity  {
	validity :: -1000
      }
checks  {
	checks :: -1000
 }
on previously  {
	previously :: -1000
 }
parsed arguments can take  {
	take :: -1000
  }
place define argp key no args x passed in before any parsing is done  {
	         done :: -1000
            }
afterwards  {
	afterwards :: -1000
 }
the values of each element of the child input field if any in the state structure is copied  {
	           copied :: -1000
                }
to each child s state to be the initial  {
	 initial :: -1000
       }
value of the input field define argp key init x use after all other keys including success end define argp key fini  {
	                finis :: 7
	                ficin :: 6
	               fixing :: 5
	               firing :: 5
	               finite :: 6
	               finish :: 6
	               fining :: 5
	               finial :: 6
	               filing :: 5
	               minify :: 5
	               vinify :: 5
	                 mini :: 5
	                 feni :: 5
	              finites :: 5
	              finises :: 5
	              finicky :: 5
	              finical :: 5
	                  fin :: 5
                    }
x passed in when parsing has successfully been  {
	   been :: -1000
      }
completed even if there are still arguments remaining define argp key success x passed in if an error occurs define argp key error x an argp structure contains  {
	                   contains :: -1000
                          }
a set of options declarations  {
	declarations :: -1000
   }
a function to deal  {
	deal :: -1000
  }
with parsing one documentation string a possible  {
	possible :: -1000
     }
vector of child argp s and perhaps a function to filter  {
	    filter :: -1000
         }
help output when actually parsing options getopt is called with the union of all the argp structures chained  {
	          chained :: -1000
                }
together  {
	together :: -1000
 }
through  {
	through :: -1000
 }
their  {
	their :: -1000
 }
child pointers  {
	pointers :: -1000
 }
with conflicts  {
	lacrymal :: -1000
 }
being  {
	being :: -1000
 }
resolved  {
	resolved :: -1000
 }
in favor  {
	favor :: -1000
 }
of the first occurrence  {
	occurrence :: -1000
  }
in the chain struct argp an array of argp option structures terminated  {
	 terminated :: -1000
          }
by an entry with both name and key having a value of const struct argp option options what to do with an option from this structure key is the key associated with the option and arg is any associated argument null if none  {
	                                      none :: -1000
                                         }
was  {
	was :: -1000
 }
supplied  {
	supplied :: -1000
 }
if key isn t understood argp err unknown should be returned if a non zero non argp err unknown value is returned then parsing is stopped  {
	                  stopped :: -1000
                        }
immediately  {
	immediately :: -1000
 }
and that value is returned from argp parse for special non user supplied values of key see the argp key definitions below  {
	               divine :: -1000
                    }
argp parser t parser a string describing  {
	describing :: -1000
     }
what other arguments are wanted  {
	wanted :: -1000
   }
by this program  {
	program :: -1000
 }
it is only  {
	only :: -1000
 }
used by argp usage to print the usage message if it contains newlines  {
	    hemlines :: 10
	    setlines :: 10
	    reclines :: 10
	    declines :: 10
	   newsiness :: 11
	    sentinel :: 10
	    neurines :: 10
	     setline :: 10
	    jawlines :: 10
	    entwines :: 10
	    nervines :: 10
	    redlines :: 10
	    towlines :: 10
	    bowlines :: 10
           }
the strings  {
	strings :: -1000
 }
separated  {
	separated :: -1000
 }
by them  {
	them :: -1000
 }
are considered alternative  {
	alternative :: -1000
 }
usage patterns  {
	patterns :: -1000
 }
and printed on separate lines  {
	lines :: -1000
   }
lines after the first are prefix by or instead of usage const char args doc if non null a string containing  {
	          containing :: -1000
                   }
extra  {
	extra :: -1000
 }
text to be printed before and after the options in a long help message separated by a vertical  {
	         vertical :: -1000
                }
tab v character const char doc a vector of argp children  {
	  children :: -1000
         }
structures terminated by a member with a argp field pointing  {
	 pointing :: -1000
        }
to child argps  {
	grasp :: 6
	fraps :: 6
	draps :: 6
	craps :: 6
	argus :: 7
	wraps :: 6
	traps :: 6
	graphs :: 6
	grapes :: 6
 }
should be parsed with this one any conflicts are resolved in favor of this argp or early  {
	           early :: -1000
               }
argps in the children list this field is useful if you use libraries  {
	   libraries :: -1000
           }
that supply  {
	supply :: -1000
 }
their own  {
	own :: -1000
 }
argp structure which you want to use in conjunction  {
	conjunction :: -1000
       }
with your own const struct argp child children if non zero this should be a function to filter the output of help messages key is either a key from an option in which case text is that option s help text or a special key from the argp key help defines  {
	                                           defines :: -1000
                                                 }
below describing which other help text text is the function should return either text if it should be used as is a replacement  {
	           replacement :: -1000
                     }
string which should be malloced  {
	balloted :: 10
	fallowed :: 10
	hallowed :: 10
	wallowed :: 10
	sallowed :: 10
	tallowed :: 10
	walloped :: 10
	galloped :: 10
	mallecho :: 11
	slalomed :: 10
	callose :: 10
	mellowed :: 10
	collared :: 10
	collated :: 10
	collaged :: 10
	malled :: 10
   }
and will be freed by argp or null meaning  {
	 meaning :: -1000
       }
print nothing  {
	nothing :: -1000
 }
the value for text is after any translation  {
	translation :: -1000
      }
has been done so if any of the replacement text also needs  {
	      needs :: -1000
          }
translation that should be done by the filter function input is either the input supplied to argp parse or null if argp help was called directly  {
	                 directly :: -1000
                        }
char help filter int key const char text void input if non zero the strings used in the argp library are translated  {
	           translated :: -1000
                    }
using  {
	using :: -1000
 }
the domain  {
	domain :: -1000
 }
described by this string otherwise the currently  {
	currently :: -1000
     }
installed  {
	installed :: -1000
 }
default domain is used const char argp domain possible key arguments to a help filter function define argp key help pre doc x help text preceeding  {
	              proceedings :: 16
	               prehending :: 12
	                precented :: 12
	             predeceasing :: 12
	                precedent :: 12
	                preceding :: 12
	               pickeering :: 12
	               precessing :: 12
	                  preened :: 12
	               precluding :: 13
	                  precede :: 12
	               rebreeding :: 12
	               precenting :: 12
	               predestine :: 12
	                 piecened :: 12
	                 piecener :: 12
	               proceeding :: 17
                        }
options define argp key help post  {
	 post :: -1000
    }
doc x help text following options define argp key help header x option header string define argp key help extra x after all other documentation text is null for this key explanatory  {
	                    explanatory :: -1000
                              }
note emitted  {
	emitted :: -1000
 }
when duplicate  {
	duplicate :: -1000
 }
option arguments have been suppressed  {
	suppressed :: -1000
   }
define argp key help dup args note x define argp key help args doc x argument doc string when an argp has a non zero children field it should point to a vector of argp child structures each of which describes a subsidiary  {
	                                subsidiary :: -1000
                                         }
argp struct argp child the child parser const struct argp argp flags for this child int flags if non zero an optional header to be printed in help output before the child options as a side  {
	                               side :: -1000
                                  }
effect a non zero value forces  {
	forces :: -1000
    }
the child options to be grouped  {
	grouped :: -1000
    }
together to achieve  {
	achieve :: -1000
 }
this effect without actually printing  {
	printing :: -1000
   }
a header string use a value of const char header where to group the child options relative  {
	        relative :: -1000
               }
to the other consolidated  {
	consolidated :: -1000
  }
options in the parent  {
	parent :: -1000
  }
argp the values are the same as the group field in argp option structs  {
	     sprucest :: 9
	      strunts :: 11
	      strouts :: 10
	      stratus :: 9
	      scrutos :: 9
	      scrunts :: 10
	      thrusts :: 9
	       struts :: 10
            }
but all child groupings  {
	groupings :: -1000
  }
follow parent options at a particular group level  {
	  level :: -1000
      }
if both this field and header are zero then they aren t grouped at all but rather merged  {
	           merged :: -1000
                }
with the parent options merging  {
	merging :: -1000
   }
the child s grouping levels  {
	levels :: -1000
   }
with the parents  {
	parents :: -1000
 }
int group parsing state this is provided  {
	provided :: -1000
     }
to parsing functions  {
	functions :: -1000
 }
called by argp which may examine  {
	examine :: -1000
    }
and as noted  {
	noted :: -1000
 }
modify fields struct argp state the top  {
	   top :: -1000
     }
level argp being parsed const struct argp root  {
	   root :: -1000
      }
argp the argument vector being parsed may be modified  {
	modified :: -1000
       }
int argc  {
	arfs :: -1000
 }
char argv the index  {
	index :: -1000
  }
in argv of the next arg that to be parsed may be modified int next the flags supplied to argp parse may be modified unsigned flags while calling a parsing function with a key of argp key arg this is the number of the current arg starting at zero and incremented  {
	                                       incremented :: -1000
                                                 }
after each such call returns at all other times this is the number of such arguments that have been processed unsigned arg num if non zero the index in argv of the first argument following a special argument which prevents  {
	                               prevents :: -1000
                                      }
anything  {
	anything :: -1000
 }
following being interpreted  {
	interpreted :: -1000
 }
as an option only set once  {
	taipan :: -1000
    }
argument parsing has proceeded  {
	proceeded :: -1000
  }
past  {
	past :: -1000
 }
this point int quoted  {
	quoted :: -1000
  }
an arbitrary pointer passed in from the user void input values to pass to child parsers this vector will be the same length as the number of children for the current parser void child inputs  {
	                            inputs :: -1000
                                 }
for the parser s use initialized  {
	initialized :: -1000
    }
to void hook  {
	hook :: -1000
 }
the name used when printing messages this is initialized to argv or program invocation  {
	   invocation :: -1000
            }
name if that is unavailable  {
	unavailable :: -1000
   }
char name streams  {
	streams :: -1000
 }
used when argp prints  {
	stonemasons :: -1000
  }
something  {
	something :: -1000
 }
file err stream for errors initialized to stderr  {
	strider :: 7
	stirred :: 7
	 storer :: 7
	starred :: 7
	 starer :: 7
      }
file out stream for information  {
	information :: -1000
   }
initialized to stdout  {
	setout :: 8
	strouts :: 7
	strouted :: 9
	redouts :: 7
	strout :: 9
	stroud :: 7
	stout :: 7
	utmost :: 7
 }
void pstate  {
	scrubbier :: -1000
 }
private  {
	private :: -1000
 }
for use by argp flags for argp parse note that the defaults  {
	   defaults :: -1000
          }
are those  {
	those :: -1000
 }
that are convenient  {
	convenient :: -1000
 }
for program command line parsing don t ignore the first element of argv normally and always  {
	         always :: -1000
              }
unless argp no errs  {
	errs :: -1000
  }
is set the first element of the argument vector is skipped  {
	   skipped :: -1000
         }
for option parsing purposes as it corresponds  {
	corresponds :: -1000
     }
to the program name in a command line define argp parse argv x don t print error messages for unknown options to stderr unless this flag is set argp parse argv is ignored as argv is used as the program name in the error messages this flag implies  {
	                                        implies :: -1000
                                              }
argp no exit on the assumption  {
	assumption :: -1000
    }
that silent  {
	silent :: -1000
 }
exiting upon  {
	upon :: -1000
 }
errors is bad behaviour  {
	behaviour :: -1000
  }
define argp no errs x don t parse any non option args normally non option args are parsed by calling the parse functions with a key of argp key arg and the actual arg as the value since  {
	                                since :: -1000
                                    }
it s impossible  {
	impossible :: -1000
 }
to know  {
	know :: -1000
 }
which parse function wants  {
	wants :: -1000
  }
to handle  {
	handle :: -1000
 }
it each one is called in turn until one returns or an error other than argp err unknown if an argument is handled  {
	            spokeshave :: -1000
                     }
by no one the argp parse returns prematurely  {
	prematurely :: -1000
      }
but with a return value of if all args have been parsed without error all parsing functions are called one last  {
	                last :: -1000
                   }
time with a key of argp key end this flag needn  {
	    neoned :: 6
	   needing :: 7
	  needling :: 6
	      nene :: 6
	      need :: 7
	     needy :: 6
	     needs :: 6
         }
t normally be set as the normal behavior  {
	behavior :: -1000
      }
is to stop parsing as soon  {
	 soon :: -1000
    }
as some argument can t be handled define argp no args x parse options and arguments in the same order they occur on the command line normally they re rearranged  {
	                   rearranged :: -1000
                            }
so that all options come  {
	come :: -1000
   }
first define argp in order x don t provide the standard  {
	  standard :: -1000
         }
long option help which causes  {
	causes :: -1000
   }
usage and option help information to be output to stdout and exit called define argp no help x don t exit on errors they may still result in error messages define argp no exit x use the gnu getopt long only rules  {
	                                    rules :: -1000
                                        }
for parsing arguments define argp long only x turns  {
	   turns :: -1000
       }
off any message printing exiting options define argp silent argp no exit argp no errs argp no help parse the options strings in argc argv according  {
	                according :: -1000
                        }
to the options in argp flags is one of the argp flags above  {
	       above :: -1000
           }
if arg index is non null the index in argv of the first unparsed option is returned in it if an unknown option is present argp err unknown is returned if some parser routine  {
	                          routine :: -1000
                                }
returned a non zero value it is returned otherwise is returned this function may also call exit unless the argp no help flag is set input is a pointer to a value to be passed in to the parser extern error t argp parse const struct argp restrict argp int argc char restrict argv unsigned flags int restrict arg index void restrict input extern error t argp parse const struct argp restrict argp int argc char restrict argv unsigned flags int restrict arg index void restrict input global  {
	                                                                                 global :: -1000
                                                                                      }
variables  {
	variables :: -1000
 }
if defined or set by the user program to a non zero value then a default option version is added unless the argp no help flag is used which will print this string followed  {
	                         followed :: -1000
                                }
by a newline and exit unless the argp no exit flag is used overridden  {
	   overridden :: -1000
            }
by argp program version hook extern const char argp program version if defined or set by the user program to a non zero value then a default option version is added unless the argp no help flag is used which calls this function with a stream to print the version to and a pointer to the current parsing state and then exits unless the argp no exit flag is used this variable takes  {
	                                                                   takes :: -1000
                                                                       }
precedent  {
	precedent :: -1000
 }
over argp program version extern void argp program version hook file restrict stream struct argp state restrict state if defined or set by the user program it should point to string that is the bug  {
	                               bug :: -1000
                                 }
reporting  {
	reporting :: -1000
 }
address for the program it will be printed by argp help if the argp help bug addr flag is set as it is by various  {
	                 various :: -1000
                       }
standard help messages embedded  {
	embedded :: -1000
  }
in a sentence  {
	sentence :: -1000
 }
that says  {
	says :: -1000
 }
something like report bugs  {
	bugs :: -1000
  }
to addr extern const char argp program bug address the exit status that argp will use when exiting due  {
	               due :: -1000
                 }
to a parsing error if not defined or set by the user program this defaults to ex usage from sysexits  {
                  }
h extern error t argp err exit status flags for argp help define argp help usage x a usage message define argp help short usage x but don t actually print options define argp help see x a try for more help message define argp help long x a long help message define argp help pre doc x doc string preceding  {
	                                                   preceding :: -1000
                                                           }
long help define argp help post doc x doc string following long help define argp help doc argp help pre doc argp help post doc define argp help bug addr x bug report address define argp help long only x modify output appropriately  {
	                             appropriately :: -1000
                                         }
to reflect argp long only mode these argp help flags are only understood by argp state help define argp help exit err x call exit instead of returning define argp help exit ok  {
	                            okra :: 2
	                            okes :: 2
	                            okeh :: 2
	                            okas :: 2
	                             oke :: 3
	                             oka :: 3
	                             oik :: 2
	                             oak :: 2
	                              ko :: 2
	                               o :: 2
                               }
x call exit instead of returning the standard thing to do after a program command line parsing error if an error message has already  {
	                already :: -1000
                      }
been printed define argp help std err argp help see argp help exit err the standard thing to do after a program command line parsing error if no more specific  {
	                     specific :: -1000
                            }
error message has been printed define argp help std usage argp help short usage argp help see argp help exit err the standard thing to do in response  {
	                   response :: -1000
                          }
to a help option define argp help std help argp help short usage argp help long argp help exit ok argp help doc argp help bug addr output a usage message for argp to stream flags are from the set argp help extern void argp help const struct argp restrict argp file restrict stream unsigned flags char restrict name extern void argp help const struct argp restrict argp file restrict stream unsigned flags char name the following routines  {
	                                                                     routines :: -1000
                                                                            }
are intended to be called from within an argp parsing routine thus  {
	       ties :: -1000
          }
taking  {
	taking :: -1000
 }
an argp state structure as the first argument they may or may not print an error message and exit depending  {
	          depending :: -1000
                  }
on the flags in state in any case the caller should be prepared  {
	   raffinose :: -1000
           }
for them not to exit and should return an appropiate  {
	appropriated :: 13
	appropriates :: 13
	appropriative :: 12
	appropriately :: 12
	appropriate :: 14
	appreciate :: 12
        }
error after calling them argp usage argp error should probably be called argp state but they re used often  {
	             often :: -1000
                 }
enough  {
	enough :: -1000
 }
that they should be short output if appropriate a usage message for state to stream flags are from the set argp help extern void argp state help const struct argp state restrict state file restrict stream unsigned int flags extern void argp state help const struct argp state restrict state file restrict stream unsigned int flags possibly  {
	                                                possibly :: -1000
                                                       }
output the standard usage message for argp to stderr and exit extern void argp usage const struct argp state state extern void argp usage const struct argp state state if appropriate print the printf string fmt  {
	                                fit :: 3
	                                fet :: 3
	                                fat :: 3
                                  }
and following args preceded  {
	preceded :: -1000
  }
by the program name and to stderr and followed by a try help message then exit extern void argp error const struct argp state restrict state const char restrict fmt attribute format printf extern void argp error const struct argp state restrict state const char restrict fmt attribute format printf similar  {
	                                           similar :: -1000
                                                 }
to the standard gnu error reporting function error but will respect  {
	   respect :: -1000
         }
the argp no exit and argp no errs flags in state and will print to state err stream this is useful for argument parsing code that is shared  {
	                     shared :: -1000
                          }
between  {
	between :: -1000
 }
program startup  {
	startup :: -1000
 }
when exiting is desired  {
	desired :: -1000
  }
and runtime  {
	centile :: -1000
 }
option parsing when typically  {
	typically :: -1000
  }
an error code is returned instead the difference  {
	difference :: -1000
      }
between this function and argp error is that the latter  {
	   lauder :: -1000
        }
is for parsing errors and the former  {
	former :: -1000
     }
is for other problems  {
	problems :: -1000
  }
that occur during  {
	during :: -1000
 }
parsing but don t reflect a syntactic  {
	syntactic :: -1000
     }
problem with the input extern void argp failure  {
	failure :: -1000
      }
const struct argp state restrict state int status int errnum  {
	   frenum :: 7
	prenumber :: 7
	   regnum :: 7
        }
const char restrict fmt attribute format printf extern void argp failure const struct argp state restrict state int status int errnum const char restrict fmt attribute format printf returns true  {
	                         true :: -1000
                            }
if the option opt is a valid short option extern int option is short const struct argp option opt throw extern int option is short const struct argp option opt throw returns true if the option opt is in fact the last unused entry in an options array extern int option is end const struct argp option opt throw extern int option is end const struct argp option opt throw return the input field for argp in the parser corresponding to state used by the help routines extern void argp input const struct argp restrict argp const struct argp state restrict state throw extern void argp input const struct argp restrict argp const struct argp state restrict state throw ifdef use extern inlines  {
	                                                                                                                    unline :: 9
	                                                                                                                    inline :: 12
	                                                                                                                    ingine :: 9
	                                                                                                                   unlines :: 11
	                                                                                                                   insinew :: 10
	                                                                                                                  inkiness :: 9
	                                                                                                                   inliers :: 9
                                                                                                                         }
if libc  {
	cibol :: 5
	libs :: 5
	lib :: 6
 }
define argp usage argp usage define argp state help argp state help define option is short option is short define option is end option is end endif ifndef argp ei define argp ei extern inline endif argp ei void argp usage const struct argp state state argp state help state stderr argp help std usage argp ei int nth option is short const struct argp option opt if opt flags option doc return else int key opt key return key key uchar  {
	                                                                      microseisms :: -1000
                                                                                }
max isprint  {
	imprint :: 11
	enprints :: 9
	imprinted :: 9
	impaints :: 9
	reprints :: 9
	imprinters :: 9
 }
key argp ei int nth option is end const struct argp option opt return opt key opt name opt doc opt group if libc undef argp usage undef argp state help undef option is short undef option is end endif endif use extern inlines ifdef cplusplus endif endif argp h routines for dealing  {
	                                             dealing :: -1000
                                                   }
with separated arg vectors  {
	vectors :: -1000
  }
copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef argz  {
	                                                                                                                                  graze :: 5
                                                                                                                                      }
h define argz h include features h define need error t include errno h include string h need size t and strchr  {
	                stich :: 7
                    }
is called below ifndef const define const const endif ifndef error t defined typedef int error t endif begin decls make  {
	                make :: -1000
                   }
a separated arg vector from a unix  {
	  unix :: -1000
     }
argv vector returning it in argz and the total  {
	   total :: -1000
       }
length in len if a memory allocation  {
	allocation :: -1000
     }
error occurs enomem  {
	mneme :: 7
 }
is returned otherwise the result can be destroyed  {
	destroyed :: -1000
      }
using free extern error t argz create  {
	create :: -1000
     }
char const argv char restrict argz size t restrict len throw extern error t argz create char const argv char restrict argz size t restrict len throw make a separated arg vector from a sep separated list in string returning it in argz and the total length in len if a memory allocation error occurs enomem is returned otherwise the result can be destroyed using free extern error t argz create sep const char restrict string int sep char restrict argz size t restrict len throw extern error t argz create sep const char restrict string int sep char restrict argz size t restrict len throw returns the number of strings in argz extern size t argz count  {
	                                                                                                                count :: -1000
                                                                                                                    }
const char argz size t len throw attribute pure extern size t argz count const char argz size t len throw attribute pure puts  {
	                   puts :: -1000
                      }
pointers to each string in argz into argv which must  {
	     nest :: -1000
        }
be large enough to hold  {
	hold :: -1000
   }
them all extern void argz extract  {
	extract :: -1000
    }
const char restrict argz size t len char restrict argv throw extern void argz extract const char restrict argz size t len char restrict argv throw make separated arg vector argz printable by converting  {
	                          timbres :: -1000
                                }
all the s except the last into the character sep extern void argz stringify  {
	      stringy :: 12
	    stringily :: 15
	    springily :: 12
	    stringier :: 11
	       string :: 11
            }
char argz size t len int sep throw extern void argz stringify char argz size t len int sep throw append  {
	              yonder :: -1000
                   }
buf of length buf len to the argz vector in argz argz len extern error t argz append char restrict argz size t restrict argz len const char restrict buf size t buf len throw extern error t argz append char restrict argz size t restrict argz len const char restrict buf size t buf len throw append str to the argz vector in argz argz len extern error t argz add char restrict argz size t restrict argz len const char restrict str throw extern error t argz add char restrict argz size t restrict argz len const char restrict str throw append sep separated list in string to the argz vector in argz argz len extern error t argz add sep char restrict argz size t restrict argz len const char restrict string int delim  {
	                                                                                                                                   kelim :: 7
	                                                                                                                                 delimit :: 7
	                                                                                                                                 delimed :: 6
	                                                                                                                                 delimes :: 7
	                                                                                                                                   gelid :: 6
	                                                                                                                                   felid :: 6
	                                                                                                                                   devil :: 6
	                                                                                                                                   denim :: 7
	                                                                                                                                   demit :: 6
	                                                                                                                                   delis :: 7
	                                                                                                                                   deism :: 6
	                                                                                                                                   bedim :: 6
	                                                                                                                                decimals :: 6
	                                                                                                                                 decimal :: 7
	                                                                                                                                  denims :: 6
	                                                                                                                                  delist :: 6
	                                                                                                                                  delime :: 8
	                                                                                                                                  delict :: 6
	                                                                                                                                  kelims :: 6
	                                                                                                                                delimits :: 6
	                                                                                                                                deliming :: 6
	                                                                                                                                 unlimed :: 6
	                                                                                                                                  meloid :: 6
	                                                                                                                                  medial :: 6
	                                                                                                                                    meld :: 6
	                                                                                                                                    deli :: 8
	                                                                                                                                    deil :: 6
	                                                                                                                                   melik :: 6
	                                                                                                                                   melic :: 6
	                                                                                                                                     del :: 6
                                                                                                                                       }
throw extern error t argz add sep char restrict argz size t restrict argz len const char restrict string int delim throw delete  {
	                delete :: -1000
                     }
entry from argz argz len if it appears  {
	appears :: -1000
      }
there extern void argz delete char restrict argz size t restrict argz len char restrict entry throw extern void argz delete char restrict argz size t restrict argz len char restrict entry throw insert  {
	                           insert :: -1000
                                }
entry into argz argz len before before which should be an existing  {
	   existing :: -1000
          }
entry in argz if before is null entry is appended  {
	 appended :: -1000
        }
to the end since argz s first entry is the same as argz argz insert argz argz len argz entry will insert entry at the beginning  {
	                beginning :: -1000
                        }
of argz if before is not in argz einval is returned else if memory can t be allocated  {
	        allocated :: -1000
                }
for the new argz enomem is returned else extern error t argz insert char restrict argz size t restrict argz len char restrict before const char restrict entry throw extern error t argz insert char restrict argz size t restrict argz len char restrict before const char restrict entry throw replace any occurrences  {
	                                         occurrences :: -1000
                                                   }
of the string str in argz with with reallocating  {
	reallocating :: -1000
       }
argz as necessary  {
	necessary :: -1000
 }
if replace count is non zero replace count will be incremented by number of replacements  {
	  replacements :: -1000
             }
performed extern error t argz replace char restrict argz size t restrict argz len const char restrict str const char restrict with unsigned int restrict replace count extern error t argz replace char restrict argz size t restrict argz len const char restrict str const char restrict with unsigned int restrict replace count returns the next entry in argz argz len after entry or null if there are no more if entry is null then the first entry is returned this behavior allows  {
	                                                                           pallors :: -1000
                                                                                 }
two convenient iteration  {
	iteration :: -1000
 }
styles  {
	styles :: -1000
 }
char entry while entry argz next argz argz len entry or char entry for entry argz entry entry argz next argz argz len entry extern char argz next const char restrict argz size t argz len const char restrict entry throw extern char argz next const char restrict argz size t argz len const char restrict entry throw ifdef use extern inlines extern inline char nth argz next const char argz size t argz len const char entry if entry if entry argz argz len entry strchr entry return entry argz argz len char null char entry else return argz len char argz extern inline char nth argz next const char argz size t argz len const char entry return argz next argz argz len entry endif use extern inlines end decls endif argz h header describing ar archive  {
	                                                                                                                                 sigmating :: -1000
                                                                                                                                         }
file format copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef ar h define ar h include sys cdefs  {
	                                                                                                                                           coeds :: 6
	                                                                                                                                           clefs :: 7
	                                                                                                                                           chefs :: 7
                                                                                                                                               }
h archive files start with the armag  {
	 grama :: 6
	 argan :: 6
	 argal :: 6
	 agmas :: 6
	damager :: 6
	  agma :: 7
     }
identifying  {
	identifying :: -1000
 }
string then follows a struct ar hdr and as many  {
	     many :: -1000
        }
bytes of member file data as its ar size member indicates for each member file define armag arch n string that begins  {
	               begins :: -1000
                    }
an archive file define sarmag  {
	karma :: 7
	massager :: 7
	grama :: 7
	sangar :: 7
	sambar :: 7
	gasman :: 7
	saggar :: 7
	gammas :: 7
	sarangi :: 7
	margosa :: 7
	margays :: 8
	smaragde :: 7
	martagons :: 7
	malmags :: 7
	tarmacs :: 7
	ragman :: 7
	smaragd :: 8
	rampages :: 7
	margay :: 7
	magmas :: 7
	harmans :: 7
	gramas :: 8
	gramash :: 7
	maras :: 7
   }
size of that string define arfmag  {
	synchroscope :: -1000
    }
n string in ar fmag  {
	frag :: 5
	flag :: 5
   }
at end of each header begin decls struct ar hdr char ar name member file name sometimes  {
	       sometimes :: -1000
               }
terminated char ar date  {
	date :: -1000
  }
file date decimal  {
	decimal :: -1000
 }
seconds since epoch  {
	epoch :: -1000
 }
char ar uid  {
	nidus :: 3
	yid :: 3
	vid :: 3
	tid :: 3
	rid :: 3
	nid :: 3
	mid :: 3
	lid :: 3
	kid :: 3
	hid :: 3
	gid :: 3
	fid :: 3
	dui :: 3
	did :: 3
	bid :: 3
	aid :: 3
	di :: 3
 }
ar gid  {
	gid :: -1000
 }
user and group ids  {
	ids :: -1000
  }
in ascii  {
	coprology :: -1000
 }
decimal char ar mode file mode in ascii octal  {
	   octal :: -1000
       }
char ar size file size in ascii decimal char ar fmag always contains arfmag end decls endif ar h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa iso c standard diagnostics  {
	                                                                                                                                                 diagnostics :: -1000
                                                                                                                                                           }
assert  {
	assert :: -1000
 }
h ifdef assert h undef assert h undef assert undef assert void cast  {
	        cast :: -1000
           }
ifdef use gnu undef assert perror  {
	pretor :: 7
	pourer :: 7
	poorer :: 7
	perron :: 7
	parroter :: 8
	perform :: 7
	terror :: 9
	repro :: 7
	terrors :: 8
	parroters :: 7
    }
endif endif assert h define assert h include features h if defined cplusplus gnuc prereq  {
	        preyer :: 8
	        prefer :: 8
	         frere :: 7
	         brere :: 7
	      prerenal :: 7
	         arere :: 7
	       preyers :: 7
	       preverb :: 7
	       preterm :: 7
	       prerace :: 7
	       prefers :: 7
	      perruque :: 7
	         prore :: 7
             }
define assert void cast static  {
	static :: -1000
   }
cast void else define assert void cast void endif void assert int expression  {
	      worral :: -1000
           }
if ndebug  {
	bedbug :: 7
	redbug :: 7
 }
is defined do nothing if not and expression is zero print an error message and abort  {
	          abort :: -1000
              }
ifdef ndebug define assert expr assert void cast void assert perror int errnum if ndebug is defined do nothing if not and errnum is not zero print an error message with the error text for errnum and abort this is a gnu extension  {
	                                 extension :: -1000
                                         }
ifdef use gnu define assert perror errnum assert void cast endif else not ndebug ifndef assert h decls define assert h decls begin decls this prints an assertion  {
	                  assertion :: -1000
                          }
failed  {
	failed :: -1000
 }
message and aborts  {
	aborts :: -1000
 }
extern void assert fail const char assertion const char file unsigned int line const char function throw attribute noreturn  {
	         northerns :: 10
	          overturn :: 10
	          northern :: 11
                 }
likewise but prints the error text for errnum extern void assert perror fail int errnum const char file unsigned int line const char function throw attribute noreturn the following is not at all used here  {
	                              here :: -1000
                                 }
but needed  {
	needed :: -1000
 }
for standard compliance  {
	compliance :: -1000
 }
extern void assert const char assertion const char file int line throw attribute noreturn end decls endif not assert h decls define assert expr expr assert void cast assert fail string expr file line assert function ifdef use gnu define assert perror errnum errnum assert void cast assert perror fail errnum file line assert function endif version and later of gcc define a magical  {
	                                                        magical :: -1000
                                                              }
variable pretty  {
	pretty :: -1000
 }
function which contains the name of the function currently being defined this is broken  {
	       broken :: -1000
            }
in g before version c x has a similar variable called func but prefer  {
	       prefer :: -1000
            }
the gcc one since it demangles  {
	bemingled :: 11
	bemingles :: 12
	lemonades :: 12
	entangles :: 11
	melanges :: 12
	megadynes :: 11
	melange :: 11
	rehandles :: 11
    }
c function names if defined cplusplus gnuc prereq gnuc prereq define assert function pretty function else if defined stdc version stdc version l define assert function func else define assert function const char endif endif endif ndebug class  {
	                                class :: -1000
                                    }
autosprintf  {
 }
formatted  {
	formatted :: -1000
 }
output to an ostream  {
	outbeams :: 9
	overmast :: 9
	omerta :: 9
	amorets :: 9
	matres :: 9
	outreads :: 9
  }
copyright c free software foundation inc this program is free software you can redistribute it and or modify it under the terms of the gnu library general public license as published by the free software foundation either version or at your option any later version this program is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu library general public license for more details you should have received a copy of the gnu library general public license along with this program if not write to the free software foundation inc franklin  {
	                                                                                                      franklin :: -1000
                                                                                                             }
street  {
	street :: -1000
 }
fifth  {
	fifth :: -1000
 }
floor  {
	floor :: -1000
 }
boston ma usa ifndef autosprintf h define autosprintf h ifndef attribute this feature is available in gcc versions and later if gnuc gnuc gnuc minor strict ansi define attribute spec empty endif the protected variants of format and printf attributes are accepted by gcc versions effectively and later if gnuc gnuc gnuc minor define format format define printf printf endif endif include string include iostream  {
	                                                        onstream :: 12
	                                                        isotherm :: 10
	                                                        mistreat :: 10
	                                                        upstream :: 10
	                                                      isothermal :: 10
                                                               }
namespace  {
	yells :: -1000
 }
gnu a temporary  {
	temporary :: -1000
 }
object usually  {
	usually :: -1000
 }
allocated on the stack  {
	stack :: -1000
  }
representing  {
	representing :: -1000
 }
the result of an asprintf  {
	repaints :: 10
	spirant :: 10
	spraint :: 10
   }
call class autosprintf public constructor  {
	hydrias :: -1000
   }
takes a format string and the printf arguments autosprintf const char format attribute format printf copy constructor autosprintf const autosprintf src  {
	                 tas :: -1000
                   }
destructor  {
	destructor :: -1000
 }
frees  {
	frees :: -1000
 }
the temporarily  {
	temporarily :: -1000
 }
allocated string autosprintf conversion  {
	conversion :: -1000
  }
to string operator  {
	operator :: -1000
 }
char const operator std string const output to an ostream friend  {
	    friend :: -1000
         }
inline std ostream operator std ostream stream const autosprintf tmp  {
	    impot :: 3
	    empty :: 3
	    umpty :: 3
	     tymp :: 3
	     tump :: 3
	     temp :: 3
	     tamp :: 3
	      ump :: 3
	      twp :: 3
	      tup :: 3
	      top :: 3
	      tip :: 3
	      tap :: 3
	      imp :: 3
	      amp :: 3
        }
stream tmp str tmp str error in autosprintf return stream private char str endif autosprintf h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef byteswap  {
                                                                                                                                                      }
h define byteswap h get the machine specific optimized  {
	optimized :: -1000
       }
definitions include bits byteswap h the following definitions must all be macros since otherwise some of the possible optimizations  {
	         turnpikes :: -1000
                 }
are not possible return a value with all bytes in the bit argument swapped  {
	      swapped :: -1000
            }
define bswap  {
 }
x bswap x return a value with all bytes in the bit argument swapped define bswap x bswap x if defined gnuc gnuc return a value with all bytes in the bit argument swapped define bswap x bswap x endif endif byteswap h copyright c dmitry  {
	                                       drifty :: 7
	                                        dirty :: 7
                                            }
butskoy  {
 }
buc  {
	butch :: 3
	bunco :: 3
	bunch :: 3
	bunce :: 3
	bucks :: 4
	bucko :: 4
	buchu :: 3
	buckra :: 3
	buckle :: 3
	buckie :: 3
	bucket :: 3
	bucker :: 3
	bucked :: 3
	curb :: 3
	cube :: 3
	buck :: 5
	buy :: 3
	but :: 3
	bus :: 3
	bur :: 3
	bun :: 3
	bum :: 3
	bug :: 3
	bud :: 3
 }
citadel  {
	undertook :: -1000
 }
stu  {
	tee :: -1000
 }
neva  {
	elvan :: 5
	venal :: 5
	vegan :: 5
	vena :: 6
	nova :: 5
	nevi :: 5
	nema :: 5
	nave :: 6
	leva :: 5
	deva :: 5
	novae :: 6
	navew :: 5
	naves :: 5
	navel :: 5
 }
ru license lgpl  {
 }
v or any later see copying  {
	copying :: -1000
    }
lib for the status of this software ifndef clif  {
	   flics :: 5
	   flick :: 5
	   clift :: 7
	   cliff :: 6
	  clifts :: 6
	  cliffy :: 5
	  cliffs :: 5
	    flic :: 6
	    cuif :: 5
	    coif :: 5
	    clip :: 5
	    clef :: 5
	    alif :: 5
       }
h define clif h typedef struct clif option struct clif option struct clif option struct const char short opt const char long opt const char arg name const char help string int function clif option optn  {
	                             opting :: 5
	                               open :: 5
                                  }
char arg void data int function plus  {
	  plus :: -1000
     }
clif option optn char arg unsigned int flags define clif end option typedef struct clif argument struct clif argument struct clif argument struct const char name const char help string int function clif argument argm  {
	                             groma :: 5
	                             grams :: 5
	                             gramp :: 5
	                             grame :: 5
	                             grama :: 5
	                              gram :: 6
	                              arum :: 5
	                             regma :: 5
	                               arm :: 5
                                 }
char arg int index void data unsigned int flags define clif end argument argument flag bits define clif more x null or several  {
	               several :: -1000
                     }
define clif strict x arg must be present define clif acc prev x arg must be accompanied  {
	     accompanied :: -1000
               }
with previous option flag bits affected  {
	affected :: -1000
    }
only by per option flags define clif extra x don t show  {
	       show :: -1000
          }
in usage line define clif exit x exit after handler  {
	pederasties :: -1000
        }
return define clif excl  {
	excel :: 5
	exilic :: 5
	exclaim :: 5
	exul :: 5
  }
x at exclusive  {
	exclusive :: -1000
 }
area affected by per option flags and by common parse flags argument of clif parse cmdline  {
	       midlines :: 9
	        decline :: 9
	        midline :: 10
	         codlin :: 9
              }
in last case appropriate bits are translated for all the options define clif may join  {
	          join :: -1000
             }
arg x define clif strict join arg x define clif join arg clif may join arg clif strict join arg define clif may noequal  {
	               unequals :: 9
	                coequal :: 11
	                unequal :: 10
                      }
x define clif strict noequal x define clif noequal clif may noequal clif strict noequal define clif may keyword  {
	           keyword :: -1000
                 }
x define clif strict keyword x define clif keyword clif may keyword clif strict keyword define clif may onedash  {
	            anodes :: 9
	            hondas :: 9
                 }
x define clif strict onedash x define clif onedash clif may onedash clif strict onedash define clif optarg  {
	          botargo :: 7
	            gator :: 7
	         outargue :: 7
	            ottar :: 7
                }
x allow missing  {
	missing :: -1000
 }
optarg define clif abbrev  {
	abbe :: 7
  }
x allow long opt abbreviation  {
	abbreviation :: -1000
   }
define clif several x several args in one opt s arg affected only by common parse flags arg of clif parse cmdline define clif help empty x print help on empty cmdline define clif posix  {
	                            posing :: 6
	                           postfix :: 6
	                              pois :: 6
	                              piso :: 6
	                             polis :: 6
	                               pos :: 6
                                 }
x follow posix standard define clif first group x first arg options group define clif strict excl x at least one exclusive define clif silent x no errors on stderr define clif min abbrev a minimal  {
	                        plasterings :: -1000
                                  }
match  {
	match :: -1000
 }
length in abbrev extern int clif parse int argc char argv clif option option list clif argument arg list unsigned int parse flags history  {
	                history :: -1000
                      }
compatibility  {
	compatibility :: -1000
 }
define clif parse cmdline argc argv optn args flags clif parse argc argv optn args flags extern void clif print options const char header const clif option option list extern void clif print arguments const char header const clif argument argument list extern void clif print usage const char header const char progname  {
	                                          programers :: 10
	                                             program :: 10
	                                           programer :: 11
	                                           programed :: 11
                                                   }
const clif option option list const clif argument argument list extern int clif current help void common useful option handlers  {
	           handlers :: -1000
                  }
extern int clif version handler clif option optn char arg extern int clif set flag clif option optn char arg extern int clif unset  {
	                  unset :: -1000
                      }
flag clif option optn char arg extern int clif set string clif option optn char arg extern int clif set int clif option optn char arg extern int clif set uint  {
	                         unity :: 5
	                         units :: 5
	                         unite :: 5
	                          vint :: 5
	                          unit :: 6
	                          tint :: 5
	                          pint :: 5
	                          mint :: 5
	                          lint :: 5
	                          hint :: 5
	                          dint :: 5
	                          bint :: 5
	                           tin :: 5
                             }
clif option optn char arg extern int clif set double  {
	singsonged :: -1000
        }
clif option optn char arg extern int clif call func clif option optn char arg extern int clif arg string clif argument argm char arg int index extern int clif arg int clif argument argm char arg int index extern int clif arg uint clif argument argm char arg int index extern int clif arg double clif argument argm char arg int index extern int clif arg func clif argument argm char arg int index some useful macros define clif help option help read this help and exit clif call func clif current help clif extra clif exit define clif version option str v version print version info and exit clif version handler str clif extra clif exit endif clif h header file for common error description library copyright student  {
	                                                                                                                          student :: -1000
                                                                                                                                }
information processing board  {
	board :: -1000
 }
of the massachusetts  {
 }
institute  {
	institute :: -1000
 }
of technology  {
	technology :: -1000
 }
for copyright and distribution  {
	distribution :: -1000
  }
info see the documentation supplied with this package  {
	package :: -1000
      }
if defined com err h defined com err h ifdef gnuc define com err attr x attribute x else define com err attr x endif include stddef h include stdarg  {
	                    strangled :: 7
	                    straggled :: 7
	                      strange :: 7
	                       strand :: 7
	                       steard :: 8
	                        strag :: 8
	                        strad :: 8
	                        stear :: 7
                            }
h typedef long errcode  {
	precode :: 9
	rescored :: 9
  }
t struct error table char const const msgs  {
	   mugs :: 5
	   mogs :: 5
	   migs :: 5
	   mags :: 5
      }
long base int n msgs struct et list extern void com err const char long const char com err attr format printf extern void com err va const char whoami  {
	                       whammo :: 7
	                     womanish :: 7
	                        whoas :: 7
	                        whamo :: 7
	                         whom :: 7
	                         whoa :: 8
                            }
errcode t code const char fmt va list args com err attr format printf extern char const error message long extern void com err hook const char long const char va list extern void set com err hook void const char long const char va list const char long const char va list extern void reset  {
	                                                  reset :: -1000
                                                      }
com err hook void const char long const char va list extern int init error table const char const msgs long base int count extern char set com err gettext  {
                            }
char const char const char extern errcode t add error table const struct error table et extern errcode t remove error table const struct error table et extern void add to error table struct et list new table provided for heimdall  {
                                       }
compatibility extern const char com right  {
	rigid :: -1000
    }
struct et list list long code extern const char com right r struct et list list long code char str size t len extern void initialize error table r struct et list list const char messages int num errors long base extern void free error table struct et list et provided for compatibility with other com err libraries extern int et list lock void extern int et list unlock  {
	                                                              unlock :: -1000
                                                                   }
void define com err h define com err h endif defined com err h defined com err h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa iso c complex  {
	                                                                                                                                                   complex :: -1000
                                                                                                                                                         }
arithmetic  {
	arithmetic :: -1000
 }
complex h ifndef complex h define complex h include features h get general and iso c specific information include bits mathdef  {
	             matched :: 9
	            fathomed :: 9
	               mated :: 9
                   }
h begin decls we might  {
	might :: -1000
   }
need to add support  {
	support :: -1000
  }
for more compilers here but since iso c is out hopefully  {
	 hopefully :: -1000
         }
all maintained  {
	maintained :: -1000
 }
compilers will soon provide the data types float  {
	  float :: -1000
      }
complex and double complex if gnuc prereq gnuc prereq define complex complex endif define complex complex narrowest  {
	       narrowest :: -1000
               }
imaginary  {
	imaginary :: -1000
 }
unit  {
	unit :: -1000
 }
this depends  {
	depends :: -1000
 }
on the floating  {
	floating :: -1000
 }
point evaluation  {
	evaluation :: -1000
 }
method  {
	method :: -1000
 }
xxx this probably has to go  {
	   go :: -1000
    }
into a gcc related  {
	related :: -1000
  }
file define complex i extension if another  {
	another :: -1000
     }
more descriptive  {
	descriptive :: -1000
 }
name is i xxx once we have the imaginary support switch  {
	    switch :: -1000
         }
this to imaginary i undef i define i complex i the file bits cmathcalls  {
            }
h contains the prototypes  {
	prototypes :: -1000
  }
for all the actual math functions these macros are used for those prototypes so we can easily  {
	          easily :: -1000
               }
declare each function as both name and name and can declare the float versions namef  {
	         ganef :: 6
	         fames :: 6
	         famed :: 6
	        namers :: 6
	        namely :: 6
	        famine :: 6
	         yamen :: 6
	          nema :: 6
	          name :: 8
	          mane :: 6
	          fane :: 6
	          fame :: 7
	         samen :: 6
	         ramen :: 6
	         names :: 7
	         namer :: 7
	         named :: 7
	           nam :: 6
             }
and namef define mathcall  {
	catchalls :: 10
	matchable :: 10
	catchall :: 11
  }
function args mathdecl  {
	latched :: 10
	matched :: 11
	maledict :: 10
 }
mdouble  {
	troubled :: 9
 }
complex function args define mathdecl type function args mathdecl type function args mathdecl type concat  {
	        comsat :: -1000
             }
function args define mathdecl type function args extern type math precname  {
	preachment :: 11
	 preenacts :: 10
	preachments :: 10
	   prename :: 10
	  preflame :: 10
	  preenact :: 11
	  preclean :: 10
         }
function args throw define mdouble double define math precname name name include bits cmathcalls h undef mdouble undef math precname now the float versions ifndef mfloat  {
	                   maloti :: 7
                        }
define mfloat float endif define mdouble mfloat ifdef stdc define math precname name name f else define math precname name name f endif include bits cmathcalls h undef mdouble undef math precname and the long double versions it is non critical  {
	                                critical :: -1000
                                       }
to define them here unconditionally  {
	unconditionally :: -1000
   }
since long double is required in iso c if stdc gnuc defined no long double math defined libc defined ldbl  {
                  }
compat if defined ldbl compat defined no long double math undef mathdecl define mathdecl type function args extern type redirect nth math precname function args function endif ifndef mlong  {
	                       klong :: 7
	                       flong :: 7
	                       emong :: 6
	                      klongs :: 6
	                       among :: 6
	                       along :: 7
	                      flongs :: 6
	                        glom :: 6
                           }
double define mlong double long double endif define mdouble mlong double ifdef stdc define math precname name name l else define math precname name name l endif include bits cmathcalls h endif undef mdouble undef math precname undef mathdecl undef mathdecl undef mathcall end decls endif complex h extended  {
	                                        extended :: -1000
                                               }
cpio  {
 }
format from posix this file is part of the gnu c library copyright c free software foundation inc note the canonical  {
	           canonical :: -1000
                   }
source  {
	source :: -1000
 }
of this file is maintained with the gnu cpio the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef cpio h define cpio h a cpio archive consists  {
	                                                                                                                                 consists :: -1000
                                                                                                                                        }
of a sequence of files each file has a byte header a variable length nul terminated filename  {
	        filename :: -1000
               }
and variable length file data a header for a filename trailer  {
	   trailer :: -1000
         }
indicates the end of the archive all the fields in the header are iso approximately  {
	 approximately :: -1000
             }
ascii strings of octal numbers  {
	numbers :: -1000
   }
left padded  {
	padded :: -1000
 }
not nul terminated field name length in bytes notes  {
	   notes :: -1000
       }
c magic must be c dev  {
	  dev :: -1000
    }
c ino  {
	inorbs :: 3
	irony :: 3
	irons :: 3
	irone :: 3
	intro :: 3
	inorb :: 4
	ingot :: 3
	infos :: 3
	indow :: 3
	indol :: 3
	incog :: 3
	ikons :: 3
	icons :: 3
	enoki :: 3
	pion :: 3
	naoi :: 3
	lion :: 3
	iron :: 4
	ions :: 3
	into :: 4
	inro :: 4
	ingo :: 4
	info :: 4
	cion :: 3
	ion :: 4
	ins :: 3
	ink :: 3
	on :: 3
	io :: 3
	in :: 4
 }
c mode see below for value c uid c gid c nlink  {
	     blinks :: 6
	     plinks :: 6
	      clink :: 7
	      blink :: 7
	     clinks :: 6
	      slink :: 7
	      plink :: 7
	     slinky :: 6
	     slinks :: 6
          }
c rdev  {
	derv :: 5
 }
only valid for chr  {
	infilling :: -1000
  }
and blk  {
	bloke :: 3
	block :: 3
	blink :: 3
	bleak :: 3
	black :: 3
	bulk :: 3
	bilk :: 3
	balk :: 3
	ilk :: 3
	elk :: 3
	bok :: 3
 }
special files c mtime  {
	mismet :: 7
	stimes :: 6
	stimed :: 6
	maimer :: 6
	maimed :: 6
	stime :: 7
	item :: 6
  }
c namesize  {
	melanizes :: 10
	nemesia :: 11
	racemizes :: 10
	nomadizes :: 10
	maderizes :: 10
 }
count includes  {
	includes :: -1000
 }
terminating  {
	terminating :: -1000
 }
nul in pathname  {
	patinae :: 10
 }
c filesize  {
	fiberize :: 10
	fiberizes :: 11
	fireside :: 10
	bitesize :: 10
	finalizes :: 10
 }
must be for fifos  {
	infos :: 6
	finos :: 6
	filos :: 6
	figos :: 6
	fifes :: 7
	fiefs :: 6
	fidos :: 6
	ficos :: 6
	offish :: 6
  }
and directories  {
	directories :: -1000
 }
value for the field c magic define magic values for c mode or d together define c irusr  {
                }
define c iwusr  {
 }
define c ixusr  {
 }
define c irgrp  {
 }
define c iwgrp  {
	twirp :: 6
 }
define c ixgrp  {
 }
define c iroth  {
	passepied :: -1000
 }
define c iwoth  {
	wroth :: 6
	swith :: 6
 }
define c ixoth  {
 }
define c isuid  {
 }
define c isgid  {
	digits :: 6
	rigid :: 6
 }
define c isvtx  {
 }
define c isblk  {
	documentation :: -1000
 }
define c ischr  {
	ichors :: 6
	richts :: 6
	riches :: 6
	orchis :: 6
	rachis :: 6
	sich :: 6
	rich :: 6
 }
define c isdir  {
	irids :: 6
	indris :: 6
 }
define c isfifo  {
 }
define c issock  {
 }
define c islnk  {
	kilns :: 7
	blinks :: 6
	plinks :: 6
	clinks :: 6
	slink :: 7
	kiln :: 6
	slinky :: 6
	slinks :: 6
 }
define c isctg  {
 }
define c isreg  {
	derigs :: 6
	rerigs :: 6
	sire :: 6
 }
endif cpio h ufc  {
	fuci :: 3
	ufo :: 3
  }
crypt  {
	crypt :: -1000
 }
ultra  {
	ultra :: -1000
 }
fast  {
	fast :: -1000
 }
crypt implementation copyright c free software foundation inc the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa crypt h ifndef crypt h define crypt h include features h begin decls encrypt  {
	                                                                                                                                     encrypt :: -1000
                                                                                                                                           }
at most  {
	most :: -1000
 }
characters  {
	characters :: -1000
 }
from key using salt  {
	salt :: -1000
  }
to perturb  {
	perturb :: -1000
 }
des extern char crypt const char key const char salt throw nonnull setup  {
	       setup :: -1000
           }
des tables  {
	tables :: -1000
 }
according key extern void setkey  {
	keyset :: 8
	kersey :: 7
	seek :: 7
	setae :: 7
	keysets :: 7
   }
const char key throw nonnull encrypt data in block in place if edflag  {
	      beflag :: 8
	     faldage :: 7
	      reflag :: 8
	     reflags :: 7
	     beflags :: 7
	     elfland :: 7
           }
is zero otherwise decrypt  {
	decrypt :: -1000
  }
block in place extern void encrypt char libc block int edflag throw nonnull ifdef use gnu reentrant  {
	       reentrant :: -1000
               }
versions of the functions above the additional  {
	additional :: -1000
     }
argument points  {
	points :: -1000
 }
to a structure where the results  {
	results :: -1000
    }
are placed  {
	placed :: -1000
 }
in struct crypt data char keysched  {
	sketched :: 10
    }
char sb  {
	sub :: 2
	sib :: 2
	sab :: 2
	obs :: 2
	abs :: 2
	s :: 2
 }
char sb char sb char sb end of aligment  {
	 flagmen :: 10
	ligament :: 12
	alignments :: 10
	 aliment :: 10
	 aligned :: 10
	 aligner :: 10
	emigrant :: 10
	regimental :: 10
	bailment :: 11
	alightment :: 10
	ligaments :: 11
	bailments :: 10
	alignment :: 11
	ligamental :: 10
	filament :: 10
       }
critical data char crypt buf char current salt long int current saltbits  {
	   saltiest :: 10
          }
int direction  {
	direction :: -1000
 }
initialized extern char crypt r const char key const char salt struct crypt data restrict data throw nonnull extern void setkey r const char key struct crypt data restrict data throw nonnull extern void encrypt r char libc block int edflag struct crypt data restrict data throw nonnull endif end decls endif crypt h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa iso c standard character handling  {
	                                                                                                                                                                                        handling :: -1000
                                                                                                                                                                                               }
ctype h ifndef ctype h define ctype h include features h include bits types h begin decls ifndef isbit  {
	            binits :: 6
	            tibias :: 6
	            vibist :: 6
                 }
these are all the characteristics  {
	characteristics :: -1000
   }
of characters if there get to be more than distinct  {
	 distinct :: -1000
        }
characteristics many things  {
	things :: -1000
 }
must be changed  {
	changed :: -1000
 }
that use unsigned short int s the characteristics are stored  {
	   stored :: -1000
        }
always in network  {
	network :: -1000
 }
byte order big endian  {
	diatomite :: -1000
  }
we define the bit value interpretations  {
	interpretations :: -1000
    }
here dependent  {
	dependent :: -1000
 }
on the machine s byte order include endian h if byte order big endian define isbit bit bit else byte order little  {
	               little :: -1000
                    }
endian define isbit bit bit bit bit endif enum isupper  {
	  conjure :: -1000
        }
isbit uppercase islower  {
	imbowers :: 9
	impowers :: 9
 }
isbit lowercase  {
	lowercase :: -1000
 }
isalpha  {
 }
isbit alphabetic isdigit  {
	microspheres :: -1000
 }
isbit numeric  {
	numeric :: -1000
 }
isxdigit  {
 }
isbit hexadecimal  {
	hexadecimal :: -1000
 }
numeric isspace  {
	dispace :: 10
	auspice :: 9
	auspices :: 9
	isopachs :: 9
	inscapes :: 9
	dispaces :: 10
	inscape :: 9
 }
isbit whitespace isprint isbit printing isgraph  {
	digraph :: 10
	digraphs :: 11
    }
isbit graphical  {
	graphical :: -1000
 }
isblank  {
	kiblas :: 9
 }
isbit blank  {
	spoonfuls :: -1000
 }
usually spc  {
	sos :: -1000
 }
and tab iscntrl  {
 }
isbit control character ispunct  {
	inputs :: 9
	expuncts :: 9
	injuncts :: 9
  }
isbit punctuation isalnum  {
 }
isbit alphanumeric  {
	alphanumeric :: -1000
 }
endif isbit these are defined in ctype info c the declarations here must match those in localeinfo  {
               }
h in the thread specific locale model  {
	 model :: -1000
     }
see uselocale  {
 }
in locale h we cannot  {
	cannot :: -1000
   }
use global variables for these as was done in the past instead the following accessor  {
	      assessor :: 10
	 accessorizing :: 11
	      accusers :: 10
	   accessorize :: 12
	   accessorise :: 10
	   accessorial :: 12
	   accessories :: 10
	  accessorized :: 11
	     accessory :: 15
	     accessary :: 11
	     accession :: 11
	     ancestors :: 11
	     acceptors :: 11
	     accentors :: 11
	        access :: 12
	      acceptor :: 10
	      accentor :: 10
             }
functions return the address of each variable which is local to the current thread if multithreaded  {
	  multistranded :: 18
              }
these point into arrays  {
	arrays :: -1000
  }
of so they can be indexed  {
	indexed :: -1000
    }
by any unsigned char value by eof  {
	 gofer :: 3
	  fore :: 3
	  fone :: 3
	  foes :: 3
	   oof :: 3
	   foe :: 4
	   erf :: 3
	   eon :: 3
	   emf :: 3
	   elf :: 3
	   eff :: 3
	    ef :: 3
     }
or by any signed  {
	signed :: -1000
  }
char value iso c requires  {
	requires :: -1000
   }
that the ctype functions work  {
	work :: -1000
   }
for unsigned char values and for eof we also support negative  {
	  negative :: -1000
         }
signed char values for broken old programs  {
	programs :: -1000
     }
the case conversion arrays are of int s rather than unsigned char s because tolower  {
	      kotowers :: 9
	     coleworts :: 9
	      colewort :: 10
	       kotower :: 10
             }
eof must be eof which doesn  {
	doeskin :: 7
	dozens :: 7
	doyens :: 7
	docents :: 6
	dovens :: 7
	donsie :: 7
	donnes :: 6
	donees :: 6
	dozen :: 6
	doyen :: 6
	dowse :: 6
	doven :: 6
	douse :: 6
	dorse :: 6
	donsy :: 6
	doest :: 7
	doers :: 6
	doeks :: 6
	devons :: 6
	corsned :: 6
	demons :: 6
	codens :: 6
	lodens :: 6
	sonde :: 6
	 ones :: 6
	 odes :: 6
	 noes :: 7
	 nods :: 6
	odeons :: 6
	 dose :: 6
	 dons :: 7
	 done :: 6
	 does :: 8
	 dens :: 6
	domines :: 6
	nosed :: 6
	nodes :: 6
	noised :: 6
	  doe :: 6
    }
t fit into an unsigned char but today  {
	  today :: -1000
      }
more important  {
	important :: -1000
 }
is that the arrays are also used for multi byte character sets  {
	       sets :: -1000
          }
extern const unsigned short int ctype b loc void throw attribute const extern const int t ctype tolower loc void throw attribute const extern const int t ctype toupper  {
	                      troupe :: 9
	                     poutier :: 9
	                     poulter :: 9
	                     stopper :: 9
	                     poufter :: 9
	                     trouper :: 9
	                   gruppetto :: 9
                           }
loc void throw attribute const ifndef cplusplus define isctype  {
	promptness :: -1000
       }
c type ctype b loc int c unsigned short int type elif  {
	      flite :: 5
	      flies :: 5
	      flier :: 5
	      flied :: 5
	      elfin :: 5
	       lief :: 5
	       alif :: 5
	        elf :: 5
          }
defined use extern inlines define isctype f type extern inline int is type int c throw return ctype b loc int c unsigned short int is type endif define isascii  {
                            }
c c x f if c is a bit value define toascii  {
          }
c c x f mask  {
	mask :: -1000
   }
off high  {
	high :: -1000
 }
bits define exctype  {
	ecotype :: 10
	ecotypes :: 9
	except :: 9
	excerpt :: 9
 }
name extern int name int throw begin namespace std the following names are all functions int ischaracteristic  {
	uncharacteristic :: 26
	uncharacteristically :: 20
               }
int c which return nonzero  {
	nonzero :: -1000
   }
iff  {
	iff :: -1000
 }
c has characteristic for the meaning of the characteristic names see the enum above exctype isalnum exctype isalpha exctype iscntrl exctype isdigit exctype islower exctype isgraph exctype isprint exctype ispunct exctype isspace exctype isupper exctype isxdigit return the lowercase version of c extern int tolower int c throw return the uppercase version of c extern int toupper int c throw end namespace std iso c introduced  {
	                                                       introduced :: -1000
                                                                }
one new function ifdef use isoc  {
	icons :: 5
	psocid :: 5
    }
begin namespace c exctype isblank end namespace c endif ifdef use gnu test  {
	        test :: -1000
           }
c for a set of character classes  {
	ironers :: -1000
     }
according to mask extern int isctype int c int mask throw endif if defined use svid  {
	           text :: -1000
              }
defined use misc  {
	mirs :: -1000
 }
defined use xopen  {
	syllabifying :: -1000
 }
return nonzero iff c is in the ascii set i e is no more than bits wide  {
	            wide :: -1000
               }
extern int isascii int c throw return the part of c that is in the ascii set i e the low order bits of c extern int toascii int c throw these are the same as toupper and tolower except that they do not check the argument for being in the range  {
	                                              range :: -1000
                                                  }
of a char exctype toupper exctype tolower endif use svid or use misc this code is needed for the optimized mapping  {
	             mapping :: -1000
                   }
functions define tobody  {
	bloody :: 7
	tomboy :: 7
	toyo :: 7
	broody :: 7
	nobody :: 9
 }
c f a args extension int res if sizeof c if builtin constant  {
	    constant :: -1000
           }
p c int c c res c c c a c else res f args else res a int c res if defined no ctype ifdef isctype f isctype f alnum  {
	                         fanum :: 6
	                         annul :: 6
	                         almug :: 6
	                         almud :: 6
	                         algum :: 7
	                         album :: 7
	                       albumen :: 7
	                       albumin :: 7
	                        alumni :: 6
	                        alumin :: 6
	                        algums :: 6
	                        albums :: 6
	                      albumens :: 6
	                      albumins :: 6
	                        manuls :: 6
	                        manual :: 6
	                          ulna :: 6
	                          alum :: 6
	                         manul :: 7
	                         linum :: 6
                             }
isctype f alpha isctype f cntrl  {
    }
isctype f digit  {
	digit :: -1000
 }
isctype f lower isctype f graph isctype f print isctype f punct isctype f space  {
	         space :: -1000
             }
isctype f upper isctype f xdigit  {
    }
ifdef use isoc isctype f blank endif elif defined isctype define isalnum c isctype c isalnum define isalpha c isctype c isalpha define iscntrl c isctype c iscntrl define isdigit c isctype c isdigit define islower c isctype c islower define isgraph c isctype c isgraph define isprint c isctype c isprint define ispunct c isctype c ispunct define isspace c isctype c isspace define isupper c isctype c isupper define isxdigit c isctype c isxdigit ifdef use isoc define isblank c isctype c isblank endif endif ifdef use extern inlines extern inline int nth tolower int c return c c ctype tolower loc c c extern inline int nth toupper int c return c c ctype toupper loc c c endif if gnuc defined optimize defined cplusplus define tolower c tobody c tolower ctype tolower loc c define toupper c tobody c toupper ctype toupper loc c endif optimizing  {
	                                                                                                                                           optimizing :: -1000
                                                                                                                                                    }
gcc if defined use svid defined use misc defined use xopen define isascii c isascii c define toascii c toascii c define tolower c int ctype tolower loc int c define toupper c int ctype toupper loc int c endif endif not no ctype ifdef use xopen k the concept  {
	                                          concept :: -1000
                                                }
of one static locale per category  {
	category :: -1000
    }
is not very  {
	very :: -1000
 }
well  {
	well :: -1000
 }
thought  {
	thought :: -1000
 }
out many applications  {
	applications :: -1000
 }
will need to process its data using information from several different  {
	 different :: -1000
         }
locales  {
	locales :: -1000
 }
another application is the implementation of the internationalization  {
	internationalization :: -1000
      }
handling in the upcoming  {
	upcoming :: -1000
  }
iso c standard library to support this another set of the functions using locale data exist which have an additional argument attention  {
	            attention :: -1000
                    }
all these functions are not standardized  {
	standardized :: -1000
    }
in any form this is a proof  {
	 proof :: -1000
     }
of concept implementation structure for reentrant locale using functions this is an almost  {
	      almost :: -1000
           }
opaque  {
	opaque :: -1000
 }
type for the user level programs include xlocale  {
      }
h these definitions are similar to the ones  {
	   ones :: -1000
      }
above but all functions take as an argument a handle for the locale which shall  {
	         shall :: -1000
             }
be used define isctype l c type locale locale ctype b int c unsigned short int type define exctype l name extern int name int locale t throw the following names are all functions int ischaracteristic int c locale t locale which return nonzero iff c has characteristic for the meaning of the characteristic names see the enum above exctype l isalnum l exctype l isalpha l exctype l iscntrl l exctype l isdigit l exctype l islower l exctype l isgraph l exctype l isprint l exctype l ispunct l exctype l isspace l exctype l isupper l exctype l isxdigit l exctype l isblank l return the lowercase version of c in locale l extern int tolower l int c locale t l throw extern int tolower l int c locale t l throw return the uppercase version of c extern int toupper l int c locale t l throw extern int toupper l int c locale t l throw if gnuc defined optimize defined cplusplus define tolower l c locale tobody c tolower l locale ctype tolower c locale define toupper l c locale tobody c toupper l locale ctype toupper c locale define tolower l c locale tolower l c locale define toupper l c locale toupper l c locale endif optimizing gcc ifndef no ctype define isalnum l c l isctype l c isalnum l define isalpha l c l isctype l c isalpha l define iscntrl l c l isctype l c iscntrl l define isdigit l c l isctype l c isdigit l define islower l c l isctype l c islower l define isgraph l c l isctype l c isgraph l define isprint l c l isctype l c isprint l define ispunct l c l isctype l c ispunct l define isspace l c l isctype l c isspace l define isupper l c l isctype l c isupper l define isxdigit l c l isctype l c isxdigit l define isblank l c l isctype l c isblank l if defined use svid defined use misc define isascii l c l l isascii c define toascii l c l l toascii c endif define isalnum l c l isalnum l c l define isalpha l c l isalpha l c l define iscntrl l c l iscntrl l c l define isdigit l c l isdigit l c l define islower l c l islower l c l define isgraph l c l isgraph l c l define isprint l c l isprint l c l define ispunct l c l ispunct l c l define isspace l c l isspace l c l define isupper l c l isupper l c l define isxdigit l c l isxdigit l c l define isblank l c l isblank l c l if defined use svid defined use misc define isascii l c l isascii l c l define toascii l c l toascii l c l endif endif not no ctype endif use posix end decls endif ctype h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa posix standard directory  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             directory :: -1000
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }
operations dirent  {
	dementi :: 7
	driest :: 7
	indent :: 7
	diverts :: 7
	bident :: 8
	dizen :: 7
	diner :: 8
	dirempt :: 7
	directs :: 8
	divert :: 8
	ditone :: 7
	direct :: 9
	dipnet :: 7
	diners :: 7
	dinero :: 7
	rodent :: 7
	ardent :: 7
	directly :: 7
	disenthral :: 7
	sprinted :: 7
	rident :: 10
	orient :: 7
	tinder :: 7
	dicentra :: 9
	direction :: 7
	directing :: 7
	dicentras :: 8
	dicentric :: 7
	virent :: 9
	indentor :: 7
	tired :: 8
	tined :: 7
	tire :: 7
	disinter :: 7
	siren :: 7
	dirt :: 7
	dire :: 8
	dine :: 7
	eident :: 8
	niter :: 7
	bidents :: 7
 }
h ifndef dirent h define dirent h include features h begin decls include bits types h ifdef use xopen ifndef ino t defined ifndef use file offset typedef ino t ino t else typedef ino t ino t endif define ino t defined endif if defined use largefile defined ino t defined typedef ino t ino t define ino t defined endif endif this file defines struct dirent it defines the macro dirent have d namlen  {
	                                                                     laymen :: 7
	                                                                     lawmen :: 7
	                                                                    lambent :: 7
	                                                                   nobleman :: 7
	                                                                   noumenal :: 7
	                                                                     vanmen :: 7
                                                                          }
iff there is a d namlen member that gives  {
	   gives :: -1000
       }
the length of d name it defines the macro dirent have d reclen  {
	      lecher :: 7
	     lucerne :: 7
	      secern :: 7
	    reclines :: 9
	    recliner :: 8
	    reclined :: 9
	    decliner :: 8
	    recleans :: 9
	      necker :: 7
	     decline :: 7
	    recently :: 7
	      decern :: 7
	      crenel :: 7
	    reliance :: 7
	      recent :: 7
	      recane :: 7
	     reflect :: 7
	     reeling :: 7
	    reblends :: 7
	     redline :: 7
	     recluse :: 7
	     reclose :: 7
	     recline :: 10
	     reclean :: 10
	     reclame :: 7
	     reblend :: 8
	   rectangle :: 7
	      ceiler :: 7
	   recliners :: 7
	   reclinate :: 8
	   decliners :: 7
	  recleaning :: 7
	    lecterns :: 7
           }
iff there is a d reclen member that gives the size of the entire  {
	       entire :: -1000
            }
directory entry it defines the macro dirent have d off iff there is a d off member that gives the file offset of the next directory entry it defines the macro dirent have d type iff there is a d type member that gives the type of the file include bits dirent h if defined use bsd  {
	                                                   bodes :: 3
	                                                   bides :: 3
	                                                    buds :: 4
	                                                    bods :: 4
	                                                    bids :: 4
	                                                    beds :: 4
	                                                     bud :: 3
	                                                     bod :: 3
	                                                     bid :: 3
	                                                     bed :: 3
	                                                     bad :: 3
                                                       }
defined use misc defined d fileno  {
	filemot :: 8
	ninefold :: 7
	folie :: 7
	filet :: 7
	files :: 7
	filer :: 7
	filed :: 7
	felon :: 8
	felonies :: 7
	lifelong :: 7
	aileron :: 7
	finely :: 7
	filose :: 7
	felony :: 7
	felons :: 7
	feline :: 7
	silen :: 7
	 fine :: 7
	 filo :: 7
	 file :: 8
	flexion :: 7
    }
define d ino d fileno backward  {
	backward :: -1000
    }
compatibility endif these macros extract size information from a struct dirent they may evaluate  {
	     evaluate :: -1000
            }
their argument multiple  {
	multiple :: -1000
 }
times so it must not have side effects  {
	effects :: -1000
      }
each of these may involve  {
	involve :: -1000
   }
a relatively  {
	relatively :: -1000
 }
costly  {
	costly :: -1000
 }
call to strlen  {
	antlers :: 7
	sarment :: 7
	saltern :: 7
	sorbent :: 7
	serpent :: 7
	streeling :: 7
	sternly :: 7
	sternal :: 7
	stelene :: 7
	runlets :: 7
	strinkle :: 7
	sutler :: 7
	styler :: 8
	strewn :: 8
	strene :: 7
	streel :: 8
	stoner :: 7
	stolen :: 9
	stelar :: 7
	staler :: 8
	style :: 7
	strae :: 7
	stole :: 7
	stile :: 7
	stern :: 7
	stele :: 7
	stale :: 7
	strangle :: 7
	surgent :: 7
 }
on some systems  {
	systems :: -1000
 }
so these values should be cached  {
	cached :: -1000
    }
d exact  {
	exact :: -1000
 }
namlen dp  {
	seaters :: -1000
 }
returns the length of dp d name not including its terminating null character d alloc namlen dp returns a size at least d exact namlen dp that is the allocation size needed to hold the dp d name string use this macro when you don t need the exact length just an upper bound  {
	                                                bound :: -1000
                                                    }
this macro is less likely  {
	likely :: -1000
   }
to require calling strlen than d exact namlen ifdef dirent have d namlen define d exact namlen d d d namlen define d alloc namlen d d exact namlen d else define d exact namlen d strlen d d name ifdef dirent have d reclen define d alloc namlen d char d d d reclen d d name else define d alloc namlen d sizeof d d name sizeof d d name d exact namlen d endif endif ifdef use bsd file types for d type enum dt  {
	                                                                                sundial :: -1000
                                                                                      }
unknown define dt unknown dt unknown dt fifo define dt fifo dt fifo dt chr define dt chr dt chr dt dir define dt dir dt dir dt blk define dt blk dt blk dt reg  {
	                                reg :: -1000
                                  }
define dt reg dt reg dt lnk  {
	 lakin :: 3
	 inkle :: 3
	 ankle :: 3
	  lunk :: 3
	  link :: 3
	  lank :: 3
	   lek :: 3
	   ink :: 3
	 likin :: 3
	 liken :: 3
     }
define dt lnk dt lnk dt sock  {
	  sock :: -1000
     }
define dt sock dt sock dt wht  {
	 withy :: 3
	 withs :: 3
	 withe :: 3
	 witch :: 3
	 whort :: 3
	 whity :: 3
	 whits :: 3
	 white :: 3
	 whist :: 3
	 whipt :: 3
	 whift :: 3
	 whets :: 3
	 wheft :: 3
	 wheat :: 3
	 whats :: 3
	 watch :: 3
	  with :: 4
	  whit :: 4
	  whet :: 4
	  what :: 4
	  thew :: 3
	  thaw :: 3
	   wot :: 3
	   wit :: 3
	   why :: 3
	   who :: 3
	   wha :: 3
	   wet :: 3
	   wat :: 3
	   pht :: 3
     }
define dt wht dt wht convert between stat structure types and directory types define iftodt  {
             }
mode mode define dttoif  {
  }
dirtype  {
	dirty :: 10
	dirempt :: 9
	mistyped :: 9
 }
dirtype endif this is the data type of directory stream objects  {
	   objects :: -1000
         }
the actual structure is opaque to users  {
	 users :: -1000
     }
typedef struct dirstream  {
	disarmer :: 11
	diastema :: 11
	midstreams :: 12
	airstreams :: 13
	airstream :: 15
	diestrum :: 11
	diastem :: 11
	diaster :: 11
	midstream :: 14
 }
dir open a directory stream on name return a dir stream on the directory or null if it could  {
	             could :: -1000
                 }
not be opened  {
	opened :: -1000
 }
this function is a possible cancellation point and therefore not marked with throw extern dir opendir  {
	         opined :: 9
	       ovenbird :: 9
	        poinder :: 10
	       poinders :: 9
              }
const char name nonnull ifdef use xopen k same as opendir but open the stream on the file descriptor fd  {
	                 et :: -1000
                  }
this function is a possible cancellation point and therefore not marked with throw extern dir fdopendir  {
              }
int fd endif close the directory stream dirp  {
	  dript :: 5
	  drips :: 5
	 dipper :: 5
	 diaper :: 5
	   drip :: 6
	   dorp :: 5
	   dirt :: 5
	   dirl :: 5
	   dirk :: 5
	   dire :: 5
	    dip :: 5
      }
return if successful if not this function is a possible cancellation point and therefore not marked with throw extern int closedir  {
	            cloudier :: 10
	            closured :: 10
	               close :: 10
	            cloister :: 10
	          cloistered :: 10
	            consider :: 10
	            cloddier :: 10
	              closed :: 12
	           colliders :: 10
	             clerids :: 10
                   }
dir dirp nonnull read a directory entry from dirp return a pointer to a struct dirent describing the entry or null for eof or error the storage  {
	                    tressy :: -1000
                         }
returned may be overwritten  {
	overwritten :: -1000
  }
by a later readdir  {
	readding :: 9
	readdict :: 9
	readd :: 9
  }
call on the same dir stream if the large file support api  {
	      apsis :: 3
	      apism :: 4
	      apish :: 4
	      apiol :: 4
	      aping :: 4
	      apian :: 3
	      aphis :: 3
	      aphid :: 3
	     apiece :: 3
	     apices :: 3
	      spina :: 3
	      spica :: 3
	      spial :: 3
	       pais :: 3
	       pair :: 3
	       pain :: 3
	       pail :: 3
	       paik :: 3
	       paid :: 3
	        pia :: 3
	        apr :: 3
	        ape :: 3
	        ani :: 3
	        ami :: 3
	        adi :: 3
	         ai :: 3
          }
is selected  {
	selected :: -1000
 }
we have to use the appropriate interface  {
	interface :: -1000
     }
this function is a possible cancellation point and therefore not marked with throw ifndef use file offset extern struct dirent readdir dir dirp nonnull else ifdef redirect extern struct dirent redirect readdir dir dirp readdir nonnull else define readdir readdir endif endif ifdef use largefile extern struct dirent readdir dir dirp nonnull endif if defined use posix defined use misc reentrant version of readdir return in result a pointer to the next entry this function is a possible cancellation point and therefore not marked with throw ifndef use file offset extern int readdir r dir restrict dirp struct dirent restrict entry struct dirent restrict result nonnull else ifdef redirect extern int redirect readdir r dir restrict dirp struct dirent restrict entry struct dirent restrict result readdir r nonnull else define readdir r readdir r endif endif ifdef use largefile extern int readdir r dir restrict dirp struct dirent restrict entry struct dirent restrict result nonnull endif endif posix or misc rewind  {
	                                                                                                                                                          rewind :: -1000
                                                                                                                                                               }
dirp to the beginning of the directory extern void rewinddir  {
        }
dir dirp throw nonnull if defined use bsd defined use misc defined use xopen include bits types h seek  {
	              seek :: -1000
                 }
to position  {
	position :: -1000
 }
pos on dirp extern void seekdir  {
    }
dir dirp long int pos throw nonnull return the current position of dirp extern long int telldir  {
	        bellbird :: 9
	          tiller :: 9
	          tilled :: 9
	        tillered :: 9
	         tallier :: 9
               }
dir dirp throw nonnull endif if defined use bsd defined use misc defined use xopen k return the file descriptor used by dirp extern int dirfd  {
	                    fired :: 6
	                   dirndl :: 6
                        }
dir dirp throw nonnull if defined optimize defined dir dirfd define dirfd dirp dir dirfd dirp endif if defined use bsd defined use misc ifndef maxnamlen  {
                        }
get the definitions of the posix limits include bits posix lim h maxnamlen is the bsd name for what posix calls name max ifdef name max define maxnamlen name max else define maxnamlen endif endif endif define need size t include stddef h scan  {
	                                       scan :: -1000
                                          }
the directory dir calling selector  {
	selector :: -1000
   }
on each directory entry entries for which select returns nonzero are individually  {
	individually :: -1000
          }
malloc d sorted using qsort  {
	quartos :: 6
	sport :: 6
	snort :: 6
	short :: 6
   }
with cmp  {
	comp :: 3
	camp :: 3
	ump :: 3
	imp :: 3
	cop :: 3
	cep :: 3
	cap :: 3
	amp :: 3
 }
and collected  {
	collected :: -1000
 }
in a malloc d array in namelist  {
	lambiest :: 10
	alienist :: 10
	medalist :: 10
	panelists :: 10
	laments :: 11
	manliest :: 11
	metalist :: 10
	mantles :: 10
	nimblest :: 11
	panelist :: 12
	novelist :: 10
	tameins :: 11
	melanist :: 11
	camelish :: 10
     }
returns the number of entries selected or on error this function is a cancellation point and therefore not marked with throw ifndef use file offset extern int scandir  {
	                   scauding :: 9
	                   scantier :: 9
	                   scandium :: 10
	                   scaldino :: 9
	                   scalding :: 9
	                    scandic :: 10
	                    scandia :: 10
	                    scabrid :: 9
                          }
const char restrict dir struct dirent restrict namelist int selector const struct dirent int cmp const struct dirent const struct dirent nonnull else ifdef redirect extern int redirect scandir const char restrict dir struct dirent restrict namelist int selector const struct dirent int cmp const struct dirent const struct dirent scandir nonnull else define scandir scandir endif endif if defined use gnu defined use largefile this function is like scandir but it uses  {
	                                                                    uses :: -1000
                                                                       }
the bit dirent structure please note that the cmp function must now work with struct dirent extern int scandir const char restrict dir struct dirent restrict namelist int selector const struct dirent int cmp const struct dirent const struct dirent nonnull endif ifdef use gnu similar to scandir but a relative dir name is interpreted relative to the directory for which dfd  {
	                                                          cut :: -1000
                                                            }
is a descriptor this function is a cancellation point and therefore not marked with throw ifndef use file offset extern int scandirat  {
	             scandias :: 11
	              scandia :: 13
                    }
int dfd const char restrict dir struct dirent restrict namelist int selector const struct dirent int cmp const struct dirent const struct dirent nonnull else ifdef redirect extern int redirect scandirat int dfd const char restrict dir struct dirent restrict namelist int selector const struct dirent int cmp const struct dirent const struct dirent scandirat nonnull else define scandirat scandirat endif endif this function is like scandir but it uses the bit dirent structure please note that the cmp function must now work with struct dirent extern int scandirat int dfd const char restrict dir struct dirent restrict namelist int selector const struct dirent int cmp const struct dirent const struct dirent nonnull endif function to compare  {
	                                                                                                             compare :: -1000
                                                                                                                   }
two struct dirent s alphabetically ifndef use file offset extern int alphasort  {
	    asphalt :: 11
	     alphas :: 12
	     alohas :: 11
	  asphalter :: 11
          }
const struct dirent e const struct dirent e throw attribute pure nonnull else ifdef redirect extern int redirect nth alphasort const struct dirent e const struct dirent e alphasort attribute pure nonnull else define alphasort alphasort endif endif if defined use gnu defined use largefile extern int alphasort const struct dirent e const struct dirent e throw attribute pure nonnull endif endif use bsd or misc or xpg  {
                                                                  }
if defined use bsd defined use misc read directory entries from fd into buf reading  {
	       reading :: -1000
             }
at most nbytes reading starts  {
	starts :: -1000
   }
at offset basep  {
	bespat :: 6
	becaps :: 6
	bates :: 6
	baste :: 6
	bases :: 6
	baser :: 7
	based :: 7
	bares :: 6
	banes :: 6
	bales :: 6
	bakes :: 6
	basely :: 6
	sabe :: 6
	pase :: 7
	salep :: 6
	base :: 8
	baps :: 6
	paseo :: 6
	bas :: 6
 }
and basep is updated  {
	updated :: -1000
  }
with the new position after reading returns the number of bytes read zero when at end of directory or for errors ifndef use file offset extern ssize t getdirentries  {
                           }
int fd char restrict buf size t nbytes off t restrict basep throw nonnull else ifdef redirect extern ssize t redirect nth getdirentries int fd char restrict buf size t nbytes off t restrict basep getdirentries nonnull else define getdirentries getdirentries endif endif ifdef use largefile extern ssize t getdirentries int fd char restrict buf size t nbytes off t restrict basep throw nonnull endif endif use bsd or misc ifdef use gnu function to compare two struct dirent s by name version ifndef use file offset extern int versionsort  {
	                                                                                 versions :: 14
                                                                                        }
const struct dirent e const struct dirent e throw attribute pure nonnull else ifdef redirect extern int redirect nth versionsort const struct dirent e const struct dirent e versionsort attribute pure nonnull else define versionsort versionsort endif endif ifdef use largefile extern int versionsort const struct dirent e const struct dirent e throw attribute pure nonnull endif endif use gnu end decls endif dirent h user functions for run time dynamic  {
	                                                               dynamic :: -1000
                                                                     }
loading  {
	loading :: -1000
 }
copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef dlfcn  {
                                                                                                                                      }
h define dlfcn h include features h define need size t include stddef h collect various system dependent definitions and declarations include bits dlfcn h ifdef use gnu if the first argument of dlsym  {
                                }
or dlvsym  {
 }
is set to rtld  {
  }
next the run time address of the symbol called name in the next shared object is returned the next relation  {
	           relation :: -1000
                  }
is defined by the order the shared objects were loaded define rtld next void l if the first argument to dlsym or dlvsym is set to rtld default the run time address of the symbol called name in the global scope  {
	                                   scope :: -1000
                                       }
is returned define rtld default void type for namespace indeces  {
	  incubus :: -1000
        }
typedef long int lmid  {
	amidol :: 5
	mild :: 5
	laid :: 5
	imid :: 5
	amid :: 5
  }
t special namespace id values define lm id base initial namespace define lm id newlm  {
	       mewling :: 6
	          mewl :: 7
	         newly :: 7
	         mewls :: 6
	           new :: 6
             }
for dlmopen  {
	nuzzler :: -1000
 }
request new namespace endif begin decls open the shared object file and map it in return a handle that can be passed to dlsym to get symbol values from it extern void dlopen  {
	                          dolmen :: 7
	                           elope :: 7
	                          ployed :: 7
	                          plowed :: 7
	                         propend :: 7
	                         eloping :: 7
	                          holpen :: 7
	                          cloned :: 7
	                          loupen :: 7
	                          looped :: 7
	                         plonked :: 7
	                          eloped :: 8
	                           slope :: 7
	                          sloped :: 8
                               }
const char file int mode throw unmap and close a shared object opened by dlopen the handle cannot be used again after calling dlclose  {
	               reclosed :: 9
	                callose :: 9
	               upclosed :: 9
	                cellose :: 9
	                 cellos :: 9
	               enclosed :: 9
	               inclosed :: 9
	               unclosed :: 9
                      }
extern int dlclose void handle throw nonnull find  {
	   find :: -1000
      }
the run time address in the shared object handle refers  {
	   refers :: -1000
        }
to of the symbol called name extern void dlsym void restrict handle const char restrict name throw nonnull ifdef use gnu like dlopen but request object to be allocated in a new namespace extern void dlmopen lmid t nsid  {
	                                  sind :: 5
	                                 snide :: 5
	                                  nids :: 5
                                     }
const char file int mode throw find the run time address in the shared object handle refers to of the symbol called name with version extern void dlvsym void restrict handle const char restrict name const char restrict version throw nonnull endif when any of the above functions fails  {
	                                           fails :: -1000
                                               }
call this function to return a string describing the error each call resets  {
	      resets :: -1000
           }
the error string so that a following call returns null extern char dlerror  {
           }
void throw ifdef use gnu structure containing information about  {
	   about :: -1000
       }
object searched  {
	searched :: -1000
 }
using dladdr  {
	spoonsful :: -1000
 }
typedef struct const char dli  {
	iliad :: 3
	glide :: 3
	flied :: 3
	elide :: 3
	drily :: 3
	drill :: 3
	doily :: 3
	deils :: 3
	daily :: 3
	clied :: 3
	blind :: 3
	slid :: 4
	olid :: 4
	slide :: 3
	laid :: 3
	dirl :: 3
	diol :: 3
	dill :: 3
	diel :: 3
	dial :: 3
	deli :: 3
	deil :: 4
	dali :: 3
	plied :: 3
	 oli :: 3
	 lid :: 3
	 dui :: 3
	  di :: 3
   }
fname  {
	flamens :: 7
	frame :: 7
	flame :: 7
	flamenco :: 6
	frames :: 6
	framer :: 6
	framed :: 6
	anime :: 6
	foeman :: 6
	foamer :: 6
	foamed :: 6
	flames :: 6
	flamer :: 6
	flamed :: 6
	fenman :: 6
	enamel :: 6
 }
file name of defining  {
	defining :: -1000
  }
object void dli fbase  {
	farce :: -1000
  }
load address of that object const char dli sname  {
	 seaming :: 6
	 flamens :: 6
	  shamer :: 6
	  shamed :: 6
	  seamer :: 6
	  seamen :: 8
	  seamed :: 6
	  seaman :: 6
	  scamel :: 6
	  gasmen :: 6
	 sarment :: 6
	   anime :: 6
	  ashmen :: 6
	  animes :: 7
	 anadems :: 6
	  meanes :: 6
	 examens :: 6
	  stamen :: 8
	 stamens :: 6
	  enemas :: 6
	  enamel :: 6
	   stane :: 6
	    sean :: 6
	    seam :: 7
	   spane :: 6
	   snare :: 7
	   snake :: 7
	   smaze :: 6
	   slane :: 6
	    mnas :: 6
	   shame :: 7
	   seamy :: 6
	   samen :: 6
	 enamors :: 6
	 enamels :: 7
	  snarer :: 6
	  snared :: 6
	  snakey :: 6
	  snaked :: 6
	   means :: 6
	   manse :: 6
       }
name of nearest  {
	nearest :: -1000
 }
symbol void dli saddr  {
	saddle :: 6
	saddhu :: 6
	sadder :: 8
	sadden :: 6
	raddles :: 6
	ladders :: 6
	saddler :: 7
	padders :: 6
	saddlery :: 6
	madders :: 6
	sard :: 7
	gadders :: 6
	wadders :: 6
  }
exact value of nearest symbol dl info fill  {
	   fill :: -1000
      }
in info with the following information about address returns iff no shared object s segments  {
	      segments :: -1000
             }
contain that address extern int dladdr const void address dl info info throw nonnull same as dladdr but additionally  {
	      additionally :: -1000
                 }
sets extra info according to flags extern int dladdr const void address dl info info void extra info int flags throw nonnull these are the possible values for the flags argument to dladdr this indicates what extra information is stored at extra info it may also be zero in which case the extra info argument is not used enum matching  {
	                                                   matching :: -1000
                                                          }
symbol table entry const elfnn  {
	elfin :: 7
	elfins :: 6
	 elf :: 6
   }
sym rtld dl syment  {
	dements :: 7
	hymen :: 7
	laments :: 7
	hymens :: 8
	loments :: 7
	foments :: 7
	seventy :: 7
	syndet :: 7
	moments :: 7
	cements :: 7
	yamens :: 7
	amnesty :: 7
	tynes :: 7
	syren :: 7
	semen :: 7
	samen :: 7
	misentry :: 7
  }
the object containing the address struct link  {
	  link :: -1000
     }
map rtld dl linkmap  {
	milkman :: 9
	linkman :: 10
  }
get information about the shared object handle refers to request is from among  {
	       among :: -1000
           }
the values below and determines  {
	determines :: -1000
   }
the use of arg on success returns zero on failure returns and records  {
	     records :: -1000
           }
an error message to be fetched  {
	fetched :: -1000
    }
with dlerror extern int dlinfo  {
   }
void restrict handle int request void restrict arg throw nonnull these are the possible values for the request argument to dlinfo enum treat  {
	                 treat :: -1000
                     }
arg as lmid t store namespace id for handle there rtld di lmid treat arg as struct link map store the struct link map for handle there rtld di linkmap rtld di configaddr  {
	                      configured :: 12
                               }
unsupported  {
	unsupported :: -1000
 }
defined by solaris  {
	solarizes :: 11
	polarised :: 9
	polarises :: 10
	solarisms :: 10
	solarised :: 12
	solarises :: 10
	solariums :: 11
	solarists :: 10
	ooralis :: 9
	sodalist :: 9
	satoris :: 9
	souaris :: 11
	salaries :: 9
	sailors :: 9
	solarising :: 10
	solaria :: 9
	solas :: 9
	solar :: 9
	solarize :: 9
	polarise :: 10
	solarism :: 13
	solarise :: 13
	solarium :: 9
	solarist :: 13
	volaries :: 9
	solanins :: 9
	solars :: 11
 }
treat arg as dl serinfo  {
	sering :: 9
	forinsec :: 9
	senior :: 9
	merinos :: 9
	farinose :: 9
	seron :: 9
	serin :: 10
	serif :: 9
   }
see below and fill in to describe the directories that will be searched for dependencies  {
	  dependencies :: -1000
             }
of this object rtld di serinfosize  {
    }
fills  {
	fills :: -1000
 }
in just the dls cnt and dls size entries to indicate the size of the buffer that must be passed to rtld di serinfo to fill in the full  {
	                        full :: -1000
                           }
information rtld di serinfo rtld di serinfosize treat arg as char and store there the directory name used to expand  {
	             expand :: -1000
                  }
origin  {
	origin :: -1000
 }
in this shared object s dependency  {
	dependency :: -1000
    }
file names rtld di origin rtld di profilename  {
      }
unsupported defined by solaris rtld di profileout  {
	profile :: 13
	profiled :: 12
	profiles :: 12
     }
unsupported defined by solaris treat arg as size t and store there the tls  {
	        tesla :: 3
	         tils :: 3
	         tels :: 3
	         slut :: 3
	         slot :: 3
	         slit :: 3
	         slat :: 3
	         lust :: 3
	         lost :: 3
	         list :: 3
	         last :: 3
	         elts :: 3
	         alts :: 3
	          tis :: 3
	          tes :: 3
	          tas :: 3
	          els :: 3
	          als :: 3
	           ts :: 3
	           sl :: 3
            }
module  {
	module :: -1000
 }
id of this object s pt  {
	  put :: 2
	  pst :: 2
	  pot :: 2
	  pit :: 2
	  pht :: 2
	  pet :: 2
	  pat :: 2
	    p :: 2
    }
tls segment as used in tls relocations  {
	relocations :: -1000
     }
store zero if this object does not define a pt tls segment rtld di tls modid  {
	       truckman :: -1000
              }
treat arg as void and store there a pointer to the calling thread s tls block corresponding to this object s pt tls segment store a null pointer if this object does not define a pt tls segment or if the calling thread has not allocated a block for it rtld di tls data rtld di max this is the type of elements  {
	                                                      elements :: -1000
                                                             }
in dl serinfo below the dls name member points to space in the buffer passed to dlinfo typedef struct char dls name name of library search path directory unsigned int dls flags indicates where this directory came  {
	                                came :: -1000
                                   }
from dl serpath  {
	seraph :: 9
	spreathe :: 11
	warpaths :: 9
	threaps :: 9
	spreathed :: 10
	spreathes :: 9
	spreathing :: 9
	spreagh :: 9
 }
this is the structure that must be passed by reference to dlinfo for the rtld di serinfo and rtld di serinfosize requests typedef struct size t dls size size in bytes of the whole  {
	                            whole :: -1000
                                }
buffer unsigned int dls cnt number of elements in dls serpath dl serpath dls serpath actually longer  {
	          longer :: -1000
               }
dls cnt elements dl serinfo endif use gnu end decls endif dlfcn h this file defines standard elf types structures and macros copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef elf h define elf h include features h begin decls standard elf types include stdint  {
	                                                                                                                                                                    stinted :: 7
	                                                                                                                                                                     ettins :: 7
	                                                                                                                                                                   strident :: 7
	                                                                                                                                                                      stint :: 7
	                                                                                                                                                                     nudist :: 7
                                                                                                                                                                          }
h type for a bit quantity  {
	quantity :: -1000
    }
typedef uint t elf half  {
	half :: -1000
   }
typedef uint t elf half types for signed and unsigned bit quantities  {
	 quantities :: -1000
          }
typedef uint t elf word typedef int t elf sword  {
	    sword :: -1000
        }
typedef uint t elf word typedef int t elf sword types for signed and unsigned bit quantities typedef uint t elf xword  {
	               swords :: 6
	                sword :: 7
                    }
typedef int t elf sxword  {
	rewords :: 7
	oxfords :: 7
	bywords :: 7
   }
typedef uint t elf xword typedef int t elf sxword type of addresses  {
	   addresses :: -1000
           }
typedef uint t elf addr typedef uint t elf addr type of file offsets typedef uint t elf off typedef uint t elf off type for section indices  {
	                    indices :: -1000
                          }
which are bit quantities typedef uint t elf section typedef uint t elf section type for version symbol information typedef elf half elf versym  {
	                versify :: 7
	                verismo :: 7
	                verisms :: 7
	                  verst :: 7
	                  verso :: 7
	                   very :: 7
	                   vers :: 8
	                 vermis :: 7
	                 verism :: 8
                      }
typedef elf half elf versym the elf file header this appears at the start of every elf file define ei nident  {
	              invent :: 7
	             indents :: 9
	              intent :: 7
	              intend :: 8
	              indent :: 10
	              inbent :: 7
	              ninety :: 7
	              nidget :: 7
	              bident :: 9
	            bidental :: 7
	              rident :: 9
	              tinned :: 7
	             intends :: 7
	               widen :: 7
	            indentor :: 8
	            indenter :: 7
	               tined :: 7
	                tide :: 7
	                nine :: 7
	                nide :: 7
	              eident :: 9
	             bidents :: 8
	           indentors :: 7
                   }
typedef struct unsigned char e ident ei nident magic number and other info elf half e type object file type elf half e machine architecture  {
	            architecture :: -1000
                       }
elf word e version object file version elf addr e entry entry point virtual  {
	      virtual :: -1000
            }
address elf off e phoff  {
	pouff :: 6
	 pho :: 6
   }
program header table file offset elf off e shoff  {
	  shroff :: 6
	  howffs :: 6
	   sowff :: 6
	   scoff :: 7
	  spoffy :: 6
       }
section header table file offset elf word e flags processor  {
	processor :: -1000
        }
specific flags elf half e ehsize  {
	resized :: 7
	resize :: 8
    }
elf header size in bytes elf half e phentsize  {
	phenetic :: 11
	phenazines :: 11
	phengites :: 11
	phenakites :: 12
	phenetics :: 12
	phonetized :: 12
	phonetizes :: 14
	phonetised :: 11
	phonetises :: 11
	phenakite :: 11
	phonetize :: 13
	phonetise :: 12
	phenacite :: 11
	phenacites :: 12
       }
program header table entry size elf half e phnum  {
       }
program header table entry count elf half e shentsize  {
	complementizers :: -1000
       }
section header table entry size elf half e shnum  {
	  shlump :: 6
	    shun :: 6
	   shtum :: 7
       }
section header table entry count elf half e shstrndx  {
       }
section header string table index elf ehdr  {
	 sherd :: 5
     }
typedef struct unsigned char e ident ei nident magic number and other info elf half e type object file type elf half e machine architecture elf word e version object file version elf addr e entry entry point virtual address elf off e phoff program header table file offset elf off e shoff section header table file offset elf word e flags processor specific flags elf half e ehsize elf header size in bytes elf half e phentsize program header table entry size elf half e phnum program header table entry count elf half e shentsize section header table entry size elf half e shnum section header table entry count elf half e shstrndx section header string table index elf ehdr fields in the e ident array the ei macros are indices into the array the macros under each ei macro are the values the byte may have define ei mag file identification  {
	                                                                                                                                          identification :: -1000
                                                                                                                                                       }
byte index define elfmag  {
	flame :: 7
	beflag :: 7
	reflag :: 7
	plumage :: 7
  }
x f magic number byte define ei mag file identification byte index define elfmag e magic number byte define ei mag file identification byte index define elfmag l magic number byte define ei mag file identification byte index define elfmag f magic number byte conglomeration  {
	                              conglomeration :: -1000
                                           }
of the identification bytes for easy  {
	 easy :: -1000
    }
testing  {
	testing :: -1000
 }
as a word define elfmag elf define selfmag  {
      }
define ei class file class byte index define elfclassnone  {
       }
invalid  {
	outgate :: -1000
 }
class define elfclass bit objects define elfclass bit objects define elfclassnum  {
         }
define ei data data encoding  {
	encoding :: -1000
   }
byte index define elfdatanone  {
  }
invalid data encoding define elfdata lsb  {
	labis :: 3
	 lobs :: 4
	 libs :: 4
	 labs :: 4
	 albs :: 3
	lubes :: 3
	lobus :: 3
	lobes :: 3
	  lob :: 3
	  lib :: 3
	  lab :: 3
    }
s complement  {
	complement :: -1000
 }
little endian define elfdata msb  {
	mobs :: 4
	mibs :: 4
	mebos :: 3
	mabes :: 3
	 mob :: 3
	 mib :: 3
	  ms :: 4
   }
s complement big endian define elfdatanum  {
	fundamental :: 12
    }
define ei version file version byte index value must be ev current define ei osabi  {
	          obas :: 6
	        isobar :: 6
	         obias :: 6
             }
os abi  {
	absit :: 3
	abris :: 3
	abrin :: 3
	abrim :: 3
	aboil :: 3
	abies :: 4
	abide :: 4
	abides :: 3
	abider :: 3
	abided :: 3
	obia :: 4
	bail :: 3
	abri :: 4
	obias :: 3
	mbira :: 3
	obi :: 3
	ani :: 3
	ami :: 3
	adi :: 3
	aby :: 3
	abs :: 3
	abo :: 3
	ai :: 3
	ab :: 4
 }
identification define elfosabi  {
 }
none unix system v abi define elfosabi sysv  {
	junctions :: -1000
      }
alias define elfosabi hpux  {
  }
hp ux  {
	u :: 2
 }
define elfosabi netbsd  {
	dents :: 7
	debts :: 7
	bents :: 7
	bends :: 7
	tends :: 7
	nets :: 7
 }
netbsd define elfosabi gnu object uses gnu elf extensions  {
	extensions :: -1000
       }
define elfosabi linux  {
	linum :: 7
 }
elfosabi gnu compatibility alias define elfosabi solaris sun  {
	    ten :: -1000
      }
solaris define elfosabi aix  {
	taxi :: 3
	maxi :: 3
	axis :: 3
	axil :: 3
	six :: 3
	pix :: 3
	nix :: 3
	mix :: 3
	ait :: 3
	ais :: 3
	air :: 3
	ain :: 3
	aim :: 3
	ail :: 3
	aid :: 3
	 xi :: 3
	 ax :: 3
	 ai :: 4
  }
ibm  {
	iambs :: 3
	zimb :: 3
	timb :: 3
	nimb :: 3
	limb :: 3
	iamb :: 4
	bima :: 3
	mib :: 3
	ism :: 3
 }
aix define elfosabi irix sgi  {
	agist :: 3
	agism :: 3
	agios :: 3
	swing :: 3
	suing :: 3
	sting :: 3
	swig :: 4
	snig :: 4
	sing :: 3
	sign :: 3
	sigh :: 3
	sling :: 3
	ghis :: 3
	egis :: 4
	saiga :: 3
	 sui :: 3
	 ski :: 3
	 sei :: 3
	 sai :: 3
	 gis :: 3
	  si :: 3
   }
irix define elfosabi freebsd  {
	frees :: 9
	freed :: 9
	freets :: 9
	freshed :: 9
	breeds :: 10
  }
freebsd define elfosabi tru compaq  {
	comparts :: 7
	compares :: 7
	comparer :: 7
	compared :: 7
	compadre :: 7
	compages :: 7
	compt :: 7
	comps :: 7
	campo :: 8
	compare :: 8
	compass :: 8
	company :: 8
	compact :: 7
	comp :: 8
	coma :: 7
	camp :: 7
   }
tru unix define elfosabi modesto  {
	modellos :: 9
	doomster :: 9
	modest :: 11
	modiste :: 9
	modesty :: 10
	moderatos :: 9
	modes :: 9
   }
novell  {
	novellas :: 10
	novellae :: 9
	covelline :: 7
	hovelling :: 8
	novelty :: 7
	novelle :: 10
	novella :: 11
	novelly :: 11
	lovely :: 7
	nole :: 7
	love :: 7
	novels :: 8
	novel :: 9
	vowelling :: 7
 }
modesto define elfosabi openbsd  {
	opens :: 9
  }
openbsd define elfosabi arm aeabi  {
	amabile :: 7
	arabin :: 6
	arabic :: 6
	arabized :: 6
	arabises :: 6
	arabised :: 6
	abaxile :: 6
	abelia :: 6
	arabize :: 7
	arabise :: 7
   }
arm eabi  {
	labile :: 5
	erbia :: 6
	sabine :: 5
	gabies :: 5
	babies :: 5
	babier :: 5
	babied :: 5
	rabies :: 5
	rabi :: 5
	habile :: 5
 }
define elfosabi arm arm define elfosabi standalone  {
     }
standalone embedded application define ei abiversion  {
	reinvasion :: 13
	subversion :: 13
	abstersion :: 14
    }
abi version define ei pad byte index of padding  {
	 padding :: -1000
       }
bytes legal  {
	legal :: -1000
 }
values for e type object file type define et none no file type define et rel relocatable  {
	     relocatable :: -1000
               }
file define et exec executable file define et dyn shared object file define et core core file define et num number of defined types define et loos  {
	                      loos :: -1000
                         }
xfe  {
	flex :: 3
	ef :: 3
 }
os specific range start define et hios  {
	 hoist :: 5
	  hits :: 5
	  hiss :: 5
	  hips :: 5
	  hins :: 5
	  hies :: 5
	  hics :: 5
	  gios :: 5
	  bios :: 5
	   his :: 5
     }
xfeff  {
 }
os specific range end define et loproc  {
	coprolith :: 7
	coprolite :: 7
	  loor :: 7
     }
xff processor specific range start define et hiproc  {
	hippocras :: 7
	  chiro :: 7
	pibroch :: 9
	 orphic :: 8
	pibrochs :: 8
	hydropic :: 7
      }
xffff processor specific range end legal values for e machine architecture define em none no machine define em m at t we define em sparc sun sparc define em intel  {
	                       untile :: 7
	                       inters :: 6
	                     interval :: 6
	                       inlets :: 7
	                     interlay :: 6
	                     interlap :: 6
	                        intil :: 6
	                        inter :: 7
	                        inset :: 6
	                        inlet :: 8
	                       infelt :: 8
	                     integral :: 6
	                      untiled :: 6
	                      untiles :: 6
	                       lutein :: 6
	                       entoil :: 6
	                       entail :: 6
	                        until :: 6
	                         nite :: 6
	                         lite :: 6
	                         inte :: 8
                            }
define em k motorola  {
	homopolar :: 10
	motorboat :: 10
  }
m k family  {
	family :: -1000
 }
define em k motorola m k family define em intel define em mips mips r big endian define em s ibm system define em mips rs  {
	                      res :: 2
	                      ras :: 2
	                        r :: 2
                        }
le mips r little endian define em parisc  {
	  laris :: 7
	 praise :: 7
	paviser :: 7
	  daris :: 7
	particles :: 7
	  carps :: 8
	parsecs :: 7
	parison :: 8
	parises :: 7
	parings :: 7
	paroicous :: 7
	paniscs :: 7
	 parvis :: 7
	 parsec :: 8
	 parish :: 9
	 paries :: 8
	 panisc :: 9
	 panics :: 7
	parsonic :: 7
	 darics :: 7
	 pacier :: 7
	auriscope :: 7
	periscian :: 7
	earpicks :: 7
	 rapist :: 7
	 racist :: 7
	 racism :: 7
	patricks :: 7
	parishen :: 7
	   sari :: 7
	   pars :: 7
	  scrip :: 7
	  saris :: 7
	paretics :: 7
	parecism :: 7
	  puris :: 7
	  picas :: 7
	 caries :: 7
	  peris :: 7
	 capris :: 7
	  pavis :: 7
	  parts :: 7
	  parks :: 7
	  paris :: 10
	  pares :: 7
	  pards :: 7
	  pairs :: 8
	  padis :: 7
	parchisi :: 7
	parchesi :: 7
	  naris :: 7
	perisarc :: 7
      }
hppa  {
	hap :: 5
 }
define em vpp  {
 }
fujitsu  {
	jujitsu :: 11
	jujitsus :: 9
 }
vpp define em sparc plus sun s v plus define em intel define em ppc  {
	           pos :: -1000
             }
powerpc  {
	cower :: 9
	power :: 9
 }
define em ppc powerpc bit define em s ibm s define em v nec v series  {
	         series :: -1000
              }
define em fr fujitsu fr define em rh  {
	   rhus :: 2
	   rhea :: 2
	    rho :: 3
	    reh :: 2
	    rah :: 2
	      r :: 2
      }
trw  {
	crwth :: 3
	trows :: 3
	trews :: 3
	trawl :: 3
	tower :: 3
	writ :: 3
	trow :: 4
	tawer :: 3
	try :: 3
	tre :: 3
	tow :: 3
	tew :: 3
	taw :: 3
	tr :: 4
 }
rh define em rce  {
	icers :: 3
	acers :: 3
	acerb :: 3
	rice :: 3
	reck :: 3
	race :: 3
	icer :: 4
	ecru :: 3
	crew :: 3
	acre :: 3
	reech :: 3
	rye :: 3
	roe :: 3
	ree :: 3
	rec :: 4
	ice :: 3
	ace :: 3
	 re :: 3
  }
motorola rce define em arm arm define em fake  {
	    fake :: -1000
       }
alpha digital  {
	digital :: -1000
 }
alpha define em sh hitachi  {
	hibachis :: 10
	hibachi :: 11
   }
sh define em sparcv  {
	eparchs :: 7
	scarph :: 7
	spar :: 8
	scar :: 7
	spart :: 7
	spark :: 7
	spare :: 7
	sprack :: 7
	scarp :: 8
	spacer :: 7
  }
sparc v bit define em tricore  {
	torchier :: 9
	tricornes :: 11
	tricar :: 9
	trichrome :: 10
	tricerion :: 9
	tricorn :: 11
	tricker :: 9
	tricorne :: 12
	tricorns :: 10
    }
siemens  {
	siemens :: -1000
 }
tricore define em arc argonaut  {
	argonaut :: -1000
   }
risc  {
	circs :: 5
	roscid :: 5
	risp :: 5
	risk :: 5
	rise :: 5
	fisc :: 5
	disc :: 5
	ricks :: 5
	cis :: 5
 }
core define em h hitachi h define em h h hitachi h h define em h s hitachi h s define em h hitachi h define em ia  {
	                       iamb :: 2
	                        tai :: 2
	                        sai :: 2
	                        rai :: 2
	                        kai :: 2
	                        ita :: 2
	                         ai :: 2
                          }
intel merced  {
	screed :: 7
	cered :: 7
	mercified :: 7
	permed :: 8
	deicer :: 7
	recced :: 8
	reamed :: 7
	metred :: 8
	merged :: 9
	merdes :: 8
	mercer :: 8
	mender :: 7
	melder :: 7
	meered :: 7
	termed :: 8
	merchet :: 7
	mercery :: 7
	mercers :: 7
	terce :: 7
	mere :: 7
	merse :: 7
	merle :: 7
	merge :: 7
	mered :: 8
	merde :: 9
 }
define em mips x stanford  {
	bowerwomen :: -1000
   }
mips x define em coldfire  {
	cornfields :: 10
	chloride :: 10
	coiffured :: 10
	coadmire :: 10
	colder :: 10
	cornfield :: 11
	wildfire :: 10
	codifier :: 10
   }
motorola coldfire define em hc  {
	 och :: 2
	 ich :: 2
	 hoc :: 2
	 hic :: 2
	  ch :: 2
   }
motorola m hc define em mma  {
	 marm :: 3
	 mams :: 3
	 mama :: 3
	 malm :: 3
	 maim :: 3
	 imam :: 3
	miasm :: 3
	  mam :: 4
	  ama :: 3
	   mm :: 4
	   am :: 3
    }
fujitsu mma multimedia  {
	multimedia :: -1000
 }
accelerator  {
	accelerator :: -1000
 }
define em pcp  {
	pup :: 3
	pop :: 3
	pip :: 3
	pep :: 3
	pap :: 3
 }
siemens pcp define em ncpu  {
   }
sony  {
	gonys :: 6
	donsy :: 5
	yonks :: 5
	yonis :: 5
	synod :: 5
	tony :: 5
	song :: 5
	sone :: 5
	sonsy :: 5
	sonny :: 5
	sonly :: 6
	pony :: 5
	noys :: 5
	nosy :: 6
	cony :: 5
	bony :: 5
	nonyls :: 5
	yon :: 5
	soy :: 5
	son :: 6
 }
ncpu embeeded  {
	redecided :: -1000
 }
risc define em ndr  {
	neb :: -1000
  }
denso  {
	kendo :: 6
	sensor :: 6
	donsie :: 7
	donees :: 6
	donsy :: 6
	dents :: 6
	dense :: 6
	dingoes :: 6
	deacons :: 6
	devons :: 6
	demons :: 6
	kendos :: 7
	dapsone :: 6
	vendors :: 6
	sendoff :: 6
	tensor :: 6
	deutons :: 6
	censor :: 6
	send :: 6
	sonde :: 6
	neds :: 6
	dons :: 7
	done :: 6
	does :: 6
	dens :: 8
	den :: 6
 }
ndr microprocessor  {
	microprocessor :: -1000
 }
define em starcore  {
	stercoral :: 13
	reactors :: 11
	stercorate :: 11
	stercorary :: 10
	starcher :: 11
	creators :: 10
	reactor :: 10
	starver :: 10
	starker :: 10
	starer :: 10
	coarser :: 10
	scarcer :: 10
	starchier :: 11
 }
motorola start core processor define em me toyota  {
	tomatoey :: 7
	 tomato :: 7
	  torot :: 7
	   toyo :: 7
      }
me processor define em st stmicroelectronic  {
    }
st processor define em tinyj  {
	tinaja :: 6
	tiny :: 8
	 tin :: 6
   }
advanced  {
	advanced :: -1000
 }
logic  {
	logic :: -1000
 }
corp  {
	crops :: 5
	corps :: 7
	copra :: 5
	coper :: 5
	corpses :: 5
	couper :: 5
	corpus :: 6
	corpse :: 6
	copper :: 5
	comper :: 5
	gorp :: 5
	dorp :: 5
	crop :: 6
	coup :: 5
	cory :: 5
	cort :: 5
	cors :: 5
	corn :: 5
	corm :: 5
	cork :: 5
	corf :: 5
	core :: 5
	cord :: 5
	comp :: 5
	porch :: 5
	cor :: 6
	cop :: 5
 }
tinyj emb fam define em x amd  {
	   alt :: -1000
     }
x architecture define em pdsp  {
	harmins :: -1000
   }
sony dsp  {
	dupes :: 3
	dopes :: 3
	dipso :: 3
	dups :: 4
	dops :: 4
	dips :: 4
	daps :: 4
	dup :: 3
	dso :: 3
	dop :: 3
	dip :: 3
	dep :: 3
	dap :: 3
 }
processor define em fx  {
	fox :: 2
	fax :: 2
	  f :: 2
  }
siemens fx microcontroller  {
 }
define em st plus stmicroelectronics  {
   }
st mc  {
	abyssal :: -1000
 }
define em st stmicroelectronics st bit mc define em hc motorola mc hc microcontroller define em hc motorola mc hc microcontroller define em hc motorola mc hc microcontroller define em hc motorola mc hc microcontroller define em svx  {
	                                  sox :: 3
	                                  six :: 3
	                                  sex :: 3
	                                  sax :: 3
                                    }
silicon  {
	silicon :: -1000
 }
graphics  {
	graphics :: -1000
 }
svx define em st stmicroelectronics st bit mc define em vax  {
	     varix :: 3
	       zax :: 3
	       wax :: 3
	       vox :: 3
	       vex :: 3
	       vaw :: 3
	       vau :: 3
	       vat :: 3
	       vas :: 3
	       var :: 3
	       van :: 3
	       vac :: 3
	       tax :: 3
	       sax :: 3
	       rax :: 3
	       pax :: 3
	       max :: 3
	       lax :: 3
	       fax :: 3
         }
digital vax define em cris  {
	days :: -1000
   }
axis  {
	axis :: -1000
 }
communications  {
	communications :: -1000
 }
bit embedded processor define em javelin  {
	javelin :: -1000
    }
infineon  {
	foundered :: -1000
 }
technologies  {
	technologies :: -1000
 }
bit embedded processor define em firepath  {
	firepots :: 10
	pinfeather :: 10
	firepot :: 11
    }
element bit dsp processor define em zsp  {
	  zips :: 4
	  zaps :: 4
	   zip :: 3
	   zap :: 3
     }
lsi  {
	leirs :: 3
	lairs :: 3
	laics :: 3
	esile :: 3
	soil :: 3
	slit :: 3
	slip :: 3
	slim :: 3
	slid :: 3
	seil :: 3
	sail :: 3
	lits :: 3
	list :: 3
	lisp :: 3
	lisk :: 3
	lips :: 3
	lins :: 3
	ligs :: 3
	lies :: 3
	lids :: 3
	libs :: 3
	leis :: 4
	isle :: 3
	loins :: 3
	psi :: 3
	lis :: 4
	lei :: 3
	li :: 3
	is :: 3
 }
logic bit dsp processor define em mmix  {
     }
donald  {
	dandle :: 7
	zonal :: 7
	tonal :: 7
	donated :: 7
	dona :: 7
	soland :: 7
	downland :: 7
	nodal :: 8
	monal :: 7
 }
knuth  {
	knuts :: 7
	thunk :: 6
	knut :: 8
 }
s educational  {
	educational :: -1000
 }
bit processor define em huany  {
	hunky :: 6
	yuans :: 6
	yuan :: 7
   }
harvard  {
 }
university  {
	university :: -1000
 }
machine independent  {
	independent :: -1000
 }
object files define em prism  {
	prism :: -1000
   }
sitera  {
	waterish :: 7
	kiter :: 7
	sierra :: 8
	inters :: 7
	asteria :: 8
	eaters :: 7
	niters :: 8
	biters :: 8
	retirals :: 7
	satires :: 7
	siderate :: 8
	retinas :: 7
	satori :: 7
	satire :: 9
	sierran :: 7
	citer :: 7
	biter :: 7
	asters :: 7
	astern :: 7
	astir :: 7
	aster :: 8
	sideral :: 8
	sidecar :: 7
	sidebar :: 7
	strigae :: 7
	wiretaps :: 7
	kiters :: 8
	soterial :: 8
	alters :: 7
	paters :: 7
	daters :: 7
	literals :: 9
	literacy :: 7
	miters :: 8
	aivers :: 7
	mistrace :: 7
	airers :: 7
	aimers :: 7
	waters :: 7
	aiders :: 7
	titers :: 8
	timers :: 7
	tilers :: 7
	afters :: 7
	tigers :: 7
	attires :: 7
	raters :: 7
	asterisk :: 7
	asteroid :: 7
	asterias :: 7
	stearin :: 7
	stearic :: 7
	literal :: 8
	citers :: 8
	striae :: 7
	maters :: 7
	stirra :: 7
	staired :: 7
	titer :: 7
	tires :: 7
	taters :: 7
	stear :: 7
	stair :: 7
	sire :: 7
	sate :: 7
	rite :: 7
	haters :: 7
	seatrain :: 7
	sizer :: 7
	sixer :: 7
	siver :: 7
	sited :: 7
	sitar :: 9
	siler :: 7
	siker :: 7
	sider :: 7
	situlae :: 7
	rites :: 8
	rates :: 7
	oaters :: 7
	literatus :: 7
	siderated :: 7
	caters :: 7
	satirize :: 7
	pitaras :: 7
	liters :: 8
	niter :: 7
	miter :: 7
	liter :: 7
	sitrep :: 7
	sistra :: 7
	sitars :: 7
 }
prism define em avr  {
	avert :: 3
	avers :: 3
	vera :: 3
	vary :: 3
	vars :: 3
	vare :: 3
	vara :: 3
	aver :: 4
	arvo :: 3
	var :: 4
	avo :: 3
	ave :: 3
	arr :: 3
	apr :: 3
	air :: 3
	 ar :: 3
  }
atmel  {
	lamest :: 6
	lament :: 6
	camel :: 6
	artel :: 6
	armet :: 6
	almes :: 6
	almeh :: 6
	armlet :: 6
	camelot :: 6
	atmolyze :: 6
	atmolyse :: 6
	tame :: 6
	tamely :: 7
	tamale :: 6
	lame :: 6
	samel :: 6
	alme :: 7
	metal :: 6
 }
avr bit microcontroller define em fr fujitsu fr define em d v mitsubishi  {
           }
d v define em d v mitsubishi d v define em v nec v define em m r mitsubishi m r define em mn  {
	                   mnas :: 2
	                    mun :: 2
	                    mna :: 3
	                    men :: 2
	                    man :: 2
	                      m :: 2
                      }
matsushita  {
	chowkidars :: -1000
 }
mn define em mn matsushita mn define em pj  {
	       p :: 2
       }
picojava  {
 }
define em openrisc  {
	incorpse :: 10
 }
openrisc bit embedded processor define em arc a arc cores  {
	    cores :: -1000
        }
tangent  {
	tangent :: -1000
 }
a define em xtensa  {
	etens :: 7
	anenst :: 7
	stengah :: 7
	sterna :: 7
	stens :: 7
	stean :: 7
	stane :: 7
	sten :: 7
  }
tensilica  {
	tenails :: 11
	conciliates :: 11
	telsonic :: 11
	felsitic :: 11
	tensility :: 11
	pensility :: 11
	gentilic :: 12
	jesuitical :: 11
 }
xtensa architecture define em num if it is necessary to assign  {
	    assign :: -1000
         }
new unofficial  {
	unofficial :: -1000
 }
em values please pick  {
	pick :: -1000
  }
large random  {
	random :: -1000
 }
numbers x xa f etc to minimize  {
	minimize :: -1000
     }
the chances  {
	chances :: -1000
 }
of collision  {
	collision :: -1000
 }
with official  {
	official :: -1000
 }
or non gnu unofficial values define em alpha x legal values for e version version define ev none invalid elf version define ev current current version define ev num section header typedef struct elf word sh name section name string tbl  {
	                                   ablet :: 3
	                                    bolt :: 3
	                                    belt :: 3
	                                     til :: 3
	                                     tel :: 3
                                       }
index elf word sh type section type elf word sh flags section flags elf addr sh addr section virtual addr at execution  {
	            execution :: -1000
                    }
elf off sh offset section file offset elf word sh size section size in bytes elf word sh link link to another section elf word sh info additional section information elf word sh addralign  {
                                }
section alignment  {
	alignment :: -1000
 }
elf word sh entsize  {
	trefah :: -1000
  }
entry size if section holds  {
	holds :: -1000
   }
table elf shdr  {
	shored :: 5
	shared :: 5
	shred :: 5
	sherd :: 6
	shard :: 6
 }
typedef struct elf word sh name section name string tbl index elf word sh type section type elf xword sh flags section flags elf addr sh addr section virtual addr at execution elf off sh offset section file offset elf xword sh size section size in bytes elf word sh link link to another section elf word sh info additional section information elf xword sh addralign section alignment elf xword sh entsize entry size if section holds table elf shdr special section indices define shn undef undefined  {
	                                                                             undefined :: -1000
                                                                                     }
section define shn loreserve  {
	unreservedly :: 11
	foreseer :: 11
	unreserve :: 12
	foreverness :: 11
	reobserve :: 12
	unreserved :: 11
	reobserved :: 11
  }
xff start of reserved indices define shn loproc xff start of processor specific define shn before xff order section before all others  {
	               others :: -1000
                    }
solaris define shn after xff order section after all others solaris define shn hiproc xff f end of processor specific define shn loos xff start of os specific define shn hios xff f end of os specific define shn abs xfff associated symbol is absolute define shn common xfff associated symbol is common define shn xindex  {
	                                                 jinxed :: 7
                                                      }
xffff index is in extra table define shn hireserve  {
	unreserve :: 12
	unreserved :: 11
	timeserver :: 12
       }
xffff end of reserved indices legal values for sh type section type define sht  {
	       shtumm :: 3
	       shtuck :: 3
	       shtoom :: 3
	       shtook :: 3
	       shtick :: 3
	         this :: 3
	         soth :: 4
	         sith :: 4
	         shut :: 4
	         shot :: 4
	         shit :: 4
	         shet :: 4
	         shat :: 4
	        sithe :: 3
	        shute :: 3
	        shunt :: 3
	        shtup :: 4
	        shtum :: 4
	        shtik :: 4
	        shout :: 3
	        shott :: 3
	        shote :: 3
	        short :: 3
	        shoot :: 3
	        shoat :: 3
	        shite :: 3
	        shirt :: 3
	        shift :: 3
	        shent :: 3
	        sheet :: 3
	        shalt :: 3
	        shaft :: 3
	         hots :: 3
	         hits :: 3
	         hets :: 3
	         hats :: 3
	          sot :: 3
	          sit :: 3
	          shy :: 3
	          she :: 3
	          sha :: 3
	          set :: 3
	          sat :: 3
	          pht :: 3
	           st :: 3
	           sh :: 4
            }
null section header table entry unused define sht progbits  {
	 frogbit :: 11
	 probits :: 10
	frogbits :: 13
	progestin :: 10
       }
program data define sht symtab  {
	tymbal :: 7
	syntagm :: 7
	tymbals :: 8
   }
symbol table define sht strtab  {
	striate :: 7
	stirabout :: 7
	statable :: 7
	strati :: 7
	strath :: 7
	strata :: 7
	strait :: 7
	stator :: 7
	stater :: 7
	start :: 7
	tarts :: 7
	stat :: 7
	sortable :: 7
   }
string table define sht rela relocation entries with addends  {
	 addends :: -1000
       }
define sht hash  {
	hash :: -1000
 }
symbol hash table define sht dynamic dynamic linking  {
	linking :: -1000
      }
information define sht note notes define sht nobits  {
	 bionts :: 8
	 binits :: 7
	 points :: 7
	bonitos :: 7
	bonitas :: 8
	bonists :: 7
	boniest :: 8
	noblest :: 7
	 robins :: 8
	 oubits :: 8
	 toxins :: 7
	 tonics :: 7
	 tobies :: 8
	 orbits :: 8
	 oobits :: 9
	 joints :: 7
	 subito :: 7
	   nobs :: 7
	norites :: 7
	  oobit :: 7
	 noints :: 7
	 bonist :: 8
	ribston :: 7
      }
program space with no data bss define sht rel relocation entries no addends define sht shlib  {
	          sahib :: 6
              }
reserved define sht dynsym  {
	donsy :: 7
  }
dynamic linker  {
	linker :: -1000
 }
symbol table define sht init array array of constructors  {
	constructors :: -1000
       }
define sht fini array array of destructors  {
	destruct :: 14
	destructs :: 16
	destructor :: 19
	obstructer :: 14
	obstructors :: 16
	distruster :: 15
	instructors :: 16
	destructions :: 15
	descriptors :: 15
     }
define sht preinit  {
	confer :: -1000
 }
array array of pre constructors define sht group section group define sht symtab shndx  {
            }
extended section indeces define sht num number of defined types define sht loos x start os specific define sht gnu attributes x ffffff object attributes define sht gnu hash x ffffff gnu style hash table define sht gnu liblist  {
	                               biblist :: 11
	                              libelist :: 9
	                              biblists :: 9
                                     }
x ffffff prelink  {
	prelim :: 9
	pralines :: 9
	prolines :: 9
	proline :: 10
	perkin :: 9
	perjink :: 9
	praline :: 10
	purline :: 9
 }
library list define sht checksum  {
	checkouts :: 11
	checkups :: 11
	checkup :: 10
	chucks :: 11
	checks :: 12
	chuckles :: 10
	chuckies :: 10
   }
x ffffff checksum for dso  {
	 dso :: -1000
   }
content  {
	content :: -1000
 }
define sht losunw  {
	derricks :: -1000
 }
x ffffffa  {
 }
sun specific low bound define sht sunw  {
	sundew :: 5
	sunbow :: 5
	  sunk :: 5
	  sung :: 5
	sunward :: 5
     }
move  {
	move :: -1000
 }
x ffffffa define sht sunw comdat  {
	coadmits :: 7
	combatted :: 7
	cordate :: 8
	combater :: 7
	combated :: 9
	tomcat :: 8
	tombac :: 7
	comrade :: 7
	comparted :: 7
	combats :: 8
	comsat :: 9
	comart :: 8
	combat :: 9
	comade :: 7
	dogmatic :: 7
	 coma :: 7
	coadmit :: 8
	tomcats :: 7
    }
x ffffffb  {
 }
define sht sunw syminfo  {
	masculy :: -1000
  }
x ffffffc  {
 }
define sht gnu verdef  {
	verified :: 7
	served :: 7
	verdelho :: 7
	nerved :: 7
	kerved :: 7
	kerfed :: 7
	venders :: 7
	versified :: 7
	verse :: 7
	verge :: 7
	verbified :: 7
	verted :: 8
	versed :: 8
	verged :: 8
	verdet :: 9
	vender :: 8
	merde :: 7
  }
x ffffffd  {
 }
version definition section define sht gnu verneed  {
	serened :: 9
	vendees :: 9
	vendee :: 10
     }
x ffffffe  {
 }
version needs section define sht gnu versym x fffffff  {
       }
version symbol table define sht hisunw  {
    }
x fffffff sun specific high bound define sht hios x fffffff end os specific type define sht loproc x start of processor specific define sht hiproc x fffffff end of processor specific define sht louser  {
	                           roubles :: 7
	                            lessor :: 7
	                             house :: 7
	                            poules :: 7
	                           louvres :: 8
	                           louvers :: 10
	                           lousier :: 9
	                            douser :: 9
	                            dorsel :: 7
	                           loudest :: 7
	                           loudens :: 7
	                           elutors :: 7
	                           elusory :: 8
	                             douse :: 7
	                           fouters :: 7
	                           loppers :: 7
	                             bouse :: 7
	                            routes :: 7
	                            rouses :: 7
	                            rouser :: 9
	                            roused :: 8
	                            rouges :: 7
	                            fouler :: 8
	                           couters :: 7
	                           souters :: 7
	                           coupers :: 7
	                           soupers :: 7
	                           longers :: 7
	                            mousle :: 7
	                            mouser :: 9
	                            morsel :: 7
	                           pouters :: 7
	                           pourers :: 7
	                           loiters :: 7
	                           mousery :: 8
	                           mousers :: 7
	                            tousle :: 7
	                            touser :: 9
	                            torsel :: 7
	                            houser :: 9
	                            housel :: 8
	                           loggers :: 7
	                           lofters :: 7
	                           lodgers :: 7
	                           gougers :: 7
	                           outlers :: 7
	                           lockers :: 7
	                            joules :: 7
	                            luster :: 7
	                           touters :: 7
	                            lusher :: 7
	                           dousers :: 7
	                           tousers :: 7
	                           tourers :: 7
	                           ourself :: 7
	                           soilure :: 7
	                           lobbers :: 7
	                           loaners :: 7
	                             youse :: 7
	                           loafers :: 7
	                           loaders :: 7
	                         lousewort :: 7
	                         housecarl :: 7
	                           closure :: 7
	                          loungers :: 7
	                            louvre :: 7
	                            louver :: 9
	                            loused :: 9
	                            loures :: 10
	                            loured :: 8
	                            loupes :: 8
	                            louies :: 8
	                            louder :: 9
	                            lories :: 7
	                            looser :: 8
	                             touse :: 7
	                             souse :: 7
	                              lour :: 7
	                              lors :: 7
	                             rouse :: 9
	                             roues :: 7
	                            souter :: 8
	                            sourer :: 8
	                            soured :: 7
	                            souper :: 8
	                            souled :: 7
	                            solver :: 7
	                            solder :: 7
	                           housers :: 7
	                            nousle :: 7
	                            norsel :: 7
	                            boules :: 7
	                            pulser :: 7
	                             mouse :: 7
	                           lauders :: 7
	                           routers :: 7
	                             lowse :: 7
	                             lousy :: 7
	                             louse :: 10
	                             lours :: 8
	                             loure :: 9
	                             loupe :: 7
	                             louie :: 7
	                             loser :: 7
	                             lores :: 7
	                           rousers :: 7
                                 }
x start of application specific define sht hiuser  {
	forequarters :: -1000
      }
x fffffff end of application specific legal values for sh flags section flags define shf  {
	         shift :: 3
	         shelf :: 3
	         sheaf :: 3
	         shaft :: 3
	           shy :: 3
	           she :: 3
	           sha :: 3
	            sh :: 4
             }
write writable  {
	writable :: -1000
 }
define shf alloc occupies  {
	occupies :: -1000
  }
memory during execution define shf execinstr  {
	externs :: 11
	cretins :: 11
	execrations :: 11
    }
executable define shf merge might be merged define shf strings contains nul terminated strings define shf info link sh info contains sht index define shf link order preserve  {
	                   preserve :: -1000
                          }
order after combining  {
	combining :: -1000
 }
define shf os nonconforming  {
	nonconforming :: -1000
  }
non standard os specific handling required define shf group section is member of a group define shf tls section hold thread local data define shf maskos  {
	                   shakos :: 7
	                  oakmoss :: 7
	                   sambos :: 7
	                  maskers :: 7
	                  maskegs :: 7
	                  mascots :: 7
	                  mascons :: 7
	                     mass :: 7
	                     mask :: 7
	                   smokos :: 7
	                    mosks :: 8
	                    makos :: 7
                        }
x ff os specific define shf maskproc  {
     }
xf processor specific define shf ordered  {
	ordered :: -1000
    }
special ordering  {
	ordering :: -1000
 }
requirement  {
	requirement :: -1000
 }
solaris define shf exclude  {
	exclude :: -1000
  }
section is excluded  {
	excluded :: -1000
 }
unless referenced or allocated solaris section group handling define grp  {
	    group :: 3
	    grope :: 3
	    gripy :: 3
	    gript :: 3
	    gripe :: 3
	    grasp :: 3
	    grapy :: 3
	    grape :: 3
	    gramp :: 3
	    graip :: 3
	    gaper :: 3
	     prog :: 3
	     prig :: 3
	     gorp :: 3
	      gip :: 3
	      gap :: 3
	       gr :: 4
        }
comdat x mark group as comdat symbol table entry typedef struct elf word st name symbol name string tbl index elf addr st value symbol value elf word st size symbol size unsigned char st info symbol type and binding  {
	                                binding :: -1000
                                      }
unsigned char st other symbol visibility  {
	visibility :: -1000
    }
elf section st shndx section index elf sym typedef struct elf word st name symbol name string tbl index unsigned char st info symbol type and binding unsigned char st other symbol visibility elf section st shndx section index elf addr st value symbol value elf xword st size symbol size elf sym the syminfo section if available contains additional information about every dynamic symbol typedef struct elf half si boundto  {
	                                                                 bound :: 9
	                                                              soundbox :: 9
	                                                                bouton :: 9
                                                                     }
direct bindings  {
	bindings :: -1000
 }
symbol bound to elf half si flags per symbol flags elf syminfo typedef struct elf half si boundto direct bindings symbol bound to elf half si flags per symbol flags elf syminfo possible values for si boundto define syminfo bt  {
	                                    but :: 2
	                                    bot :: 2
	                                    bit :: 2
	                                    bet :: 2
	                                    bat :: 2
	                                      b :: 2
                                      }
self xffff symbol bound to self define syminfo bt parent xfffe  {
         }
symbol bound to parent define syminfo bt lowreserve  {
	wheresoever :: 12
      }
xff beginning of reserved entries possible bitmasks  {
	basmatis :: 10
	kismats :: 10
	bitmaps :: 10
	biomass :: 10
	dismasks :: 10
     }
for si flags define syminfo flg  {
	fugle :: 3
	fugal :: 3
	fogle :: 3
	flung :: 3
	flong :: 3
	flogs :: 3
	fling :: 3
	flags :: 3
	 flog :: 4
	 flag :: 4
	  fug :: 3
	  fog :: 3
	  fly :: 3
	  flu :: 3
	  fig :: 3
	  fag :: 3
	   gl :: 3
	   fl :: 4
    }
direct x direct bound symbol define syminfo flg passthru  {
	pushcarts :: 10
       }
x pass thru  {
	tice :: -1000
 }
symbol for translator  {
	translator :: -1000
 }
define syminfo flg copy x symbol is a copy reloc define syminfo flg lazyload  {
            }
x symbol bound to object to be lazy loaded syminfo version values define syminfo none define syminfo current define syminfo num how to extract and insert information held  {
	                       held :: -1000
                          }
in the st info field define elf st bind val unsigned char val define elf st type val val xf define elf st info bind type bind type xf both elf sym and elf sym use the same one byte st info field define elf st bind val elf st bind val define elf st type val elf st type val define elf st info bind type elf st info bind type legal values for st bind subfield  {
	                                                                     subfield :: -1000
                                                                            }
of st info symbol binding define stb  {
	 stilb :: 3
	  tubs :: 3
	  stub :: 4
	  stob :: 4
	  stab :: 4
	  tabs :: 3
	 sabot :: 3
	   sub :: 3
	   sib :: 3
	   sab :: 3
	    st :: 4
     }
local local symbol define stb global global symbol define stb weak  {
	      weak :: -1000
         }
weak symbol define stb num number of defined types define stb loos start of os specific define stb gnu unique  {
	             unique :: -1000
                  }
unique symbol define stb hios end of os specific define stb loproc start of processor specific define stb hiproc end of processor specific legal values for st type subfield of st info symbol type define stt  {
	                                ted :: -1000
                                  }
notype  {
	netops :: 7
	cotypes :: 8
	potency :: 7
	cotype :: 9
	notepad :: 7
	note :: 7
	netop :: 8
 }
symbol type is unspecified  {
	unspecified :: -1000
  }
define stt object symbol is a data object define stt func symbol is a code object define stt section symbol associated with a section define stt file symbol s name is file name define stt common symbol is a common data object define stt tls symbol is thread local data object define stt num number of defined types define stt loos start of os specific define stt gnu ifunc  {
                                                                   }
symbol is indirect  {
	indirect :: -1000
 }
code object define stt hios end of os specific define stt loproc start of processor specific define stt hiproc end of processor specific symbol table indices are found in the hash buckets  {
	                        buckets :: -1000
                              }
and chain table of a symbol hash table section this special index value indicates the end of a chain meaning no further symbols  {
	               symbols :: -1000
                     }
are found in that bucket define stn  {
	 synth :: 3
	 stunk :: 3
	 stung :: 3
	 stown :: 3
	 stoun :: 3
	 stony :: 3
	 stonk :: 3
	 stong :: 3
	 stone :: 3
	 stond :: 3
	 stink :: 3
	 sting :: 3
	 stern :: 3
	 steno :: 3
	 stend :: 3
	 steen :: 3
	 stean :: 3
	 starn :: 3
	 stank :: 3
	 stang :: 3
	 stane :: 3
	 stand :: 3
	 stain :: 3
	  tuns :: 3
	  tons :: 3
	  tins :: 3
	  tens :: 3
	  sten :: 4
	  tans :: 3
	  snot :: 3
	  snit :: 3
	  sent :: 4
	  sant :: 4
	 senti :: 3
	 santo :: 3
	   son :: 3
	   sin :: 3
	   sen :: 3
	   san :: 3
	    st :: 4
     }
undef end of a chain how to extract and insert information held in the st other field define elf st visibility o o x for elf the definitions are the same define elf st visibility o elf st visibility o symbol visibility specification  {
	                             specification :: -1000
                                         }
encoded  {
	encoded :: -1000
 }
in the st other field define stv  {
	   tef :: -1000
     }
default default symbol visibility rules define stv internal processor specific hidden class define stv hidden sym unavailable in other modules  {
	           quarries :: -1000
                  }
define stv protected not preemptible  {
	preemptive :: 16
	preempted :: 14
	perceptible :: 16
	preventible :: 14
	preemptively :: 16
   }
not exported  {
	exported :: -1000
 }
relocation table entry without addend in section of type sht rel typedef struct elf addr r offset address elf word r info relocation type and symbol index elf rel i have seen  {
	                           seen :: -1000
                              }
two different definitions of the elf rel and elf rela structures so we ll  {
            }
leave  {
	leave :: -1000
 }
them out until novell or whoever  {
	whoever :: -1000
    }
gets  {
	gets :: -1000
 }
their act together the following at least is used on sparc v mips and alpha typedef struct elf addr r offset address elf xword r info relocation type and symbol index elf rel relocation table entry with addend in section of type sht rela typedef struct elf addr r offset address elf word r info relocation type and symbol index elf sword r addend addend elf rela typedef struct elf addr r offset address elf xword r info relocation type and symbol index elf sxword r addend addend elf rela how to extract and insert information held in the r info field define elf r sym val val define elf r type val val xff define elf r info sym type sym type xff define elf r sym i i define elf r type i i xffffffff  {
                                                                                                                                       }
define elf r info sym type elf xword sym type program segment header typedef struct elf word p type segment type elf off p offset segment file offset elf addr p vaddr  {
	                          vardy :: 6
                              }
segment virtual address elf addr p paddr  {
	parded :: 6
	paddle :: 6
	padder :: 8
	paddler :: 7
	padders :: 7
	paddlers :: 6
	  prad :: 6
	  pard :: 7
	 pardy :: 6
	 pards :: 6
	 pardi :: 6
	 paddy :: 7
     }
segment physical  {
	physical :: -1000
 }
address elf word p filesz  {
	flies :: 8
	fixes :: 7
	fives :: 7
	fires :: 7
	fines :: 7
	filos :: 7
	filet :: 7
	files :: 10
	filer :: 7
	filed :: 7
	fices :: 7
	biles :: 7
	fliest :: 7
	filose :: 8
	filets :: 8
	filers :: 8
	fizzles :: 7
	wiles :: 7
	tiles :: 7
	sile :: 7
	siles :: 7
	fils :: 7
	file :: 8
	riles :: 7
	piles :: 7
	miles :: 7
	filmset :: 7
	liefs :: 7
   }
segment size in file elf word p memsz  {
	mobocratic :: -1000
      }
segment size in memory elf word p flags segment flags elf word p align segment alignment elf phdr  {
                }
typedef struct elf word p type segment type elf word p flags segment flags elf off p offset segment file offset elf addr p vaddr segment virtual address elf addr p paddr segment physical address elf xword p filesz segment size in file elf xword p memsz segment size in memory elf xword p align segment alignment elf phdr special value for e phnum this indicates that the real number of program headers  {
	                                                                 headers :: -1000
                                                                       }
is too  {
	too :: -1000
 }
large to fit into e phnum instead the real value is in the field sh info of section define pn  {
	           tamburas :: -1000
                  }
xnum  {
 }
xffff legal values for p type segment type define pt null program header table entry unused define pt load loadable  {
	           voidable :: 10
	           loanable :: 13
	           readable :: 10
	           fordable :: 10
	           tradable :: 10
	           gradable :: 10
	           lockable :: 10
	           loveable :: 10
	           laudable :: 12
	           adorable :: 10
	           foldable :: 12
	           holdable :: 12
	           lendable :: 10
	           leasable :: 10
	           bondable :: 10
	           boatable :: 10
                  }
program segment define pt dynamic dynamic linking information define pt interp program interpreter  {
	 interpreter :: -1000
           }
define pt note auxiliary  {
	auxiliary :: -1000
  }
information define pt shlib reserved define pt phdr entry for header table itself define pt tls thread local storage segment define pt num number of defined types define pt loos x start of os specific define pt gnu eh frame  {
	                                  frame :: -1000
                                      }
x e gcc eh frame hdr segment define pt gnu stack x e indicates stack executability  {
	  delectability :: 17
	  ineducability :: 16
	  detectability :: 17
	  expendability :: 16
	  exportability :: 16
	  extrudability :: 18
	  excludability :: 18
	  resectability :: 17
	  computability :: 16
	  creditability :: 16
              }
define pt gnu relro  {
	rolfer :: 6
	relator :: 6
	retros :: 6
	retrod :: 6
	reroll :: 6
	repros :: 6
	regrow :: 6
	reproval :: 6
	retro :: 7
	repro :: 7
  }
x e read only after relocation define pt losunw x ffffffa define pt sunwbss  {
            }
x ffffffa sun specific segment define pt sunwstack  {
      }
x ffffffb stack segment define pt hisunw x fffffff define pt hios x fffffff end of os specific define pt loproc x start of processor specific define pt hiproc x fffffff end of processor specific legal values for p flags segment flags define pf  {
	                                       pfui :: 2
	                                          p :: 2
                                          }
x segment is executable define pf w segment is writable define pf r segment is readable  {
	       readable :: -1000
              }
define pf maskos x ff os specific define pf maskproc xf processor specific legal values for note segment descriptor types for core files define nt prstatus  {
	                upstaters :: 11
	                 upstarts :: 12
	                 upstates :: 11
                        }
contains copy of prstatus struct define nt fpregset  {
      }
contains copy of fpregset struct define nt prpsinfo  {
	propines :: 10
      }
contains copy of prpsinfo struct define nt prxreg  {
	  prore :: 7
      }
contains copy of prxregset  {
  }
struct define nt taskstruct  {
  }
contains copy of task structure define nt platform  {
	platform :: -1000
      }
string from sysinfo  {
 }
si platform define nt auxv  {
   }
contains copy of auxv array define nt gwindows  {
      }
contains copy of gwindows struct define nt asrs  {
	   sars :: 6
	  sarsa :: 5
	   asps :: 5
	   asks :: 5
	    ass :: 5
      }
contains copy of asrset  {
	assertor :: 7
	asserter :: 7
	asserted :: 7
	assentor :: 7
	assenter :: 7
	asserts :: 7
	russet :: 7
	sarsen :: 7
	asters :: 8
	assort :: 7
	assert :: 9
	assent :: 7
	asset :: 7
	arrest :: 7
	basset :: 7
	artless :: 7
	arrests :: 8
	afreets :: 7
	straes :: 8
	starets :: 7
	assorter :: 7
	assorted :: 7
	tasset :: 7
	strae :: 7
	tasse :: 7
	tessera :: 7
	rasse :: 7
  }
struct define nt pstatus  {
	stratus :: 9
	petasus :: 9
  }
contains copy of pstatus struct define nt psinfo  {
	 points :: 7
	 poinds :: 7
	  foins :: 7
	spinoff :: 7
	 spinto :: 7
	  psion :: 8
	  pions :: 7
      }
contains copy of psinfo struct define nt prcred  {
	 pricer :: 7
	 priced :: 7
	 curred :: 7
	 parred :: 8
	  prore :: 7
	 purred :: 8
      }
contains copy of prcred struct define nt utsname  {
	 unteam :: 9
	 unseat :: 9
	 unseam :: 10
	outnames :: 10
	unteams :: 10
	unstate :: 9
	unshamed :: 9
	unseamed :: 9
	outname :: 9
	unstamped :: 9
	surname :: 9
      }
contains copy of utsname struct define nt lwpstatus  {
	irresponsibility :: -1000
      }
contains copy of lwpstatus struct define nt lwpsinfo  {
      }
contains copy of lwpinfo  {
  }
struct define nt prfpxreg  {
  }
contains copy of fprxregset  {
  }
struct define nt prxfpreg  {
	kowtowing :: -1000
  }
x e b f contains copy of user fxsr  {
       }
struct define nt ppc vmx  {
	 vox :: 3
	 vex :: 3
   }
x powerpc altivec  {
	actively :: 11
	actives :: 10
 }
vmx registers  {
	registers :: -1000
 }
define nt ppc spe x powerpc spe evr  {
	   vire :: 3
	   very :: 3
	   vert :: 3
	   vers :: 3
	   verb :: 3
	   vera :: 3
	   vare :: 3
	   over :: 3
	   perv :: 3
	   ever :: 3
	   derv :: 3
	   aver :: 3
	    vre :: 3
	    rev :: 3
	    err :: 3
	     er :: 3
      }
registers define nt ppc vsx  {
	vexes :: 3
	 vox :: 3
	 vex :: 3
   }
x powerpc vsx registers define nt tls x i tls slots  {
	     slots :: -1000
         }
struct user desc define nt ioperm  {
	moperies :: 7
	impure :: 7
	import :: 7
	hoper :: 7
	improve :: 7
	impower :: 7
	imposer :: 7
	implore :: 7
	imported :: 7
	doper :: 7
	coper :: 7
	mopier :: 8
	mopery :: 8
	mopers :: 8
	impellor :: 7
	copremia :: 7
	toper :: 7
	 rope :: 7
	 mope :: 7
	roper :: 7
	emporia :: 7
	moper :: 9
	loper :: 7
    }
x x io permission  {
	permission :: -1000
  }
bitmap  {
	bitmap :: -1000
 }
deny  {
	deny :: -1000
 }
define nt x xstate  {
	astuter :: 7
	rotates :: 7
	astute :: 8
	nutates :: 7
	estated :: 8
	estates :: 7
	taxites :: 7
	estate :: 9
  }
x x extended state using xsave  {
	suave :: 6
	stave :: 6
	soave :: 6
	slave :: 6
	shave :: 6
    }
legal values for the note segment descriptor types for object files define nt version contains a version string dynamic section entry typedef struct elf sword d tag  {
	                       tag :: -1000
                         }
dynamic entry type union elf word d val integer  {
	 integer :: -1000
       }
value elf addr d ptr  {
	 pub :: -1000
   }
address value d un elf dyn typedef struct elf sxword d tag dynamic entry type union elf xword d val integer value elf addr d ptr address value d un elf dyn legal values for d tag dynamic entry type define dt null marks  {
	                                      marks :: -1000
                                          }
end of dynamic section define dt needed name of needed library define dt pltrelsz  {
	      petrols :: 10
	      petrels :: 11
            }
size in bytes of plt relocs  {
	nerols :: 7
	ceros :: 7
	relucts :: 7
	decors :: 7
	relocks :: 10
	reloans :: 7
	reloads :: 7
	relicts :: 7
	resold :: 7
	reoils :: 7
	relock :: 9
	relics :: 9
	colors :: 7
	rectos :: 7
	recoil :: 7
	recoal :: 7
	reccos :: 7
	realos :: 7
	refocus :: 7
	solacer :: 7
	relocates :: 7
	redocks :: 7
	recoils :: 8
	recocks :: 7
	recoals :: 8
	reclose :: 7
	cerous :: 7
	ceorls :: 8
	celoms :: 8
	roles :: 7
	relic :: 7
    }
define dt pltgot  {
 }
processor defined value define dt hash address of symbol hash table define dt strtab address of string table define dt symtab address of symbol table define dt rela address of rela relocs define dt relasz  {
	                             lears :: 7
	                             arles :: 7
	                            resail :: 7
	                            relays :: 8
	                            regals :: 7
	                             zeals :: 7
	                          zelators :: 7
	                             seral :: 7
	                             relay :: 7
	                             relax :: 7
	                             reals :: 8
	                             razes :: 7
	                             rales :: 8
	                            velars :: 7
                                 }
total size of rela relocs define dt relaent  {
	teleran :: 9
	telaine :: 9
	replanted :: 9
	reagents :: 9
	remanet :: 9
	reliant :: 9
	related :: 9
	relates :: 9
	percental :: 9
	 relent :: 9
	 relate :: 10
	relevant :: 9
	realest :: 9
	reagent :: 10
	  telae :: 9
      }
size of one rela reloc define dt strsz  {
      }
size of string table define dt syment size of one symbol table entry define dt init address of init function define dt fini address of termination  {
	              termination :: -1000
                        }
function define dt soname  {
	bynames :: 7
	bonemeals :: 7
	agnames :: 7
	sudamen :: 7
	foramens :: 8
	foramen :: 7
	mopane :: 7
	monals :: 7
	monads :: 7
	renames :: 7
	benames :: 7
	mangoes :: 7
	monstera :: 7
	sagamen :: 7
	ancomes :: 7
	sokemen :: 7
	sokeman :: 8
	monases :: 9
	monades :: 9
	sockmen :: 7
	sone :: 7
	soma :: 7
	sena :: 7
	sonar :: 7
	soman :: 8
	mona :: 7
	tonemes :: 7
	donates :: 7
	solemn :: 7
	nomas :: 7
	hoseman :: 7
	nonages :: 7
	nomade :: 7
	monas :: 8
	nomades :: 8
	oarsmen :: 7
	sonarmen :: 7
  }
name of shared object define dt rpath  {
	apathy :: 6
	 wrath :: 6
	  rapt :: 6
	  prat :: 6
	  phat :: 6
	spathe :: 6
	sparth :: 6
     }
library search path deprecated  {
	deprecated :: -1000
  }
define dt symbolic  {
	symbolic :: -1000
 }
start symbol search here define dt rel address of rel relocs define dt relsz  {
	         zels :: 7
            }
total size of rel relocs define dt relent  {
	 relent :: -1000
      }
size of one rel reloc define dt pltrel type of reloc in plt define dt debug for debugging  {
	        debugging :: -1000
                }
unspecified define dt textrel  {
	lettre :: 10
	textless :: 9
	lettres :: 9
	texture :: 9
	textile :: 9
  }
reloc might modify text define dt jmprel  {
	ampler :: 7
	emparl :: 7
     }
address of plt relocs define dt bind now process relocations of object define dt init array array with addresses of init fct define dt fini array array with addresses of fini fct define dt init arraysz  {
	                           queerity :: -1000
                                  }
size in bytes of dt init array define dt fini arraysz size in bytes of dt fini array define dt runpath  {
                   }
library search path define dt flags flags for the object being loaded define dt encoding start of encoded range define dt preinit array array with addresses of preinit fct define dt preinit arraysz size in bytes of dt preinit array define dt num number used define dt loos x d start of os specific define dt hios x ffff end of os specific define dt loproc x start of processor specific define dt hiproc x fffffff end of processor specific define dt procnum  {
                                                                                 }
dt mips num most used by any processor dt entries which fall  {
	       fall :: -1000
          }
between dt valrnghi  {
	haling :: 10
 }
dt valrnglo  {
 }
use the dyn d un d val field of the elf dyn structure this follows sun s approach  {
	         approach :: -1000
                }
define dt valrnglo x ffffd  {
   }
define dt gnu prelinked  {
	spelunked :: 11
	prebilled :: 11
  }
x ffffdf  {
 }
prelinking  {
	preslicing :: 12
	princekin :: 12
	princeling :: 13
	prenticing :: 12
	plenishing :: 12
	princelings :: 12
	preuniting :: 12
	preboiling :: 12
	rethinking :: 12
	prevailing :: 12
	prebilling :: 13
	prebinding :: 14
	spelunkings :: 12
	spelunking :: 13
 }
timestamp  {
 }
define dt gnu conflictsz  {
	conflicted :: 14
	conflictual :: 12
	conflictive :: 12
	conflict :: 16
  }
x ffffdf size of conflict section define dt gnu liblistsz  {
	 biblists :: 13
        }
x ffffdf size of library list define dt checksum x ffffdf define dt pltpadsz  {
            }
x ffffdf define dt moveent  {
	moreen :: 9
	movement :: 9
	voteen :: 10
   }
x ffffdfa  {
 }
define dt movesz  {
	doves :: 7
	movies :: 7
	movers :: 8
	moze :: 7
	move :: 8
	mose :: 7
	roves :: 7
	mozes :: 9
	moves :: 10
	mover :: 7
	moved :: 7
	moues :: 7
	motes :: 7
	moses :: 7
	mores :: 7
	mopes :: 7
	moles :: 7
	mokes :: 7
	modes :: 7
	loves :: 7
 }
x ffffdfb  {
 }
define dt feature x ffffdfc  {
   }
feature selection  {
	selection :: -1000
 }
dtf  {
	defat :: 3
	deft :: 4
	daft :: 4
	def :: 3
 }
define dt posflag  {
 }
x ffffdfd  {
 }
flags for dt entries effecting  {
	effecting :: -1000
   }
the following dt entry define dt syminsz  {
     }
x ffffdfe  {
 }
size of syminfo table in bytes define dt syminent  {
	  banter :: -1000
       }
x ffffdff  {
 }
entry size of syminfo define dt valrnghi x ffffdff define dt valtagidx  {
          }
tag dt valrnghi tag reverse  {
	reverse :: -1000
   }
order define dt valnum  {
	vallums :: 7
	vuln :: 7
	vallum :: 8
  }
dt entries which fall between dt addrrnghi  {
     }
dt addrrnglo  {
 }
use the dyn d un d ptr field of the elf dyn structure if any adjustment  {
	     adjustment :: -1000
              }
is made to the elf object after it has been built these entries will need to be adjusted  {
	         adjusted :: -1000
                }
define dt addrrnglo x ffffe  {
   }
define dt gnu hash x ffffef  {
    }
gnu style hash table define dt tlsdesc  {
	lithification :: -1000
     }
plt x ffffef define dt tlsdesc got  {
	   got :: -1000
     }
x ffffef define dt gnu conflict x ffffef start of conflict section define dt gnu liblist x ffffef library list define dt config x ffffefa  {
                       }
configuration  {
	personalties :: -1000
 }
information define dt depaudit  {
	preaudit :: 11
	preaudits :: 10
  }
x ffffefb  {
 }
dependency auditing  {
	decussate :: -1000
 }
define dt audit x ffffefc  {
   }
object auditing define dt pltpad x ffffefd  {
     }
plt padding define dt movetab  {
	bovate :: 9
   }
x ffffefe  {
 }
move table define dt syminfo x ffffeff  {
     }
syminfo table define dt addrrnghi x ffffeff define dt addrtagidx  {
        }
tag dt addrrnghi tag reverse order define dt addrnum  {
       }
the versioning  {
	tensioning :: 14
	reinvoking :: 13
	versionist :: 12
	pensioning :: 14
	environing :: 13
	varnishing :: 12
	versifying :: 14
	overmining :: 12
	sectioning :: 13
	conserving :: 12
	version :: 12
	scrivening :: 13
	unvisoring :: 12
 }
entry types the next are defined as part of the gnu extension define dt versym x ffffff define dt relacount  {
	          reluctant :: 13
	          recountal :: 11
	        reluctation :: 11
	           relation :: 11
	          headcount :: 11
                  }
x ffffff define dt relcount  {
	relucent :: 10
   }
x ffffffa these were chosen  {
	chosen :: -1000
   }
by sun define dt flags x ffffffb state flags see df below define dt verdef x ffffffc address of version definition table define dt verdefnum  {
                       }
x ffffffd number of version definitions define dt verneed x ffffffe address of table with needed versions define dt verneednum  {
                  }
x fffffff number of needed versions define dt versiontagidx  {
       }
tag dt verneednum tag reverse order define dt versiontagnum  {
       }
sun added these machine independent extensions in the processor specific range be compatible  {
	  compatible :: -1000
           }
define dt auxiliary x ffffffd shared object to load before self define dt filter x fffffff shared object to get values from define dt extratagidx  {
                       }
tag elf word elf sword tag define dt extranum  {
	   extra :: 10
       }
values of d un d val in the dt flags entry define df origin x object may use df origin define df symbolic x symbol resolutions  {
	              resolutions :: -1000
                        }
starts here define df textrel x object contains text relocations define df bind now x no lazy binding for this object define df static tls x module uses the static tls model state flags selectable  {
	                        selectable :: -1000
                                 }
in the d un d val element of the dt flags entry in the dynamic section define df now x set rtld now for this object define df global x set rtld global for this object define df group x set rtld group for this object define df nodelete  {
	                                        novelese :: 10
	                                      nonelected :: 10
	                                       novelette :: 10
                                               }
x set rtld nodelete for this object define df loadfltr  {
        }
x trigger  {
	trigger :: -1000
 }
filtee  {
	fileted :: 9
	leftie :: 8
	fifteen :: 7
	flite :: 7
	filth :: 7
	filet :: 8
	filterers :: 8
	filter :: 8
	filets :: 7
	keltie :: 7
	filtered :: 9
	filterer :: 9
	fertile :: 7
	fistmele :: 7
	fettle :: 7
	felted :: 7
	feline :: 7
	felsite :: 7
	listees :: 7
	lefties :: 7
	file :: 7
	felt :: 7
	listee :: 8
	filmset :: 7
 }
loading at runtime define df initfirst  {
	cooking :: -1000
    }
x set rtld initfirst for this object define df noopen  {
	   unopen :: 8
	     noop :: 7
	     noon :: 7
	   nooned :: 8
        }
x set rtld noopen for this object define df origin x origin must be handled define df direct x direct binding enabled  {
	              enabled :: -1000
                    }
define df trans x define df interpose  {
	interpose :: -1000
     }
x object is used to interpose define df nodeflib  {
	 lobefin :: 10
       }
x ignore default lib search path define df nodump  {
	   novum :: 7
	   notum :: 7
	   nodus :: 7
       }
x object can t be dldump  {
    }
ed define df confalt  {
	fontal :: 10
	consulta :: 9
	confab :: 9
	conflated :: 10
	conflates :: 10
	conflate :: 11
	nonfacts :: 9
	nonfact :: 10
  }
x configuration alternative created  {
	created :: -1000
  }
define df endfiltee  {
 }
x filtee terminates filters  {
	governmentese :: -1000
  }
search define df dispreldne  {
	dispelled :: 12
	dispread :: 12
  }
x disp reloc applied  {
	applied :: -1000
  }
at build  {
	dermatosis :: -1000
 }
time define df disprelpnd  {
  }
x disp reloc applied at run time flags for the feature selection in dt feature define dtf parinit  {
	         paintier :: 9
	         pirating :: 9
	           rapini :: 10
	           marini :: 9
	         parities :: 9
                }
x define dtf confexp  {
	convex :: 9
	confix :: 9
	confer :: 9
  }
x flags in the dt posflag entry effecting only the next dt entry define df p lazyload x lazyload following object define df p groupperm  {
	                 grouper :: 11
                       }
x symbols from next object are not generally  {
	generally :: -1000
      }
available version definition sections  {
	sections :: -1000
  }
typedef struct elf half vd  {
	  ut :: -1000
   }
version version revision  {
	revision :: -1000
 }
elf half vd flags version information elf half vd ndx  {
	    nixed :: 3
	      nix :: 3
        }
version index elf half vd cnt number of associated aux entries elf word vd hash version name hash value elf word vd aux offset in bytes to verdaux  {
                          }
array elf word vd next offset in bytes to next verdef entry elf verdef typedef struct elf half vd version version revision elf half vd flags version information elf half vd ndx version index elf half vd cnt number of associated aux entries elf word vd hash version name hash value elf word vd aux offset in bytes to verdaux array elf word vd next offset in bytes to next verdef entry elf verdef legal values for vd version version revision define ver def none no version define ver def current current version define ver def num given version number legal values for vd flags version information flags define ver flg base x version definition of file itself define ver flg weak x weak version identifier  {
	                                                                                                                   identifier :: -1000
                                                                                                                            }
versym symbol index values define ver ndx local symbol is local define ver ndx global symbol is global define ver ndx loreserve xff beginning of reserved entries define ver ndx eliminate  {
	                     eliminate :: -1000
                             }
xff symbol is to be eliminated  {
	eliminated :: -1000
    }
auxialiary  {
	auxiliary :: 12
 }
version information typedef struct elf word vda  {
	   uta :: -1000
     }
name version or dependency names elf word vda next offset in bytes to next verdaux entry elf verdaux typedef struct elf word vda name version or dependency names elf word vda next offset in bytes to next verdaux entry elf verdaux version dependency section typedef struct elf half vn  {
	                                             vin :: 2
	                                             van :: 2
	                                               v :: 2
                                               }
version version of structure elf half vn cnt number of associated aux entries elf word vn file offset of filename for this dependency elf word vn aux offset in bytes to vernaux  {
	                         vernal :: 9
                              }
array elf word vn next offset in bytes to next verneed entry elf verneed typedef struct elf half vn version version of structure elf half vn cnt number of associated aux entries elf word vn file offset of filename for this dependency elf word vn aux offset in bytes to vernaux array elf word vn next offset in bytes to next verneed entry elf verneed legal values for vn version version revision define ver need none no version define ver need current current version define ver need num given version number auxiliary needed version information typedef struct elf word vna  {
	                                                                                              knave :: 3
	                                                                                              viand :: 3
	                                                                                               vina :: 3
	                                                                                               vena :: 3
	                                                                                               vant :: 3
	                                                                                               vans :: 3
	                                                                                               vang :: 3
	                                                                                               vane :: 3
	                                                                                               vain :: 3
	                                                                                                via :: 3
	                                                                                                van :: 4
	                                                                                                mna :: 3
	                                                                                                ana :: 3
	                                                                                                 an :: 3
                                                                                                  }
hash hash value of dependency name elf half vna flags dependency specific information elf half vna other unused elf word vna name dependency name string offset elf word vna next offset in bytes to next vernaux entry elf vernaux typedef struct elf word vna hash hash value of dependency name elf half vna flags dependency specific information elf half vna other unused elf word vna name dependency name string offset elf word vna next offset in bytes to next vernaux entry elf vernaux legal values for vna flags define ver flg weak x weak version identifier auxiliary vector this vector is normally only used by the program interpreter the usual definition in an abi supplement  {
	                                                                                                        supplement :: -1000
                                                                                                                 }
uses the name auxv t the vector is not usually defined in a standard elf h file but it can t hurt  {
	                 hurt :: -1000
                    }
we rename  {
	rename :: -1000
 }
it to avoid  {
	avoid :: -1000
 }
conflicts the sizes  {
	sizes :: -1000
 }
of these types are an arrangement  {
	epistases :: -1000
    }
between the exec server  {
	server :: -1000
  }
and the program interpreter so we don t fully  {
	   gelly :: -1000
       }
specify them here typedef struct uint t a type entry type union uint t a val integer value we use to have pointer elements added here we cannot do that though since it does not work when using bit definitions on bit platforms  {
	                                 platforms :: -1000
                                         }
and vice  {
	vice :: -1000
 }
versa  {
	serval :: 7
	versant :: 8
	veritas :: 6
	verglas :: 6
	verbals :: 7
	servals :: 6
	servant :: 6
	vesta :: 6
	vespa :: 6
	verts :: 6
	verst :: 7
	verso :: 7
	verse :: 6
	verbs :: 6
	vares :: 7
	versants :: 6
	vers :: 8
	vera :: 7
	vars :: 7
	vare :: 6
	sera :: 6
	revs :: 6
	versin :: 6
	versal :: 9
	vernal :: 6
	vermal :: 6
	verbal :: 6
	velars :: 6
	varsal :: 6
	varies :: 6
	varecs :: 6
 }
a un elf auxv t typedef struct uint t a type entry type union uint t a val integer value we use to have pointer elements added here we cannot do that though since it does not work when using bit definitions on bit platforms and vice versa a un elf auxv t legal values for a type entry type define at null end of vector define at ignore entry should be ignored define at execfd  {
	                                                                      execs :: 7
	                                                                       exec :: 8
                                                                          }
file descriptor of program define at phdr program headers for program define at phent size of program header entry define at phnum number of program headers define at pagesz  {
	                       gazes :: 8
	                       gapes :: 8
	                       gages :: 7
	                       cages :: 7
	                      pagers :: 8
	                       wages :: 7
	                        sage :: 7
	                        pase :: 7
	                        page :: 8
	                       sages :: 7
	                       rages :: 7
	                       peags :: 7
	                       paxes :: 7
	                       paves :: 7
	                       pates :: 7
	                       pases :: 7
	                       pares :: 7
	                       panes :: 7
	                       pales :: 7
	                       pages :: 10
	                       pager :: 7
	                       paged :: 7
	                       paces :: 7
	                       mages :: 7
                           }
system page size define at base base address of interpreter define at flags flags define at entry entry point of program define at notelf  {
	                  hotel :: 7
	                  botel :: 7
	                fontlet :: 7
	                novelty :: 7
	                notedly :: 7
	                   note :: 8
	                   nole :: 7
	                   lote :: 7
	                  often :: 7
	                  novel :: 7
	                  notes :: 7
	                  noter :: 7
	                  noted :: 7
	                  notal :: 7
	                  motel :: 7
                      }
program is not elf define at uid real uid define at euid  {
	      guide :: 6
	     guides :: 5
	     guider :: 5
	       suid :: 5
	       quid :: 5
	       muid :: 5
	        dui :: 5
          }
effective uid define at gid real gid define at egid  {
	    guide :: 5
	    gride :: 5
	    glide :: 5
	     gied :: 5
	     egis :: 5
	     egad :: 5
        }
effective gid define at clktck  {
   }
frequency  {
	frequency :: -1000
 }
of times some more special a type values describing the hardware  {
	  hardware :: -1000
         }
define at platform string identifying platform define at hwcap  {
       }
machine dependent hints  {
	hints :: -1000
 }
about processor capabilities  {
	strategizes :: -1000
 }
this entry gives some information about the fpu  {
	    gae :: -1000
      }
initialization  {
	initialization :: -1000
 }
performed by the kernel  {
	kernel :: -1000
  }
define at fpucw  {
 }
used fpu control word cache block sizes define at dcachebsize  {
        }
data cache block size define at icachebsize  {
     }
instruction  {
	instruction :: -1000
 }
cache block size define at ucachebsize  {
    }
unified  {
	unified :: -1000
 }
cache block size a special ignored value for ppc used by the kernel to control the interpretation of the auxv must be define at ignoreppc  {
	                  ignore :: 12
	                 ignored :: 11
	                 ignores :: 11
                       }
entry should be ignored define at secure  {
	secure :: -1000
     }
boolean  {
	boolean :: -1000
 }
was exec setuid  {
	retunds :: 7
	studied :: 7
	studier :: 7
	stupider :: 7
	toluides :: 7
	feudist :: 7
	sedulity :: 7
	reduit :: 7
	outside :: 8
	reduits :: 8
	tenuis :: 7
	suited :: 8
	stupid :: 7
	sited :: 7
	setup :: 7
	jesuit :: 7
	outsider :: 7
	outrides :: 7
	duties :: 7
 }
like define at base platform string identifying real platforms define at random address of random bytes define at execfn  {
	             execs :: 7
	              exec :: 8
                 }
filename of executable pointer to the global system page used for system calls and other nice  {
	           nice :: -1000
              }
things define at sysinfo define at sysinfo ehdr shapes  {
	  shapes :: -1000
       }
of the caches  {
	caches :: -1000
 }
bits contains associativity  {
	associativity :: -1000
 }
bits contains log of line size mask those to get cache size define at l i cacheshape  {
               }
define at l d cacheshape define at l cacheshape define at l cacheshape note section contents  {
	       contents :: -1000
              }
each entry in the note section begins with a header of a fixed  {
	       fixed :: -1000
           }
form typedef struct elf word n namesz  {
	 lames :: 7
	 kames :: 7
	 james :: 7
	 hames :: 7
	 games :: 7
	nemesia :: 7
	 fames :: 7
	 dames :: 7
	 cames :: 7
	namers :: 8
	yamens :: 7
	 wames :: 7
	 tames :: 7
	  same :: 7
	  naze :: 7
	  nams :: 7
	  name :: 8
	 sames :: 7
	 samen :: 8
	 nomes :: 7
	 nazes :: 9
	 naves :: 7
	 nates :: 7
	 nares :: 7
	 napes :: 7
	 names :: 10
	 namer :: 7
	 named :: 7
	 nabes :: 7
	 mazes :: 8
	 manes :: 8
     }
length of the note s name elf word n descsz  {
	    discs :: 7
	    desks :: 7
        }
length of the note s descriptor elf word n type type of the note elf nhdr  {
              }
typedef struct elf word n namesz length of the note s name elf word n descsz length of the note s descriptor elf word n type type of the note elf nhdr known  {
	                           known :: -1000
                               }
names of notes solaris entries in the note section have this name define elf note solaris sunw solaris note entries for gnu systems have this name define elf note gnu gnu defined types of notes for solaris value of descriptor one word is desired pagesize  {
	                                   paganizes :: 10
                                           }
for the binary  {
	binary :: -1000
 }
define elf note pagesize hint defined note types for gnu systems abi information the descriptor consists of words  {
	            words :: -1000
                }
word os descriptor word major  {
	major :: -1000
   }
version of the abi word minor version of the abi word subminor  {
	  submicron :: 12
	    subring :: 10
	 submicrons :: 10
	     suborn :: 10
	    bromins :: 10
          }
version of the abi define nt gnu abi tag define elf note abi nt gnu abi tag old name known oses  {
	                oses :: -1000
                   }
these values can appear in word of an nt gnu abi tag note section entry define elf note os linux define elf note os gnu define elf note os solaris define elf note os freebsd synthetic  {
	                          synthetic :: -1000
                                  }
hwcap information the descriptor begins with two words word number of entries word bitmask of enabled entries then follow variable length entries one byte followed by a terminated hwcap name string the byte gives the bit number to test if enabled u bit bitmask define nt gnu hwcap build id bits as generated  {
	                                           generated :: -1000
                                                   }
by ld build id the descriptor consists of any nonzero number of bytes define nt gnu build id version note generated by gnu gold  {
	                   gold :: -1000
                      }
containing a version string define nt gnu gold version move records typedef struct elf xword m value symbol value elf word m info size and index elf word m poffset  {
	                      toffies :: 9
	                      toffees :: 9
	                     coffrets :: 9
	                     pomfrets :: 9
                            }
symbol offset elf half m repeat  {
	repeat :: -1000
    }
repeat count elf half m stride  {
	stride :: -1000
    }
stride info elf move typedef struct elf xword m value symbol value elf xword m info size and index elf xword m poffset symbol offset elf half m repeat repeat count elf half m stride stride info elf move macro to construct move records define elf m sym info info define elf m size info unsigned char info define elf m info sym size sym unsigned char size define elf m sym info elf m sym info define elf m size info elf m size info define elf m info sym size elf m info sym size motorola k specific definitions values for elf ehdr e flags define ef cpu  {
	                                                                                                          dae :: -1000
                                                                                                            }
x m k relocs define r k none no reloc define r k direct bit define r k direct bit define r k direct bit define r k pc pc relative bit define r k pc pc relative bit define r k pc pc relative bit define r k got bit pc relative got entry define r k got bit pc relative got entry define r k got bit pc relative got entry define r k got o bit got offset define r k got o bit got offset define r k got o bit got offset define r k plt bit pc relative plt address define r k plt bit pc relative plt address define r k plt bit pc relative plt address define r k plt o bit plt offset define r k plt o bit plt offset define r k plt o bit plt offset define r k copy copy symbol at runtime define r k glob dat create got entry define r k jmp slot create plt entry define r k relative adjust by program base define r k tls gd  {
	                                                                                                                                                                                     god :: 2
	                                                                                                                                                                                     gid :: 2
	                                                                                                                                                                                     ged :: 2
	                                                                                                                                                                                     gad :: 2
	                                                                                                                                                                                       g :: 2
                                                                                                                                                                                       }
bit got offset for gd define r k tls gd bit got offset for gd define r k tls gd bit got offset for gd define r k tls ldm  {
	                        lemed :: 3
	                        lamed :: 3
	                          lem :: 3
	                          lam :: 3
	                        limed :: 3
                            }
bit got offset for ldm define r k tls ldm bit got offset for ldm define r k tls ldm bit got offset for ldm define r k tls ldo  {
	                        idols :: 3
	                         plod :: 3
	                         odyl :: 3
	                         odal :: 3
	                         ludo :: 3
	                         loud :: 3
	                         lord :: 3
	                         lode :: 3
	                         load :: 3
	                         idol :: 4
	                         dool :: 3
	                         diol :: 3
	                         clod :: 3
	                         alod :: 3
	                        loord :: 3
	                        looed :: 3
	                          udo :: 3
	                          old :: 3
	                          loo :: 3
	                          dol :: 3
	                          ado :: 3
	                           od :: 3
	                           lo :: 3
                            }
bit module relative offset define r k tls ldo bit module relative offset define r k tls ldo bit module relative offset define r k tls ie bit got offset for ie define r k tls ie bit got offset for ie define r k tls ie bit got offset for ie define r k tls le bit offset relative to static tls block define r k tls le bit offset relative to static tls block define r k tls le bit offset relative to static tls block define r k tls dtpmod  {
                                                                                           }
bit module number define r k tls dtprel  {
	 drupel :: 7
	 petrel :: 7
	dipteral :: 7
	 duplet :: 7
      }
bit module relative offset define r k tls tprel  {
	  pertly :: 6
	  triple :: 6
	   mpret :: 6
       }
bit tp relative offset keep  {
	keep :: -1000
   }
this the last entry define r k num intel specific definitions i relocs define r none no reloc define r direct bit define r pc pc relative bit define r got bit got entry define r plt bit plt address define r copy copy symbol at runtime define r glob dat create got entry define r jmp slot create plt entry define r relative adjust by program base define r gotoff  {
                                                                     }
bit offset to got define r gotpc  {
	   got :: 6
     }
bit pc relative offset to got define r plt define r tls tpoff  {
	      spoffy :: 6
           }
offset in static tls block define r tls ie address of got entry for static tls block offset define r tls gotie  {
	               dotier :: 6
	                fogie :: 6
	                dogie :: 6
	                cogie :: 6
	                bogie :: 6
	               toeing :: 6
	              logiest :: 6
	              goriest :: 7
	                vogie :: 6
	              gooiest :: 6
	                towie :: 6
	                 gite :: 6
	               gorier :: 6
	              goiters :: 6
	               goitre :: 6
	               goiter :: 7
	               goetic :: 6
	               gobies :: 6
	                logie :: 6
	                  got :: 6
                    }
got entry for static tls block offset define r tls le offset relative to static tls block define r tls gd direct bit for gnu version of general dynamic thread local data define r tls ldm direct bit for gnu version of local dynamic thread local data in le code define r define r pc define r define r pc define r tls gd direct bit for general dynamic thread local data define r tls gd push  {
	                                                                        push :: -1000
                                                                           }
tag for pushl  {
	poshly :: 6
	lushly :: 6
	pushball :: 6
	push :: 8
	puls :: 6
	pushy :: 7
	pughs :: 6
	plush :: 6
	pushily :: 7
	pushful :: 6
	pusher :: 6
	pushed :: 6
	pus :: 6
 }
in gd tls code define r tls gd call relocation for call to tls get addr define r tls gd pop  {
	                 pop :: -1000
                   }
tag for popl  {
	poulps :: 5
	poulpe :: 5
	poplin :: 6
	poplar :: 6
	peplos :: 5
	poplins :: 5
	poplars :: 5
	pops :: 5
	pope :: 5
	plop :: 5
	poulp :: 6
	polyp :: 5
	pop :: 6
	lop :: 5
 }
in gd tls code define r tls ldm direct bit for local dynamic thread local data in le code define r tls ldm push tag for pushl in ldm tls code define r tls ldm call relocation for call to tls get addr in ldm code define r tls ldm pop tag for popl in ldm tls code define r tls ldo offset relative to tls block define r tls ie got entry for negated  {
	                                                                  tussucks :: -1000
                                                                         }
static tls block offset define r tls le negated offset relative to static tls block define r tls dtpmod id of module containing symbol define r tls dtpoff  {
	                    tipoffs :: 7
	                     tipoff :: 8
	                     putoff :: 7
                          }
offset in tls block define r tls tpoff negated offset in static tls block define r tls gotdesc  {
	          coldest :: 9
	          goldest :: 10
	           godets :: 9
                }
got offset for tls descriptor define r tls desc call marker  {
	    marker :: -1000
         }
of call through tls descriptor for relaxation  {
	relaxation :: -1000
     }
define r tls desc tls descriptor containing pointer to code and to argument returning the tls offset for the symbol define r irelative  {
	             inflative :: 12
	             predative :: 12
	             urinative :: 11
	             operative :: 11
	             iterative :: 14
	             vibratile :: 11
	             precative :: 12
	           privatively :: 11
	           operatively :: 11
	             writative :: 11
	           iteratively :: 14
	             prelatize :: 12
	             prelatise :: 12
	             emulative :: 11
	             fricative :: 11
	             privative :: 11
	             violative :: 11
	             prolative :: 12
	             isolative :: 12
	             versatile :: 11
	            prelatized :: 11
	            prelatizes :: 11
	            prelatised :: 11
	            prelatises :: 11
	             aperitive :: 12
                     }
adjust indirectly  {
	indirectly :: -1000
 }
by program base keep this the last entry define r num sun sparc specific definitions legal values for st type subfield of st info symbol type define stt sparc register global register reserved to app values for elf ehdr e flags define ef sparcv mm define ef sparcv tso  {
	                                           troys :: 3
	                                           trows :: 3
	                                           trons :: 3
	                                           trois :: 3
	                                           trogs :: 3
	                                           toons :: 3
	                                           tooms :: 3
	                                           tools :: 3
	                                           thous :: 3
	                                           those :: 3
	                                            twos :: 4
	                                            toys :: 3
	                                            tows :: 3
	                                            toss :: 3
	                                            tosh :: 3
	                                            tose :: 3
	                                            tors :: 3
	                                            tosa :: 3
	                                            tops :: 3
	                                            tons :: 3
	                                            toms :: 3
	                                            togs :: 3
	                                            toes :: 3
	                                            tods :: 3
	                                            swot :: 3
	                                            stow :: 3
	                                            stot :: 3
	                                            stop :: 3
	                                            stob :: 3
	                                            stoa :: 3
	                                            taos :: 4
	                                            spot :: 3
	                                            soot :: 3
	                                            snot :: 3
	                                            slot :: 3
	                                            shot :: 3
	                                            scot :: 3
	                                             two :: 3
	                                             tsk :: 3
	                                             too :: 3
	                                             tho :: 3
	                                             tao :: 3
	                                             sot :: 3
	                                             dso :: 3
	                                              ts :: 4
	                                              to :: 3
	                                              os :: 3
                                               }
define ef sparcv pso  {
	stop :: 3
	spot :: 3
	slop :: 3
	shop :: 3
	scop :: 3
	pros :: 4
	pows :: 3
	pots :: 3
	posy :: 3
	post :: 3
	poss :: 3
	posh :: 3
	pose :: 3
	pons :: 3
	pols :: 3
	pois :: 3
	pohs :: 3
	pods :: 3
	poas :: 3
	piso :: 3
	phos :: 4
	peso :: 3
	epos :: 3
	pyots :: 3
	psora :: 4
	psoas :: 3
	psoai :: 4
	psoae :: 4
	psion :: 3
	prows :: 3
	prosy :: 3
	prost :: 3
	pross :: 3
	prose :: 3
	proms :: 3
	progs :: 3
	profs :: 3
	prods :: 3
	proas :: 3
	poots :: 3
	poons :: 3
	pools :: 3
	pooks :: 3
	poohs :: 3
	poofs :: 3
	poods :: 3
	ploys :: 3
	plows :: 3
	plots :: 3
	plods :: 3
	pions :: 3
	phots :: 3
	phohs :: 3
	peons :: 3
	sop :: 3
	pst :: 3
	psi :: 3
	pro :: 3
	pos :: 4
	poo :: 3
	pho :: 3
	dso :: 3
	psoric :: 3
	 po :: 3
	 os :: 3
	psocid :: 3
  }
define ef sparcv rmo  {
	amour :: 3
	amort :: 3
	room :: 4
	roms :: 3
	romp :: 3
	roma :: 3
	roam :: 3
	prom :: 3
	smore :: 3
	omer :: 3
	moor :: 3
	from :: 3
	roomy :: 3
	rooms :: 3
	rhomb :: 3
	roo :: 3
	rom :: 4
	rho :: 3
	mor :: 3
	 om :: 3
  }
define ef sparc ledata  {
	laterad :: 7
	gelada :: 7
	lanated :: 7
	dealt :: 7
	hematal :: 7
	legatary :: 7
  }
x little endian data define ef sparc ext mask xffff define ef sparc plus x generic v features define ef sparc sun us x sun ultrasparc  {
	               ultrasmart :: 13
                        }
extensions define ef sparc hal r x hal r extensions define ef sparc sun us x sun ultrasparciii  {
                }
extensions sparc relocs define r sparc none no reloc define r sparc direct bit define r sparc direct bit define r sparc direct bit define r sparc disp pc relative bit define r sparc disp pc relative bit define r sparc disp pc relative bit define r sparc wdisp  {
                                               }
pc relative bit shifted  {
	shifted :: -1000
  }
define r sparc wdisp pc relative bit shifted define r sparc hi high bit define r sparc direct bit define r sparc direct bit define r sparc lo truncated  {
	                   truncated :: -1000
                           }
bit define r sparc got truncated bit got entry define r sparc got bit got entry define r sparc got bit got entry shifted define r sparc pc pc relative bit truncated define r sparc pc pc relative bit shifted define r sparc wplt  {
	                                       wilt :: 5
	                                       welt :: 5
                                          }
bit pc relative plt address define r sparc copy copy symbol at runtime define r sparc glob dat create got entry define r sparc jmp slot create plt entry define r sparc relative adjust by program base define r sparc ua  {
	                                     uva :: 2
	                                     uta :: 2
	                                     vau :: 2
	                                     tau :: 2
	                                     sau :: 2
	                                     gau :: 2
	                                     eau :: 2
	                                       u :: 2
                                       }
direct bit unaligned  {
	unaligned :: -1000
 }
additional sparc relocs define r sparc plt direct bit ref to plt entry define r sparc hiplt  {
	         hilltop :: 7
	        hilltops :: 6
	            hilt :: 6
	          spilth :: 6
	         haplite :: 6
	             hip :: 6
               }
high bit plt entry define r sparc loplt  {
	   toll :: 6
	   poll :: 6
	  poult :: 6
      }
truncated bit plt entry define r sparc pcplt  {
      }
pc rel bit ref to plt entry define r sparc pcplt pc rel high bit plt entry define r sparc pcplt pc rel trunc bit plt entry define r sparc direct bit define r sparc direct bit define r sparc direct bit define r sparc olo  {
	                                         wool :: 3
	                                         tool :: 3
	                                         sool :: 3
	                                         pool :: 3
	                                         olio :: 4
	                                         oleo :: 4
	                                         obol :: 4
	                                         mool :: 3
	                                         loot :: 3
	                                         loos :: 3
	                                         loor :: 3
	                                         loop :: 3
	                                         loon :: 3
	                                         loom :: 3
	                                         look :: 3
	                                         loof :: 3
	                                         gool :: 3
	                                         fool :: 3
	                                         dool :: 3
	                                         cool :: 3
	                                        ovoli :: 3
	                                        ology :: 4
	                                        olios :: 3
	                                        oleos :: 3
	                                        obols :: 3
	                                        oboli :: 3
	                                        obole :: 3
	                                          oho :: 3
	                                          obo :: 3
	                                          loo :: 4
	                                           oo :: 3
                                            }
bit with secondary  {
	secondary :: -1000
 }
bit addend define r sparc hh  {
	  huh :: 2
	  hoh :: 2
	  heh :: 2
	  hah :: 2
    }
top bits of direct bit define r sparc hm  {
	      hm :: -1000
       }
high middle  {
	middle :: -1000
 }
bits of define r sparc lm low middle bits of define r sparc pc hh top bits of pc rel bit define r sparc pc hm high middle bit of define r sparc pc lm low miggle  {
	                              miggle :: -1000
                                   }
bits of define r sparc wdisp pc relative bit shifted define r sparc wdisp pc relative bit shifted define r sparc glob jmp was part of v abi but was removed  {
	                       removed :: -1000
                             }
define r sparc direct bit define r sparc direct bit define r sparc direct bit define r sparc disp pc relative bit define r sparc plt direct bit ref to plt entry define r sparc hix  {
	                              sixth :: 3
	                                six :: 3
	                                pix :: 3
	                                nix :: 3
	                                mix :: 3
	                                hox :: 3
	                                hit :: 3
	                                his :: 3
	                                hip :: 3
	                                hin :: 3
	                                him :: 3
	                                hie :: 3
	                                hid :: 3
	                                hic :: 3
	                                hex :: 3
	                                 xi :: 3
	                                 hi :: 4
                                  }
high bit complemented  {
	complemented :: -1000
 }
define r sparc lox  {
	lox :: -1000
  }
truncated bit complemented define r sparc h direct high of bit define r sparc m direct mid of bit define r sparc l direct low of bit define r sparc register global register usage define r sparc ua direct bit unaligned define r sparc ua direct bit unaligned define r sparc tls gd hi define r sparc tls gd lo define r sparc tls gd add define r sparc tls gd call define r sparc tls ldm hi define r sparc tls ldm lo define r sparc tls ldm add define r sparc tls ldm call define r sparc tls ldo hix define r sparc tls ldo lox define r sparc tls ldo add define r sparc tls ie hi define r sparc tls ie lo define r sparc tls ie ld define r sparc tls ie ldx  {
	                                                                                                                                    loxed :: 3
	                                                                                                                                      lux :: 3
	                                                                                                                                      lox :: 3
	                                                                                                                                      lex :: 3
	                                                                                                                                      lax :: 3
                                                                                                                                        }
define r sparc tls ie add define r sparc tls le hix define r sparc tls le lox define r sparc tls dtpmod define r sparc tls dtpmod define r sparc tls dtpoff define r sparc tls dtpoff define r sparc tls tpoff define r sparc tls tpoff define r sparc gotdata  {
	                                            dogmata :: 9
                                                  }
hix define r sparc gotdata lox define r sparc gotdata op hix define r sparc gotdata op lox define r sparc gotdata op define r sparc h define r sparc size define r sparc size define r sparc jmp irel define r sparc irelative define r sparc gnu vtinherit  {
                                               }
define r sparc gnu vtentry  {
   }
define r sparc rev keep this the last entry define r sparc num for sparc legal values for d tag of elf dyn define dt sparc register x define dt sparc num mips r specific definitions legal values for e flags field of elf ehdr define ef mips noreorder  {
	                                         roneoed :: 11
	                                       forlorner :: 11
                                               }
a noreorder directive  {
	directive :: -1000
 }
was used define ef mips pic contains pic code define ef mips cpic  {
	        spic :: 5
	        epic :: 5
	        chic :: 5
           }
uses pic calling sequence define ef mips xgot  {
      }
define ef mips bit whirl  {
	whirl :: -1000
   }
define ef mips abi define ef mips abi on define ef mips arch xf mips architecture level legal values for mips architecture level define ef mips arch x mips code define ef mips arch x mips code define ef mips arch x mips code define ef mips arch x mips code define ef mips arch x mips code define ef mips arch x mips code define ef mips arch x mips code the following are non official names and should not be used define e mips arch x mips code define e mips arch x mips code define e mips arch x mips code define e mips arch x mips code define e mips arch x mips code define e mips arch x mips code define e mips arch x mips code special section indices define shn mips acommon  {
	                                                                                                                                  scammony :: 9
                                                                                                                                         }
xff allocated common symbols define shn mips text xff allocated test symbols define shn mips data xff allocated data symbols define shn mips scommon  {
	               scammony :: 10
                      }
xff small  {
	small :: -1000
 }
common symbols define shn mips sundefined  {
	misdefined :: 13
    }
xff small undefined symbols legal values for sh type field of elf shdr define sht mips liblist x shared objects used in link define sht mips msym  {
                         }
x define sht mips conflict x conflicting  {
	conflicting :: -1000
     }
symbols define sht mips gptab  {
   }
x global data area sizes define sht mips ucode  {
	   douce :: 6
	    ecod :: 7
       }
x reserved for sgi mips compilers define sht mips debug x mips ecoff  {
	      scoffs :: 6
	       cloff :: 6
	     scoffed :: 7
	     scoffer :: 7
	      coiffe :: 6
	    scoffers :: 6
	       scoff :: 7
           }
debugging information define sht mips reginfo  {
	tarpons :: -1000
    }
x register usage information define sht mips package x define sht mips packsym  {
	      packly :: 9
	       yacks :: 9
	       packs :: 10
	       macks :: 9
	      jacksy :: 9
           }
x define sht mips reld  {
	weldor :: 5
	reload :: 5
	relaid :: 5
	yeld :: 5
	weld :: 5
	veld :: 5
	teld :: 5
	seld :: 5
	rely :: 5
	read :: 5
	meld :: 5
	held :: 5
	ruled :: 5
	geld :: 5
	riled :: 5
	redly :: 5
	 red :: 5
	 del :: 5
   }
x define sht mips iface  {
	fiacre :: 6
   }
x b define sht mips content x c define sht mips options x d miscellaneous  {
	 miscellaneous :: -1000
             }
options define sht mips shdr x define sht mips fdesc  {
	   fresco :: 6
	     feds :: 6
        }
x define sht mips extsym  {
	exonyms :: 7
   }
x define sht mips dense  {
	dense :: -1000
   }
x define sht mips pdesc  {
	peascod :: 6
	prescind :: 6
	peds :: 6
   }
x define sht mips locsym  {
	comsymp :: 7
	mocs :: 7
	loys :: 7
	lousy :: 7
	lossy :: 7
   }
x define sht mips auxsym  {
   }
x define sht mips optsym  {
	potsy :: 8
	mopsy :: 7
   }
x define sht mips locstr  {
	plodder :: -1000
   }
x define sht mips line x define sht mips rfdesc  {
	    rodes :: 7
	    rides :: 7
        }
x a define sht mips deltasym  {
	delta :: 10
	deltas :: 12
	delays :: 10
    }
x b define sht mips deltainst  {
	delations :: 11
	mentalist :: 12
	destains :: 12
	deliriants :: 11
	daintiest :: 11
	delating :: 11
	gelatins :: 11
	destain :: 12
	auntliest :: 11
	detrains :: 12
    }
x c define sht mips deltaclass  {
	castellans :: 12
    }
x d define sht mips dwarf  {
	dwarf :: -1000
    }
x e dwarf debugging information define sht mips deltadecl  {
	declaredly :: 11
       }
x f define sht mips symbol lib x define sht mips events  {
	     events :: -1000
          }
x event section define sht mips translate x define sht mips pixie  {
	      pixie :: -1000
          }
x define sht mips xlate  {
	exalt :: 6
	elate :: 7
	plates :: 6
	plater :: 6
	platen :: 6
	plated :: 6
	blate :: 7
	alate :: 7
	alates :: 6
	alated :: 6
	elates :: 6
	elater :: 6
	elated :: 6
	slate :: 7
	leat :: 6
	plate :: 7
	slatey :: 6
	slates :: 6
	slater :: 6
	slated :: 6
   }
x define sht mips xlate debug x define sht mips whirl x define sht mips eh region  {
	          region :: -1000
               }
x define sht mips xlate old x define sht mips pdr  {
	      prod :: 3
	      prad :: 3
	      pard :: 4
	      dorp :: 3
	     pured :: 3
	     purda :: 3
	     pored :: 3
	     perdy :: 3
	     perdu :: 3
	     pardy :: 3
	     pared :: 3
	     pards :: 3
	     pardi :: 3
	       pur :: 3
	       per :: 3
	       par :: 3
	        rd :: 3
         }
exception  {
	exception :: -1000
 }
x legal values for sh flags field of elf shdr define shf mips gprel  {
	        gruel :: 6
            }
x must be part of global data area define shf mips merge x define shf mips addr x define shf mips strings x define shf mips nostrip  {
	                    postin :: 9
	                   oestrin :: 9
	                   unstrip :: 10
	                  nostrils :: 9
	                   nostril :: 11
	                  coscript :: 9
                         }
x define shf mips local x define shf mips names x define shf mips nodupe  {
	       noduled :: 7
	       nodules :: 8
	       pounded :: 7
	       pounder :: 7
	       pounced :: 7
	       unroped :: 7
	       unpoped :: 7
	       unhoped :: 7
	          node :: 7
	       uncoped :: 7
	         nodus :: 7
	        nodule :: 9
             }
x symbol tables mips specific values for st other define sto mips default x define sto mips internal x define sto mips hidden x define sto mips protected x define sto mips plt x define sto mips sc align unused xff mips specific values for st info define stb mips split  {
	                                             split :: -1000
                                                 }
common entries found in sections of type sht mips gptab typedef union struct elf word gt  {
	            got :: 2
	            git :: 2
	            get :: 2
	            gat :: 2
	              g :: 2
              }
current g value g value used for compilation  {
	compilation :: -1000
      }
elf word gt unused not used gt header first entry in section struct elf word gt g value if this value were used for g elf word gt bytes this many bytes would be used gt entry subsequent  {
	                           subsequent :: -1000
                                    }
entries in section elf gptab entry found in sections of type sht mips reginfo typedef struct elf word ri gprmask  {
	           pugmarks :: 9
	             gramps :: 9
                  }
general registers used elf word ri cprmask  {
	cramps :: 9
     }
coprocessor  {
	coprocessor :: -1000
 }
registers used elf sword ri gp value gp register value elf reginfo entries found in sections of type sht mips options typedef struct unsigned char kind  {
	                     kind :: -1000
                        }
determines interpretation of the variable part of descriptor unsigned char size size of descriptor including header elf section section section header index of section affected for global options elf word info kind specific information elf options values for kind field in elf options define odk  {
	                                   harmonize :: -1000
                                           }
null undefined define odk reginfo register usage information define odk exceptions  {
	exceptions :: -1000
         }
exception processing options define odk pad section padding options define odk hwpatch  {
          }
hardware workarounds  {
	wraparounds :: 15
 }
performed define odk fill record the fill value used by the linker define odk tags  {
	          tags :: -1000
             }
reserve space for desktop  {
	desktop :: -1000
  }
tools  {
	tools :: -1000
 }
to write define odk hwand  {
	dwang :: 6
	hwan :: 8
   }
hw workarounds and bits when merging define odk hwor  {
	   whort :: 5
	   whorl :: 5
	   whore :: 5
       }
hw workarounds or bits when merging values for info in elf options for odk exceptions entries define oex  {
	             oxes :: 3
	             oxer :: 3
	             oxen :: 3
	            sexto :: 3
	              yex :: 3
	              vex :: 3
	              sex :: 3
	              rex :: 3
	              oes :: 3
	              lex :: 3
	              hex :: 3
	              dex :: 3
	               ox :: 3
	               oe :: 4
                }
fpu min x f fpe  {
	 fou :: -1000
   }
s which must be enabled define oex fpu max x f fpe s which may be enabled define oex page x page zero must be mapped  {
	               unobscured :: -1000
                        }
define oex smm  {
	emmas :: 3
	ammos :: 3
	smarm :: 3
	smalm :: 3
	mums :: 3
	moms :: 3
	mems :: 3
	mams :: 3
	umm :: 3
	sum :: 3
	sim :: 3
	sam :: 3
	hmm :: 3
	sm :: 3
 }
x force sequential  {
	sequential :: -1000
 }
memory mode define oex fpdbug  {
   }
x force floating point debug mode define oex precisefp  {
	precisely :: 11
	prespecify :: 11
	 precise :: 13
	 precipe :: 13
	precised :: 12
	precises :: 11
	precipes :: 14
       }
oex fpdbug define oex dismiss  {
	dismiss :: -1000
   }
x dismiss invalid address faults  {
	faults :: -1000
   }
define oex fpu inval x define oex fpu div  {
	     div :: -1000
       }
x define oex fpu oflo  {
   }
x define oex fpu uflo  {
	 ufo :: 5
   }
x define oex fpu inex  {
	barrennesses :: -1000
   }
x masks  {
	pectised :: -1000
 }
for info in elf options for an odk hwpatch entry define ohw  {
	       whop :: 3
	       whom :: 3
	       whoa :: 3
	       show :: 3
	       hows :: 3
	       howl :: 3
	       howf :: 3
	       howe :: 3
	       dhow :: 3
	       chow :: 3
	        who :: 4
	        ohs :: 3
	        ohm :: 3
	        how :: 4
	         ow :: 3
	         oh :: 4
          }
r keop  {
	knop :: 5
	kemp :: 5
	kelp :: 5
	kep :: 5
 }
x r end of page patch  {
	patch :: -1000
    }
define ohw r kpfetch  {
  }
x may need r prefetch  {
	prefect :: 12
	prefects :: 11
	perfect :: 10
   }
patch define ohw r keop x r end of page patch define ohw r kcvtl  {
             }
x r cvt  {
	cut :: 3
	cot :: 3
	cit :: 3
	cat :: 3
 }
ds l bug clean  {
	clean :: -1000
  }
define opad  {
	apods :: 5
	apode :: 5
	opaled :: 5
	spado :: 6
	orad :: 5
	oped :: 5
	opal :: 5
	opah :: 5
	apod :: 6
	spados :: 5
	oda :: 5
 }
prefix x define opad postfix  {
	postfix :: -1000
   }
x define opad symbol x entry found in options section typedef struct elf word hwp flags extra flags elf word hwp flags extra flags elf options hw masks for info in elfoptions  {
	                     coemptions :: 12
	                     flotations :: 12
	                     preoptions :: 13
	                     evolutions :: 12
	                     encolpions :: 12
	                     olfactions :: 13
	                     elocutions :: 13
	                     reflations :: 12
	                     epulations :: 12
	                     epilations :: 12
                              }
for odk hwand and odk hwor entries define ohwa  {
	   whoas :: 5
	    whoa :: 6
	    ohia :: 5
       }
r keop checked  {
	checked :: -1000
 }
x define ohwa r keop clean x mips relocs define r mips none no reloc define r mips direct bit define r mips direct bit define r mips rel pc relative bit define r mips direct bit shifted define r mips hi high bit define r mips lo low bit define r mips gprel gp relative bit define r mips literal  {
	                                                     literal :: -1000
                                                           }
bit literal entry define r mips got bit got entry define r mips pc pc relative bit define r mips call bit got entry for function define r mips gprel gp relative bit define r mips shift define r mips shift define r mips define r mips got disp define r mips got page define r mips got ofst  {
	                                                      soft :: 5
	                                                      onst :: 5
	                                                      oast :: 5
	                                                       oft :: 5
                                                         }
define r mips got hi define r mips got lo define r mips sub define r mips insert a define r mips insert b define r mips delete define r mips higher  {
	                         higher :: -1000
                              }
define r mips highest  {
	highest :: -1000
  }
define r mips call hi define r mips call lo define r mips scn  {
	        acnes :: 3
	        synch :: 3
	         sync :: 4
	         scan :: 4
	        sonic :: 3
	        sonce :: 3
	        since :: 3
	        scran :: 3
	        scorn :: 3
	        scone :: 3
	        scion :: 3
	        scent :: 3
	        scene :: 3
	        scend :: 3
	        scena :: 3
	        scant :: 3
	         cons :: 3
	         cens :: 3
	         cans :: 3
	          son :: 3
	          sin :: 3
	          sen :: 3
	          san :: 3
            }
disp define r mips rel define r mips add immediate define r mips pjump  {
	       plumpy :: 6
	       plumps :: 6
	        plump :: 7
            }
define r mips relgot  {
	replots :: 7
	revolt :: 7
	retool :: 7
	replot :: 8
	reglow :: 7
	regilt :: 7
	merlot :: 7
  }
define r mips jalr  {
	jamb :: -1000
  }
define r mips tls dtpmod module number bit define r mips tls dtprel module relative offset bit define r mips tls dtpmod module number bit define r mips tls dtprel module relative offset bit define r mips tls gd bit got offset for gd define r mips tls ldm bit got offset for ldm define r mips tls dtprel hi module relative offset high bits define r mips tls dtprel lo module relative offset low bits define r mips tls gottprel  {
	                                                                        troutier :: -1000
                                                                               }
bit got offset for ie define r mips tls tprel tp relative offset bit define r mips tls tprel tp relative offset bit define r mips tls tprel hi tp relative offset high bits define r mips tls tprel lo tp relative offset low bits define r mips glob dat define r mips copy define r mips jump  {
	                                                     kemp :: -1000
                                                        }
slot keep this the last entry define r mips num legal values for p type field of elf phdr define pt mips reginfo x register usage information define pt mips rtproc  {
	                       porrect :: 7
	                        raptor :: 7
	                         repro :: 7
                             }
x runtime procedure  {
	procedure :: -1000
 }
table define pt mips options x special program header types define pf mips local x legal values for d tag field of elf dyn define dt mips rld  {
	                      elder :: 3
	                      alder :: 3
	                      redly :: 3
	                      older :: 3
	                        rod :: 3
	                        rid :: 3
	                        red :: 3
	                        rad :: 3
	                        old :: 3
	                        eld :: 3
	                         rd :: 3
                          }
version x runtime linker interface version define dt mips time stamp  {
	     stamp :: -1000
         }
x timestamp define dt mips ichecksum  {
    }
x checksum define dt mips iversion  {
	envision :: 10
	recision :: 10
	revision :: 12
	ivories :: 10
	oversizing :: 10
	oversoon :: 10
	overspin :: 11
	aversion :: 13
	eversion :: 13
	emersion :: 10
	overswing :: 10
	aversions :: 11
	eversions :: 11
	revisions :: 10
	revisional :: 10
	derision :: 10
    }
x version string string tbl index define dt mips flags x flags define dt mips base address x base address define dt mips msym x define dt mips conflict x address of conflict section define dt mips liblist x address of liblist section define dt mips local gotno  {
	                                      dictyogen :: -1000
                                              }
x a number of local got entries define dt mips conflictno  {
	conflicted :: 12
	conflictions :: 16
	conflicting :: 13
	confliction :: 17
	confection :: 12
	  conflict :: 14
	conflation :: 12
         }
x b number of conflict entries define dt mips liblistno  {
	  biblist :: 11
	 billions :: 11
	billionths :: 11
        }
x number of liblist entries define dt mips symtabno  {
	symbiont :: 10
       }
x number of dynsym entries define dt mips unrefextno  {
       }
x first external  {
	external :: -1000
 }
dynsym define dt mips gotsym  {
	gutsy :: 7
	gorsy :: 7
	mots :: 7
	goys :: 7
	gousty :: 7
	potsy :: 7
   }
x first got entry in dynsym define dt mips hipageno  {
	 hypogean :: 10
        }
x number of got page table entries define dt mips rld map x address of run time loader  {
	           loader :: -1000
                }
map define dt mips delta class x delta c class definition define dt mips delta class no x number of entries in dt mips delta class define dt mips delta instance x delta c class instances  {
	                          instances :: -1000
                                  }
define dt mips delta instance no x a number of entries in dt mips delta instance define dt mips delta reloc x b delta relocations define dt mips delta reloc no x c number of entries in dt mips delta reloc define dt mips delta sym x d delta symbols that delta relocations refer to define dt mips delta sym no x e number of entries in dt mips delta sym define dt mips delta classsym  {
	                                                                   classism :: 12
	                                                                    classis :: 10
                                                                          }
x delta symbols that hold the class declaration define dt mips delta classsym no x number of entries in dt mips delta classsym define dt mips cxx  {
	                   fulfill :: -1000
                         }
flags x flags indicating for c flavor  {
	flavor :: -1000
     }
define dt mips pixie init x define dt mips symbol lib x define dt mips localpage  {
              }
gotidx  {
	doting :: 7
	ootid :: 7
 }
x define dt mips local gotidx x define dt mips hidden gotidx x define dt mips protected gotidx x define dt mips options x address of options define dt mips interface x a address of interface define dt mips dynstr  {
	                              dynatrons :: 7
	                                dyester :: 7
	                               drystone :: 7
	                                 dynast :: 7
                                      }
align x b define dt mips interface size x c size of the interface section define dt mips rld text resolve addr x d address of rld text rsolve  {
	                   figurante :: -1000
                           }
function stored in got define dt mips perf suffix  {
	  suffix :: -1000
       }
x e default suffix of dso to be added by rld on dlopen calls define dt mips compact  {
	          compact :: -1000
                }
size x f o size of compact rel section define dt mips gp value x gp value for aux gots define dt mips aux dynamic x address of aux dynamic the address of got plt in an executable using the new non pic abi define dt mips pltgot x the base of the plt in an executable using the new non pic abi if that plt is writable for a non writable plt this is omitted  {
	                                                                    omitted :: -1000
                                                                          }
or has a zero value define dt mips rwplt  {
       }
x define dt mips num x legal values for dt mips flags elf dyn entry define rhf  {
	             rif :: 3
	             rho :: 3
	             ref :: 3
               }
none no flags define rhf quickstart  {
	quicks :: 12
	quickset :: 12
	tracksuit :: 12
    }
use quickstart define rhf notpot  {
	pottos :: 7
	tompon :: 7
	hotpot :: 9
	cotton :: 7
	tinpot :: 7
	noop :: 7
	topnotch :: 7
	potto :: 8
	hotpots :: 8
	outpoint :: 7
   }
hash size not power of define rhf no library replacement ignore ld library path define rhf no move define rhf sgi only define rhf guarantee  {
	               guarantee :: -1000
                       }
init define rhf delta c plus plus define rhf guarantee start init define rhf pixie define rhf default delay  {
	             delay :: -1000
                 }
load define rhf requickstart  {
  }
define rhf requickstarted  {
	overutilizations :: -1000
 }
define rhf cord  {
	cord :: -1000
 }
define rhf no unres  {
	unrest :: 9
	unreal :: 6
	unread :: 6
	unmesh :: 6
	dures :: 6
	cures :: 6
	unwiser :: 6
	unropes :: 6
	unrobes :: 6
	unrisen :: 6
	unrests :: 7
	unreins :: 6
	unreels :: 6
	unrakes :: 6
	uprisen :: 6
	ungears :: 6
	urges :: 6
	unsex :: 6
	unsew :: 6
	unset :: 6
	unred :: 7
	under :: 6
	unces :: 7
	sures :: 6
	sure :: 6
	runes :: 7
	unbears :: 6
	pures :: 6
	unrested :: 6
	nurse :: 6
	neurs :: 6
	mures :: 6
	nares :: 6
	uprest :: 6
  }
undef define rhf rld order safe  {
	syllabified :: -1000
    }
entries found in sections of type sht mips liblist typedef struct elf word l name name string table index elf word l time stamp timestamp elf word l checksum checksum elf word l version interface version elf word l flags flags elf lib typedef struct elf word l name name string table index elf word l time stamp timestamp elf word l checksum checksum elf word l version interface version elf word l flags flags elf lib legal values for l flags define ll none define ll exact match require exact match define ll ignore int ver ignore interface version define ll require minor define ll exports  {
	                                                                                                   exports :: -1000
                                                                                                         }
define ll delay load define ll delta entries found in sections of type sht mips conflict typedef elf addr elf conflict hppa specific definitions legal values for e flags field of elf ehdr define ef parisc trapnil  {
	                           traplines :: 10
	                            triplane :: 9
	                           trampolin :: 9
	                               train :: 9
	                             trenail :: 9
	                             graplin :: 9
	                            trapline :: 11
	                            traplike :: 9
                                   }
x trap nil  {
	nil :: -1000
 }
pointer dereference  {
 }
define ef parisc ext x program uses arch extensions define ef parisc lsb x program expects  {
	        expects :: -1000
              }
little endian define ef parisc wide x program expects wide mode define ef parisc no kabp  {
	           kabs :: 5
	            kab :: 6
              }
x no kernel assisted  {
	assisted :: -1000
  }
branch  {
	branch :: -1000
 }
prediction  {
	prediction :: -1000
 }
define ef parisc lazyswap  {
  }
x allow lazy swapping  {
	swapping :: -1000
  }
define ef parisc arch x ffff architecture version defined values for e flags ef parisc arch are define efa  {
	              leaf :: 3
	              frae :: 3
	              feat :: 3
	              fear :: 3
	              deaf :: 3
	               eta :: 3
	               era :: 3
	               eft :: 3
	               efs :: 3
	                ef :: 4
                 }
parisc x b pa risc big endian define efa parisc x pa risc big endian define efa parisc x pa risc big endian additional section indeces define shn parisc ansi common xff section for tenatively  {
	                        lenitively :: 14
	                        inactively :: 12
	                        reactively :: 13
	                          lenitive :: 12
	                          relative :: 12
	                        putatively :: 13
	                        optatively :: 13
	                        negatively :: 16
	                        rotatively :: 13
	                        relatively :: 14
	                        creatively :: 13
	                          negative :: 12
                                 }
declared symbols in ansi c define shn parisc huge  {
	    huge :: -1000
       }
common xff common blocks  {
	blocks :: -1000
  }
in huge model legal values for sh type field of elf shdr define sht parisc ext x contains product  {
	           product :: -1000
                 }
specific ext define sht parisc unwind  {
	unwind :: -1000
    }
x unwind information define sht parisc doc x debug info for optimized code legal values for sh flags field of elf shdr define shf parisc short x section with short addressing  {
	                    addressing :: -1000
                             }
define shf parisc huge x section far  {
	   far :: -1000
     }
from gp define shf parisc sbp  {
	 bops :: 3
	 baps :: 3
	  sup :: 3
	  sop :: 3
	  sip :: 3
	  sap :: 3
    }
x static branch prediction code legal values for st type subfield of st info symbol type define stt parisc millicode  {
	          millipeds :: 11
	          millipede :: 12
	        millisecond :: 12
	       milliseconds :: 11
	         millipedes :: 11
                  }
millicode function entry point define stt hp opaque stt loos x define stt hp stub  {
	          stub :: -1000
             }
stt loos x hppa relocs define r parisc none no reloc define r parisc dir direct bit reference define r parisc dir l left bits of eff address define r parisc dir r right bits of eff address define r parisc dir f bits of eff address define r parisc dir r right bits of eff address define r parisc pcrel bit rel address define r parisc pcrel l left bits of rel address define r parisc pcrel r right bits of rel address define r parisc pcrel f bits of rel address define r parisc pcrel r right bits of rel address define r parisc dprel  {
	                                                                                                    direly :: 6
                                                                                                         }
l left bits of rel address define r parisc dprel r right bits of rel address define r parisc gprel l gp relative left bits define r parisc gprel r gp relative right bits define r parisc ltoff  {
	                                cloff :: 6
                                    }
l lt relative left bits define r parisc ltoff r lt relative right bits define r parisc secrel  {
	            leers :: 7
	         secretly :: 9
	         secretin :: 7
	           leches :: 7
	           lecher :: 7
	           seller :: 7
	           secure :: 7
	           secret :: 9
	           seckel :: 9
	           secern :: 7
	           searce :: 7
	           sealer :: 7
	           sclere :: 7
	         recleans :: 7
	          rescale :: 7
	          deckels :: 7
	        sacrilege :: 7
	          crewels :: 7
	        decretals :: 7
	          crenels :: 7
	          ferrels :: 7
	          verrels :: 7
	          petrels :: 7
	          cereals :: 7
	           escrol :: 7
	           lucres :: 7
	          recluse :: 7
	          reclose :: 7
	         cervelas :: 7
	           tercel :: 7
	           streel :: 7
	          lechers :: 8
	            sucre :: 7
	             seer :: 7
	          ceilers :: 7
	            serre :: 7
	            scree :: 7
	          tercels :: 8
	         securely :: 7
	          sectile :: 7
	          secreta :: 8
	          secrets :: 7
	          secrecy :: 7
	          seckels :: 7
	         lecterns :: 7
                }
bits section rel address define r parisc segbase  {
	megasse :: 9
      }
no relocation set segment base define r parisc segrel  {
	   leges :: 7
	   leger :: 7
	   leers :: 7
	  legers :: 8
	wergelds :: 7
	wergelts :: 7
	  eagres :: 7
	  seller :: 7
	  genres :: 7
	  sealer :: 7
	 keglers :: 8
	segreant :: 7
	  kegler :: 7
	 ferrels :: 7
	 verrels :: 7
	 regress :: 7
	 regrets :: 7
	 reglues :: 7
	  regoes :: 7
	  reglet :: 7
	 reglets :: 8
	 regales :: 7
	 petrels :: 7
	 redlegs :: 7
	 egglers :: 7
	 leggers :: 7
	  streel :: 7
	 ledgers :: 7
	    seer :: 7
	   serre :: 7
	   serge :: 8
	   segue :: 7
	   reges :: 7
	 gelders :: 7
       }
bits segment rel address define r parisc pltoff  {
	 tipoff :: 7
	putoffs :: 8
	 putoff :: 9
      }
l plt rel address left bits define r parisc pltoff r plt rel address right bits define r parisc ltoff fptr  {
                   }
bits lt rel function pointer define r parisc ltoff fptr l lt rel fct ptr left bits define r parisc ltoff fptr r lt rel fct ptr right bits define r parisc fptr bits function address define r parisc plabel  {
	                                 plexal :: 7
	                                pliable :: 8
                                      }
bits function address define r parisc plabel l left bits of fdesc address define r parisc plabel r right bits of fdesc address define r parisc pcrel bits pc rel address define r parisc pcrel f bits pc rel address define r parisc pcrel wr pc rel address right bits define r parisc pcrel dr pc rel address right bits define r parisc pcrel f bits pc rel address define r parisc pcrel wf  {
                                                                        }
bits pc rel address define r parisc pcrel df bits pc rel address define r parisc dir bits of eff address define r parisc dir wr bits of eff address define r parisc dir dr bits of eff address define r parisc dir f bits of eff address define r parisc dir wf bits of eff address define r parisc dir df bits of eff address define r parisc gprel bits of gp rel address define r parisc gprel wr gp rel address right bits define r parisc gprel dr gp rel address right bits define r parisc gprel f bits gp rel address define r parisc gprel wf bits gp rel address define r parisc gprel df bits gp rel address define r parisc ltoff bits lt rel address define r parisc ltoff wr lt rel address right bits define r parisc ltoff dr lt rel address right bits define r parisc ltoff f bits lt rel address define r parisc ltoff wf bits lt rel address define r parisc ltoff df bits lt rel address define r parisc secrel bits section rel address define r parisc segrel bits segment rel address define r parisc pltoff wr plt rel address right bits define r parisc pltoff dr plt rel address right bits define r parisc pltoff f bits lt rel address define r parisc pltoff wf bits plt rel address define r parisc pltoff df bits plt rel address define r parisc ltoff fptr bits lt rel function ptr define r parisc ltoff fptr wr lt rel fct ptr right bits define r parisc ltoff fptr dr lt rel fct ptr right bits define r parisc ltoff fptr f bits lt rel function ptr define r parisc ltoff fptr wf bits lt rel function ptr define r parisc ltoff fptr df bits lt rel function ptr define r parisc loreserve define r parisc copy copy relocation define r parisc iplt  {
	                                                                                                                                                                                                                                                                                                                           uplit :: 5
	                                                                                                                                                                                                                                                                                                                           split :: 5
                                                                                                                                                                                                                                                                                                                               }
dynamic reloc imported  {
	imported :: -1000
 }
plt define r parisc eplt  {
	pelt :: 6
	lept :: 5
	pelts :: 5
	pelta :: 5
   }
dynamic reloc exported plt define r parisc tprel bits tp rel address define r parisc tprel l tp rel address left bits define r parisc tprel r tp rel address right bits define r parisc ltoff tp l lt tp rel address left bits define r parisc ltoff tp r lt tp rel address right bits define r parisc ltoff tp f bits lt tp rel address define r parisc tprel bits tp rel address define r parisc tprel wr tp rel address right bits define r parisc tprel dr tp rel address right bits define r parisc tprel f bits tp rel address define r parisc tprel wf bits tp rel address define r parisc tprel df bits tp rel address define r parisc ltoff tp bits lt tp rel address define r parisc ltoff tp wr lt tp rel address right bits define r parisc ltoff tp dr lt tp rel address right bits define r parisc ltoff tp f bits lt tp rel address define r parisc ltoff tp wf bits lt tp rel address define r parisc ltoff tp df bits lt tp rel address define r parisc gnu vtentry define r parisc gnu vtinherit define r parisc tls gd l gd bit left define r parisc tls gd r gd bit right define r parisc tls gdcall  {
	                                                                                                                                                                                                                      ducally :: 7
                                                                                                                                                                                                                            }
gd call to t g a define r parisc tls ldm l ld module bit left define r parisc tls ldm r ld module bit right define r parisc tls ldmcall  {
                             }
ld module call to t g a define r parisc tls ldo l ld offset bit left define r parisc tls ldo r ld offset bit right define r parisc tls dtpmod dtp module bit define r parisc tls dtpmod dtp module bit define r parisc tls dtpoff dtp offset bit define r parisc tls dtpoff dtp offset bit define r parisc tls le l r parisc tprel l define r parisc tls le r r parisc tprel r define r parisc tls ie l r parisc ltoff tp l define r parisc tls ie r r parisc ltoff tp r define r parisc tls tprel r parisc tprel define r parisc tls tprel r parisc tprel define r parisc hireserve legal values for p type field of elf phdr elf phdr define pt hp tls pt loos x define pt hp core none pt loos x define pt hp core version pt loos x define pt hp core kernel pt loos x define pt hp core comm pt loos x define pt hp core proc pt loos x define pt hp core loadable pt loos x define pt hp core stack pt loos x define pt hp core shm  {
	                                                                                                                                                                                                 shmuck :: 3
	                                                                                                                                                                                                 shmock :: 3
	                                                                                                                                                                                                 shmear :: 3
	                                                                                                                                                                                                  sumph :: 3
	                                                                                                                                                                                                   shmo :: 5
	                                                                                                                                                                                                   sham :: 4
	                                                                                                                                                                                                   ohms :: 4
	                                                                                                                                                                                                   mhos :: 3
	                                                                                                                                                                                                  shtum :: 3
	                                                                                                                                                                                                  shmek :: 4
	                                                                                                                                                                                                  shawm :: 3
	                                                                                                                                                                                                  shame :: 3
	                                                                                                                                                                                                  shama :: 3
	                                                                                                                                                                                                  shalm :: 3
	                                                                                                                                                                                                   hums :: 3
	                                                                                                                                                                                                   hems :: 3
	                                                                                                                                                                                                   hams :: 3
	                                                                                                                                                                                                    sum :: 3
	                                                                                                                                                                                                    sim :: 3
	                                                                                                                                                                                                    shy :: 3
	                                                                                                                                                                                                    she :: 3
	                                                                                                                                                                                                    sha :: 3
	                                                                                                                                                                                                    sam :: 3
	                                                                                                                                                                                                    ohm :: 3
	                                                                                                                                                                                                     sm :: 3
	                                                                                                                                                                                                     sh :: 4
                                                                                                                                                                                                      }
pt loos x define pt hp core mmf  {
	    emf :: 3
	     mm :: 4
      }
pt loos x define pt hp parallel  {
	parallel :: -1000
     }
pt loos x define pt hp fastbind  {
     }
pt loos x define pt hp opt annot  {
	antonym :: 6
	  annoy :: 7
	  annat :: 6
	  anion :: 6
	  anent :: 6
	  ancon :: 6
	 anoint :: 6
	 annoys :: 6
	   anon :: 6
	   anno :: 8
	    ann :: 6
      }
pt loos x define pt hp hsl  {
	 hylas :: 3
	 hulks :: 3
	 hules :: 3
	 hulas :: 3
	 holts :: 3
	 holms :: 3
	 holks :: 3
	 holes :: 3
	 holds :: 3
	 hilus :: 3
	 hilts :: 3
	 helps :: 3
	 helos :: 3
	 helms :: 3
	 heles :: 3
	 halts :: 3
	 halos :: 3
	 halms :: 3
	 hales :: 3
     }
annot pt loos x define pt hp stack pt loos x define pt parisc archext  {
	      archlute :: 9
	       recheat :: 9
	        rachet :: 9
	       archlet :: 10
	       archest :: 11
             }
x define pt parisc unwind x legal values for p flags field of elf phdr elf phdr define pf parisc sbp x define pf hp page size x define pf hp far shared x define pf hp near shared x define pf hp code x define pf hp modify x define pf hp lazyswap x define pf hp sbp x alpha specific definitions legal values for e flags field of elf ehdr define ef alpha bit all addresses must be gb  {
	                                                                              fr :: -1000
                                                                               }
define ef alpha canrelax  {
	perchlorate :: -1000
  }
relocations for relaxing  {
	relaxing :: -1000
 }
exist legal values for sh type field of elf shdr these two are primerily  {
	       primer :: 11
	    primarily :: 15
	    primaries :: 11
            }
concerned  {
	concerned :: -1000
 }
with ecoff debugging info define sht alpha debug x define sht alpha reginfo x legal values for sh flags field of elf shdr define shf alpha gprel x legal values for st other field of elf sym define sto alpha nopv  {
	                                    nope :: 5
                                       }
x no pv  {
	 p :: 2
 }
required define sto alpha std gpload  {
	galopade :: 7
	galop :: 8
	galops :: 7
	galoped :: 8
	uploading :: 8
	uploads :: 8
	upload :: 9
    }
x pv only used for initial ldgp  {
     }
alpha relocs define r alpha none no reloc define r alpha reflong  {
	    erelong :: 9
	 reflowings :: 9
	 refloating :: 9
	     reflow :: 9
	    reflown :: 10
	  reflowing :: 10
          }
direct bit define r alpha refquad  {
    }
direct bit define r alpha gprel gp relative bit define r alpha literal gp relative bit w optimization define r alpha lituse  {
	               letups :: 7
	               intuse :: 8
	             lituuses :: 7
	                ileus :: 7
	               setule :: 7
	              lotuses :: 7
	              tituled :: 7
	              titules :: 9
	             luthiers :: 7
	             rivulets :: 7
	             litmuses :: 7
	               dilute :: 7
	                aitus :: 7
	              dilutes :: 8
	             liquates :: 7
	              untiles :: 7
	              rutiles :: 7
	              outlies :: 7
	               titule :: 8
	              luteins :: 7
	              lustier :: 7
	               sutile :: 8
	                tiles :: 7
	                 litu :: 8
	                 lits :: 7
	                 lite :: 7
	                situs :: 7
	              situses :: 7
	              situlae :: 8
	               lituus :: 7
	               litres :: 7
	               liters :: 7
	               listee :: 7
	               likest :: 7
	              ligures :: 7
	                lotus :: 7
	                liths :: 7
	                lites :: 9
	                litas :: 7
	                lieus :: 9
	               situla :: 7
                    }
optimization hint for literal define r alpha gpdisp  {
	  gadis :: 7
      }
add displacement  {
	displacement :: -1000
 }
to gp define r alpha braddr  {
	exotoxic :: -1000
    }
pc relative bit shifted define r alpha hint pc relative bit shifted define r alpha srel  {
	         stelar :: 5
	           seel :: 5
	          riels :: 5
	          reels :: 5
              }
pc relative bit define r alpha srel pc relative bit define r alpha srel pc relative bit define r alpha gprelhigh  {
                   }
gp relative bit high bits define r alpha gprellow  {
       }
gp relative bit low bits define r alpha gprel gp relative bit define r alpha copy copy symbol at runtime define r alpha glob dat create got entry define r alpha jmp slot create plt entry define r alpha relative adjust by program base define r alpha tls gd hi define r alpha tlsgd  {
                                                    }
define r alpha tls ldm define r alpha dtpmod define r alpha gotdtprel  {
           }
define r alpha dtprel define r alpha dtprelhi  {
      }
define r alpha dtprello  {
	petrolled :: 10
	patrolled :: 10
  }
define r alpha dtprel define r alpha gottprel define r alpha tprel define r alpha tprelhi  {
	      turophile :: 9
              }
define r alpha tprello  {
	preallot :: 9
  }
define r alpha tprel keep this the last entry define r alpha num magic values of the lituse relocation addend define lituse alpha addr define lituse alpha base define lituse alpha bytoff  {
                              }
define lituse alpha jsr  {
	jerks :: 3
	jarls :: 3
	jarks :: 3
	jars :: 4
	jor :: 3
	jar :: 3
  }
define lituse alpha tls gd define lituse alpha tls ldm legal values for d tag of elf dyn define dt alpha pltro  {
	              patrols :: 7
	               petrol :: 8
	               patron :: 6
	               patrol :: 8
	              petrols :: 7
	             patronly :: 6
	             patronal :: 6
	                 plot :: 6
	             petrosal :: 6
	             petrolic :: 6
	             petronel :: 6
                    }
dt loproc define dt alpha num powerpc specific declarations values for elf ehdr e flags define ef ppc emb x powerpc embedded flag cygnus  {
	                 scungy :: 7
	                cygnets :: 7
                      }
local bits below define ef ppc relocatable x powerpc mrelocatable  {
	correlatable :: 16
        }
flag define ef ppc relocatable lib x powerpc mrelocatable lib flag powerpc relocations defined by the abis  {
	           absit :: 5
	           abris :: 5
	           abies :: 6
	          abides :: 5
	            obis :: 5
	            ibis :: 5
	            bias :: 5
	            axis :: 5
	            anis :: 5
	            abys :: 5
	            abos :: 5
	           obias :: 5
	             abs :: 5
               }
define r ppc none define r ppc addr bit absolute address define r ppc addr bit address bits ignored define r ppc addr bit absolute address define r ppc addr lo lower bit of absolute address define r ppc addr hi high bit of absolute address define r ppc addr ha adjusted high bit define r ppc addr bit address bits ignored define r ppc addr brtaken  {
	                                                            betake :: 9
	                                                           betaken :: 11
	                                                           retaken :: 10
	                                                             break :: 9
	                                                           bracken :: 10
	                                                           bracket :: 9
	                                                          brackens :: 9
	                                                          betaking :: 9
	                                                          breaking :: 9
                                                                 }
define r ppc addr brntaken  {
   }
define r ppc rel pc relative bit define r ppc rel pc relative bit define r ppc rel brtaken define r ppc rel brntaken define r ppc got define r ppc got lo define r ppc got hi define r ppc got ha define r ppc pltrel define r ppc copy define r ppc glob dat define r ppc jmp slot define r ppc relative define r ppc local pc define r ppc uaddr  {
                                                                        }
define r ppc uaddr define r ppc rel define r ppc plt define r ppc pltrel define r ppc plt lo define r ppc plt hi define r ppc plt ha define r ppc sdarel  {
	                             lears :: 7
	                            blares :: 7
	                            blared :: 7
	                            shared :: 8
	                            shaled :: 7
	                            shader :: 7
	                            drazel :: 7
	                           slander :: 7
	                            seared :: 8
	                            sealer :: 7
	                            sealed :: 7
	                            scared :: 8
	                            scaler :: 7
	                            scaled :: 7
	                           fardels :: 7
	                            saurel :: 8
	                            sarred :: 7
	                            sardel :: 9
	                             dears :: 7
	                            saired :: 7
	                            sacred :: 7
	                            sabred :: 7
	                           snarled :: 8
	                           sardels :: 7
	                          sparkled :: 8
	                           dealers :: 7
	                            flares :: 7
	                            flared :: 7
	                           sparkle :: 7
	                           sparely :: 8
	                          startled :: 8
	                           darnels :: 7
	                           bedrals :: 7
	                           loaders :: 7
	                           dialers :: 7
	                            adores :: 7
	                            swaled :: 7
	                           startle :: 7
	                            stared :: 8
	                            staler :: 7
	                            staled :: 7
	                          sacredly :: 7
	                              sear :: 7
	                             spare :: 7
	                             snare :: 7
	                             slade :: 8
	                             share :: 7
	                             scare :: 7
	                           leaders :: 7
	                            spared :: 8
	                            spader :: 7
	                           scalder :: 7
	                           drazels :: 8
	                          swaddler :: 7
	                            snared :: 8
	                            slayer :: 7
	                            slayed :: 7
	                            slaver :: 7
	                            slaved :: 7
	                            slater :: 7
	                            slated :: 7
	                            slaker :: 7
	                            slaked :: 7
	                            glares :: 7
	                            glared :: 7
	                          spiraled :: 7
                                 }
define r ppc sectoff  {
	sector :: 9
	castoff :: 9
  }
define r ppc sectoff lo define r ppc sectoff hi define r ppc sectoff ha powerpc relocations defined for the tls access abi define r ppc tls none sym add tls define r ppc dtpmod word sym add dtpmod define r ppc tprel half sym add tprel define r ppc tprel lo half sym add tprel l define r ppc tprel hi half sym add tprel h define r ppc tprel ha half sym add tprel ha define r ppc tprel word sym add tprel define r ppc dtprel half sym add dtprel define r ppc dtprel lo half sym add dtprel l define r ppc dtprel hi half sym add dtprel h define r ppc dtprel ha half sym add dtprel ha define r ppc dtprel word sym add dtprel define r ppc got tlsgd half sym add got tlsgd define r ppc got tlsgd lo half sym add got tlsgd l define r ppc got tlsgd hi half sym add got tlsgd h define r ppc got tlsgd ha half sym add got tlsgd ha define r ppc got tlsld  {
                                                                                                                                                                                    }
half sym add got tlsld define r ppc got tlsld lo half sym add got tlsld l define r ppc got tlsld hi half sym add got tlsld h define r ppc got tlsld ha half sym add got tlsld ha define r ppc got tprel half sym add got tprel define r ppc got tprel lo half sym add got tprel l define r ppc got tprel hi half sym add got tprel h define r ppc got tprel ha half sym add got tprel ha define r ppc got dtprel half sym add got dtprel define r ppc got dtprel lo half sym add got dtprel l define r ppc got dtprel hi half sym add got dtprel h define r ppc got dtprel ha half sym add got dtprel ha the remaining relocs are from the embedded elf abi and are not in the svr  {
	                                                                                                                                               vers :: 3
	                                                                                                                                               vars :: 3
	                                                                                                                                              servo :: 3
	                                                                                                                                              serve :: 3
	                                                                                                                                                sir :: 3
	                                                                                                                                                ser :: 3
	                                                                                                                                                sar :: 3
                                                                                                                                                  }
elf abi define r ppc emb naddr  {
	narded :: 6
	radding :: 6
	dander :: 6
	  rand :: 6
	  nard :: 7
	 nards :: 6
	 nadir :: 6
     }
define r ppc emb naddr define r ppc emb naddr lo define r ppc emb naddr hi define r ppc emb naddr ha define r ppc emb sdai  {
	                     shaird :: 5
	                      staid :: 6
	                       sida :: 5
	                       said :: 5
	                       sadi :: 6
	                      sayid :: 5
	                      sapid :: 5
                          }
define r ppc emb sda i define r ppc emb sda rel define r ppc emb sda bit offset in sda define r ppc emb mrkref  {
                        }
define r ppc emb relsec  {
	wavery :: -1000
   }
define r ppc emb relst  {
	least :: 6
	holster :: 6
	bolster :: 6
	relucts :: 6
	relists :: 6
	relicts :: 6
	relates :: 6
	result :: 6
	relist :: 7
	relets :: 7
	reasty :: 6
	verst :: 6
	tels :: 7
	rets :: 7
	rest :: 6
	lets :: 6
	resit :: 6
	resat :: 6
	relit :: 7
	relet :: 6
	reist :: 7
	reest :: 6
	reast :: 7
   }
lo define r ppc emb relst hi define r ppc emb relst ha define r ppc emb bit fld  {
	             fluid :: 3
	             flued :: 3
	             flood :: 3
	             flied :: 3
	              fold :: 3
	              fled :: 4
	               old :: 3
	               fly :: 3
	               flu :: 3
	               fid :: 3
	               fed :: 3
	               fad :: 3
	               eld :: 3
	                fl :: 4
                 }
define r ppc emb relsda  {
	arled :: 7
	remudas :: 7
	reloads :: 8
	reseda :: 7
	reload :: 7
	relays :: 7
	relaid :: 7
	readds :: 7
	selfward :: 7
	residual :: 7
	redials :: 7
	felspar :: 7
	reds :: 7
	dels :: 7
	reals :: 7
	reads :: 7
	rased :: 7
	rales :: 7
	rassled :: 7
	geladas :: 7
   }
bit relative offset in sda diab  {
	disbar :: 5
	diabolo :: 5
	 drab :: 5
	 doab :: 5
	 dieb :: 5
	 dial :: 5
	  dib :: 5
    }
tool relocations define r ppc diab sda lo like emb sda but lower bit define r ppc diab sda hi like emb sda but high bit define r ppc diab sda ha like emb sda adjusted high define r ppc diab relsda lo like emb relsda but lower bit define r ppc diab relsda hi like emb relsda but high bit define r ppc diab relsda ha like emb relsda adjusted high gnu extension to support local ifunc define r ppc irelative gnu relocs used in pic code sequences  {
	                                                                               sequences :: -1000
                                                                                       }
define r ppc rel half sym add define r ppc rel lo half sym add l define r ppc rel hi half sym add h define r ppc rel ha half sym add ha this is a phony  {
	                                phony :: -1000
                                    }
reloc to handle any old fashioned  {
	rectifies :: -1000
    }
toc  {
	tocsin :: 3
	tocked :: 3
	tocher :: 3
	toxic :: 3
	touch :: 3
	toric :: 3
	torcs :: 3
	torch :: 3
	topic :: 3
	tonic :: 3
	tocos :: 3
	tocks :: 4
	torc :: 4
	toco :: 4
	tock :: 5
	taco :: 4
	tacos :: 3
	tacho :: 3
	cott :: 3
	cots :: 3
	coth :: 3
	cote :: 3
	cost :: 3
	cort :: 3
	colt :: 3
	coit :: 3
	coft :: 3
	coat :: 3
	toy :: 3
	tow :: 3
	tor :: 3
	top :: 3
	ton :: 3
	tom :: 3
	tog :: 3
	toe :: 3
	tod :: 3
	tic :: 3
	soc :: 3
	roc :: 3
	hoc :: 3
	doc :: 3
	cot :: 4
	to :: 4
 }
references that may still be in object files define r ppc toc powerpc specific values for the dyn d tag field define dt ppc got dt loproc define dt ppc num powerpc relocations defined by the abis define r ppc none r ppc none define r ppc addr r ppc addr bit absolute address define r ppc addr r ppc addr bit address word aligned  {
	                                                         aligned :: -1000
                                                               }
define r ppc addr r ppc addr bit absolute address define r ppc addr lo r ppc addr lo lower bits of address define r ppc addr hi r ppc addr hi high bits of address define r ppc addr ha r ppc addr ha adjusted high bits define r ppc addr r ppc addr bit address word aligned define r ppc addr brtaken r ppc addr brtaken define r ppc addr brntaken r ppc addr brntaken define r ppc rel r ppc rel pc rel bit word aligned define r ppc rel r ppc rel pc relative bit define r ppc rel brtaken r ppc rel brtaken define r ppc rel brntaken r ppc rel brntaken define r ppc got r ppc got define r ppc got lo r ppc got lo define r ppc got hi r ppc got hi define r ppc got ha r ppc got ha define r ppc copy r ppc copy define r ppc glob dat r ppc glob dat define r ppc jmp slot r ppc jmp slot define r ppc relative r ppc relative define r ppc uaddr r ppc uaddr define r ppc uaddr r ppc uaddr define r ppc rel r ppc rel define r ppc plt r ppc plt define r ppc pltrel r ppc pltrel define r ppc plt lo r ppc plt lo define r ppc plt hi r ppc plt hi define r ppc plt ha r ppc plt ha define r ppc sectoff r ppc sectoff define r ppc sectoff lo r ppc sectoff lo define r ppc sectoff hi r ppc sectoff hi define r ppc sectoff ha r ppc sectoff ha define r ppc addr word s a p define r ppc addr doubleword  {
	                                                                                                                                                                                                                                                                                       accoutrement :: -1000
                                                                                                                                                                                                                                                                                                  }
s a define r ppc addr higher half higher s a define r ppc addr highera  {
	         sigher :: 9
	         nigher :: 9
	         hither :: 9
	         higher :: 12
	       highroad :: 9
	       highbred :: 9
              }
half highera s a define r ppc addr highest half highest s a define r ppc addr highesta  {
	        eightsman :: 10
	           hithes :: 11
	           hights :: 11
	          nighest :: 11
	       nightshade :: 10
	          highest :: 14
	           eights :: 10
                }
half highesta s a define r ppc uaddr doubleword s a define r ppc rel doubleword s a p define r ppc plt doubleword l a define r ppc pltrel doubleword l a p define r ppc toc half s a toc define r ppc toc lo half lo s a toc define r ppc toc hi half hi s a toc define r ppc toc ha half ha s a toc define r ppc toc doubleword toc define r ppc pltgot half m a define r ppc pltgot lo half lo m a define r ppc pltgot hi half hi m a define r ppc pltgot ha half ha m a define r ppc addr ds half ds s a define r ppc addr lo ds half ds lo s a define r ppc got ds half ds g a define r ppc got lo ds half ds lo g a define r ppc plt lo ds half ds lo l a define r ppc sectoff ds half ds r a define r ppc sectoff lo ds half ds lo r a define r ppc toc ds half ds s a toc define r ppc toc lo ds half ds lo s a toc define r ppc pltgot ds half ds m a define r ppc pltgot lo ds half ds lo m a powerpc relocations defined for the tls access abi define r ppc tls none sym add tls define r ppc dtpmod doubleword sym add dtpmod define r ppc tprel half sym add tprel define r ppc tprel lo half sym add tprel l define r ppc tprel hi half sym add tprel h define r ppc tprel ha half sym add tprel ha define r ppc tprel doubleword sym add tprel define r ppc dtprel half sym add dtprel define r ppc dtprel lo half sym add dtprel l define r ppc dtprel hi half sym add dtprel h define r ppc dtprel ha half sym add dtprel ha define r ppc dtprel doubleword sym add dtprel define r ppc got tlsgd half sym add got tlsgd define r ppc got tlsgd lo half sym add got tlsgd l define r ppc got tlsgd hi half sym add got tlsgd h define r ppc got tlsgd ha half sym add got tlsgd ha define r ppc got tlsld half sym add got tlsld define r ppc got tlsld lo half sym add got tlsld l define r ppc got tlsld hi half sym add got tlsld h define r ppc got tlsld ha half sym add got tlsld ha define r ppc got tprel ds half ds sym add got tprel define r ppc got tprel lo ds half ds sym add got tprel l define r ppc got tprel hi half sym add got tprel h define r ppc got tprel ha half sym add got tprel ha define r ppc got dtprel ds half ds sym add got dtprel define r ppc got dtprel lo ds half ds sym add got dtprel l define r ppc got dtprel hi half sym add got dtprel h define r ppc got dtprel ha half sym add got dtprel ha define r ppc tprel ds half ds sym add tprel define r ppc tprel lo ds half ds sym add tprel l define r ppc tprel higher half sym add tprel higher define r ppc tprel highera half sym add tprel highera define r ppc tprel highest half sym add tprel highest define r ppc tprel highesta half sym add tprel highesta define r ppc dtprel ds half ds sym add dtprel define r ppc dtprel lo ds half ds sym add dtprel l define r ppc dtprel higher half sym add dtprel higher define r ppc dtprel highera half sym add dtprel highera define r ppc dtprel highest half sym add dtprel highest define r ppc dtprel highesta half sym add dtprel highesta gnu extension to support local ifunc define r ppc jmp irel define r ppc irelative define r ppc rel half sym add define r ppc rel lo half sym add l define r ppc rel hi half sym add h define r ppc rel ha half sym add ha powerpc specific values for the dyn d tag field define dt ppc glink  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        blinks :: 6
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         glisk :: 7
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         glint :: 7
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         glike :: 6
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         glaik :: 6
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         fling :: 6
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        plinks :: 6
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         clink :: 7
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         cling :: 6
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         blink :: 7
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        clinks :: 6
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         slink :: 7
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         sling :: 6
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         plink :: 7
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         pling :: 6
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        slinky :: 6
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        slinks :: 6
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        glisks :: 6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }
dt loproc define dt ppc opd  {
	  oot :: -1000
    }
dt loproc define dt ppc opdsz  {
	 pods :: 6
    }
dt loproc define dt ppc num arm specific declarations processor specific flags for the elf header e flags field define ef arm relexec  {
	           semiskilled :: -1000
                     }
x define ef arm hasentry  {
	ancestry :: 10
	misentry :: 10
   }
x define ef arm interwork  {
	interwork :: -1000
   }
x define ef arm apcs  {
	pacs :: 6
	caps :: 5
	apes :: 5
   }
x define ef arm apcs float x define ef arm pic x define ef arm align x bit structure alignment is in use define ef arm new abi x define ef arm old abi x define ef arm soft float x define ef arm vfp  {
                                           }
float x define ef arm maverick  {
	maverick :: -1000
    }
float x other constants  {
	constants :: -1000
  }
defined in the arm elf spec version b nb these conflict with values defined above define ef arm symsaresorted  {
                 }
x define ef arm dynsymsusesegidx  {
   }
x define ef arm mapsymsfirst  {
   }
x define ef arm eabimask  {
   }
xff constants defined in aaelf  {
   }
define ef arm be x define ef arm le x define ef arm eabi version flags flags ef arm eabimask define ef arm eabi unknown x define ef arm eabi ver x define ef arm eabi ver x define ef arm eabi ver x define ef arm eabi ver x define ef arm eabi ver x additional symbol types for thumb  {
	                                                       thumb :: -1000
                                                           }
define stt arm tfunc  {
	cantorial :: -1000
  }
stt loproc a thumb function define stt arm bit stt hiproc a thumb label  {
	specialisation :: -1000
            }
arm specific values for sh flags define shf arm entrysect  {
	entrechats :: 11
	intersects :: 11
	intersect :: 13
        }
x section contains an entry point define shf arm comdef  {
	    comte :: 7
	    combe :: 7
	    comae :: 7
	  condemn :: 7
	  compend :: 7
	   comped :: 8
	   comedy :: 7
	   combed :: 8
	   comade :: 7
	   coifed :: 7
	   coffed :: 7
	     come :: 7
	     coed :: 7
        }
x section may be multiply  {
	multiply :: -1000
   }
defined in the input to a link step  {
	   step :: -1000
      }
arm specific program header flags define pf arm sb x segment contains the location addressed  {
	     addressed :: -1000
             }
by the static base define pf arm pi x position independent segment define pf arm abs x absolute segment processor specific values for the phdr p type field define pt arm exidx  {
                              }
pt loproc arm unwind segment processor specific values for the shdr sh type field define sht arm exidx sht loproc arm unwind section define sht arm preemptmap  {
                         }
sht loproc preemption  {
	preemption :: -1000
 }
details define sht arm attributes sht loproc arm attributes section arm relocs define r arm none no reloc define r arm pc pc relative bit branch define r arm abs direct bit define r arm rel pc relative bit define r arm pc define r arm abs direct bit define r arm abs direct bit define r arm thm  {
	                                                     thymy :: 3
	                                                     thymi :: 3
	                                                     thyme :: 3
	                                                     thump :: 3
	                                                     thumb :: 3
	                                                     thrum :: 3
	                                                     therm :: 3
	                                                     theme :: 3
	                                                     thema :: 3
	                                                     tharm :: 3
	                                                      them :: 4
	                                                       tum :: 3
	                                                       tom :: 3
	                                                       thy :: 3
	                                                       tho :: 3
	                                                       the :: 3
	                                                       tam :: 3
	                                                       ohm :: 3
                                                         }
abs define r arm abs direct bit define r arm sbrel  {
	      duos :: -1000
         }
define r arm thm pc define r arm thm pc define r arm amp  {
	          amp :: -1000
            }
vcall  {
	scalls :: 6
	scall :: 7
 }
define r arm swi obsolete  {
	obsolete :: -1000
   }
static relocation define r arm tls desc dynamic relocation define r arm thm swi define r arm xpc  {
                }
define r arm thm xpc define r arm tls dtpmod id of module containing symbol define r arm tls dtpoff offset in tls block define r arm tls tpoff offset in static tls block define r arm copy copy symbol at runtime define r arm glob dat create got entry define r arm jump slot create plt entry define r arm relative adjust by program base define r arm gotoff bit offset to got define r arm gotpc bit pc relative offset to got define r arm got bit got entry define r arm plt bit plt address define r arm alu  {
	                                                                                                alure :: 4
	                                                                                                alums :: 4
	                                                                                                aloud :: 3
	                                                                                                almug :: 3
	                                                                                                almud :: 3
	                                                                                                algum :: 3
	                                                                                                album :: 3
	                                                                                                ahull :: 3
	                                                                                                adult :: 3
	                                                                                               alumni :: 3
	                                                                                               alumin :: 3
	                                                                                                 waul :: 3
	                                                                                                 ulva :: 3
	                                                                                                 ulna :: 3
	                                                                                                 ulan :: 3
	                                                                                                 saul :: 3
	                                                                                                 paul :: 3
	                                                                                                 maul :: 3
	                                                                                                 lauf :: 3
	                                                                                                 laud :: 3
	                                                                                                 haul :: 3
	                                                                                                 caul :: 3
	                                                                                                 auld :: 3
	                                                                                                 alum :: 5
	                                                                                                  ulu :: 3
	                                                                                                  flu :: 3
	                                                                                                  ayu :: 3
	                                                                                                  alt :: 3
	                                                                                                  als :: 3
	                                                                                                  alp :: 3
	                                                                                                  ale :: 3
	                                                                                                  alc :: 3
	                                                                                                  alb :: 3
	                                                                                                   al :: 4
                                                                                                    }
pcrel define r arm alu pcrel define r arm alu pcrel define r arm ldr  {
	         lered :: 3
	         lardy :: 3
	         lards :: 3
	          lord :: 4
	          lard :: 4
	          dirl :: 3
	         lurid :: 3
	         lordy :: 3
	         lords :: 3
	           lur :: 3
	           lor :: 3
	           lar :: 3
	            rd :: 3
             }
sbrel define r arm alu sbrel define r arm alu sbrel define r arm tls gotdesc define r arm tls call define r arm tls descseq  {
                        }
define r arm thm tls call define r arm gnu vtentry define r arm gnu vtinherit define r arm thm pc thumb unconditional branch define r arm thm pc thumb conditional  {
	                   conditional :: -1000
                             }
branch define r arm tls gd pc rel bit for global dynamic thread local data define r arm tls ldm pc rel bit for local dynamic thread local data define r arm tls ldo bit offset relative to tls block define r arm tls ie pc rel bit for got entry of static tls block offset define r arm tls le bit offset relative to static tls block define r arm thm tls descseq define r arm irelative define r arm rxpc  {
                                                                                }
define r arm rsbrel  {
	barrel :: 7
	burrels :: 8
	burrel :: 7
	sorrel :: 7
	barrels :: 8
	borrel :: 7
  }
define r arm thm rpc  {
	recap :: 3
	 roc :: 3
	 rec :: 3
   }
define r arm rrel  {
	saul :: -1000
  }
define r arm rabs  {
	rabies :: 5
	wabs :: 5
	tabs :: 5
	rubs :: 5
	sabs :: 5
	robs :: 5
	ribs :: 5
	rebs :: 5
	rays :: 5
	raws :: 5
	rats :: 5
	raps :: 5
	rams :: 5
	rahs :: 5
	rags :: 5
	rads :: 5
	rabi :: 5
	nabs :: 5
	labs :: 5
	kabs :: 5
	jabs :: 5
	gabs :: 5
	dabs :: 5
	sabre :: 5
	sabir :: 5
	saber :: 5
	bras :: 5
	cabs :: 5
	bars :: 6
	rabis :: 6
	sab :: 5
	ras :: 5
  }
define r arm rpc define r arm rbase  {
	 blares :: 6
	  braes :: 6
	  blase :: 6
	brasero :: 6
	  bears :: 6
	  abuse :: 6
	  abase :: 7
	abaters :: 6
	abasers :: 6
	 rabies :: 6
	 abuser :: 7
	 abaser :: 8
	 abased :: 6
	  urase :: 6
	   rebs :: 6
	   eras :: 6
	  sabre :: 6
	   bras :: 6
	  reast :: 6
	  rasse :: 6
	  raise :: 6
	  prase :: 6
	 brazes :: 6
	 braves :: 6
	 brakes :: 6
	 braces :: 6
      }
keep this the last entry define r arm num ia specific declarations processor specific flags for the ehdr e flags field define ef ia maskos x f os specific flags define ef ia abi x bit abi define ef ia arch xff arch version mask processor specific values for the phdr p type field define pt ia archext pt loproc arch extension bits define pt ia unwind pt loproc ia unwind bits define pt ia hp opt anot pt loos x define pt ia hp hsl anot pt loos x define pt ia hp stack pt loos x processor specific flags for the phdr p flags field define pf ia norecov  {
                                                                                                             }
x spec insns  {
	insnares :: 6
	inspans :: 6
 }
w o recovery  {
	recovery :: -1000
 }
processor specific values for the shdr sh type field define sht ia ext sht loproc extension bits define sht ia unwind sht loproc unwind bits processor specific flags for the shdr sh flags field define shf ia short x section near gp define shf ia norecov x spec insns w o recovery processor specific values for the dyn d tag field define dt ia plt reserve dt loproc define dt ia num ia relocations define r ia none x none define r ia imm x symbol addend add imm define r ia imm x symbol addend add imm define r ia imm x symbol addend mov imm define r ia dir msb x symbol addend data msb define r ia dir lsb x symbol addend data lsb define r ia dir msb x symbol addend data msb define r ia dir lsb x symbol addend data lsb define r ia gprel x a gprel sym add add imm define r ia gprel i x b gprel sym add mov imm define r ia gprel msb x c gprel sym add data msb define r ia gprel lsb x d gprel sym add data lsb define r ia gprel msb x e gprel sym add data msb define r ia gprel lsb x f gprel sym add data lsb define r ia ltoff x ltoff sym add add imm define r ia ltoff i x ltoff sym add mov imm define r ia pltoff x a pltoff sym add add imm define r ia pltoff i x b pltoff sym add mov imm define r ia pltoff msb x e pltoff sym add data msb define r ia pltoff lsb x f pltoff sym add data lsb define r ia fptr i x fptr sym add mov imm define r ia fptr msb x fptr sym add data msb define r ia fptr lsb x fptr sym add data lsb define r ia fptr msb x fptr sym add data msb define r ia fptr lsb x fptr sym add data lsb define r ia pcrel b x pcrel sym add brl  {
	                                                                                                                                                                                                                                                                                                                                                         brool :: 3
	                                                                                                                                                                                                                                                                                                                                                         broil :: 3
	                                                                                                                                                                                                                                                                                                                                                         brill :: 3
	                                                                                                                                                                                                                                                                                                                                                         brawl :: 3
	                                                                                                                                                                                                                                                                                                                                                         brail :: 3
	                                                                                                                                                                                                                                                                                                                                                         bolar :: 3
	                                                                                                                                                                                                                                                                                                                                                         baler :: 3
	                                                                                                                                                                                                                                                                                                                                                          burl :: 3
	                                                                                                                                                                                                                                                                                                                                                          blur :: 3
	                                                                                                                                                                                                                                                                                                                                                          birl :: 3
	                                                                                                                                                                                                                                                                                                                                                           bro :: 3
	                                                                                                                                                                                                                                                                                                                                                           bre :: 3
	                                                                                                                                                                                                                                                                                                                                                           bra :: 3
	                                                                                                                                                                                                                                                                                                                                                           bel :: 3
	                                                                                                                                                                                                                                                                                                                                                           bal :: 3
	                                                                                                                                                                                                                                                                                                                                                            br :: 4
                                                                                                                                                                                                                                                                                                                                                             }
define r ia pcrel b x pcrel sym add ptb  {
	      pub :: 3
        }
call define r ia pcrel m x a pcrel sym add chk  {
	      chunk :: 3
	      chook :: 3
	      choko :: 3
	      choke :: 3
	      chirk :: 3
	      chink :: 3
	      cheka :: 3
	      cheek :: 3
	      chark :: 3
	      chank :: 3
	      chalk :: 3
	        chi :: 3
	        che :: 3
	        cha :: 3
	         ch :: 4
          }
s define r ia pcrel f x b pcrel sym add fchkf  {
          }
define r ia pcrel msb x c pcrel sym add data msb define r ia pcrel lsb x d pcrel sym add data lsb define r ia pcrel msb x e pcrel sym add data msb define r ia pcrel lsb x f pcrel sym add data lsb define r ia ltoff fptr x ltoff fptr s a imm define r ia ltoff fptr i x ltoff fptr s a imm define r ia ltoff fptr msb x ltoff fptr s a data msb define r ia ltoff fptr lsb x ltoff fptr s a data lsb define r ia ltoff fptr msb x ltoff fptr s a data msb define r ia ltoff fptr lsb x ltoff fptr s a data lsb define r ia segrel msb x c segrel sym add data msb define r ia segrel lsb x d segrel sym add data lsb define r ia segrel msb x e segrel sym add data msb define r ia segrel lsb x f segrel sym add data lsb define r ia secrel msb x secrel sym add data msb define r ia secrel lsb x secrel sym add data lsb define r ia secrel msb x secrel sym add data msb define r ia secrel lsb x secrel sym add data lsb define r ia rel msb x c data rel define r ia rel lsb x d data rel define r ia rel msb x e data rel define r ia rel lsb x f data rel define r ia ltv  {
	                                                                                                                                                                                                                                                         lovat :: 3
	                                                                                                                                                                                                                                                           luv :: 3
	                                                                                                                                                                                                                                                           lev :: 3
	                                                                                                                                                                                                                                                           lav :: 3
                                                                                                                                                                                                                                                             }
msb x symbol addend data msb define r ia ltv lsb x symbol addend data lsb define r ia ltv msb x symbol addend data msb define r ia ltv lsb x symbol addend data lsb define r ia pcrel bi x pcrel sym add bit inst define r ia pcrel x a pcrel sym add bit inst define r ia pcrel i x b pcrel sym add bit inst define r ia ipltmsb  {
                                                                        }
x dynamic reloc imported plt msb define r ia ipltlsb  {
        }
x dynamic reloc imported plt lsb define r ia copy x copy relocation define r ia sub x addend and symbol difference define r ia ltoff x x ltoff relaxable  {
	                    relatable :: 15
	                    reachable :: 11
	                    repayable :: 12
	                    separable :: 11
	                    reparable :: 11
	                    resalable :: 14
	                    lacerable :: 11
	                    learnable :: 12
	                    relegable :: 11
	                    clearable :: 12
	                    alterable :: 11
	                    exhalable :: 12
                            }
define r ia ldxmov  {
  }
x use of ltoff x define r ia tprel x tprel sym add imm define r ia tprel x tprel sym add imm define r ia tprel i x tprel sym add imm define r ia tprel msb x tprel sym add data msb define r ia tprel lsb x tprel sym add data lsb define r ia ltoff tprel x a ltoff tprel s a imm define r ia dtpmod msb xa dtpmod sym add data msb define r ia dtpmod lsb xa dtpmod sym add data lsb define r ia ltoff dtpmod xaa  {
	                                                                                          taxa :: 3
	                                                                                          axal :: 3
	                                                                                           maa :: 3
                                                                                             }
ltoff dtpmod sym add imm define r ia dtprel xb  {
        }
dtprel sym add imm define r ia dtprel xb dtprel sym add imm define r ia dtprel i xb dtprel sym add imm define r ia dtprel msb xb dtprel sym add data msb define r ia dtprel lsb xb dtprel sym add data lsb define r ia dtprel msb xb dtprel sym add data msb define r ia dtprel lsb xb dtprel sym add data lsb define r ia ltoff dtprel xba  {
	                                                                     oba :: 3
	                                                                     aba :: 3
	                                                                      ab :: 3
                                                                       }
ltoff dtprel s a imm sh specific declarations processor specific flags for the elf header e flags field define ef sh mach mask x f define ef sh unknown x define ef sh x define ef sh x define ef sh x define ef sh dsp x define ef sh dsp x define ef sh al dsp x define ef sh e x define ef sh x define ef sh e xb define ef sh a xc  {
                                                                           }
define ef sh a xd define ef sh nofpu  {
	    noup :: 7
	   noups :: 6
       }
x define ef sh a nofpu x define ef sh nommu  {
	  communal :: 6
	  communes :: 6
	  communed :: 6
	   commune :: 7
	    summon :: 6
         }
nofpu x define ef sh a nofpu x define ef sh nommu x define ef sh a sh nofpu x define ef sh a sh nofpu x define ef sh a sh x define ef sh a sh e x sh relocs define r sh none define r sh dir define r sh rel define r sh dir wpn  {
	                                                       wyn :: 3
	                                                       won :: 3
	                                                       win :: 3
	                                                       wen :: 3
	                                                       wan :: 3
                                                         }
define r sh ind w define r sh dir wpl define r sh dir wpz  {
	           wiz :: 3
             }
define r sh dir bp  {
	fluorometric :: -1000
   }
define r sh dir w define r sh dir l define r sh switch define r sh switch define r sh uses define r sh count define r sh align define r sh code define r sh data define r sh label define r sh switch define r sh gnu vtinherit define r sh gnu vtentry define r sh tls gd define r sh tls ld define r sh tls ldo define r sh tls ie define r sh tls le define r sh tls dtpmod define r sh tls dtpoff define r sh tls tpoff define r sh got define r sh plt define r sh copy define r sh glob dat define r sh jmp slot define r sh relative define r sh gotoff define r sh gotpc keep this the last entry define r sh num s specific definitions valid values for the e flags field define ef s high gprs  {
	                                                                                                                                                    grasp :: 5
	                                                                                                                                                    gorps :: 5
	                                                                                                                                                    sprug :: 5
	                                                                                                                                                    sprog :: 5
	                                                                                                                                                    sprig :: 5
	                                                                                                                                                    sprag :: 5
	                                                                                                                                                     gers :: 5
	                                                                                                                                                     gars :: 5
                                                                                                                                                        }
x high gprs kernel facility  {
	facility :: -1000
   }
needed additional s relocs define r none no reloc define r direct bit define r direct bit define r direct bit define r direct bit define r pc pc relative bit define r got bit got offset define r got bit got offset define r plt bit pc relative plt address define r copy copy symbol at runtime define r glob dat create got entry define r jmp slot create plt entry define r relative adjust by program base define r gotoff bit offset to got define r gotpc bit pc relative offset to got define r got bit got offset define r pc pc relative bit define r pc dbl  {
	                                                                                                          bold :: 3
	                                                                                                           dol :: 3
	                                                                                                           del :: 3
	                                                                                                           dal :: 3
                                                                                                             }
pc relative bit shifted by define r plt dbl bit pc rel plt shifted by define r pc dbl pc relative bit shifted by define r plt dbl bit pc rel plt shifted by define r gotpcdbl  {
                                   }
bit pc rel got shifted by define r direct bit define r pc pc relative bit define r got bit got offset define r plt bit pc relative plt address define r gotent  {
	                          potent :: 9
	                        potently :: 7
	                         potents :: 8
	                          ostent :: 8
	                         ostents :: 7
	                          cogent :: 8
	                         gothite :: 7
	                            gone :: 7
	                         tomenta :: 7
	                          gotten :: 9
                               }
bit pc rel to got entry define r gotoff bit offset to got define r gotoff bit offset to got define r gotplt  {
	                pottle :: 7
                     }
bit offset to jump slot define r gotplt bit offset to jump slot define r gotplt bit offset to jump slot define r gotplt bit offset to jump slot define r gotpltent  {
                              }
bit rel offset to jump slot define r pltoff bit offset from got to plt define r pltoff bit offset from got to plt define r pltoff bit offset from got to plt define r tls load tag for load insn in tls code define r tls gdcall tag for function call in general dynamic tls code define r tls ldcall  {
	                                                     locally :: 8
	                                                     ducally :: 7
                                                           }
tag for function call in local dynamic tls code define r tls gd direct bit for general dynamic thread local data define r tls gd direct bit for general dynamic thread local data define r tls gotie bit got offset for static tls block offset define r tls gotie bit got offset for static tls block offset define r tls gotie bit got offset for static tls block offset define r tls ldm direct bit for local dynamic thread local data in le code define r tls ldm direct bit for local dynamic thread local data in le code define r tls ie bit address of got entry for negated static tls block offset define r tls ie bit address of got entry for negated static tls block offset define r tls ieent  {
	                                                                                                                               inert :: 6
	                                                                                                                               inept :: 6
	                                                                                                                               fient :: 6
	                                                                                                                               event :: 6
	                                                                                                                             reinter :: 6
	                                                                                                                              teenty :: 6
	                                                                                                                              teeing :: 6
	                                                                                                                             feinted :: 6
	                                                                                                                               teeny :: 6
	                                                                                                                               teens :: 6
	                                                                                                                                teen :: 7
	                                                                                                                                eten :: 6
	                                                                                                                              venite :: 6
                                                                                                                                   }
bit rel offset to got entry for negated static tls block offset define r tls le bit negated offset relative to static tls block define r tls le bit negated offset relative to static tls block define r tls ldo bit offset relative to tls block define r tls ldo bit offset relative to tls block define r tls dtpmod id of module containing symbol define r tls dtpoff offset in tls block define r tls tpoff negated offset in static tls block define r direct bit define r got bit got offset define r gotplt bit offset to jump slot define r tls gotie bit got offset for static tls block offset keep this the last entry define r num cris relocations define r cris none define r cris define r cris define r cris define r cris pcrel define r cris pcrel define r cris pcrel define r cris gnu vtinherit define r cris gnu vtentry define r cris copy define r cris glob dat define r cris jump slot define r cris relative define r cris got define r cris got define r cris gotplt define r cris gotplt define r cris gotrel  {
	                                                                                                                                                                                             petrol :: 7
	                                                                                                                                                                                             torsel :: 7
	                                                                                                                                                                                             grovel :: 7
	                                                                                                                                                                                               goer :: 7
	                                                                                                                                                                                             goslet :: 7
	                                                                                                                                                                                             golfer :: 7
	                                                                                                                                                                                             goiter :: 7
	                                                                                                                                                                                             goblet :: 7
                                                                                                                                                                                                  }
define r cris plt gotrel define r cris plt pcrel define r cris num amd x relocations define r x none no reloc define r x direct bit define r x pc pc relative bit signed define r x got bit got entry define r x plt bit plt address define r x copy copy symbol at runtime define r x glob dat create got entry define r x jump slot create plt entry define r x relative adjust by program base define r x gotpcrel  {
	                                                                            goldcrest :: 10
                                                                                    }
bit signed pc relative offset to got define r x direct bit zero extended define r x s direct bit sign extended define r x direct bit zero extended define r x pc bit sign extended pc relative define r x direct bit sign extended define r x pc bit sign extended pc relative define r x dtpmod id of module containing symbol define r x dtpoff offset in module s tls block define r x tpoff offset in initial tls block define r x tlsgd bit signed pc relative offset to two got entries for gd symbol define r x tlsld bit signed pc relative offset to two got entries for ld symbol define r x dtpoff offset in tls block define r x gottpoff  {
                                                                                                                            }
bit signed pc relative offset to got entry for ie symbol define r x tpoff offset in initial tls block define r x pc pc relative bit define r x gotoff bit offset to got define r x gotpc bit signed pc relative offset to got define r x got bit got entry offset define r x gotpcrel bit pc relative offset to got entry define r x gotpc bit pc relative offset to got define r x gotplt like got says plt entry needed define r x pltoff bit got relative offset to plt entry define r x size size of symbol plus bit addend define r x size size of symbol plus bit addend define r x gotpc tlsdesc got offset for tls descriptor define r x tlsdesc call marker for call through tls descriptor define r x tlsdesc tls descriptor define r x irelative adjust indirectly by program base define r x num am relocations define r mn none no reloc define r mn direct bit define r mn direct bit define r mn direct bit define r mn pcrel pc relative bit define r mn pcrel pc relative bit signed define r mn pcrel pc relative bit signed define r mn gnu vtinherit ancient  {
	                                                                                                                                                                                                        ancient :: -1000
                                                                                                                                                                                                              }
c vtable  {
	stable :: 9
	stabled :: 8
	stables :: 8
	stabler :: 8
	viable :: 9
	stablers :: 7
 }
garbage  {
	garbage :: -1000
 }
define r mn gnu vtentry collection  {
	collection :: -1000
    }
annotation  {
	annotation :: -1000
 }
define r mn direct bit define r mn gotpc bit pcrel offset to got define r mn gotpc bit pcrel offset to got define r mn gotoff bit offset from got define r mn gotoff bit offset from got define r mn gotoff bit offset from got define r mn plt bit pcrel to plt entry define r mn plt bit pcrel to plt entry define r mn got bit offset to got entry define r mn got bit offset to got entry define r mn got bit offset to got entry define r mn copy copy symbol at runtime define r mn glob dat create got entry define r mn jmp slot create plt entry define r mn relative adjust by program base define r mn num m r relocs define r m r none no reloc define r m r direct bit define r m r direct bit define r m r direct bit define r m r pcrel pc relative bit shifted define r m r pcrel pc relative bit shifted define r m r pcrel pc relative bit shifted define r m r hi ulo  {
	                                                                                                                                                                                       glout :: 3
	                                                                                                                                                                                       flout :: 3
	                                                                                                                                                                                       flour :: 3
	                                                                                                                                                                                       clout :: 3
	                                                                                                                                                                                       clous :: 3
	                                                                                                                                                                                       clour :: 3
	                                                                                                                                                                                       cloud :: 3
	                                                                                                                                                                                       aloud :: 3
	                                                                                                                                                                                        clou :: 4
	                                                                                                                                                                                       plouk :: 3
	                                                                                                                                                                                         upo :: 3
	                                                                                                                                                                                         ult :: 3
	                                                                                                                                                                                         ule :: 3
	                                                                                                                                                                                         ufo :: 3
	                                                                                                                                                                                         udo :: 3
                                                                                                                                                                                           }
high bit with unsigned low define r m r hi slo high bit with signed low define r m r lo low bit define r m r sda bit offset in sda define r m r gnu vtinherit define r m r gnu vtentry m r relocs use sht rela define r m r rela direct bit define r m r rela direct bit define r m r rela direct bit define r m r pcrel rela pc relative bit shifted define r m r pcrel rela pc relative bit shifted define r m r pcrel rela pc relative bit shifted define r m r hi ulo rela high bit with unsigned low define r m r hi slo rela high bit with signed low define r m r lo rela low bit define r m r sda rela bit offset in sda define r m r rela gnu vtinherit define r m r rela gnu vtentry define r m r rel pc relative bit define r m r got bit got entry define r m r pltrel bit pc relative to plt shifted define r m r copy copy symbol at runtime define r m r glob dat create got entry define r m r jmp slot create plt entry define r m r relative adjust by program base define r m r gotoff bit offset to got define r m r gotpc bit pc relative offset to got define r m r got hi ulo high bit got entry with unsigned low define r m r got hi slo high bit got entry with signed low define r m r got lo low bit got entry define r m r gotpc hi ulo high bit pc relative offset to got with unsigned low define r m r gotpc hi slo high bit pc relative offset to got with signed low define r m r gotpc lo low bit pc relative offset to got define r m r gotoff hi ulo high bit offset to got with unsigned low define r m r gotoff hi slo high bit offset to got with signed low define r m r gotoff lo low bit offset to got define r m r num keep this the last entry end decls endif elf h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef endian h define endian h include features h definitions for byte order according to significance  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      significance :: -1000
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 }
of bytes from low addresses to high addresses the value is what you get by putting  {
	        putting :: -1000
              }
in the most significant  {
	significant :: -1000
  }
byte in the second most significant byte in the second least significant byte and in the least significant byte and then writing  {
	              writing :: -1000
                    }
down  {
	down :: -1000
 }
one digit for each byte starting with the byte at the lowest  {
	     lowest :: -1000
          }
address at the left and proceeding  {
	proceeding :: -1000
    }
to the byte with the highest address at the right define little endian define big endian define pdp  {
	            piped :: 3
	              pup :: 3
	              pop :: 3
	              pip :: 3
	              pep :: 3
	              pap :: 3
                }
endian this file defines byte order for the particular machine include bits endian h some machines  {
	       machines :: -1000
              }
may need to use a different endianness  {
	venialness :: 12
	genialness :: 12
	inspanned :: 12
	insaneness :: 13
	unkindness :: 12
	innateness :: 13
     }
for floating point values ifndef float word order define float word order byte order endif ifdef use bsd define little endian little endian define big endian big endian define pdp endian pdp endian define byte order byte order endif if byte order little endian define long long pair  {
	                                           pair :: -1000
                                              }
hi lo lo hi elif byte order big endian define long long pair hi lo hi lo endif ifdef use bsd conversion interfaces  {
	            interfaces :: -1000
                     }
include bits byteswap h if byte order little endian define htobe  {
	    hotbed :: 7
	   howbeit :: 6
	   hotbeds :: 6
         }
x bswap x define htole  {
	hoyle :: 6
	hotel :: 6
	helot :: 6
	haole :: 7
	dhole :: 6
	cholent :: 6
	howlet :: 7
	hostel :: 6
	hooley :: 6
	thowel :: 6
	tholes :: 7
	tholed :: 7
	whole :: 6
	stoles :: 6
	stolen :: 6
	stoled :: 6
	thole :: 8
	stole :: 7
	haoles :: 6
	howlets :: 6
   }
x x define be toh  {
	tough :: 3
	touch :: 3
	toshy :: 3
	torch :: 3
	torah :: 3
	tophi :: 3
	tophe :: 3
	tohos :: 3
	tosh :: 4
	toph :: 4
	toho :: 4
	thro :: 3
	thou :: 3
	thon :: 3
	thio :: 3
	soth :: 3
	moth :: 3
	loth :: 3
	hout :: 3
	hots :: 3
	hote :: 3
	host :: 3
	holt :: 3
	doth :: 3
	coth :: 3
	both :: 3
	 toy :: 3
	 tow :: 3
	 tor :: 3
	 top :: 3
	 ton :: 3
	 tom :: 3
	 tog :: 3
	 toe :: 3
	 tod :: 3
	 tho :: 4
	 soh :: 3
	 poh :: 3
	 ooh :: 3
	 noh :: 3
	 hot :: 4
	 hoh :: 3
	 foh :: 3
	 doh :: 3
	 boh :: 3
	  to :: 4
	  ho :: 3
   }
x bswap x define le toh x x define htobe x bswap x define htole x x define be toh x bswap x define le toh x x define htobe x bswap x define htole x x define be toh x bswap x define le toh x x else define htobe x x define htole x bswap x define be toh x x define le toh x bswap x define htobe x x define htole x bswap x define be toh x x define le toh x bswap x define htobe x x define htole x bswap x define be toh x x define le toh x bswap x endif endif endif endian h routines for dealing with separated environment  {
	                                                                                                            environment :: -1000
                                                                                                                      }
vectors copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef envz  {
	                                                                                                                                    envy :: 5
                                                                                                                                       }
h define envz h include features h include errno h envz s are argz s too and should be created etc using the same routines include argz h begin decls returns a pointer to the entry in envz for name or if there is none extern char envz entry const char restrict envz size t envz len const char restrict name throw attribute pure returns a pointer to the value portion  {
	                                                               portion :: -1000
                                                                     }
of the entry in envz for name or if there is none extern char envz get const char restrict envz size t envz len const char restrict name throw attribute pure adds  {
	                           adds :: -1000
                              }
an entry for name with value value to envz envz len if an entry with the same name already exists  {
	             exists :: -1000
                  }
in envz it is removed if value is null then the new entry will a special null one for which envz get will return null although  {
	                 although :: -1000
                        }
envz entry will still return an entry this is handy  {
	protectionists :: -1000
        }
because when merging with another envz the null entry can override  {
	  override :: -1000
         }
an entry in the other one null entries can be removed with envz strip  {
	        strip :: -1000
            }
extern error t envz add char restrict envz size t restrict envz len const char restrict name const char restrict value throw adds each entry in envz to envz envz len as if with envz add if override is true then values in envz will supersede  {
	                                    supersede :: -1000
                                            }
those with the same name in env otherwise not extern error t envz merge char restrict envz size t restrict envz len const char restrict envz size t envz len int override throw remove the entry for name from envz envz len if any extern void envz remove char restrict envz size t restrict envz len const char restrict name throw remove null entries extern void envz strip char restrict envz size t restrict envz len throw end decls endif envz h bsd utility  {
	                                                                            utility :: -1000
                                                                                  }
functions for error messages copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef err h define err h include features h define need va list include stdarg h ifndef gnuc va list define gnuc va list ptr t endif begin decls print program format the standard error string for errno and a newline on stderr extern void warn  {
	                                                                                                                                                                                   warn :: -1000
                                                                                                                                                                                      }
const char format attribute format printf extern void vwarn  {
	  awarns :: 6
	   awarn :: 7
       }
const char format gnuc va list attribute format printf likewise but without and the standard error string extern void warnx  {
	             warned :: 6
	              warns :: 7
	               warn :: 8
	               rawn :: 6
	                war :: 6
                  }
const char format attribute format printf extern void vwarnx  {
	   awarn :: 7
       }
const char format gnuc va list attribute format printf likewise and then exit with status extern void err int status const char format attribute noreturn format printf extern void verr  {
	                      verruca :: 5
	                      verruga :: 5
	                        verry :: 7
	                         veur :: 5
	                         serr :: 5
	                       verrey :: 5
	                       verrel :: 5
                            }
int status const char format gnuc va list attribute noreturn format printf extern void errx  {
	          errs :: 5
	           err :: 6
             }
int status const char format attribute noreturn format printf extern void verrx  {
	      verry :: 7
          }
int status const char gnuc va list attribute noreturn format printf end decls endif err h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa iso c standard errors errno h ifndef errno h the includer  {
	                                                                                                                                                          uncled :: 10
	                                                                                                                                                         include :: 14
	                                                                                                                                                        excluder :: 10
	                                                                                                                                                        decliner :: 10
	                                                                                                                                                        nuclides :: 10
	                                                                                                                                                        indulger :: 10
	                                                                                                                                                         intrude :: 10
	                                                                                                                                                       inclosure :: 10
	                                                                                                                                                         nuclide :: 11
	                                                                                                                                                        intruder :: 10
	                                                                                                                                                        incurred :: 10
	                                                                                                                                                        incurved :: 10
	                                                                                                                                                        includes :: 13
	                                                                                                                                                        included :: 12
	                                                                                                                                                        incloser :: 10
                                                                                                                                                               }
defined need emath  {
	heath :: 6
	meathes :: 6
	earth :: 6
	death :: 6
	beath :: 6
	amate :: 6
	meathe :: 7
	meat :: 6
	heat :: 6
	neath :: 6
	meath :: 8
 }
if he wants only the definitions of edom  {
	  drome :: 5
      }
and erange  {
	krang :: 7
	grantees :: 7
	flanger :: 7
	grandees :: 7
	dragee :: 7
	clanger :: 7
	avenger :: 8
	brangle :: 7
	evangely :: 7
	evangels :: 7
	orangey :: 8
	oranges :: 8
	enraged :: 8
	enrages :: 8
	orange :: 9
	engagers :: 7
	avengers :: 7
	raunge :: 7
	pranged :: 8
	ergate :: 7
	wrang :: 7
	enrage :: 9
	grenade :: 7
	ennage :: 7
	engager :: 8
	engage :: 7
	greaten :: 7
	encage :: 7
	changer :: 7
	uneager :: 7
	twanger :: 7
	grange :: 9
	grande :: 8
	gran :: 7
	grantee :: 8
	granted :: 7
	wrangle :: 7
	granges :: 8
	granger :: 7
	prang :: 7
	orang :: 7
 }
and not everything  {
	everything :: -1000
 }
else ifndef need emath define errno h include features h endif begin decls get the error number constants from the system specific file this file will test need emath and errno h include bits errno h undef need emath ifdef errno h declare the errno variable unless it s defined as a macro by bits errno h this is the case in gnu where it is a per thread variable this redeclaration  {
	                                                          recalibration :: 16
	                                                          derealization :: 17
                                                                      }
using the macro still works  {
	works :: -1000
   }
but it will be a function declaration without a prototype and may trigger a wstrict  {
	       astrict :: 11
	      astricts :: 9
             }
prototypes warning  {
	warning :: -1000
 }
ifndef errno extern int errno endif ifdef use gnu the full and simple  {
	      simple :: -1000
           }
forms  {
	roosing :: -1000
 }
of the name with which the program was invoked  {
	 invoked :: -1000
       }
these variables are set up automatically  {
	protheses :: -1000
    }
at startup based  {
	based :: -1000
 }
on the value of argv this works only if you use gnu ld extern char program invocation name program invocation short name endif use gnu endif errno h end decls endif errno h the hurd bits errno h defines error t as an enumerated  {
	                                 enumerated :: -1000
                                          }
type so that printing error t values in the debugger  {
	 debugger :: -1000
        }
shows  {
	shows :: -1000
 }
the names we might need this definition sometimes even if this file was included before if defined use gnu defined need error t ifndef error t defined typedef int error t define error t defined endif undef need error t endif declaration for error reporting function copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef error h define error h include features h begin decls print a message with fprintf  {
	                                                                                                                                                                                             sprint :: 9
                                                                                                                                                                                                  }
stderr format if errnum is nonzero follow it with and strerror  {
         }
errnum if status is nonzero terminate the program with exit status extern void error int status int errnum const char format attribute format printf extern void error at line int status int errnum const char fname unsigned int lineno  {
	                              ninefold :: 7
	                                kinone :: 7
	                              minneola :: 7
	                               linuron :: 7
	                                  linn :: 7
	                                  line :: 7
	                               lineman :: 7
	                                linnet :: 7
	                                lineny :: 9
	                                linens :: 9
	                                linden :: 7
	                                 liven :: 7
	                                 linen :: 10
	                                 limen :: 7
	                                 liken :: 7
                                     }
const char format attribute format printf if null error will flush  {
	     flush :: -1000
         }
stdout then print on stderr the program name a colon  {
	    colon :: -1000
        }
and a space otherwise error will call this function without parameters  {
	parameters :: -1000
         }
instead extern void error print progname void this variable is incremented each time error is called extern unsigned int error message count sometimes we want to have at most one error per line this variable controls  {
	                           controls :: -1000
                                  }
whether  {
	whether :: -1000
 }
this mode is selected or not extern int error one per line if defined extern always inline defined va arg pack include bits error h endif end decls endif error h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef execinfo  {
	                                                                                                                                                             execution :: 10
                                                                                                                                                                     }
h define execinfo h include features h begin decls store up to size return address of the current program state in array and return the exact number of values stored extern int backtrace  {
	                      bacitracin :: 11
	                       backspace :: 12
	                     backtracked :: 14
	                         backare :: 11
	                    backscatters :: 11
	                      backspaces :: 11
	                      backspacer :: 13
	                      backspaced :: 11
	                       racetrack :: 13
	                     backscatter :: 12
	                      backtracks :: 13
	                      racetracks :: 12
	                        backchat :: 11
	                       backtrack :: 14
                               }
void array int size nonnull return names of functions from the backtrace list in array in a newly  {
	            newly :: -1000
                }
malloc ed memory block extern char backtrace symbols void const array int size throw nonnull this function is similar to backtrace symbols but it writes  {
	                  writes :: -1000
                       }
the result immediately to a file extern void backtrace symbols fd void const array int size int fd throw nonnull end decls endif execinfo h expat  {
	                    expat :: -1000
                        }
config h generated from expat config h in by configure expat config h in generated from configure in by autoheader  {
	        autographed :: 12
                  }
lil  {
	zill :: 3
	yill :: 3
	will :: 3
	vill :: 3
	till :: 3
	sill :: 3
	rill :: 3
	pill :: 3
	nill :: 3
	mill :: 3
	lily :: 5
	lilt :: 5
	lill :: 3
	kill :: 3
	jill :: 3
	illy :: 3
	ills :: 3
	hill :: 3
	gill :: 3
	fill :: 3
	dill :: 3
	cill :: 3
	bill :: 3
	lilted :: 3
	til :: 3
	oil :: 3
	nil :: 3
	mil :: 3
	ill :: 4
	ail :: 3
	lisle :: 3
	lilts :: 4
	lilac :: 4
	libel :: 3
	li :: 3
 }
endian bigendian  {
	ribanding :: 11
	biguanide :: 11
	bignonia :: 11
 }
define byteorder  {
 }
define to if you have the bcopy  {
     }
function define have bcopy define to if you have the dlfcn h header file define have dlfcn h define to if you have the fcntl h header file define have fcntl h define to if you have the getpagesize  {
                                     }
function define have getpagesize define to if you have the inttypes  {
	    instep :: 10
	   tintype :: 11
	  isotypes :: 10
	  tintypes :: 13
	   isotype :: 10
         }
h header file define have inttypes h define to if you have the memmove  {
            }
function define have memmove define to if you have the memory h header file define have memory h define to if you have a working  {
	                 working :: -1000
                       }
mmap  {
	charkhas :: -1000
 }
system call undef have mmap define to if you have the stdint h header file define have stdint h define to if you have the stdlib  {
	                   stolid :: 8
	                   stiled :: 7
	                    styli :: 7
	                    stilb :: 8
                        }
h header file define have stdlib h define to if you have the strings h header file define have strings h define to if you have the string h header file define have string h define to if you have the sys stat h header file define have sys stat h define to if you have the sys types h header file define have sys types h define to if you have the unistd  {
	                                                                   unwits :: 7
	                                                                   untied :: 7
	                                                                   unsaid :: 7
	                                                                   unites :: 7
	                                                                   united :: 8
	                                                                   unfits :: 7
	                                                                    inust :: 8
	                                                                 unitards :: 7
	                                                                  unstaid :: 7
	                                                                  unipods :: 7
	                                                                  unipeds :: 7
	                                                                    units :: 8
	                                                                    suint :: 7
	                                                                     unit :: 7
	                                                                     unis :: 8
                                                                        }
h header file define have unistd h define to the address where bug reports  {
	      reports :: -1000
            }
for this package should be sent define package bugreport  {
	tabulated :: -1000
       }
expat bugs libexpat  {
 }
org  {
	paw :: -1000
 }
define to the full name of this package define package name expat define to the full name and version of this package define package string expat define to the one symbol short name of this package define package tarname  {
	                              earthman :: 9
	                               tartane :: 9
	                             sacrament :: 9
	                               magnate :: 9
	                                tarnal :: 9
                                     }
expat define to the version of this package define package version define to if you have the ansi c header files define stdc headers whether byteorder is bigendian undef words bigendian define to specify how much context  {
	                             context :: -1000
                                   }
to retain  {
	retain :: -1000
 }
around  {
	zander :: -1000
 }
the current parse point define xml  {
	sizzle :: -1000
    }
context bytes define to make parameter entity  {
	unconformities :: -1000
     }
parsing functionality  {
	functionality :: -1000
 }
available define xml dtd  {
	didst :: 3
	dud :: 3
	dod :: 3
	did :: 3
	dad :: 3
  }
define to make xml namespaces  {
	headspaces :: 12
	pancreases :: 12
	nameplates :: 13
	namesakes :: 12
	aerospaces :: 12
	pleasances :: 12
   }
functionality available define xml ns define to function or if func does not conform  {
	      conform :: -1000
            }
to ansi c undef func define to empty if const does not conform to ansi c undef const define to long if sys types h does not define undef off t define to unsigned if sys types h does not define undef size t copyright c thai  {
	                                       thairms :: 5
	                                        thalli :: 5
	                                        thairm :: 6
	                                          thaw :: 5
	                                          thar :: 5
	                                          than :: 5
	                                          thae :: 5
	                                          chai :: 5
                                             }
open source software center  {
	infixion :: -1000
  }
ltd  {
	scrimshanders :: -1000
 }
see the file copying for copying permission ifndef expat external included define expat external included external api definitions if defined msc  {
	                mocs :: 4
	                macs :: 4
	               mucus :: 3
	               mocks :: 3
	               micos :: 3
	               micks :: 3
	               micas :: 3
	               macks :: 3
	               machs :: 3
	                 mac :: 3
	                  ms :: 4
	                  cs :: 3
                   }
extensions defined beos  {
	brose :: 6
	bowse :: 5
	bouse :: 5
	besot :: 5
	besom :: 5
	obes :: 5
	geos :: 5
	bros :: 5
	boos :: 5
	bios :: 5
	beys :: 5
	bets :: 5
	bens :: 5
	bels :: 5
	beds :: 5
 }
defined cygwin  {
	clawing :: 7
	cymling :: 7
	chowing :: 7
	chewing :: 7
	chawing :: 7
	clewing :: 7
 }
define xml use msc extensions endif expat tries  {
	  tries :: -1000
      }
very hard to make the api boundary  {
	boundary :: -1000
     }
very specifically  {
	specifically :: -1000
 }
defined there are two macros defined to control this boundary each of these can be defined before including this header to achieve some different behavior but doing  {
	                     doing :: -1000
                         }
so it not recommended  {
	recommended :: -1000
  }
or tested  {
	tested :: -1000
 }
frequently  {
	frequently :: -1000
 }
xmlcall  {
 }
the calling convention to use for all calls across  {
	  across :: -1000
       }
the library boundary this will default to cdecl  {
	sexennial :: -1000
      }
and try really  {
	really :: -1000
 }
hard to tell the compiler that s what we want xmlimport  {
	sectarianism :: -1000
         }
whatever  {
	whatever :: -1000
 }
magic is needed to note that a function is to be imported from a dynamically  {
	   dynamically :: -1000
             }
loaded library dll  {
	allod :: 3
	doll :: 3
	dill :: 3
	dell :: 3
	ill :: 3
	ell :: 3
	dol :: 3
	del :: 3
	dal :: 3
	all :: 3
 }
so or sl depending on your platform the xmlcall macro was added in expat the only one which is expected to be directly useful in client  {
	                   client :: -1000
                        }
code is xmlcall note that on at least some unix versions the expat library must be compiled  {
	        compiled :: -1000
               }
with the cdecl calling convention as the default since system headers may assume the cdecl convention ifndef xmlcall if defined msc ver define xmlcall cdecl elif defined gnuc defined i defined intel compiler define xmlcall attribute cdecl else for any platform which uses this definition and supports  {
	                                      supports :: -1000
                                             }
more than one calling convention we need to extend this definition to declare the convention used on that platform if it s possible to do so if this is the case for your platform please file a bug report with information on how to identify your platform via  {
	                                            via :: -1000
                                              }
the c pre processor and how to specify the same calling convention as the platform s malloc implementation define xmlcall endif endif not defined xmlcall if defined xml static defined xmlimport ifndef xml building  {
	                         building :: -1000
                                }
expat using expat from an application ifdef xml use msc extensions define xmlimport declspec  {
            }
dllimport  {
	members :: -1000
 }
endif endif endif not defined xml static if we didn t define it above define it away  {
	            away :: -1000
               }
ifndef xmlimport define xmlimport endif define xmlparseapi  {
     }
type xmlimport type xmlcall ifdef cplusplus extern c endif ifdef xml unicode  {
	    unicode :: -1000
          }
wchar  {
	echard :: 6
 }
t define xml unicode endif ifdef xml unicode information is utf  {
	  trapezia :: -1000
         }
encoded ifdef xml unicode wchar t typedef wchar t xml char typedef wchar t xml lchar  {
	          larch :: 6
	          lahar :: 7
	         echard :: 6
	         lahars :: 6
              }
else typedef unsigned short xml char typedef char xml lchar endif xml unicode wchar t else information is utf encoded typedef char xml char typedef char xml lchar endif xml unicode ifdef xml large size use large integers  {
	                             integers :: -1000
                                    }
for file stream positions  {
	positions :: -1000
  }
if defined xml use msc extensions msc ver typedef int xml index typedef unsigned int xml size else typedef long long xml index typedef unsigned long long xml size endif else typedef long xml index typedef unsigned long xml size endif xml large size ifdef cplusplus endif endif not expat external included copyright c thai open source software center ltd see the file copying for copying permission ifndef expat included define expat included ifdef vms  {
	                                                                      vims :: 3
	                                                                       vis :: 3
	                                                                       vas :: 3
	                                                                       ums :: 3
	                                                                       oms :: 3
	                                                                       ems :: 3
	                                                                        sm :: 3
                                                                         }
define xml setprocessinginstructionhandler  {
 }
xml setprocessinginstrhandler  {
 }
define xml setunparsedentitydeclhandler  {
 }
xml setunparsedentdeclhandler  {
	scrupler :: -1000
 }
define xml setstartnamespacedeclhandler  {
 }
xml setstartnamespcdeclhandler  {
 }
define xml setexternalentityrefhandlerarg  {
 }
xml setexternalentrefhandlerarg  {
 }
endif include stdlib h include expat external h ifdef cplusplus extern c endif struct xml parserstruct  {
              }
typedef struct xml parserstruct xml parser should this be defined using stdbool  {
          }
h when c is available typedef unsigned char xml bool define xml true xml bool define xml false  {
	            false :: -1000
                }
xml bool the xml status enum gives the possible return values for several api functions the preprocessor  {
	    preprocessor :: -1000
               }
defines are included so this stanza  {
	stanza :: -1000
    }
can be added to code that still needs to support older  {
	     older :: -1000
         }
versions of expat x ifndef xml status ok define xml status ok define xml status error endif otherwise the define hackery  {
	              hyenas :: -1000
                   }
is quite  {
	quite :: -1000
 }
ugly  {
	ugly :: -1000
 }
and would have been dropped  {
	dropped :: -1000
   }
enum xml status xml status error define xml status error xml status error xml status ok define xml status ok xml status ok xml status suspended  {
	                suspended :: -1000
                        }
define xml status suspended xml status suspended enum xml error xml error none xml error no memory xml error syntax  {
	             syntax :: -1000
                  }
xml error no elements xml error invalid token  {
	  token :: -1000
      }
xml error unclosed  {
	unclosed :: -1000
 }
token xml error partial  {
	partial :: -1000
  }
char xml error tag mismatch  {
	mismatch :: -1000
   }
xml error duplicate attribute xml error junk  {
	  junk :: -1000
     }
after doc element xml error param entity ref xml error undefined entity xml error recursive  {
	     recursive :: -1000
             }
entity ref xml error async entity xml error bad char ref xml error binary entity ref xml error attribute external entity ref xml error misplaced  {
	               misplaced :: -1000
                       }
xml pi xml error unknown encoding xml error incorrect  {
	incorrect :: -1000
       }
encoding xml error unclosed cdata  {
	carta :: 6
	adyta :: 6
   }
section xml error external entity handling xml error not standalone xml error unexpected  {
	  unexpected :: -1000
           }
state xml error entity declared in pe xml error feature requires xml dtd xml error cant  {
	           cant :: -1000
              }
change feature once parsing added in xml error unbound  {
	 unbound :: -1000
       }
prefix added in xml error undeclaring  {
	undertaking :: 15
	calendaring :: 15
	undertaxing :: 15
	underpaying :: 15
	underacting :: 16
	undereating :: 14
	underrating :: 15
	interlacing :: 14
	underlaying :: 18
	underlining :: 14
	underlapping :: 14
	underlains :: 14
	underlain :: 15
	underling :: 14
	undertakings :: 14
    }
prefix xml error incomplete  {
	overcooks :: -1000
  }
pe xml error xml decl xml error text decl xml error publicid  {
	  vulpicide :: 10
	    publics :: 10
	  publicize :: 12
	  publicise :: 12
	  publicist :: 12
	  publicity :: 12
	  duplicity :: 10
	 publicizes :: 11
	 publicized :: 13
	 publicises :: 11
	 publicised :: 13
	 publicists :: 11
	     public :: 11
          }
xml error suspended xml error not suspended xml error aborted  {
	  aborted :: -1000
        }
xml error finished  {
	finished :: -1000
 }
xml error suspend pe added in xml error reserved prefix xml xml error reserved prefix xmlns  {
              }
xml error reserved namespace uri  {
	urite :: 4
	urine :: 4
	urial :: 4
	ureic :: 3
	urali :: 3
	uraei :: 3
	uric :: 5
	ruin :: 3
	puir :: 3
	muir :: 3
	urites :: 3
	urines :: 3
	urinal :: 3
	urials :: 3
	 urs :: 3
	 urn :: 3
	 uni :: 3
	  ur :: 4
   }
enum xml content type xml ctype empty xml ctype any xml ctype mixed  {
	       mixed :: -1000
           }
xml ctype name xml ctype choice  {
	choice :: -1000
    }
xml ctype seq enum xml content quant xml cquant  {
	  creant :: -1000
       }
none xml cquant opt xml cquant rep xml cquant plus if type xml ctype empty or xml ctype any then quant will be xml cquant none and the other fields will be zero or null if type xml ctype mixed then quant will be none or rep and numchildren  {
                                               }
will contain number of elements that may be mixed in and children point to an array of xml content cells  {
	              cells :: -1000
                  }
that will be all of xml ctype name type with no quantification  {
	quantification :: -1000
          }
if type xml ctype name then the name points to the name and the numchildren field will be zero and children will be null the quant fields indicates any quantifiers  {
	                  quantifiers :: -1000
                            }
placed on the name choice and seq will have name null the number of children in numchildren and children will point recursively  {
	          recursively :: -1000
                    }
to an array of xml content cells the empty any and mixed types will only occur at top level typedef struct xml cp xml content struct xml cp enum xml content type type enum xml content quant quant xml char name unsigned int numchildren xml content children this is called for an element declaration see above for description of the model argument it s the caller s responsibility  {
	                                                     responsibility :: -1000
                                                                  }
to free model when finished with it typedef void xmlcall xml elementdeclhandler  {
          }
void userdata  {
 }
const xml char name xml content model xmlparseapi void xml setelementdeclhandler  {
         }
xml parser parser xml elementdeclhandler eldecl  {
	bedell :: 7
	cadelle :: 7
	elderly :: 8
    }
the attlist  {
	titlist :: 10
	etatist :: 9
	attrits :: 9
	attrist :: 11
	statist :: 9
	altoist :: 10
 }
declaration handler is called for each attribute so a single attlist declaration with multiple attributes declared will generate multiple calls to this handler the default parameter may be null in the case of the implied or required keyword the isrequired  {
	                             unrequired :: 14
	                             reacquired :: 12
                                      }
parameter will be true and the default value will be null in the case of required if isrequired is true and default is non null then this is a fixed default typedef void xmlcall xml attlistdeclhandler  {
                                  }
void userdata const xml char elname  {
	elmen :: 7
	bename :: 8
	gleeman :: 7
	gleamed :: 7
	gleamer :: 7
	benamed :: 7
	renamed :: 7
	renames :: 7
	benames :: 7
	entamed :: 7
	empanels :: 7
	rename :: 8
	ensample :: 7
	menage :: 7
	menace :: 7
	velamen :: 8
	enlace :: 7
	enamel :: 7
	empale :: 7
	embale :: 7
	elance :: 7
	leadmen :: 7
	bonemeal :: 7
	empanel :: 8
    }
const xml char attname  {
  }
const xml char att type const xml char dflt  {
	   delft :: 5
	    dolt :: 5
	    dalt :: 5
       }
int isrequired xmlparseapi void xml setattlistdeclhandler  {
    }
xml parser parser xml attlistdeclhandler attdecl  {
    }
the xml declaration handler is called for both xml declarations and text declarations the way  {
	           way :: -1000
             }
to distinguish is that the version parameter will be null for text declarations the encoding parameter may be null for xml declarations the standalone parameter will be or indicating respectively  {
	                 respectively :: -1000
                            }
that there was no standalone parameter in the declaration that it was given as no or that it was given as yes  {
	                  yes :: -1000
                    }
typedef void xmlcall xml xmldeclhandler  {
   }
void userdata const xml char version const xml char encoding int standalone xmlparseapi void xml setxmldeclhandler  {
              }
xml parser parser xml xmldeclhandler xmldecl typedef struct void malloc fcn size t size void realloc fcn void ptr size t size void free fcn void ptr xml memory handling suite constructs  {
	                     constructs :: -1000
                              }
a new parser encoding is the encoding specified  {
	specified :: -1000
      }
by the external protocol  {
	protocol :: -1000
  }
or null if there is none specified xmlparseapi xml parser xml parsercreate  {
          }
const xml char encoding constructs a new parser and namespace processor element type names and attribute names that belong  {
	            belong :: -1000
                 }
to a namespace will be expanded  {
	expanded :: -1000
    }
unprefixed  {
	underfired :: 12
	unprofited :: 14
	unprecise :: 12
	underfire :: 12
	unpriested :: 12
 }
attribute names are never expanded unprefixed element type names are expanded only if there is a default namespace the expanded name is the concatenation  {
	          concatenation :: -1000
                      }
of the namespace uri the namespace separator  {
	separator :: -1000
     }
character and the local part of the name if the namespace separator is then the namespace uri and the local part will be concatenated  {
	           concatenated :: -1000
                      }
without any separator it is a programming  {
	programming :: -1000
     }
error to use the separator with namespace triplets  {
	triplets :: -1000
      }
see xml setreturnnstriplet  {
 }
xmlparseapi xml parser xml parsercreatens  {
   }
const xml char encoding xml char namespaceseparator  {
     }
constructs a new parser using the memory management  {
	management :: -1000
      }
suite referred  {
	referred :: -1000
 }
to by memsuite  {
	semimute :: 11
	mesquite :: 11
	mesquites :: 10
	mimetites :: 10
	mezquites :: 10
 }
if memsuite is null then use the standard library memory suite if namespaceseparator is non null it creates  {
	          creates :: -1000
                }
a parser with namespace processing as described above the character pointed  {
	   pointed :: -1000
         }
at will serve as the namespace separator all further memory operations used for the created parser will come from the given suite xmlparseapi xml parser xml parsercreate mm const xml char encoding const xml memory handling suite memsuite const xml char namespaceseparator prepare a parser object to be re used this is particularly  {
	                                        particularly :: -1000
                                                   }
valuable  {
	valuable :: -1000
 }
when memory allocation overhead  {
	overhead :: -1000
  }
is disproportionatly  {
	disproportions :: 23
	disproportioned :: 22
	disproportional :: 28
	disproportionately :: 31
	disproportionating :: 24
	disproportionated :: 27
	disproportionates :: 27
	disproportion :: 25
	disproportionate :: 29
 }
high such as when a large number of small documnents  {
	documents :: 14
	decumbent :: 12
	 document :: 13
	incumbents :: 13
	condiments :: 13
	demulcents :: 12
	documenting :: 12
	documenters :: 12
        }
need to be parsed all handlers are cleared  {
	cleared :: -1000
      }
from the parser except for the unknownencodinghandler  {
     }
the parser s external state is re initialized except for the values of ns and ns triplets added in expat xmlparseapi xml bool xml parserreset  {
	               parterres :: 15
                       }
xml parser parser const xml char encoding atts  {
	   beds :: -1000
      }
is array of name value pairs  {
	pairs :: -1000
    }
terminated by names and values are terminated typedef void xmlcall xml startelementhandler  {
          }
void userdata const xml char name const xml char atts typedef void xmlcall xml endelementhandler  {
             }
void userdata const xml char name s is not terminated typedef void xmlcall xml characterdatahandler  {
             }
void userdata const xml char s int len target  {
	  target :: -1000
       }
and data are terminated typedef void xmlcall xml processinginstructionhandler  {
       }
void userdata const xml char target const xml char data data is terminated typedef void xmlcall xml commenthandler  {
                }
void userdata const xml char data typedef void xmlcall xml startcdatasectionhandler  {
         }
void userdata typedef void xmlcall xml endcdatasectionhandler  {
     }
void userdata this is called for any characters in the xml document for which there is no applicable  {
	       applicable :: -1000
                }
handler this includes both characters that are part of markup  {
	   markup :: -1000
        }
which is of a kind that is not reported  {
	reported :: -1000
       }
comments  {
	comments :: -1000
 }
markup declarations or characters that are part of a construct which could be reported but for which no handler has been supplied the characters are passed exactly  {
	                   exactly :: -1000
                         }
as they were in the xml document except that they will be encoded in utf or utf line boundaries  {
	        boundaries :: -1000
                 }
are not normalized  {
	normalized :: -1000
 }
note that a byte order mark character is not passed to the default handler there are no guarantees  {
	       guarantees :: -1000
                }
about how characters are divided  {
	divided :: -1000
   }
between calls to the default handler for example  {
	example :: -1000
      }
a comment might be split between multiple calls typedef void xmlcall xml defaulthandler  {
           }
void userdata const xml char s int len this is called for the start of the doctype  {
	         ecotype :: 9
	         decrypt :: 9
               }
declaration before any dtd or internal subset  {
	subset :: -1000
     }
is parsed typedef void xmlcall xml startdoctypedeclhandler  {
     }
void userdata const xml char doctypename  {
    }
const xml char sysid  {
	mysids :: 7
	sayids :: 7
	sylis :: 6
	mysid :: 7
  }
const xml char pubid  {
	upbind :: 6
	cupid :: 6
	unbid :: 6
	pudic :: 6
	pubis :: 7
	pubic :: 7
	pub :: 6
  }
int has internal subset this is called for the start of the doctype declaration when the closing  {
	         closing :: -1000
               }
is encountered  {
	encountered :: -1000
 }
but after processing any external subset typedef void xmlcall xml enddoctypedeclhandler  {
         }
void userdata this is called for entity declarations the is parameter entity argument will be non zero if the entity is a parameter entity zero otherwise for internal entities  {
	                    entities :: -1000
                           }
entity foo bar value will be non null and systemid  {
	 systemic :: 13
	 systemed :: 12
	   system :: 12
	systemize :: 11
	systemics :: 10
	systemized :: 12
	systemised :: 10
	   sisted :: 10
        }
publicid and notationname  {
 }
will be null the value string is not nul terminated the length is provided in the value length argument since it is legal to have zero length values do not use this argument to test for internal entities for external entities value will be null and systemid will be non null the publicid argument will be null unless a public identifier was provided the notationname argument will have a non null value only for unparsed entity declarations note that is parameter entity can t be changed to xml bool since that would break  {
	                                                                                       break :: -1000
                                                                                           }
binary compatibility typedef void xmlcall xml entitydeclhandler  {
     }
void userdata const xml char entityname  {
	antimonate :: 12
    }
int is parameter entity const xml char value int value length const xml char base const xml char systemid const xml char publicid const xml char notationname xmlparseapi void xml setentitydeclhandler  {
                             }
xml parser parser xml entitydeclhandler handler obsolete obsolete obsolete this handler has been superceded  {
	   superceded :: -1000
            }
by the entitydeclhandler above it is provided here for backward compatibility this is called for a declaration of an unparsed ndata  {
	               adyta :: 6
	             adamant :: 6
                   }
entity the base argument is whatever was set by xml setbase  {
	   sebates :: 9
	   sensate :: 9
         }
the entityname systemid and notationname arguments will never be null the other arguments may be typedef void xmlcall xml unparsedentitydeclhandler  {
                  }
void userdata const xml char entityname const xml char base const xml char systemid const xml char publicid const xml char notationname this is called for a declaration of notation the base argument is whatever was set by xml setbase the notationname will never be null the other arguments can be typedef void xmlcall xml notationdeclhandler  {
	                                             resemblers :: -1000
                                                      }
void userdata const xml char notationname const xml char base const xml char systemid const xml char publicid when namespace processing is enabled these are called once for each namespace declaration the call to the start and end element handlers occur between the calls to the start and end namespace declaration handlers for an xmlns attribute prefix will be null for an xmlns attribute uri will be null typedef void xmlcall xml startnamespacedeclhandler  {
	                                                            advancements :: -1000
                                                                       }
void userdata const xml char prefix const xml char uri typedef void xmlcall xml endnamespacedeclhandler  {
             }
void userdata const xml char prefix this is called if the document is not standalone that is it has an external subset or a reference to a parameter entity but does not have standalone yes if this handler returns xml status error then processing will not continue  {
	                                      continue :: -1000
                                             }
and the parser will return a xml error not standalone error if parameter entity parsing is enabled then in addition to the conditions  {
	            conditions :: -1000
                     }
above this handler will only be called if the referenced entity was actually read typedef int xmlcall xml notstandalonehandler  {
                 }
void userdata this is called for a reference to an external parsed general entity the referenced entity is not automatically parsed the application can parse it immediately or later using xml externalentityparsercreate  {
                              }
the parser argument is the parser parsing the entity containing the reference it can be passed as the parser argument to xml externalentityparsercreate the systemid argument is the system identifier as specified in the entity declaration it will not be null the base argument is the system identifier that should be used as the base for resolving  {
	                                               resolving :: -1000
                                                       }
systemid if systemid was relative this is set by xml setbase it may be null the publicid argument is the public identifier as specified in the entity declaration or null if none was specified the whitespace in the public identifier will have been normalized as required by the xml spec the context argument specifies  {
	                                            specifies :: -1000
                                                    }
the parsing context in the format expected by the context argument to xml externalentityparsercreate context is valid only until the handler returns so if the referenced entity is to be parsed later it must be copied context is null only when the entity is a parameter entity the handler should return xml status error if processing should not continue because of a fatal  {
	                                                         fatal :: -1000
                                                             }
error in the handling of the external entity in this case the calling parser will return an xml error external entity handling error note that unlike  {
	                   unlike :: -1000
                        }
other handlers the first argument is the parser not userdata typedef int xmlcall xml externalentityrefhandler  {
             }
xml parser parser const xml char context const xml char base const xml char systemid const xml char publicid this is called in two situations  {
	              situations :: -1000
                       }
an entity reference is encountered for which no declaration has been read and this is not an error an internal entity reference is read but not expanded because xml setdefaulthandler  {
                            }
has been called note skipped parameter entities in declarations and skipped general entities in attribute values cannot be reported because the event would be out of sync with the reporting of the declarations or attribute values typedef void xmlcall xml skippedentityhandler  {
	                                 pentode :: -1000
                                       }
void userdata const xml char entityname int is parameter entity this structure is filled  {
	       filled :: -1000
            }
in by the xml unknownencodinghandler to provide information to the parser about encodings  {
	    decoying :: 11
	    decoding :: 12
	    recoding :: 12
	   canoeings :: 12
	    inceding :: 12
	    snodding :: 11
	    encasing :: 12
	    snedding :: 11
	    seceding :: 11
	    escoting :: 12
	    endowing :: 12
	   seconding :: 11
	   becomings :: 11
	   incomings :: 12
	   oncomings :: 12
	   enticings :: 11
	    scending :: 12
	    encoring :: 13
	    snooding :: 12
	    encoding :: 16
           }
that are unknown to the parser the map b member gives information about byte sequences whose  {
	          whose :: -1000
              }
first byte is b if map b is c where c is then b by itself encodes  {
	         encodes :: -1000
               }
the unicode scalar  {
	scalar :: -1000
 }
value c if map b is then the byte sequence is malformed  {
	  malformed :: -1000
          }
if map b is n where n then b is the first byte of an n byte sequence that encodes a single unicode scalar value the data member will be passed as the first argument to the convert function the convert function is used to convert multibyte  {
	                                      multijet :: 12
	                                      multeity :: 12
	                                     multisite :: 11
                                             }
sequences s will point to a n byte sequence where map unsigned char s n the convert function must return the unicode scalar value represented  {
	             represented :: -1000
                       }
by this byte sequence or if the byte sequence is malformed the convert function may be null if the encoding is a single byte encoding that is if map b for all bytes b when the parser is finished with the encoding then if release  {
	                                   weaseller :: -1000
                                           }
is not null it will call release passing  {
	passing :: -1000
      }
it the data member once release has been called the convert function will not be called again expat places  {
	            places :: -1000
                 }
certain  {
	certain :: -1000
 }
restrictions  {
	restrictions :: -1000
 }
on the encodings that are supported  {
	supported :: -1000
    }
using this mechanism  {
	mechanism :: -1000
 }
every ascii character that can appear in a well formed  {
	   formed :: -1000
        }
xml document other than the characters must be represented by a single byte and that byte must be the same byte that represents  {
	            represents :: -1000
                     }
that character in ascii no character may require more than bytes to encode all characters encoded must have unicode scalar values xffff i e characters that would be encoded by surrogates  {
	                    surrogates :: -1000
                             }
in utf are not allowed  {
	allowed :: -1000
   }
note that this restriction doesn t apply to the built in support for utf and utf no unicode character may be encoded by more than one distinct sequence of bytes typedef struct int map void data int xmlcall convert void data const char s void xmlcall release void data xml encoding this is called for an encoding that is unknown to the parser the encodinghandlerdata  {
                                                               }
argument is that which was passed as the second argument to xml setunknownencodinghandler  {
           }
the name argument gives the name of the encoding as specified in the encoding declaration if the callback  {
	         callback :: -1000
                }
can provide information about the encoding it must fill in the xml encoding structure and return xml status ok otherwise it must return xml status error if info does not describe a suitable  {
	                        suitable :: -1000
                               }
encoding then the parser will return an xml unknown encoding error typedef int xmlcall xml unknownencodinghandler void encodinghandlerdata const xml char name xml encoding info xmlparseapi void xml setelementhandler  {
                           }
xml parser parser xml startelementhandler start xml endelementhandler end xmlparseapi void xml setstartelementhandler  {
           }
xml parser parser xml startelementhandler handler xmlparseapi void xml setendelementhandler  {
        }
xml parser parser xml endelementhandler handler xmlparseapi void xml setcharacterdatahandler  {
	 agenesis :: -1000
        }
xml parser parser xml characterdatahandler handler xmlparseapi void xml setprocessinginstructionhandler xml parser parser xml processinginstructionhandler handler xmlparseapi void xml setcommenthandler  {
                  }
xml parser parser xml commenthandler handler xmlparseapi void xml setcdatasectionhandler  {
        }
xml parser parser xml startcdatasectionhandler start xml endcdatasectionhandler end xmlparseapi void xml setstartcdatasectionhandler  {
           }
xml parser parser xml startcdatasectionhandler start xmlparseapi void xml setendcdatasectionhandler  {
        }
xml parser parser xml endcdatasectionhandler end this sets the default handler and also inhibits  {
	totalitarianizes :: -1000
            }
expansion  {
	expansion :: -1000
 }
of internal entities these entity references will be passed to the default handler or to the skipped entity handler if one is set xmlparseapi void xml setdefaulthandler xml parser parser xml defaulthandler handler this sets the default handler but does not inhibit expansion of internal entities the entity reference will not be passed to the default handler xmlparseapi void xml setdefaulthandlerexpand  {
                                                           }
xml parser parser xml defaulthandler handler xmlparseapi void xml setdoctypedeclhandler  {
        }
xml parser parser xml startdoctypedeclhandler start xml enddoctypedeclhandler end xmlparseapi void xml setstartdoctypedeclhandler  {
           }
xml parser parser xml startdoctypedeclhandler start xmlparseapi void xml setenddoctypedeclhandler  {
	   lunars :: -1000
        }
xml parser parser xml enddoctypedeclhandler end xmlparseapi void xml setunparsedentitydeclhandler xml parser parser xml unparsedentitydeclhandler handler xmlparseapi void xml setnotationdeclhandler  {
                  }
xml parser parser xml notationdeclhandler handler xmlparseapi void xml setnamespacedeclhandler  {
        }
xml parser parser xml startnamespacedeclhandler start xml endnamespacedeclhandler end xmlparseapi void xml setstartnamespacedeclhandler xml parser parser xml startnamespacedeclhandler start xmlparseapi void xml setendnamespacedeclhandler  {
                     }
xml parser parser xml endnamespacedeclhandler end xmlparseapi void xml setnotstandalonehandler  {
        }
xml parser parser xml notstandalonehandler handler xmlparseapi void xml setexternalentityrefhandler xml parser parser xml externalentityrefhandler handler if a non null value for arg is specified here then it will be passed as the first argument to the external entity ref handler instead of the parser object xmlparseapi void xml setexternalentityrefhandlerarg xml parser parser void arg xmlparseapi void xml setskippedentityhandler  {
                                                         }
xml parser parser xml skippedentityhandler handler xmlparseapi void xml setunknownencodinghandler xml parser parser xml unknownencodinghandler handler void encodinghandlerdata this can be called within a handler for a start element end element processing instruction or character data it causes the corresponding markup to be passed to the default handler xmlparseapi void xml defaultcurrent  {
                                                  }
xml parser parser if do nst  {
	  odd :: -1000
    }
is non zero and namespace processing is in effect and a name has a prefix i e an explicit  {
	          grinders :: -1000
                 }
namespace qualifier  {
	qualifier :: -1000
 }
then that name is returned as a triplet in a single string separated by the separator character specified when the parser was created uri sep local name sep prefix if do nst is zero then namespace information is returned in the default manner uri sep local name whether or not the name has a prefix note calling xml setreturnnstriplet after xml parse or xml parsebuffer  {
                                                               }
has no effect xmlparseapi void xml setreturnnstriplet xml parser parser int do nst this value is passed as the userdata argument to callbacks  {
	             callbacks :: -1000
                     }
xmlparseapi void xml setuserdata  {
  }
xml parser parser void userdata returns the last value set by xml setuserdata or null define xml getuserdata  {
                }
parser void parser this is equivalent  {
	equivalent :: -1000
    }
to supplying  {
	supplying :: -1000
 }
an encoding argument to xml parsercreate on success xml setencoding  {
	telescoping :: 14
	retroceding :: 14
        }
returns non zero zero otherwise note calling xml setencoding after xml parse or xml parsebuffer has no effect and returns xml status error xmlparseapi enum xml status xml setencoding xml parser parser const xml char encoding if this function is called then the parser will be passed as the first argument to callbacks instead of userdata the userdata will still be accessible  {
	                                                   accessible :: -1000
                                                            }
using xml getuserdata xmlparseapi void xml useparserashandlerarg  {
     }
xml parser parser if usedtd  {
	stedd :: 7
	used :: 7
	dusted :: 7
   }
xml true is passed to this function then the parser will assume that there is an external subset even if none is specified in the document in such a case the parser will call the externalentityrefhandler with a value of null for the systemid argument the publicid and context arguments will be null as well note for the purpose of checking  {
	                                                    checking :: -1000
                                                           }
wfc  {
 }
entity declared passing usedtd xml true will make the parser behave  {
	    behave :: -1000
         }
as if the document had  {
	 had :: -1000
   }
a dtd with an external subset note if this function is called then this must be done before the first call to xml parse or xml parsebuffer since it will have no effect after that returns xml error cant change feature once parsing note if the document does not have a doctype declaration at all then startdoctypedeclhandler and enddoctypedeclhandler will not be called despite  {
	                                                        despite :: -1000
                                                              }
an external subset being parsed note if xml dtd is not defined when expat is compiled returns xml error feature requires xml dtd xmlparseapi enum xml error xml useforeigndtd  {
                           }
xml parser parser xml bool usedtd sets the base to be used for resolving relative uris  {
	         trisul :: 5
	           urns :: 5
	           uric :: 5
	           unis :: 5
	           sris :: 5
	         urites :: 5
	         urines :: 5
	         urials :: 5
	            urs :: 5
              }
in system identifiers  {
	identifiers :: -1000
 }
in declarations resolving relative identifiers is left to the application this value will be passed through as the base argument to the xml externalentityrefhandler xml notationdeclhandler and xml unparsedentitydeclhandler the base argument will be copied returns xml status error if out of memory xml status ok otherwise xmlparseapi enum xml status xml setbase xml parser parser const xml char base xmlparseapi const xml char xml getbase  {
	                                                          gestate :: 9
	                                                          getable :: 9
                                                                }
xml parser parser returns the number of the attribute value pairs passed in last call to the xml startelementhandler that were specified in the start tag rather than defaulted  {
	                   defaulted :: -1000
                           }
each attribute value pair counts  {
	counts :: -1000
   }
as thus this correspondds  {
	corresponsive :: 15
	correspond :: 18
	corresponded :: 18
	corresponds :: 20
	correspondents :: 15
  }
to an index into the atts array passed to the xml startelementhandler xmlparseapi int xml getspecifiedattributecount  {
              }
xml parser parser returns the index of the id attribute passed in the last call to xml startelementhandler or if there is no id attribute each attribute value pair counts as thus this correspondds to an index into the atts array passed to the xml startelementhandler xmlparseapi int xml getidattributeindex  {
                                                }
xml parser parser parses  {
	parses :: -1000
  }
some input returns xml status error if a fatal error is detected the last call to xml parse must have isfinal  {
	             incisal :: 9
                   }
true len may be zero for this call or any other though the return values for these functions has always been described as a boolean value the implementation at least for the x series has always returned exactly one of the xml status values xmlparseapi enum xml status xml parse xml parser parser const char s int len int isfinal xmlparseapi void xml getbuffer  {
                                                              }
xml parser parser int len xmlparseapi enum xml status xml parsebuffer xml parser parser int len int isfinal stops parsing causing  {
	             causing :: -1000
                   }
xml parse or xml parsebuffer to return must be called from within a call back handler except when aborting  {
	          aborting :: -1000
                 }
resumable  {
	resumable :: -1000
 }
an already suspended parser some call backs  {
	 backs :: -1000
     }
may still follow because they would otherwise get lost  {
	    lost :: -1000
       }
examples  {
	examples :: -1000
 }
endelementhandler for empty elements when stopped in startelementhandler endnamespacedeclhandler when stopped in endelementhandler and possibly others can be called from most handlers including dtd related call backs except when parsing an external parameter entity and resumable returns xml status ok when successful xml status error otherwise possible error codes xml error suspended when suspending  {
	                                           suspending :: -1000
                                                    }
an already suspended parser xml error finished when the parser has already finished xml error suspend pe when suspending while parsing an external pe when resumable true then parsing is suspended that is xml parse and xml parsebuffer return xml status suspended otherwise parsing is aborted that is xml parse and xml parsebuffer return xml status error with error code xml error aborted note this will be applied to the current parser instance only that is if there is a parent parser then it will continue parsing when the externalentityrefhandler returns it is up to the implementation of the externalentityrefhandler to call xml stopparser  {
	                                                                                              channeled :: -1000
                                                                                                      }
on the parent parser recursively if one wants to stop parsing altogether  {
	 altogether :: -1000
          }
when suspended parsing can be resumed  {
	resumed :: -1000
    }
by calling xml resumeparser  {
  }
xmlparseapi enum xml status xml stopparser xml parser parser xml bool resumable resumes  {
	     resumes :: -1000
           }
parsing after it has been suspended with xml stopparser must not be called from within a handler call back returns same status codes as xml parse or xml parsebuffer additional error code xml error not suspended possible note this must be called on the most deeply  {
	                                       deeply :: -1000
                                            }
nested  {
	nested :: -1000
 }
child parser instance first and on its parent parser only after the child parser has finished to be applied recursively until the document entity s parser is restarted  {
	                  restarted :: -1000
                          }
that is the parent parser will not resume by itself and it is up to the application to call xml resumeparser on it at the appropriate moment  {
	                    moment :: -1000
                         }
xmlparseapi enum xml status xml resumeparser xml parser parser enum xml parsing xml initialized xml parsing xml finished xml suspended typedef struct enum xml parsing parsing xml bool finalbuffer  {
	                   asphyxies :: -1000
                           }
xml parsingstatus  {
 }
returns status of parser with respect to being initialized parsing finished or suspended and processing the final buffer xxx xml parse and xml parsebuffer should return xml parsingstatus xxx with xml finished ok or xml finished error replacing  {
	                            replacing :: -1000
                                    }
xml finished xmlparseapi void xml getparsingstatus  {
    }
xml parser parser xml parsingstatus status creates an xml parser object that can parse an external general entity context is a terminated string specifying  {
	             specifying :: -1000
                      }
the parse context encoding is a terminated string giving  {
	spottiest :: -1000
       }
the name of the externally  {
	externally :: -1000
   }
specified encoding or null if there is no externally specified encoding the context string consists of a sequence of tokens  {
	             tokens :: -1000
                  }
separated by formfeeds  {
	wormseed :: 12
	forefend :: 11
	forefends :: 13
	forefeels :: 12
	wormseeds :: 12
 }
f a token consisting  {
	consisting :: -1000
  }
of a name specifies that the general entity of the name is open a token of the form prefix uri specifies the namespace for a particular prefix a token of the form uri specifies the default namespace this can be called at any point after the first call to an externalentityrefhandler so longer as the parser has not yet  {
	                                                       yet :: -1000
                                                         }
been freed the new parser is completely independent and may safely  {
	    safely :: -1000
         }
be used in a separate thread the handlers and userdata are initialized from the parser argument returns null if out of memory otherwise returns a new xml parser object xmlparseapi xml parser xml externalentityparsercreate xml parser parser const xml char context const xml char encoding enum xml paramentityparsing  {
                                              }
xml param entity parsing never xml param entity parsing unless standalone xml param entity parsing always controls parsing of parameter entities including the external dtd subset if parsing of parameter entities is enabled then references to external parameter entities including the external dtd subset will be passed to the handler set with xml setexternalentityrefhandler the context passed will be unlike external general entities external parameter entities can only be parsed synchronously  {
	                                                         synchronously :: -1000
                                                                     }
if the external parameter entity is to be parsed it must be parsed during the call to the external entity ref handler the complete sequence of xml externalentityparsercreate xml parse xml parsebuffer and xml parserfree  {
                                 }
calls must be made during this call after xml externalentityparsercreate has been called to create the parser for the external parameter entity context must be for this call it is illegal  {
	                       illegal :: -1000
                             }
to make any calls on the old parser until xml parserfree has been called on the newly created parser if the library has been compiled without support for parameter entity parsing ie without xml dtd being defined then xml setparamentityparsing  {
                                      }
will return if parsing of parameter entities is requested otherwise it will return non zero note if xml setparamentityparsing is called after xml parse or xml parsebuffer then it has no effect and will always return xmlparseapi int xml setparamentityparsing xml parser parser enum xml paramentityparsing parsing sets the hash salt to use for internal hash calculations  {
	                                            calculations :: -1000
                                                       }
helps  {
	helps :: -1000
 }
in preventing  {
	preventing :: -1000
 }
dos  {
	dos :: -1000
 }
attacks  {
	attacks :: -1000
 }
based on predicting  {
	predicting :: -1000
 }
hash function behavior this must be called before parsing is started  {
	   started :: -1000
         }
returns if successful when called after parsing has started xmlparseapi int xml sethashsalt  {
           }
xml parser parser unsigned long hash salt if xml parse or xml parsebuffer have returned xml status error then xml geterrorcode  {
	               linos :: -1000
                   }
returns information about the error xmlparseapi enum xml error xml geterrorcode xml parser parser these functions return information about the current parse location they may be called from any callback called to report some parse event in this case the location is the location of the first of the sequence of characters that generated the event when called from callbacks generated by declarations in the document prologue  {
	                                                          prologue :: -1000
                                                                 }
the location identified  {
	identified :: -1000
 }
isn t as neatly  {
	neatly :: -1000
  }
defined but will be within the relevant  {
	relevant :: -1000
     }
markup when called outside  {
	outside :: -1000
  }
of the callback functions the position indicated  {
	indicated :: -1000
     }
will be just past the last parse event regardless  {
	regardless :: -1000
       }
of whether there was an associated callback they may also be called after returning from a call to xml parse or xml parsebuffer if the return value is xml status error then the location is the location of the character at which the error was detected otherwise the location is the location of the last parse event as described above xmlparseapi xml size xml getcurrentlinenumber  {
                                                               }
xml parser parser xmlparseapi xml size xml getcurrentcolumnnumber  {
      }
xml parser parser xmlparseapi xml index xml getcurrentbyteindex  {
      }
xml parser parser return the number of bytes in the current event returns if the event is in an internal entity xmlparseapi int xml getcurrentbytecount  {
                       }
xml parser parser if xml context bytes is defined returns the input buffer sets the integer pointed to by offset to the offset within this buffer of the current parse position and sets the integer pointed to by size to the size of this buffer the number of input bytes otherwise returns a null pointer also returns a null pointer if a parse isn t active  {
	                                                       leucocytes :: -1000
                                                                }
note the character pointer returned should not be used outside the handler that makes  {
	        makes :: -1000
            }
the call xmlparseapi const char xml getinputcontext  {
     }
xml parser parser int offset int size for backwards  {
	backwards :: -1000
       }
compatibility with previous versions define xml geterrorlinenumber  {
     }
xml getcurrentlinenumber define xml geterrorcolumnnumber  {
   }
xml getcurrentcolumnnumber define xml geterrorbyteindex  {
   }
xml getcurrentbyteindex frees the content model passed to the element declaration handler xmlparseapi void xml freecontentmodel  {
              }
xml parser parser xml content model exposing  {
	exposing :: -1000
     }
the memory handling functions used in expat xmlparseapi void xml memmalloc  {
         }
xml parser parser size t size xmlparseapi void xml memrealloc  {
	memorable :: 12
        }
xml parser parser void ptr size t size xmlparseapi void xml memfree  {
          }
xml parser parser void ptr frees memory used by the parser xmlparseapi void xml parserfree xml parser parser returns a string describing the error xmlparseapi const xml lchar xml errorstring  {
                            }
enum xml error code return a string containing the version number of this expat xmlparseapi const xml lchar xml expatversion  {
	       exasperation :: 15
	      extraversions :: 17
	      extroversions :: 15
	       extraversion :: 19
	       extroversion :: 17
                  }
void typedef struct int major int minor int micro xml expat version return an xml expat version structure containing numeric version number information for this version of expat xmlparseapi xml expat version xml expatversioninfo  {
                                }
void added in expat enum xml featureenum  {
     }
xml feature end xml feature unicode xml feature unicode wchar t xml feature dtd xml feature context bytes xml feature min size xml feature sizeof xml char xml feature sizeof xml lchar xml feature ns xml feature large size additional features must be added to the end of this enum typedef struct enum xml featureenum feature const xml lchar name long int value xml feature xmlparseapi const xml feature xml getfeaturelist  {
	                                                            outshaming :: -1000
                                                                     }
void expat follows the gnu linux convention of odd  {
	     odd :: -1000
       }
number minor version for beta  {
	beta :: -1000
   }
development  {
	development :: -1000
 }
releases  {
	weasellers :: -1000
 }
and even number minor version for stable  {
	stable :: -1000
     }
releases micro is bumped  {
	bumped :: -1000
  }
with each release and set to with each change to major or minor version define xml major version define xml minor version define xml micro version ifdef cplusplus endif endif not expat included copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa posix standard file control operations fcntl h ifndef fcntl h define fcntl h include features h this must be early so bits fcntl h can define types winningly  {
	                                                                                                                                                                                         winningly :: -1000
                                                                                                                                                                                                 }
begin decls get the definitions of o f fd all the numbers and flag bits for open fcntl et al include bits fcntl h for xpg all symbols from sys stat h should also be available if defined use xopen defined use xopen k include bits types h for mode t and dev t define need timespec include time h include bits stat h define s ifmt  {
                                                                 }
s ifmt define s ifdir  {
   }
s ifdir define s ifchr  {
	rich :: 6
   }
s ifchr define s ifblk  {
   }
s ifblk define s ifreg  {
   }
s ifreg ifdef s ififo  {
   }
define s ififo s ififo endif ifdef s iflnk  {
	    kiln :: 6
       }
define s iflnk s iflnk endif if defined use unix defined use xopen k defined s ifsock  {
               }
define s ifsock s ifsock endif protection  {
	protection :: -1000
     }
bits define s isuid s isuid set user id on execution define s isgid s isgid set group id on execution if defined use bsd defined use misc defined use xopen save  {
	                           save :: -1000
                              }
swapped text after use sticky  {
	sticky :: -1000
   }
bit this is pretty well obsolete define s isvtx s isvtx endif define s irusr s iread  {
	          dreads :: 6
	           irked :: 6
	           irade :: 7
	           ideas :: 6
	           ideal :: 6
	           dream :: 6
	           dread :: 7
	           bread :: 7
	           aread :: 7
	           aired :: 6
	          areads :: 6
	          treads :: 6
	          oreads :: 6
	         invader :: 6
	          tirade :: 6
	        preadmit :: 6
	        dreading :: 6
	        treading :: 6
	           triad :: 6
	           tread :: 7
	            idea :: 7
	          bready :: 6
	          breads :: 6
	           oread :: 7
	          uredia :: 6
	          irades :: 6
	             ire :: 6
               }
read by owner  {
	owner :: -1000
 }
define s iwusr s iwrite  {
	intire :: 7
	inciter :: 7
	wiriest :: 7
	inviter :: 7
	twinier :: 7
	igniter :: 7
	awaiter :: 7
   }
write by owner define s ixusr s iexec  {
	lexemic :: 6
	  xebec :: 6
      }
execute  {
	execute :: -1000
 }
by owner read write and execute by owner define s irwxu  {
         }
s iread s iwrite s iexec define s irgrp s irusr read by group define s iwgrp s iwusr write by group define s ixgrp s ixusr execute by group read write and execute by group define s irwxg  {
                                     }
s irwxu define s iroth s irgrp read by others define s iwoth s iwgrp write by others define s ixoth s ixgrp execute by others read write and execute by others define s irwxo  {
                                 }
s irwxg endif ifdef use misc ifndef r ok verbatim  {
	 verbatim :: -1000
        }
from unistd h ugh  {
	ugh :: -1000
  }
values for the second argument to access these may be or d together define r ok test for read permission define w ok test for write permission define x ok test for execute permission define f ok test for existence  {
	                              existence :: -1000
                                      }
endif endif use misc xpg wants the following symbols stdio h has the same definitions if defined use xopen defined use xopen k define seek set seek from beginning of file define seek cur seek from current position define seek end seek from end of file endif xpg do the file control operation described by cmd on fd the remaining arguments are interpreted depending on cmd this function is a cancellation point and therefore not marked with throw extern int fcntl int fd int cmd open file and return a new file descriptor for it or on error oflag  {
	                                                                                             oflag :: -1000
                                                                                                 }
determines the type of access used if o creat is on oflag the third argument is taken  {
	           taken :: -1000
               }
as a mode t the mode of the created file this function is a cancellation point and therefore not marked with throw ifndef use file offset extern int open const char file int oflag nonnull else ifdef redirect extern int redirect open const char file int oflag open nonnull else define open open endif endif ifdef use largefile extern int open const char file int oflag nonnull endif ifdef use atfile  {
	                                                              frailest :: 7
	                                                                aplite :: 7
	                                                                albite :: 7
	                                                                facile :: 7
	                                                                stifle :: 7
	                                                              antileft :: 8
                                                                     }
similar to open but a relative path name is interpreted relative to the directory for which fd is a descriptor note some other openat  {
	                operate :: 7
	                operand :: 7
	                operant :: 9
	               phonated :: 7
	               phonates :: 7
	              operation :: 7
	              operating :: 8
	               pronated :: 7
	               pronates :: 7
	                spinate :: 7
	              operantly :: 7
	                pronate :: 8
	                phonate :: 8
	                 optant :: 7
	               operatic :: 7
	               operants :: 8
	                 teopan :: 7
	               opencast :: 8
	                   open :: 8
	                  opera :: 7
	                  opens :: 7
                      }
implementation support additional functionality through this interface especially  {
	especially :: -1000
      }
using the o xattr  {
	tart :: 6
	ratty :: 6
  }
flag this is not yet supported here this function is a cancellation point and therefore not marked with throw ifndef use file offset extern int openat int fd const char file int oflag nonnull else ifdef redirect extern int redirect openat int fd const char file int oflag openat nonnull else define openat openat endif endif ifdef use largefile extern int openat int fd const char file int oflag nonnull endif endif create and open file with mode mode this takes an int mode argument because that is what mode t will be widened  {
	                                                                                      widened :: -1000
                                                                                            }
to this function is a cancellation point and therefore not marked with throw ifndef use file offset extern int creat const char file mode t mode nonnull else ifdef redirect extern int redirect creat const char file mode t mode creat nonnull else define creat creat endif endif ifdef use largefile extern int creat const char file mode t mode nonnull endif if defined f lock defined use misc defined use xopen extended defined use posix note these declarations also appear in unistd h be sure  {
	                                                                                 sure :: -1000
                                                                                    }
to keep both files consistent  {
	consistent :: -1000
   }
some systems have them there and some here and some software depends on the macros being defined without including both lockf  {
	                 wem :: -1000
                   }
is a simpler  {
	simpler :: -1000
 }
interface to the locking  {
	locking :: -1000
  }
facilities  {
	facilities :: -1000
 }
of fcntl len is always relative to the current file position the cmd argument is one of the following define f ulock  {
	               blocky :: 6
	               blocks :: 6
	                flock :: 7
	                cluck :: 6
	                clonk :: 6
	                clock :: 7
	                cloak :: 6
	                block :: 7
	               flocky :: 6
	               flocks :: 6
	               clocks :: 6
	                 clou :: 6
	                pluck :: 6
	                plouk :: 6
                    }
unlock a previously locked  {
	weld :: -1000
  }
region define f lock lock a region for exclusive use define f tlock  {
	      blocky :: 6
	      blocks :: 6
	       flock :: 7
	       clonk :: 6
	       clock :: 7
	       cloak :: 6
	       block :: 7
	      trocks :: 6
	      flocky :: 6
	      flocks :: 6
	      clocks :: 6
	       trock :: 7
	       stock :: 6
	        clot :: 6
           }
test and lock a region for exclusive use define f test test a region for other processes  {
	       processes :: -1000
               }
locks ifndef use file offset extern int lockf int fd int cmd off t len else ifdef redirect extern int redirect lockf int fd int cmd off t len lockf else define lockf lockf endif endif ifdef use largefile extern int lockf int fd int cmd off t len endif endif ifdef use xopen k advice  {
	                                                 advice :: -1000
                                                      }
the system about the expected behaviour of the application with respect to the file associated with fd ifndef use file offset extern int posix fadvise  {
	                 farside :: 9
                       }
int fd off t offset off t len int advise  {
	   advise :: -1000
        }
throw else ifdef redirect nth extern int redirect nth posix fadvise int fd off t offset off t len int advise posix fadvise else define posix fadvise posix fadvise endif endif ifdef use largefile extern int posix fadvise int fd off t offset off t len int advise throw endif reserve storage for the data of the file associated with fd this function is a possible cancellation point and therefore not marked with throw ifndef use file offset extern int posix fallocate  {
	                                                                       secularity :: -1000
                                                                                }
int fd off t offset off t len else ifdef redirect extern int redirect posix fallocate int fd off t offset off t len posix fallocate else define posix fallocate posix fallocate endif endif ifdef use largefile extern int posix fallocate int fd off t offset off t len endif endif define some inlines helping  {
	                                               helping :: -1000
                                                     }
to catch  {
	catch :: -1000
 }
common problems if use fortify  {
	fortify :: -1000
   }
level defined extern always inline defined va arg pack len include bits fcntl h endif end decls endif fcntl h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef features h define features h these are defined by the user or the compiler to specify the desired environment strict ansi iso standard c isoc source extensions to iso c from iso c posix source ieee  {
                                                                                                                                                                                             }
std posix c source if like posix source if add ieee std if l add ieee std b if l add ieee std c if l all of ieee if l all of ieee xopen source includes posix and xpg things set to if single unix conformance  {
	                                   conformance :: -1000
                                             }
is wanted to for the sixth  {
	sixth :: -1000
    }
revision to for the seventh  {
	seventh :: -1000
   }
revision xopen source extended xpg things and x open unix extensions largefile source some more functions for correct  {
	          correct :: -1000
                }
standard i o largefile source additional functionality from lfs  {
	     los :: 3
	     lis :: 3
	     les :: 3
	     las :: 3
	     ifs :: 3
	     efs :: 3
	      lf :: 4
       }
for large files file offset bits n select default filesystem  {
	lifestyles :: 12
	filmsetters :: 13
	 filmsets :: 12
        }
interface bsd source iso c posix and bsd things svid source iso c posix and svid things atfile source additional at interfaces gnu source all of the above plus gnu extensions reentrant select additionally reentrant object thread safe same as reentrant often used by other systems fortify source if set to numeric value additional security  {
	                                              security :: -1000
                                                     }
measures  {
	measures :: -1000
 }
are defined according to level the ansi switch to the gnu c compiler defines strict ansi if none of these are defined the default is to have svid source bsd source and posix source set to one and posix c source set to l if more than one of these are defined they accumulate  {
	                                           accumulate :: -1000
                                                    }
for example strict ansi posix source and posix c source together give you iso c and but nothing else these are defined by this file and are used by the header files to decide  {
	                           decide :: -1000
                                }
what to declare or define use isoc define iso c things use isoc define iso c amd c things use posix define ieee std things use posix define ieee std things use posix define ieee std and b things use posix define ieee std b c and i things use xopen define xpg things use xopen extended define x open unix things use unix define single unix v things use xopen k define xpg things use xopen kxsi  {
                                                                            }
define xpg xsi  {
	axis :: 3
	xis :: 4
	six :: 3
	psi :: 3
	xi :: 3
	is :: 3
 }
things use xopen k define xpg things use xopen k xsi define xpg xsi things use largefile define correct standard i o things use largefile define lfs things with separate names use file offset define bit interface as default use bsd define bsd things use svid define svid things use misc define things common to bsd and system v unix use atfile define at interfaces and at constants for them use gnu define gnu extensions use reentrant define reentrant thread safe r functions use fortify level additional security measures used according to level favor bsd favor bsd things in cases of conflict the macros gnu library glibc  {
	                                                                                                     glias :: -1000
                                                                                                         }
and glibc minor are defined by this file unconditionally gnu library is provided only for compatibility all new code should use the other symbols to test for features all macros listed  {
	                        listed :: -1000
                             }
above as possibly being defined by this file are explicitly  {
	explicitly :: -1000
        }
undefined if they are not explicitly defined feature test macros that are not defined by the user or compiler but are implied by the other feature test macros defined or by the lack  {
	                            lack :: -1000
                               }
of any definitions are defined by the file undefine everything so we get a clean slate  {
	          slate :: -1000
              }
undef use isoc undef use isoc undef use posix undef use posix undef use posix undef use posix undef use xopen undef use xopen extended undef use unix undef use xopen k undef use xopen kxsi undef use xopen k undef use xopen k xsi undef use largefile undef use largefile undef use file offset undef use bsd undef use svid undef use misc undef use atfile undef use gnu undef use reentrant undef use fortify level undef favor bsd undef kernel strict names suppress kernel name space pollution  {
	                                                                               pollution :: -1000
                                                                                       }
unless user expressedly  {
	repressed :: 14
	expressly :: 14
	expressed :: 18
	expresser :: 14
	depressed :: 14
	expressible :: 15
	expressively :: 15
	professedly :: 14
 }
asks  {
	asks :: -1000
 }
for it ifndef loose  {
	loose :: -1000
  }
kernel names define kernel strict names endif always use iso c things define use ansi convenience  {
	    convenience :: -1000
              }
macros to test the versions of glibc and gcc use them like this if gnuc prereq code requiring  {
	        requiring :: -1000
                }
gcc or later endif note they won t work for gcc or glibc since the minor macros were not defined then if defined gnuc defined gnuc minor define gnuc prereq maj min gnuc gnuc minor maj min else define gnuc prereq maj min endif if bsd source was defined by the user favor bsd over posix if defined bsd source defined posix source defined posix c source defined xopen source defined gnu source defined svid source define favor bsd endif if gnu source was defined by the user turn on all the other features ifdef gnu source undef isoc source define isoc source undef isoc source define isoc source undef posix source define posix source undef posix c source define posix c source l undef xopen source define xopen source undef xopen source extended define xopen source extended undef largefile source define largefile source undef bsd source define bsd source undef svid source define svid source undef atfile source define atfile source endif if nothing other than gnu source is defined define bsd source and svid source if defined strict ansi defined isoc source defined posix source defined posix c source defined xopen source defined bsd source defined svid source define bsd source define svid source endif this is to enable the iso c extension also recognize  {
	                                                                                                                                                                                                               recognize :: -1000
                                                                                                                                                                                                                       }
the old macro which was used prior to the standard acceptance  {
	acceptance :: -1000
         }
this macro will eventually  {
	eventually :: -1000
  }
go away and the features enabled by default once the iso c standard is widely  {
	        widely :: -1000
             }
adopted  {
	adopted :: -1000
 }
if defined isoc source defined isoc x source defined stdc version stdc version l define use isoc endif this is to enable the iso c amendment  {
	                amendment :: -1000
                        }
extension if defined isoc source defined isoc x source defined stdc version stdc version l define use isoc endif if none of the ansi posix macros are defined use posix and posix and ieee std b unless xopen source is defined if defined strict ansi xopen source defined posix source defined posix c source define posix source if defined xopen source xopen source define posix c source elif defined xopen source xopen source define posix c source l elif defined xopen source xopen source define posix c source l else define posix c source l endif define use posix implicitly  {
	                                                                                         implicitly :: -1000
                                                                                                  }
endif if defined posix source posix c source defined xopen source define use posix endif if defined posix c source posix c source defined xopen source define use posix endif if posix c source l define use posix endif if posix c source l define use posix endif if posix c source l define use xopen k undef use isoc define use isoc undef use isoc define use isoc endif if posix c source l define use xopen k undef atfile source define atfile source endif ifdef xopen source define use xopen if xopen source define use xopen extended define use unix undef largefile source define largefile source if xopen source if xopen source define use xopen k define use xopen k xsi endif define use xopen k define use xopen kxsi undef use isoc define use isoc undef use isoc define use isoc endif else ifdef xopen source extended define use xopen extended endif endif endif ifdef largefile source define use largefile endif ifdef largefile source define use largefile endif if defined file offset bits file offset bits define use file offset endif if defined bsd source defined svid source define use misc endif ifdef bsd source define use bsd endif ifdef svid source define use svid endif ifdef atfile source define use atfile endif ifdef gnu source define use gnu endif if defined reentrant defined thread safe define use reentrant endif if defined fortify source fortify source gnuc prereq defined optimize optimize if fortify source define use fortify level else define use fortify level endif else define use fortify level endif define stdc iec and other similar macros include bits predefs  {
	                                                                                                                                                                                                                                                                         pedders :: 9
	                                                                                                                                                                                                                                                                         premeds :: 10
	                                                                                                                                                                                                                                                                         prefers :: 9
	                                                                                                                                                                                                                                                                        prefades :: 9
	                                                                                                                                                                                                                                                                       presifted :: 9
	                                                                                                                                                                                                                                                                         feeders :: 9
	                                                                                                                                                                                                                                                                           prese :: 9
                                                                                                                                                                                                                                                                               }
h wchar t uses iso nd ed published unicode define stdc iso l this macro indicates that the installed library is the gnu c library for historic  {
	                  historic :: -1000
                         }
reasons  {
	reasons :: -1000
 }
the value now is and this will stay  {
	   stay :: -1000
      }
from now on the use of this variable is deprecated use glibc and glibc minor now see below when you want to test for a specific gnu c library version and use the values in gnu lib names h to get the sonames  {
	                                   monases :: 12
	                                   monades :: 10
	                                   nomades :: 9
                                         }
of the shared libraries undef gnu library define gnu library major and minor version number of the gnu c library package use these macros to test for features in specific releases define glibc define glibc minor define glibc prereq maj min glibc glibc minor maj min decide whether a compiler supports the long long datatypes  {
	                                             antitypes :: 11
	                                             autotypes :: 11
	                                             antetypes :: 11
                                                     }
if defined gnuc defined pgi  {
	prig :: 4
	ping :: 3
	pigs :: 3
	igap :: 3
	prigs :: 3
	pling :: 3
	 psi :: 3
	 poi :: 3
	 pig :: 4
	 phi :: 3
	 gip :: 3
	  pi :: 3
   }
defined i defined intel compiler defined i defined ia defined stdc version stdc version l define glibc have long long endif this is here only because every header file already includes this one ifndef assembler  {
	                         assembler :: -1000
                                 }
ifndef sys cdefs h include sys cdefs h endif if we don t have redirect prototypes will be missing if use file offset but not use largefile if defined use file offset defined redirect define use largefile define use largefile endif endif assembler decide whether we can define extern inline functions in headers if gnuc prereq defined optimize defined optimize size defined no inline defined extern inline define use extern inlines endif there are some functions that must be declared extern inline even with os when building libc or they ll end up undefined if gnuc prereq defined optimize defined libc defined optimize size defined no inline defined extern inline define use extern inlines in libc endif this is here only because every header file already includes this one get the definitions of all the appropriate stub function symbols gnu stubs  {
	                                                                                                                                       stubs :: -1000
                                                                                                                                           }
h contains define stub function when function is a stub that will always return failure and set errno to enosys  {
	         roughnecks :: -1000
                  }
include gnu stubs h endif features h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa iso c floating point environment fenv  {
	                                                                                                                                              fens :: 5
	                                                                                                                                              feni :: 5
	                                                                                                                                              fend :: 5
	                                                                                                                                               fen :: 6
                                                                                                                                                 }
h ifndef fenv h define fenv h include features h get the architecture dependend  {
	     defended :: 11
	  dependently :: 11
	    dependent :: 13
	   dependance :: 11
	   dependency :: 12
	     depended :: 14
            }
definitions the following definitions are expected to be done fenv t type for object representing an entire floating point environment fe dfl env macro of type pointer to fenv t to be used as the argument to functions taking an argument of type fenv t in this case the default environment will be used fexcept  {
                                                     }
t type for object representing the floating point exception flags including status associated with the flags the following macros are defined iff the implementation supports this kind of exception fe inexact  {
	                       inexact :: -1000
                             }
inexact result fe divbyzero  {
  }
division  {
	division :: -1000
 }
by zero fe underflow  {
	underflow :: -1000
  }
result not representable  {
	representable :: -1000
 }
due to underflow fe overflow  {
	overflow :: -1000
   }
result not representable due to overflow fe invalid invalid operation fe all except bitwise  {
            }
or of all supported exceptions the next macros are defined iff the appropriate rounding  {
	     rounding :: -1000
            }
mode is supported by the implementation fe tonearest  {
	roseate :: 11
	centares :: 11
	tentages :: 11
	tenderest :: 11
	toweriest :: 11
	tonettes :: 11
	tonearms :: 11
	rottenest :: 11
	honestest :: 11
      }
round to nearest fe upward  {
	upward :: -1000
   }
round toward  {
	toward :: -1000
 }
inf fe downward  {
	downward :: -1000
 }
round toward inf fe towardzero  {
	nyet :: -1000
   }
round toward include bits fenv h begin decls floating point exception handling clear the supported exceptions represented by excepts  {
	           excepts :: -1000
                 }
extern int feclearexcept  {
 }
int excepts throw store implementation defined representation  {
	representation :: -1000
     }
of the exception flags indicated by excepts in the object pointed to by flagp  {
	     flapping :: 6
	        flaps :: 6
	        flags :: 7
	     flagship :: 6
	     flagpole :: 6
	       flappy :: 6
	       flagon :: 6
	         flap :: 7
	         flag :: 8
	        plage :: 6
            }
extern int fegetexceptflag  {
 }
fexcept t flagp int excepts throw raise  {
	 raise :: -1000
     }
the supported exceptions represented by excepts extern int feraiseexcept  {
       }
int excepts throw set complete status for exceptions indicated by excepts according to the representation in the object pointed to by flagp extern int fesetexceptflag  {
                       }
const fexcept t flagp int excepts throw determine which of subset of the exceptions specified by excepts are currently set extern int fetestexcept  {
                     }
int excepts throw rounding control get current rounding direction extern int fegetround  {
	foregrounds :: 12
          }
void throw establish  {
	establish :: -1000
 }
the rounding direction represented by round extern int fesetround  {
	deuterons :: 12
	tenebrous :: 12
	frostbound :: 12
	foregrounds :: 12
       }
int rounding direction throw floating point environment store the current floating point environment in the object pointed to by envp  {
	               envy :: 5
                  }
extern int fegetenv  {
	vegete :: 11
 }
fenv t envp throw save the current environment in the object pointed to by envp clear exception flags and install a non stop mode if available for all exceptions extern int feholdexcept  {
                              }
fenv t envp throw establish the floating point environment represented by the object pointed to by envp extern int fesetenv  {
                  }
const fenv t envp throw save current exceptions in temporary storage install environment represented by object pointed to by envp and raise exceptions according to saved  {
	                    saved :: -1000
                        }
exceptions extern int feupdateenv  {
  }
const fenv t envp throw include optimization ifdef optimize include bits fenvinline  {
          }
h endif ifdef use gnu enable individual exceptions will not enable more exceptions than excepts specifies returns the previous enabled exceptions if all exceptions are successfully set otherwise returns extern int feenableexcept  {
                              }
int excepts throw disable  {
	disable :: -1000
  }
individual exceptions will not disable more exceptions than excepts specifies returns the previous enabled exceptions if all exceptions are successfully disabled  {
	            disabled :: -1000
                   }
otherwise returns extern int fedisableexcept  {
   }
int excepts throw return enabled exceptions extern int fegetexcept void throw endif end decls endif fenv h c flexlexer  {
                 }
h define interfaces for lexical  {
	lexical :: -1000
   }
analyzer  {
	analyzer :: -1000
 }
classes generated by flex copyright c the regents  {
	regents :: -1000
      }
of the university of california  {
	californium :: 15
	salicornia :: 16
	calibration :: 12
   }
all rights  {
	rights :: -1000
 }
reserved this code is derived  {
	derived :: -1000
   }
from software contributed  {
	contributed :: -1000
 }
to berkeley  {
 }
by kent  {
	kent :: -1000
 }
williams  {
	willies :: 10
	milliares :: 10
	milliards :: 10
 }
and tom  {
	tom :: -1000
 }
epperly  {
 }
redistribution  {
	redistribution :: -1000
 }
and use in source and binary forms with or without modification  {
	modification :: -1000
         }
are permitted  {
	permitted :: -1000
 }
provided that the following conditions are met redistributions  {
	redistributions :: -1000
      }
of source code must retain the above copyright notice  {
	  notice :: -1000
       }
this list of conditions and the following disclaimer  {
	disclaimer :: -1000
      }
redistributions in binary form must reproduce  {
	reproduce :: -1000
    }
the above copyright notice this list of conditions and the following disclaimer in the documentation and or other materials  {
	         materials :: -1000
                 }
provided with the distribution neither  {
	neither :: -1000
   }
the name of the university nor the names of its contributors  {
	contributors :: -1000
         }
may be used to endorse  {
	endorse :: -1000
   }
or promote  {
	promote :: -1000
 }
products  {
	products :: -1000
 }
derived from this software without specific prior written permission this software is provided as is and without any express or implied warranties  {
	           warranties :: -1000
                    }
including without limitation  {
	limitation :: -1000
 }
the implied warranties of merchantability and fitness for a particular purpose this file defines flexlexer an abstract  {
	        abstract :: -1000
               }
class which specifies the external interface provided to flex c lexer  {
	     lexes :: 7
	     lever :: 7
	     leres :: 6
	     lered :: 6
	     leper :: 7
	     leger :: 7
	     laxer :: 7
	    levers :: 6
	    lepers :: 6
	    legers :: 6
	    sexers :: 6
	     hexer :: 7
	    hexers :: 6
	     vexer :: 7
	      lere :: 7
	      leer :: 6
	     sexer :: 7
	    vexers :: 6
	     rexes :: 6
         }
objects and yyflexlexer  {
 }
which defines a particular lexer class if you want to create multiple lexer classes you use the p flag to rename each yyflexlexer to some other xxflexlexer  {
                         }
you then include flexlexer h in your other sources  {
	 sources :: -1000
       }
once per lexer class undef yyflexlexer define yyflexlexer xxflexlexer include flexlexer h undef yyflexlexer define yyflexlexer zzflexlexer  {
               }
include flexlexer h ifndef flex lexer h never included before need to define base class define flex lexer h include iostream ifndef flex std define flex std std endif extern c struct yy buffer state typedef int yy state type class flexlexer public virtual flexlexer const char yytext  {
                                              }
const return yytext int yyleng  {
   }
const return yyleng virtual void yy switch to buffer struct yy buffer state new buffer virtual struct yy buffer state yy create buffer flex std istream  {
	                   imaret :: 9
	                   mitres :: 9
	                  imarets :: 10
	                   matres :: 9
                        }
s int size virtual void yy delete buffer struct yy buffer state b virtual void yyrestart  {
              }
flex std istream s virtual int yylex  {
	 xylem :: 6
     }
call yylex with new input output sources int yylex flex std istream new in flex std ostream new out switch streams new in new out return yylex switch to new input output streams a nil stream pointer indicates keep the current one virtual void switch streams flex std istream new in flex std ostream new out int lineno const return yylineno  {
                                                           }
int debug const return yy flex debug void set debug int flag yy flex debug flag protected char yytext int yyleng int yylineno only maintained if you use option yylineno int yy flex debug only has effect with d or option debug endif flexlexer h if defined yyflexlexer defined yyflexlexeronce  {
                                                }
either this is the first time through yyflexlexeronce not defined or this is a repeated  {
	      repeated :: -1000
             }
include to define a different flavor of yyflexlexer as discussed  {
	discussed :: -1000
        }
in the flex manual  {
	manual :: -1000
  }
define yyflexlexeronce extern c class yyflexlexer public flexlexer public arg yyin  {
	      pyin :: 5
	      ayin :: 5
         }
and arg yyout  {
 }
default to the cin  {
	finch :: 3
	conia :: 3
	cions :: 3
	cines :: 4
	cinct :: 3
	cinch :: 3
	canid :: 3
	zincy :: 3
	zincs :: 3
	zinco :: 3
	yince :: 3
	cinque :: 3
	cineol :: 3
	cinema :: 3
	cinder :: 3
	winch :: 3
	wince :: 3
	vinca :: 3
	tinct :: 3
	zinc :: 4
	nick :: 3
	nice :: 3
	since :: 3
	coni :: 4
	coin :: 3
	cion :: 4
	cine :: 5
	chin :: 3
	cain :: 3
	pinch :: 3
	mincy :: 3
	mince :: 3
	zin :: 3
	yin :: 3
	win :: 3
	vin :: 3
	tin :: 3
	sin :: 3
	rin :: 3
	pin :: 3
	kin :: 3
	jin :: 3
	hin :: 3
	gin :: 3
	fin :: 3
	din :: 3
	con :: 3
	cit :: 3
	cis :: 3
	cig :: 3
	can :: 3
	bin :: 3
	ain :: 3
	linch :: 3
	linac :: 3
  }
and cout  {
	couth :: 7
	court :: 6
	count :: 6
	couther :: 5
	couthie :: 5
	couters :: 5
	coutil :: 6
	couthy :: 6
	couths :: 6
	couter :: 6
	courts :: 5
	county :: 5
	counts :: 5
	coitus :: 5
	touch :: 5
	tout :: 5
	rout :: 5
	pout :: 5
	lout :: 5
	hout :: 5
	gout :: 5
	coup :: 5
	cott :: 5
	cost :: 5
	cort :: 5
	colt :: 5
	coit :: 5
	coft :: 5
	coat :: 5
	chut :: 5
	bout :: 5
	cot :: 5
 }
but we only make that assignment  {
	assignment :: -1000
    }
when initializing  {
	initializing :: -1000
 }
in yylex yyflexlexer flex std istream arg yyin flex std ostream arg yyout virtual yyflexlexer void yy switch to buffer struct yy buffer state new buffer struct yy buffer state yy create buffer flex std istream s int size void yy delete buffer struct yy buffer state b void yyrestart flex std istream s void yypush  {
                                                      }
buffer state struct yy buffer state new buffer void yypop  {
        }
buffer state virtual int yylex virtual void switch streams flex std istream new in flex std ostream new out virtual int yywrap  {
                    }
protected virtual int lexerinput  {
  }
char buf int max size virtual void lexeroutput  {
      }
const char buf int size virtual void lexererror  {
      }
const char msg void yyunput  {
   }
int c char buf ptr int yyinput  {
     }
void yy load buffer state void yy init buffer struct yy buffer state b flex std istream s void yy flush buffer struct yy buffer state b int yy start stack ptr int yy start stack depth  {
	                               depth :: -1000
                                   }
int yy start stack void yy push state int new state void yy pop state int yy top state yy state type yy get previous state yy state type yy try nul trans yy state type current state int yy get next buffer flex std istream yyin input source for default lexerinput flex std ostream yyout output sink  {
	                                                     sink :: -1000
                                                        }
for default lexeroutput yy hold char holds the character lost when yytext is formed char yy hold char number of characters read into yy ch buf int yy n chars  {
	                overstretched :: -1000
                            }
points to current character in buffer char yy c buf p int yy init whether we need to initialize int yy start start state number flag which is used to allow yywrap s to do buffer switches  {
	                            switches :: -1000
                                   }
instead of setting  {
	setting :: -1000
 }
up a fresh  {
	fresh :: -1000
 }
yyin a bit of a hack int yy did buffer switch on eof size t yy buffer stack top index of top of stack size t yy buffer stack max capacity  {
	                      capacity :: -1000
                             }
of stack struct yy buffer state yy buffer stack stack as an array void yyensure  {
             }
buffer stack void the following are not always needed but may be depending on use of certain flex features like reject  {
	              reject :: -1000
                   }
or yymore  {
	memory :: 7
 }
yy state type yy last accepting  {
	accepting :: -1000
    }
state char yy last accepting cpos  {
	samel :: -1000
    }
yy state type yy state buf yy state type yy state ptr char yy full match int yy full state int yy full lp  {
	                    lop :: 2
	                    lip :: 2
	                    lep :: 2
	                    lap :: 2
	                      l :: 2
                      }
int yy lp int yy looking  {
	looking :: -1000
    }
for trail begin int yy more flag int yy more len int yy more offset int yy prev more offset endif yyflexlexer yyflexlexeronce message display handling copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef fmtmsg  {
                                                                                                                                                                }
h define fmtmsg h include features h begin decls values to control fmtmsg function enum mm hard x source of the condition is hardware define mm hard mm hard mm soft x source of the condition is software define mm soft mm soft mm firm  {
	                                        firm :: -1000
                                           }
x source of the condition is firmware  {
	firmware :: -1000
     }
define mm firm mm firm mm appl x condition detected by application define mm appl mm appl mm util x condition detected by utility define mm util mm util mm opsys  {
	                         padis :: -1000
                             }
x condition detected by operating  {
	operating :: -1000
   }
system define mm opsys mm opsys mm recover x recoverable  {
	recoverable :: -1000
        }
error define mm recover mm recover mm nrecov  {
	 crepon :: 7
      }
x non recoverable error define mm nrecov mm nrecov mm print x display message in standard error define mm print mm print mm console  {
	                console :: -1000
                      }
x display message on system console define mm console mm console values to be for severity  {
	       severity :: -1000
              }
parameter of fmtmsg enum mm nosev  {
	hosen :: 6
	dovens :: 6
	wovens :: 6
	covens :: 6
	 sone :: 6
	 nose :: 8
	 noes :: 6
	novels :: 7
	noyes :: 6
	novel :: 6
	notes :: 6
	nosey :: 7
	noses :: 6
	noser :: 7
	nosed :: 7
	nopes :: 6
	nomes :: 6
	nodes :: 6
	  nos :: 6
    }
no severity level provided for the message define mm nosev mm nosev mm halt  {
	         halt :: -1000
            }
error causing application to halt define mm halt mm halt mm error application has encountered a non fatal fault define mm error mm error mm warning application has detected unusual  {
	                      unusual :: -1000
                            }
non error condition define mm warning mm warning mm info informative  {
	informative :: -1000
         }
message define mm info mm info macros which can be used as null values for the arguments of fmtmsg define mm nulllbl  {
                    }
char define mm nullsev  {
	nulls :: 10
  }
define mm nullmc  {
	pullman :: 7
	mullock :: 7
	mullen :: 7
	null :: 8
	mull :: 7
	nulls :: 7
	nulla :: 7
 }
long int define mm nulltxt  {
   }
char define mm nullact  {
	callant :: 9
	nullas :: 9
	nullah :: 9
	nulla :: 10
  }
char define mm nulltag  {
	nutgall :: 9
	gallnut :: 9
	nulla :: 9
  }
char possible return values of fmtmsg enum mm notok  {
	   kotos :: 6
	    toko :: 6
	    nook :: 6
	    koto :: 7
	  notour :: 6
       }
define mm notok mm notok mm ok define mm ok mm ok mm nomsg  {
	         noms :: 8
	         nogs :: 7
	         mons :: 6
	         mogs :: 6
	        nomes :: 6
	        nomas :: 6
	        mongs :: 6
	          nom :: 6
            }
define mm nomsg mm nomsg mm nocon  {
	netsuke :: -1000
     }
define mm nocon mm nocon print message with given classification  {
	classification :: -1000
        }
label severity text action  {
	action :: -1000
  }
and tag to console or standard error extern int fmtmsg long int classification const char label int severity const char text const char action const char tag ifdef use svid add or remove severity level extern int addseverity  {
                                    }
int severity const char string throw endif end decls endif fmtmsg h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef fnmatch  {
	                                                                                                                                          unmatched :: 9
                                                                                                                                                  }
h define fnmatch h ifdef cplusplus extern c endif ifndef const if defined stdc stdc defined cplusplus define const const else define const endif endif we undef these before defining them because some losing  {
	                           losing :: -1000
                                }
systems hp ux a for example define these in unistd h undef fnm pathname undef fnm noescape  {
	       conepates :: 10
	       notecases :: 10
	        kneecaps :: 10
	        notecase :: 11
               }
undef fnm period  {
	period :: -1000
 }
bits set in the flags argument to fnmatch define fnm pathname no wildcard  {
	    wildcard :: -1000
           }
can ever match define fnm noescape backslashes  {
	backslashes :: -1000
     }
don t quote special chars define fnm period leading is matched  {
	   matched :: -1000
         }
only explicitly if defined posix c source posix c source defined gnu source define fnm file name fnm pathname preferred  {
	          preferred :: -1000
                  }
gnu name define fnm leading dir ignore after a match define fnm casefold  {
	    gatefold :: 10
	  scaffolder :: 10
	    caseload :: 11
	    fasciole :: 10
	    scaffold :: 10
           }
compare without regard to case define fnm extmatch  {
	outmatch :: 10
	outmatches :: 10
	outmatched :: 10
      }
use ksh  {
	kohls :: 3
	kish :: 3
	khis :: 3
	kesh :: 3
	ish :: 3
	ash :: 3
 }
like extended matching endif value returned by fnmatch if string does not match pattern define fnm nomatch  {
	        nomarchy :: 10
	        nomarchs :: 10
	         monarch :: 9
	         nomarch :: 11
               }
this value is returned if the implementation does not support fnmatch since this is not the case here it will never be returned but the conformance test suites  {
	                     suites :: -1000
                          }
still require the symbol to be defined ifdef xopen source define fnm nosys  {
	       gonys :: 6
	       sonsy :: 6
	        noys :: 6
	        nosy :: 7
	       noyes :: 6
	      noseys :: 7
	       noses :: 7
           }
endif match name against the filename pattern pattern returning zero if it matches  {
	     matches :: -1000
           }
fnm nomatch if not extern int fnmatch const char pattern const char name int flags ifdef cplusplus endif endif fnmatch h copyright c the regents of the university of california all rights reserved redistribution and use in source and binary forms with or without modification are permitted provided that the following conditions are met redistributions of source code must retain the above copyright notice this list of conditions and the following disclaimer redistributions in binary form must reproduce the above copyright notice this list of conditions and the following disclaimer in the documentation and or other materials provided with the distribution neither the name of the university nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission this software is provided by the regents and contributors as is and any express or implied warranties including but not limited  {
	                                                                                                                                              oolakans :: -1000
                                                                                                                                                     }
to the implied warranties of merchantability and fitness for a particular purpose are disclaimed  {
	   disclaimed :: -1000
            }
in no event shall the regents or contributors be liable  {
	   liable :: -1000
        }
for any direct indirect incidental  {
	incidental :: -1000
   }
special exemplary  {
	exemplary :: -1000
 }
or consequential  {
	consequential :: -1000
 }
damages  {
	damages :: -1000
 }
including but not limited to procurement  {
	procurement :: -1000
    }
of substitute  {
	substitute :: -1000
 }
goods  {
	goods :: -1000
 }
or services  {
	services :: -1000
 }
loss  {
	loss :: -1000
 }
of use data or profits  {
	profits :: -1000
   }
or business  {
	business :: -1000
 }
interruption  {
	interruption :: -1000
 }
however caused  {
	caused :: -1000
 }
and on any theory  {
	theory :: -1000
  }
of liability  {
	liability :: -1000
 }
whether in contract  {
	contract :: -1000
 }
strict liability or tort  {
	tort :: -1000
  }
including negligence  {
	negligence :: -1000
 }
or otherwise arising  {
	arising :: -1000
 }
in any way out of the use of this software even if advised  {
	     advised :: -1000
           }
of the possibility  {
	possibility :: -1000
 }
of such damage fstab  {
	fetas :: 6
	fats :: 6
  }
h berkeley ifndef fstab h define fstab h include features h file system table see fstab used by dump  {
	             scary :: -1000
                 }
mount  {
	mount :: -1000
 }
umount  {
	amount :: 9
	amounted :: 7
	amounts :: 8
 }
swapon  {
	weapons :: 9
	peason :: 7
	weason :: 7
	weapon :: 8
	swaption :: 8
	swankpot :: 7
	swap :: 8
	swan :: 7
	soap :: 7
	snap :: 7
	spawn :: 7
 }
fsck  {
	fecks :: 6
	feck :: 5
 }
df for ufs  {
	ufos :: 4
	fuse :: 3
	uts :: 3
	urs :: 3
	uns :: 3
	ums :: 3
	ugs :: 3
	ufo :: 3
	uds :: 3
	ifs :: 3
	efs :: 3
	us :: 3
 }
fs spec field is the block special name programs that want to use the character special name must create that name by prepending  {
	                 tutti :: -1000
                     }
a r after the right most slash  {
	 slash :: -1000
     }
quota  {
	quota :: -1000
 }
files are always named  {
	named :: -1000
  }
quotas  {
	quotas :: -1000
 }
so if type is rq  {
	   r :: 2
   }
then use concatenation of fs file and quotas to locate  {
	   locate :: -1000
        }
quota file define path fstab etc fstab define fstab etc fstab deprecated define fstab rw rw read write device  {
	            device :: -1000
                 }
define fstab rq rq read write with quotas define fstab ro ro read only device define fstab sw sw swap device define fstab xx xx ignore totally  {
	                   totally :: -1000
                         }
struct fstab char fs spec block special device name char fs file file system path prefix char fs vfstype  {
                 }
file system type ufs nfs  {
	nefs :: 3
	 nos :: 3
	 nis :: 3
	 nas :: 3
	 ifs :: 3
	 efs :: 3
	  ns :: 3
   }
char fs mntops  {
	netops :: 8
	mutons :: 8
	pitons :: 7
	metopes :: 7
	putons :: 7
 }
mount options ala  {
	ala :: -1000
 }
o const char fs type fstab from fs mntops int fs freq dump frequency in days  {
	           days :: -1000
              }
int fs passno  {
	password :: 7
	passioning :: 7
	passions :: 7
	casinos :: 7
	passout :: 7
	passmen :: 7
	passing :: 7
	passion :: 10
	parsons :: 7
	basons :: 7
	paseos :: 7
	parson :: 7
	paeons :: 7
	parisons :: 7
	poss :: 7
	pass :: 8
	bassoon :: 7
	passe :: 7
	passional :: 7
	passioned :: 8
 }
pass number on parallel dump begin decls extern struct fstab getfsent  {
	  gentlest :: 10
         }
void throw extern struct fstab getfsspec  {
    }
const char name throw extern struct fstab getfsfile  {
      }
const char name throw extern int setfsent  {
	setenants :: 10
	sentients :: 10
     }
void throw extern void endfsent  {
   }
void throw end decls endif fstab h ft  {
	    fit :: 2
	    fet :: 2
	    fat :: 2
	      f :: 2
      }
build h build macros of the freetype  {
	freety :: 10
     }
library copyright by david  {
	gadid :: 6
	dived :: 6
	davit :: 6
	divide :: 6
	dividual :: 6
	dividant :: 6
	vapid :: 6
	valid :: 6
	pavid :: 7
	madid :: 6
  }
turner  {
	turner :: -1000
 }
robert  {
	borer :: 8
	robuster :: 8
	roburite :: 8
	retort :: 7
	resort :: 7
	report :: 7
	reborn :: 7
	rebore :: 7
	rebirth :: 7
	robertsman :: 8
	rore :: 7
	robe :: 7
	sober :: 7
	rower :: 7
	rover :: 7
	roper :: 7
	roker :: 7
	roger :: 7
	obvert :: 7
	arboret :: 7
	borers :: 7
 }
wilhelm  {
 }
and werner  {
	weiners :: 8
	earner :: 8
	nerver :: 8
	nearer :: 7
	wearers :: 7
	weaners :: 8
	wiener :: 8
	weiner :: 9
	wearer :: 8
	weaner :: 9
	wieners :: 7
	warners :: 8
	fernery :: 8
	renter :: 7
	render :: 7
	warren :: 7
	warner :: 9
	western :: 7
	ween :: 7
	wernerite :: 7
	earners :: 7
	nervers :: 7
 }
lemberg  {
	lamber :: 9
	remble :: 9
	member :: 9
	limber :: 9
 }
this file is part of the freetype project  {
	project :: -1000
      }
and may only be used modified and distributed under the terms of the freetype project license license txt by continuing  {
	         continuing :: -1000
                  }
to use modify or distribute this file you indicate that you have read the license and understand  {
	      understand :: -1000
               }
and accept it fully this is a unix specific version of ft build h that should be used exclusively  {
	       exclusively :: -1000
                 }
after installation  {
	installation :: -1000
 }
of the library it assumes  {
	assumes :: -1000
   }
that usr  {
	usher :: 3
	user :: 4
	ursa :: 3
	urns :: 3
	surf :: 3
	sure :: 3
	surd :: 3
	sura :: 3
	purs :: 3
	ours :: 3
	nurs :: 3
	lurs :: 3
	curs :: 3
	burs :: 3
	use :: 3
	urs :: 4
	us :: 4
	ur :: 3
 }
local include freetype or whatever is returned by the freetype config cflags  {
	      calfs :: 7
	     clangs :: 7
	     oflags :: 9
	     califs :: 7
	      oflag :: 7
          }
or pkg  {
	pug :: 3
	pig :: 3
	peg :: 3
 }
config cflags command is in your compilation include path we don t need to do anything special in this release however for a future  {
	                 future :: -1000
                      }
freetype release the following installation changes  {
	phenetols :: -1000
    }
will be performed the contents of freetype x include freetype will be installed to usr local include freetype instead of usr local include freetype freetype this file will include freetype config ftheader  {
	                       threader :: 11
	                       threaden :: 10
	                       defeater :: 10
	                       reheated :: 10
	                      threaders :: 10
	                       fathered :: 10
                              }
h instead of freetype config ftheader h the contents of ftheader h will be processed with sed  {
	             sed :: -1000
               }
to replace all freetype xxx with freetype xxx adding  {
	  adding :: -1000
       }
usr local include freetype to your compilation include path will not be necessary anymore  {
	      anymore :: -1000
            }
these changes will be transparent  {
	transparent :: -1000
   }
to client applications which use freetype config or pkg config no modifications  {
	modifications :: -1000
          }
will be necessary to compile with the new scheme  {
	  scheme :: -1000
       }
ifndef ft build unix h define ft build unix h prefix include freetype must be in your current inclusion  {
	         inclusion :: -1000
                 }
path include freetype config ftheader h endif ft build unix h end copyright c the regents of the university of california all rights reserved redistribution and use in source and binary forms with or without modification are permitted provided that the following conditions are met redistributions of source code must retain the above copyright notice this list of conditions and the following disclaimer redistributions in binary form must reproduce the above copyright notice this list of conditions and the following disclaimer in the documentation and or other materials provided with the distribution neither the name of the university nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission this software is provided by the regents and contributors as is and any express or implied warranties including but not limited to the implied warranties of merchantability and fitness for a particular purpose are disclaimed in no event shall the regents or contributors be liable for any direct indirect incidental special exemplary or consequential damages including but not limited to procurement of substitute goods or services loss of use data or profits or business interruption however caused and on any theory of liability whether in contract strict liability or tort including negligence or otherwise arising in any way out of the use of this software even if advised of the possibility of such damage fts  {
	                                                                                                                                                                                                                                      fusty :: 3
	                                                                                                                                                                                                                                      fisty :: 3
	                                                                                                                                                                                                                                      festa :: 3
	                                                                                                                                                                                                                                      fasti :: 3
	                                                                                                                                                                                                                                       fits :: 3
	                                                                                                                                                                                                                                       fist :: 4
	                                                                                                                                                                                                                                       fets :: 3
	                                                                                                                                                                                                                                       fats :: 3
	                                                                                                                                                                                                                                       fast :: 4
	                                                                                                                                                                                                                                        uts :: 3
	                                                                                                                                                                                                                                        its :: 3
	                                                                                                                                                                                                                                        fas :: 3
	                                                                                                                                                                                                                                        ats :: 3
	                                                                                                                                                                                                                                         st :: 3
                                                                                                                                                                                                                                          }
h berkeley ifndef fts h define fts h include features h include sys types h the fts interface is incompatible  {
	       incompatible :: -1000
                  }
with the lfs interface which transparently  {
	transparently :: -1000
    }
uses the bit file access functions ifdef use file offset error fts h cannot be used with d file offset bits endif typedef struct struct ftsent  {
	                   fustet :: 7
	                   funest :: 7
	                   ostent :: 7
	                   finest :: 7
	                  foments :: 7
	                  fluents :: 7
	                 fistnote :: 7
                        }
fts cur current node struct ftsent fts child linked  {
	  linked :: -1000
       }
list of children struct ftsent fts array sort array dev t fts dev starting device char fts path path for this descent  {
	              descent :: -1000
                    }
int fts rfd fd for root int fts pathlen  {
	  lathen :: 9
	 pantler :: 9
	patulent :: 9
	  hantle :: 9
	nathless :: 9
	pathless :: 10
       }
sizeof path int fts nitems  {
	inters :: 7
	bitumens :: 7
	nitres :: 8
	niters :: 9
	nicest :: 7
	entrism :: 7
	mizens :: 7
	mixens :: 7
	mitres :: 7
	miters :: 8
	miners :: 7
	tineas :: 7
	timers :: 7
	tines :: 7
	times :: 7
	nits :: 7
	nite :: 8
	mite :: 7
	limens :: 7
	nites :: 9
	niter :: 7
	mites :: 8
	mines :: 7
   }
elements in the sort array int fts compar const void const void compare fn define fts comfollow  {
               }
x follow command line symlinks  {
	simlins :: 10
	soymilks :: 10
	cymlings :: 10
	cymlins :: 10
	skylines :: 11
   }
define fts logical  {
	logical :: -1000
 }
x logical walk  {
	walk :: -1000
 }
define fts nochdir  {
 }
x don t change directories define fts nostat  {
	rottans :: 7
	costate :: 8
	unstate :: 7
	costated :: 7
	contacts :: 7
	instate :: 7
	testation :: 7
	gestation :: 7
	gustation :: 7
	nougats :: 7
      }
x don t get stat info define fts physical x physical walk define fts seedot  {
	        sedent :: 7
	         deets :: 7
	      epidotes :: 7
	      deodates :: 7
	       cestode :: 7
	      feedlots :: 7
	       reedits :: 7
	         stede :: 7
	          teed :: 7
	          sted :: 7
	          seed :: 8
	       seedbox :: 7
	      sectored :: 7
             }
x return dot  {
	dot :: -1000
 }
and dot dot define fts xdev  {
    }
x don t cross  {
	cross :: -1000
  }
devices  {
	devices :: -1000
 }
define fts whiteout  {
	whiteout :: -1000
 }
x return whiteout information define fts optionmask  {
	optionees :: 12
	option :: 12
	optional :: 12
	options :: 13
     }
x ff valid user option mask define fts nameonly  {
       }
x private child names only define fts stop x private unrecoverable  {
	unrecoverable :: -1000
         }
error int fts options fts open options global flags fts typedef struct ftsent struct ftsent fts cycle  {
	           cycle :: -1000
               }
cycle node struct ftsent fts parent parent directory struct ftsent fts link next file in directory long fts number local numeric value void fts pointer local address value char fts accpath  {
                             }
access path char fts path root path int fts errno errno for this node int fts symfd  {
               }
fd for symlink u short fts pathlen strlen fts path u short fts namelen  {
	     cameleon :: 9
	     nameless :: 9
	     cameline :: 9
            }
strlen fts name ino t fts ino inode  {
	 intoed :: 7
	  irone :: 6
	  indue :: 6
	 indole :: 6
	  diode :: 6
	  anode :: 7
	 anodes :: 6
	 hoiden :: 6
	inorbed :: 6
	 emodin :: 6
	  snide :: 6
	 ironed :: 7
      }
dev t fts dev device nlink t fts nlink link count define fts rootparentlevel  {
            }
define fts rootlevel  {
 }
short fts level depth to n define fts d preorder  {
	 preorder :: -1000
        }
directory define fts dc directory that causes cycles  {
	 cycles :: -1000
      }
define fts default none of the above define fts dnr  {
	      dob :: -1000
        }
unreadable  {
	unreadable :: -1000
 }
directory define fts dot dot or dot dot define fts dp postorder  {
	 protoderms :: 11
	  protrudes :: 11
	 potholders :: 12
	posteriorly :: 11
	  postrider :: 13
	 portioners :: 11
	   postcode :: 12
	  posterior :: 13
	  potholder :: 11
	 postmodern :: 13
	 posteriors :: 11
	   portoise :: 11
	 torpedoers :: 11
          }
directory define fts err error errno is set define fts f regular  {
	    regular :: -1000
          }
file define fts init initialized only define fts ns stat failed define fts nsok  {
	        snoke :: 5
	         nook :: 5
	        norks :: 5
	        nooks :: 6
	        nocks :: 5
            }
no stat requested define fts sl symbolic link define fts slnone  {
	    xenons :: 7
	   pinones :: 7
	    pleons :: 7
	   ionones :: 7
	    tenons :: 7
	     solen :: 7
	  longness :: 7
	  loneness :: 7
         }
symbolic link without target define fts w whiteout object u short fts info user flags for ftsent structure define fts dontchdir  {
                   }
x don t chdir  {
	cider :: 6
	choir :: 7
	chirr :: 6
	chair :: 7
	choired :: 7
	chirred :: 6
	choirs :: 6
	chider :: 6
	chairs :: 6
	chadri :: 7
	chaired :: 7
	chid :: 6
  }
to the parent define fts symfollow  {
    }
x followed a symlink to get here u short fts flags private flags for ftsent structure define fts again read node again define fts follow follow symbolic link define fts noinstr  {
	                         noint :: 9
	                        noints :: 10
                             }
no instructions  {
	instructions :: -1000
 }
define fts skip discard  {
	discard :: -1000
  }
node u short fts instr fts set instructions struct stat fts statp  {
	    startup :: 6
	     statue :: 6
	     stator :: 6
	     static :: 6
	     stater :: 6
	     stated :: 6
	      stats :: 6
	      state :: 7
	      start :: 6
	      stamp :: 6
	       stat :: 8
	       stap :: 6
	       spat :: 7
	      spate :: 6
          }
stat information char fts name file name ftsent begin decls ftsent fts children fts int int fts close fts fts fts open char const int int const ftsent const ftsent ftsent fts read fts int fts set fts ftsent int throw end decls endif fts h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa x open portability  {
	                                                                                                                                                                           portability :: -1000
                                                                                                                                                                                     }
guide  {
	guide :: -1000
 }
ftw  {
	fug :: -1000
 }
h ifndef ftw h define ftw h include features h include sys types h include sys stat h begin decls values for the flag argument to the user function passed to ftw and nftw  {
	                   agglomerations :: -1000
                                }
enum ftw f regular file define ftw f ftw f ftw d directory define ftw d ftw d ftw dnr unreadable directory define ftw dnr ftw dnr ftw ns unstatable  {
	                   statutable :: 14
	                   unsatiable :: 15
	                   unslakable :: 14
	                   insatiable :: 12
	                   insultable :: 13
	                    unsatable :: 12
	                   untestable :: 15
	                   unscalable :: 14
	                   unsaleable :: 13
	                      unstate :: 12
	                   unsuitable :: 13
	                   intuitable :: 12
	                   unswayable :: 14
	                    sultanate :: 12
	                   untearable :: 13
	                   unbeatably :: 13
	                   unbeatable :: 14
	                   unerasable :: 13
	                   unlettable :: 13
	                  inflatables :: 12
	                   unshakable :: 14
	                   untameable :: 12
	                   unpassable :: 12
                            }
file define ftw ns ftw ns if defined use bsd defined use xopen extended ftw sl symbolic link define ftw sl ftw sl endif ifdef use xopen extended these flags are only passed from the nftw function ftw dp directory all subdirs  {
	                                suberised :: 9
	                                  sardius :: 9
	                                  siddurs :: 9
	                                  subside :: 9
	                                  subsidy :: 9
	                                 subsider :: 10
	                                  burdies :: 9
	                                subdorsal :: 9
	                                 sunbirds :: 10
	                                  sundris :: 9
                                        }
have been visited  {
	visited :: -1000
 }
define ftw dp ftw dp ftw sln symbolic link naming  {
	   naming :: -1000
        }
non existing file define ftw sln ftw sln endif extended x open ifdef use xopen extended flags for fourth  {
	            fourth :: -1000
                 }
argument of nftw enum ftw phys perform physical walk ignore symlinks define ftw phys ftw phys ftw mount report only files on same file system as the argument define ftw mount ftw mount ftw chdir change to current directory while processing it define ftw chdir ftw chdir ftw depth report files in directory before directory itself define ftw depth ftw depth ifdef use gnu ftw actionretval  {
                                                                }
assume callback to return ftw values instead of zero to continue and non zero to terminate define ftw actionretval ftw actionretval endif ifdef use gnu return values from callback functions enum ftw continue continue with next sibling  {
	                             sibling :: -1000
                                   }
or for ftw d with the first child define ftw continue ftw continue ftw stop return from ftw or nftw with ftw stop as return value define ftw stop ftw stop ftw skip subtree  {
	                        outbreeds :: 9
	                          subtler :: 9
	                          subteen :: 9
	                           tubers :: 9
	                         subtrend :: 9
	                         subtiler :: 9
	                         subtheme :: 9
	                       subprefect :: 9
	                         tuberose :: 9
	                         suberate :: 10
	                         suberect :: 10
	                         gumtrees :: 9
	                            suber :: 9
	                         subbreed :: 9
                                }
only meaningful  {
	meaningful :: -1000
 }
for ftw d don t walk through the subtree instead just continue with its next sibling define ftw skip subtree ftw skip subtree ftw skip siblings  {
	                 siblings :: -1000
                        }
continue with ftw dp callback for current directory if ftw depth and then its siblings define ftw skip siblings ftw skip siblings endif structure used for fourth argument to callback function for nftw struct ftw int base int level endif extended x open convenient types for callback functions typedef int ftw func t const char filename const struct stat status int flag ifdef use largefile typedef int ftw func t const char filename const struct stat status int flag endif ifdef use xopen extended typedef int nftw func t const char filename const struct stat status int flag struct ftw info ifdef use largefile typedef int nftw func t const char filename const struct stat status int flag struct ftw info endif endif call a function on every element in a directory tree  {
	                                                                                                                                tree :: -1000
                                                                                                                                   }
this function is a possible cancellation point and therefore not marked with throw ifndef use file offset extern int ftw const char dir ftw func t func int descriptors  {
	                 descriptors :: -1000
                           }
nonnull else ifdef redirect extern int redirect ftw const char dir ftw func t func int descriptors ftw nonnull else define ftw ftw endif endif ifdef use largefile extern int ftw const char dir ftw func t func int descriptors nonnull endif ifdef use xopen extended call a function on every element in a directory tree flag allows to specify the behaviour more detailed  {
	                                                       detailed :: -1000
                                                              }
this function is a possible cancellation point and therefore not marked with throw ifndef use file offset extern int nftw const char dir nftw func t func int descriptors int flag nonnull else ifdef redirect extern int redirect nftw const char dir nftw func t func int descriptors int flag nftw nonnull else define nftw nftw endif endif ifdef use largefile extern int nftw const char dir nftw func t func int descriptors int flag nonnull endif endif end decls endif ftw h this file is needed by libio  {
	                                                                                 libidos :: 7
	                                                                                 bilious :: 6
	                                                                                    lobi :: 7
	                                                                                  libido :: 8
	                                                                                   libri :: 6
                                                                                       }
to define various configuration parameters these are always the same in the gnu c library ifndef g config h define g config h define types for libio in terms of the standard internal type names include bits types h define need size t if defined libc defined glibcpp  {
                                              }
use wchar t define need wchar t endif define need null include stddef h define need mbstate  {
	         bistate :: 10
               }
t if defined libc defined glibcpp use wchar t define need wint  {
	    wintled :: 5
	    wintles :: 5
	    wintery :: 5
	    winters :: 5
	     wintry :: 6
	     wintle :: 6
	     winter :: 6
	      witan :: 5
	       wist :: 5
	       winy :: 5
	       wins :: 5
	       wino :: 5
	       wink :: 5
	       wing :: 5
	       wine :: 5
	       wind :: 5
	       wilt :: 5
	       went :: 5
	       want :: 5
	       vint :: 5
	       tint :: 5
	       pint :: 5
	       mint :: 5
	       lint :: 5
	       hint :: 5
	       dint :: 5
	       bint :: 5
	        wit :: 5
	        win :: 6
	        tin :: 5
          }
t endif include wchar h define g size t size t typedef struct off t pos mbstate t state g fpos  {
	               flops :: 5
	                fops :: 6
	                epos :: 5
                   }
t typedef struct off t pos mbstate t state g fpos t define g ssize t ssize t define g off t off t define g off t off t define g pid  {
	                             pht :: -1000
                               }
t pid t define g uid t uid t define g wchar t wchar t define g wint t wint t define g stat stat if defined libc defined glibcpp use wchar t include gconv  {
                                 }
h typedef union struct gconv info cd struct struct gconv info cd struct gconv step data data combined  {
	      domiciliary :: -1000
                }
g iconv  {
	icons :: 7
	ovonic :: 6
	icones :: 6
	cion :: 6
 }
t endif typedef int g int t attribute mode hi typedef int g int t attribute mode si typedef unsigned int g uint t attribute mode hi typedef unsigned int g uint t attribute mode si define g have bool these library features are always available in the gnu c library define g have atexit  {
	                                                atwixt :: 7
                                                     }
define g have sys cdefs define g have sys wait define g need stdarg h define g va list gnuc va list define g have printf fp define g have mmap define g have mremap  {
	                            premia :: 7
	                            preman :: 8
	                            preamp :: 7
	                          mapmaker :: 7
	                             trema :: 7
                                 }
define g have long double io define g have io file open define g have io getline  {
	         telaine :: 9
	        jetliner :: 10
	        setlines :: 10
	       negligent :: 9
	       jetliners :: 9
	         neglige :: 9
	        gentiles :: 10
	         keeling :: 9
	         heeling :: 9
	         setline :: 11
	         reeling :: 9
	         penlite :: 9
	         feeling :: 9
	         ettling :: 9
	         seeling :: 9
	         gentile :: 11
	         netlike :: 10
	         peeling :: 9
               }
info define g io io file version x define g open open define g lseek  {
	         leeks :: 6
	         gleek :: 6
	         cleek :: 6
	        kneels :: 6
	        cleeks :: 7
	         steek :: 6
	          slee :: 6
	          skee :: 6
	         smeek :: 6
	         sleek :: 8
	          leke :: 6
	        sleeky :: 7
	        sleeks :: 7
	        gleeks :: 7
	        skeely :: 6
	       sleekit :: 6
	       sleekly :: 6
             }
lseek define g mmap mmap define g fstat  {
	 fettas :: 6
	 estate :: 6
      }
fd buf fxstat  {
 }
stat ver fd buf this is defined by bits stat h if st blksize  {
            }
exists define g have st blksize defined statbuf  {
      }
st blksize define g bufsiz  {
   }
these are the vtbl  {
	rhomboideus :: -1000
  }
details for elf define g names have underscore  {
	underscore :: -1000
      }
define g vtable label has length define g using thunks  {
	   thunks :: -1000
        }
define g vtable label prefix vt define g vtable label prefix id vt if defined cplusplus defined stdc define g args arglist  {
	              orgiast :: 9
	               argles :: 9
	               argils :: 10
	             anglists :: 9
	              oralist :: 10
	              realist :: 9
	               gratis :: 9
                    }
arglist else define g args arglist endif endif g config h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa this header provides  {
	                                                                                                                                           provides :: -1000
                                                                                                                                                  }
no interface for a user to the internals  {
	internals :: -1000
      }
of the gconv implementation in the libc therefore there is no use for these definitions beside  {
	         beside :: -1000
              }
for writing additional gconv modules ifndef gconv h define gconv h include features h define need mbstate t define need wint t include wchar h define need size t define need wchar t include stddef h iso value used to signal invalid value define unknown char wchar t xfffd  {
                                               }
error codes for gconv functions enum gconv ok gconv noconv  {
	destructionist :: -1000
        }
gconv nodb  {
	nods :: 5
	nodi :: 5
	node :: 5
	bond :: 5
	nod :: 6
	nob :: 5
	bod :: 5
 }
gconv nomem  {
	moment :: 6
	nome :: 7
	mome :: 6
	nomes :: 6
	modem :: 6
 }
gconv empty input gconv full output gconv illegal input gconv incomplete input gconv illegal descriptor gconv internal error flags the gconv open function can set enum gconv is last x gconv ignore errors x gconv swap x forward  {
	                              forward :: -1000
                                    }
declarations struct gconv step struct gconv step data struct gconv loaded object struct gconv trans data type of a conversion function typedef int gconv fct struct gconv step struct gconv step data const unsigned char const unsigned char unsigned char size t int int type of a specialized  {
	                                    specialized :: -1000
                                              }
conversion function for a single byte to internal typedef wint t gconv btowc  {
           }
fct struct gconv step unsigned char constructor and destructor for local data for conversion step typedef int gconv init fct struct gconv step typedef void gconv end fct struct gconv step type of a transliteration  {
	                   transliteration :: -1000
                                 }
transscription  {
	transcriptions :: 19
 }
function typedef int gconv trans fct struct gconv step struct gconv step data void const unsigned char const unsigned char const unsigned char unsigned char size t function to call to provide transliteration module with context typedef int gconv trans context fct void const unsigned char const unsigned char unsigned char unsigned char function to query  {
	                                                  query :: -1000
                                                      }
module about supported encoded character sets typedef int gconv trans query fct const char const char size t constructor and destructor for local data for transliteration typedef int gconv trans init fct void const char typedef void gconv trans end fct void struct gconv trans data transliteration transscription function gconv trans fct trans fct gconv trans context fct trans context fct gconv trans end fct trans end fct void data struct gconv trans data next description of a conversion step struct gconv step struct gconv loaded object shlib handle const char modname  {
	                                                                                   madwomen :: 10
	                                                                                   misnamed :: 9
                                                                                          }
int counter  {
	counter :: -1000
 }
char from name char to name gconv fct fct gconv btowc fct btowc fct gconv init fct init fct gconv end fct end fct information about the number of bytes needed or produced  {
	                        produced :: -1000
                               }
in this step this helps optimizing the buffer sizes int min needed from int max needed from int min needed to int max needed to flag whether this is a stateful  {
	                      plateful :: 10
	                     platefuls :: 11
	                      hasteful :: 11
	                      wasteful :: 11
	                      tasteful :: 13
	                    tastefully :: 10
	                     stagefuls :: 10
	                      startful :: 12
	                      spadeful :: 10
	                       stately :: 10
	                        statue :: 10
	                         state :: 10
	                      feastful :: 10
	                      stageful :: 12
	                      grateful :: 10
	                      spiteful :: 10
	                      shameful :: 10
                             }
encoding or not int stateful void data pointer to step local data additional data for steps  {
	          steps :: -1000
              }
in use of conversion descriptor this is allocated by the init function struct gconv step data unsigned char outbuf  {
	         outbluffs :: 7
	          outburns :: 7
	          outbully :: 7
	          outbulks :: 7
	          outbuild :: 7
	          outbluff :: 8
	            outbuy :: 9
	         outfumble :: 7
	           outbuys :: 8
	           outburn :: 8
	           outbulk :: 8
                 }
output buffer for this step unsigned char outbufend  {
	outburned :: 13
	outbulked :: 11
      }
address of first byte after the output buffer is this the last module in the chain int flags counter for number of invocations  {
	           invocations :: -1000
                     }
of the module function for this descriptor int invocation counter flag whether this is an internal use of the module in the mb towc  {
	                   towy :: 5
	                   tows :: 5
	                   town :: 5
	                   torc :: 5
	                    tow :: 6
	                    cow :: 5
                      }
and wc tomb  {
	tomb :: -1000
 }
functions or regular with iconv int internal use mbstate t statep  {
	    prates :: 7
	    plates :: 7
	   patters :: 7
	   pattens :: 7
	   spattee :: 7
	   spatted :: 7
	   spatter :: 7
	    pattes :: 8
	  statedly :: 7
	   stature :: 7
	   statued :: 7
	   stative :: 7
	   statice :: 7
	   staters :: 7
	   stately :: 8
	    statue :: 8
	    states :: 8
	    stater :: 9
	    stated :: 9
	     teats :: 7
	     stept :: 7
	     state :: 10
	     taste :: 7
	      stet :: 7
	      stat :: 8
	      spat :: 7
	      seat :: 7
	     spate :: 9
	     slate :: 7
	     skate :: 7
	     septa :: 7
	    spathe :: 7
	    spates :: 7
	     peats :: 7
	     patte :: 7
	     paste :: 7
         }
mbstate t state this element must not be used directly by any module always use statep transliteration information struct gconv trans data trans combine conversion step description with data typedef struct gconv info size t nsteps  {
	                             setups :: 7
	                             netops :: 8
	                             aspens :: 7
	                             patens :: 7
	                             estops :: 8
	                             streps :: 7
	                             steeps :: 7
                                  }
struct gconv step steps extension struct gconv step data data flexarr  {
	   flaxier :: 9
         }
gconv t endif gconv h gcrypt  {
    }
h gnu cryptographic  {
	cryptographic :: -1000
 }
library interface c copyright c free software foundation inc this file is part of libgcrypt  {
             }
libgcrypt is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version libgcrypt is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with this program if not see http  {
	                                                                                            podites :: -1000
                                                                                                  }
www  {
 }
gnu org licenses  {
	licenses :: -1000
 }
file src gcrypt h generated from gcrypt h in by configure ifndef gcrypt h define gcrypt h include stdlib h include stdarg h include string h include gpg  {
	                 garishness :: -1000
                          }
error h include sys types h if defined win defined win include winsock  {
	    windsock :: 9
	    windocks :: 12
	     winnock :: 10
	     windock :: 11
	    winnocks :: 11
           }
h include ws tcpip  {
  }
h include time h ifndef gnuc typedef long ssize t typedef int pid t endif gnuc else include sys socket  {
	             socket :: -1000
                  }
h include sys time h include sys select h endif win typedef socklen  {
	      sickle :: 9
	    locksmen :: 9
	    rockless :: 9
	    sockless :: 9
	      cockle :: 9
	     lockmen :: 10
	      suckle :: 9
	     slocken :: 10
	     sockmen :: 11
	     cockles :: 10
           }
t gcry socklen t this is required for error code compatibility define gcry err source default gpg err source gcrypt ifdef cplusplus extern c if keep emacsens  {
	                   encases :: 10
                         }
auto indent  {
	indent :: -1000
 }
happy  {
	happy :: -1000
 }
endif endif the version of this header should match the one of the library it should not be used by a program because gcry check version should return the same version the purpose of this macro is to let  {
	                                   let :: -1000
                                     }
autoconf  {
	autocoid :: 10
	autonomic :: 10
 }
using the am path gcrypt macro check that this header matches the installed library define gcrypt version internal we can t use the convenience macros for the multi precision  {
	                   precision :: -1000
                           }
integer functions when building this library ifdef gcrypt in libgcrypt ifndef gcrypt no mpi  {
	          moy :: -1000
            }
macros define gcrypt no mpi macros endif endif we want to use gcc attributes when possible warning don t use these macros in your programs as indicated by the leading underscore they are subject  {
	                          subject :: -1000
                                }
to change without notice ifdef gnuc define gcry gcc version gnuc gnuc minor gnuc patchlevel  {
             }
if gcry gcc version define gcry gcc attr deprecated attribute deprecated endif if gcry gcc version define gcry gcc attr pure attribute pure endif if gcry gcc version define gcry gcc attr malloc attribute malloc endif endif gnuc ifndef gcry gcc attr deprecated define gcry gcc attr deprecated endif ifndef gcry gcc attr pure define gcry gcc attr pure endif ifndef gcry gcc attr malloc define gcry gcc attr malloc endif make up an attribute to mark functions and types as deprecated but allow internal use by libgcrypt ifdef gcrypt in libgcrypt define gcry attr internal else define gcry attr internal gcry gcc attr deprecated endif wrappers  {
	                                                                                                  wrappers :: -1000
                                                                                                         }
for the libgpg  {
 }
error library typedef gpg error t gcry error t typedef gpg err code t gcry err code t typedef gpg err source t gcry err source t static gpg err inline gcry error t gcry err make gcry err source t source gcry err code t code return gpg err make source code the user can define gpg err source default before including this file to specify a default source for gpg error ifndef gcry err source default define gcry err source default gpg err source user endif static gpg err inline gcry error t gcry error gcry err code t code return gcry err make gcry err source default code static gpg err inline gcry err code t gcry err code gcry error t err return gpg err code err static gpg err inline gcry err source t gcry err source gcry error t err return gpg err source err return a pointer to a string containing a description of the error code in the error value err const char gcry strerror gcry error t err return a pointer to a string containing a description of the error source in the error value err const char gcry strsource  {
	                                                                                                                                                                                            scrutoires :: 11
	                                                                                                                                                                                             outsource :: 11
	                                                                                                                                                                                            outsources :: 11
                                                                                                                                                                                                     }
gcry error t err retrieve the error code for the system error err this returns gpg err unknown errno if the system error is not mapped report this gcry err code t gcry err code from errno int err retrieve the system error for the error code code this returns if code is not a system error code int gcry err code to errno gcry err code t code return an error value with the error source source and the system error err gcry error t gcry err make from errno gcry err source t source int err return an error value with the system error err gcry err code t gcry error from errno int err this enum is deprecated it is only declared for the sake  {
	                                                                                                                           sake :: -1000
                                                                                                                              }
of complete api compatibility enum gcry thread option gcry thread option dummy  {
	      dummy :: -1000
          }
gcry gcc attr deprecated constants defining the thread model to use used with the option field of the struct gcry thread cbs  {
	                 cobs :: 3
	                 cabs :: 3
	                  obs :: 3
	                  cis :: 3
	                  abs :: 3
	                   cs :: 3
                    }
define gcry thread option default define gcry thread option user define gcry thread option pth  {
	          pith :: 3
	          phot :: 3
	          phat :: 3
	          path :: 3
	           poh :: 3
	           pht :: 4
	           peh :: 3
	           pah :: 3
	           nth :: 3
	           eth :: 3
             }
define gcry thread option pthread  {
	pothead :: 9
	pithead :: 9
   }
the version number encoded in the option field of the struct gcry thread cbs define gcry thread option version wrapper for struct ath  {
	                 ethal :: 3
	                athrob :: 3
	                 ashet :: 3
	                  tahr :: 3
	                  taha :: 3
	                  baht :: 3
	                   nth :: 3
	                   hat :: 3
	                   eth :: 3
	                   ats :: 3
	                   ate :: 3
	                   ash :: 3
	                    at :: 4
                     }
ops struct gcry thread cbs the option field encodes the thread model and the version number of this structure bits are used for the thread model bits are used for the version number unsigned int option int init void int mutex  {
	                                  mutely :: 6
	                                   muxes :: 6
	                                   muxed :: 6
	                                   muter :: 7
	                                   muted :: 7
	                                   muset :: 6
	                                   murex :: 7
                                       }
init void priv int mutex destroy void priv int mutex lock void priv int mutex unlock void priv ssize t read int fd void buf size t nbytes ssize t write int fd const void buf size t nbytes ifdef win ssize t select int nfd  {
	                                          net :: -1000
                                            }
void rset  {
	frets :: 5
	arets :: 5
	trets :: 5
	rets :: 5
	rest :: 6
	erst :: 5
	resty :: 5
	rests :: 5
	rents :: 5
	reest :: 5
 }
void wset  {
	wrest :: 5
	whets :: 6
	wests :: 5
	welts :: 5
	wefts :: 5
	weets :: 6
	weest :: 5
	waste :: 5
	whet :: 5
	wets :: 5
	west :: 6
	weet :: 5
	stew :: 5
 }
void eset  {
	leets :: 5
	keets :: 5
	evets :: 6
	etens :: 5
	ester :: 5
	egest :: 5
	deets :: 5
	beets :: 5
	weets :: 5
	tees :: 5
	evet :: 5
	meets :: 5
 }
struct timeval  {
	bimetals :: 9
	bimetal :: 10
 }
timeout ssize t waitpid  {
	wapiti :: 9
  }
pid t pid int status int options int accept int s void addr int length ptr int connect  {
	          connect :: -1000
                }
int s void addr gcry socklen t length int sendmsg  {
	    sends :: 9
        }
int s const void msg int flags int recvmsg  {
       }
int s void msg int flags else ssize t select int nfd fd set rset fd set wset fd set eset struct timeval timeout ssize t waitpid pid t pid int status int options int accept int s struct sockaddr  {
	                              dockyards :: 10
                                      }
addr gcry socklen t length ptr int connect int s struct sockaddr addr gcry socklen t length int sendmsg int s const struct msghdr  {
                      }
msg int flags int recvmsg int s struct msghdr msg int flags endif ifdef win define gcry thread option pth impl net static ssize t gcry pth select int nfd void rset void wset void eset struct timeval timeout return pth select nfd rset wset eset timeout static ssize t gcry pth waitpid pid t pid int status int options return pth waitpid pid status options static int gcry pth accept int s void addr gcry socklen t length ptr return pth accept s addr length ptr static int gcry pth connect int s void addr gcry socklen t length return pth connect s addr length else win define gcry thread option pth impl net static ssize t gcry pth select int nfd fd set rset fd set wset fd set eset struct timeval timeout return pth select nfd rset wset eset timeout static ssize t gcry pth waitpid pid t pid int status int options return pth waitpid pid status options static int gcry pth accept int s struct sockaddr addr gcry socklen t length ptr return pth accept s addr length ptr static int gcry pth connect int s struct sockaddr addr gcry socklen t length return pth connect s addr length endif win define gcry thread option pth impl static int gcry pth init void return pth init false errno static int gcry pth mutex init void priv int err pth mutex t lock malloc sizeof pth mutex t if lock err enomem if err err pth mutex init lock if err false err errno else err if err free lock else priv lock return err static int gcry pth mutex destroy void lock gnu pth has no destructor function free lock return static int gcry pth mutex lock void lock return pth mutex acquire  {
	                                                                                                                                                                                                                                                                                                  acquire :: -1000
                                                                                                                                                                                                                                                                                                        }
lock null false errno static int gcry pth mutex unlock void lock return pth mutex release lock false errno static ssize t gcry pth read int fd void buf size t nbytes return pth read fd buf nbytes static ssize t gcry pth write int fd const void buf size t nbytes return pth write fd buf nbytes gcry thread option pth impl net note gnu pth is missing pth sendmsg and pth recvmsg static struct gcry thread cbs gcry threads pth gcry thread option pth gcry thread option version gcry pth init gcry pth mutex init gcry pth mutex destroy gcry pth mutex lock gcry pth mutex unlock gcry pth read gcry pth write gcry pth select gcry pth waitpid gcry pth accept gcry pth connect null null define gcry thread option pthread impl static int gcry pthread mutex init void priv int err pthread mutex t lock pthread mutex t malloc sizeof pthread mutex t if lock err enomem if err err pthread mutex init lock null if err free lock else priv lock return err static int gcry pthread mutex destroy void lock int err pthread mutex destroy pthread mutex t lock free lock return err static int gcry pthread mutex lock void lock return pthread mutex lock pthread mutex t lock static int gcry pthread mutex unlock void lock return pthread mutex unlock pthread mutex t lock static struct gcry thread cbs gcry threads pthread gcry thread option pthread gcry thread option version null gcry pthread mutex init gcry pthread mutex destroy gcry pthread mutex lock gcry pthread mutex unlock null null null null null null null null the data object used to hold a multi precision integer struct gcry mpi typedef struct gcry mpi gcry mpi t ifndef gcrypt no deprecated typedef struct gcry mpi gcry mpi gcry gcc attr deprecated typedef struct gcry mpi gcrympi  {
	                                                                                                                                                                                                                                                                                                               scrimpy :: 9
                                                                                                                                                                                                                                                                                                                     }
gcry gcc attr deprecated endif check that the library fulfills  {
	 fulfills :: -1000
        }
the version requirement const char gcry check version const char req version codes for function dispatchers  {
	    dispatchers :: -1000
              }
codes used with the gcry control function enum gcry ctl  {
	    cults :: 3
	    culti :: 3
	    culet :: 3
	    colts :: 3
	    celts :: 3
	     talc :: 3
	     cult :: 4
	     colt :: 4
	     clot :: 3
	     celt :: 4
	      col :: 3
	      cel :: 3
        }
cmds  {
	soapier :: -1000
 }
gcryctl  {
 }
set key gcryctl set iv gcryctl cfb  {
	   bur :: -1000
     }
sync gcryctl reset e g for mds  {
	 adsum :: 3
	  mids :: 3
	  mads :: 3
	 mysid :: 3
	 mused :: 3
	 mosed :: 3
	 misdo :: 3
	 mased :: 3
	   uds :: 3
	   ods :: 3
	   mus :: 3
	   mos :: 3
	   mis :: 3
	   mes :: 3
	   mas :: 3
	   ids :: 3
	   ads :: 3
	    ms :: 3
     }
gcryctl finalize  {
	finalize :: -1000
 }
gcryctl get keylen  {
	kayle :: 7
	keeling :: 7
	kernel :: 7
	kennel :: 7
	keenly :: 8
	yeelin :: 7
	keel :: 7
	keyline :: 10
	keyless :: 8
	kernelly :: 7
 }
gcryctl get blklen  {
	johns :: -1000
 }
gcryctl test algo  {
	argol :: 6
	along :: 5
	algor :: 7
	aglow :: 5
	argols :: 5
	algors :: 6
	algoid :: 6
	alto :: 5
	also :: 5
 }
gcryctl is secure gcryctl get asnoid  {
	ganoid :: 8
	askoi :: 7
	adios :: 7
	astonied :: 7
	adonise :: 7
	conoids :: 7
	ganoids :: 9
	adonis :: 8
	inroads :: 7
	adjoin :: 7
	adjoints :: 7
    }
gcryctl enable algo gcryctl disable algo gcryctl dump random stats  {
	    stats :: -1000
        }
gcryctl dump secmem  {
	semsem :: 7
	sememic :: 7
 }
stats gcryctl get algo npkey  {
	champers :: -1000
   }
gcryctl get algo nskey  {
	chancers :: -1000
  }
gcryctl get algo nsign  {
	redacting :: -1000
  }
gcryctl get algo nencr  {
	nonce :: 6
	noncrime :: 6
	nance :: 6
  }
gcryctl set verbosity  {
	verbosity :: -1000
 }
gcryctl set debug flags gcryctl clear debug flags gcryctl use secure rndpool  {
          }
gcryctl dump memory stats gcryctl init secmem gcryctl term secmem gcryctl disable secmem warn gcryctl suspend secmem warn gcryctl resume secmem warn gcryctl drop privs  {
	                  privet :: 6
	                  prissy :: 6
	                  priest :: 6
	                   drips :: 6
	                 proviso :: 6
	                 privies :: 6
	                 privets :: 7
	                  parvis :: 6
	                privates :: 6
	                 previse :: 6
	                   trips :: 6
	                    spiv :: 6
	                   spivs :: 6
	                   privy :: 7
	                   prism :: 6
	                   prise :: 6
	                   prims :: 7
	                   prigs :: 7
	                   pries :: 7
	                   pervs :: 6
	                   pairs :: 6
                       }
gcryctl enable m guard  {
	heard :: -1000
  }
gcryctl start dump gcryctl stop dump gcryctl get algo usage gcryctl is algo enabled gcryctl disable internal locking gcryctl disable secmem gcryctl initialization finished gcryctl initialization finished p gcryctl any initialization p gcryctl set cbc  {
                                 }
cts  {
	blackberries :: -1000
 }
gcryctl set cbc mac gcryctl set ctr  {
	spraint :: -1000
     }
gcryctl enable quick random gcryctl set random seed file gcryctl update random seed file gcryctl set thread cbs gcryctl fast poll gcryctl set random daemon  {
	                  daemon :: -1000
                       }
socket gcryctl use random daemon gcryctl faked  {
	 faked :: -1000
     }
random p gcryctl set rndegd  {
	redding :: 7
	underdog :: 8
	undergod :: 7
	underdo :: 7
	underdogs :: 7
   }
socket gcryctl print config gcryctl operational  {
	operational :: -1000
    }
p gcryctl fips  {
	zips :: 5
	yips :: 5
	tips :: 5
	sips :: 5
	rips :: 5
	pips :: 5
	nips :: 5
	lips :: 5
	kips :: 5
	hips :: 5
	gips :: 5
	fops :: 5
	fits :: 5
	fins :: 5
	fils :: 5
	figs :: 5
	fies :: 5
	fids :: 5
	fibs :: 5
	dips :: 5
	sip :: 5
 }
mode p gcryctl force fips mode gcryctl selftest  {
	sedatest :: 10
	fettles :: 10
	swiftest :: 10
	settles :: 11
	sveltest :: 11
	fleetest :: 10
      }
note are used internally  {
	internally :: -1000
  }
gcryctl disable hwf  {
	howf :: 3
 }
perform various operations defined by cmd gcry error t gcry control enum gcry ctl cmds cmd s expression management the object to represent an s expression as used with the public key functions struct gcry sexp  {
	                             sexpot :: 6
	                               sexy :: 5
	                               sext :: 5
	                                sex :: 6
                                  }
typedef struct gcry sexp gcry sexp t ifndef gcrypt no deprecated typedef struct gcry sexp gcry sexp gcry gcc attr deprecated typedef struct gcry sexp gcrysexp  {
                        }
gcry gcc attr deprecated endif the possible values for the s expression format enum gcry sexp format gcrysexp fmt default gcrysexp fmt canon gcrysexp fmt base gcrysexp fmt advanced create an new s expression object from buffer of size length and return it in retsexp  {
	                                 letterboxed :: -1000
                                           }
with autodetect  {
 }
set to the data in buffer is expected to be in canonized  {
	  canonized :: -1000
          }
format gcry error t gcry sexp new gcry sexp t retsexp const void buffer size t length int autodetect same as gcry sexp new but allows to pass a freefnc  {
	                     offended :: -1000
                            }
which has the effect to transfer ownership  {
	ownership :: -1000
     }
of buffer to the created object gcry error t gcry sexp create gcry sexp t retsexp void buffer size t length int autodetect void freefnc void scan buffer and return a new s expression object in retsexp this function expects a printf like string in buffer gcry error t gcry sexp sscan  {
	                                            schanse :: 6
	                                               sacs :: 6
	                                              scans :: 6
	                                            secants :: 7
                                                  }
gcry sexp t retsexp size t erroff  {
	highly :: -1000
     }
const char buffer size t length same as gcry sexp sscan but expects a string in format and can thus only be used for certain encodings gcry error t gcry sexp build gcry sexp t retsexp size t erroff const char format like gcry sexp build but uses an array instead of variable function arguments gcry error t gcry sexp build array gcry sexp t retsexp size t erroff const char format void arg list release the s expression object sexp void gcry sexp release gcry sexp t sexp calculate  {
	                                                                                calculate :: -1000
                                                                                        }
the length of an canonized s expresion  {
	exemptions :: 11
	expulsion :: 11
	expressing :: 12
	excretions :: 13
	repletions :: 11
	extrusion :: 11
	expansion :: 11
	excretion :: 12
	exceptions :: 11
	expresso :: 12
	exsertion :: 12
	expressions :: 12
	expressional :: 11
	exsertions :: 11
	explosion :: 11
	extension :: 11
     }
in buffer and check for a valid encoding size t gcry sexp canon len const unsigned char buffer size t length size t erroff gcry error t errcode copies  {
	                      copies :: -1000
                           }
the s expression object sexp into buffer using the format specified in mode size t gcry sexp sprint  {
	           sprint :: -1000
                }
gcry sexp t sexp int mode void buffer size t maxlength  {
         }
dumps  {
	dumps :: -1000
 }
the s expression object a in a format suitable for debugging to libgcrypt s logging  {
	       logging :: -1000
             }
stream void gcry sexp dump const gcry sexp t a gcry sexp t gcry sexp cons const gcry sexp t a const gcry sexp t b gcry sexp t gcry sexp alist  {
	                      notecases :: -1000
                              }
const gcry sexp t array gcry sexp t gcry sexp vlist  {
	      slit :: 6
	     slipt :: 6
	     ovist :: 6
         }
const gcry sexp t a gcry sexp t gcry sexp append const gcry sexp t a const gcry sexp t n gcry sexp t gcry sexp prepend const gcry sexp t a const gcry sexp t n scan the s expression for a sublist  {
	                                  subtitles :: 9
	                                  subtilest :: 9
	                                    subsite :: 9
	                                    subsist :: 10
	                                    submits :: 9
	                                    sublots :: 9
	                                    sublets :: 9
	                                   subtlist :: 9
	                                   sublimes :: 9
	                                   sublines :: 9
	                                     subtil :: 9
	                                     stilbs :: 9
	                                 sublimates :: 9
	                                 submittals :: 9
                                          }
with a type the car  {
	 car :: -1000
   }
of the list matching the string token if toklen  {
	 asklent :: 7
	  molten :: 7
	  anklet :: 7
	  tonlet :: 7
	  tonker :: 7
	  tonked :: 7
	  tokens :: 7
	 towline :: 7
	 pollent :: 7
	  stolen :: 7
	 topline :: 7
	   token :: 8
	   toile :: 7
	    toke :: 7
       }
is not the token is assumed to be raw  {
	     raw :: -1000
       }
memory of this length the function returns a newly allocated s expression consisting of the found sublist or null when not found gcry sexp t gcry sexp find token gcry sexp t list const char tok size t toklen return the length of the list for a valid s expression this should be at least int gcry sexp length const gcry sexp t list create and return a new s expression from the element with index number in list note that the first element has the index if there is no such element null is returned gcry sexp t gcry sexp nth const gcry sexp t list int number create and return a new s expression from the first element in list this called the type and should always exist and be a string null is returned in case of a problem gcry sexp t gcry sexp car const gcry sexp t list create and return a new list form all elements except for the first one note that this function may return an invalid s expression because it is not guaranteed  {
	                                                                                                                                                                           guaranteed :: -1000
                                                                                                                                                                                    }
that the type exists and is a string however for parsing a complex s expression it might be useful for intermediate  {
	        intermediate :: -1000
                   }
lists  {
	lists :: -1000
 }
returns null on error gcry sexp t gcry sexp cdr  {
	      bub :: -1000
        }
const gcry sexp t list gcry sexp t gcry sexp cadr  {
	     chard :: 5
	     cedar :: 5
	     cardy :: 5
	     cared :: 5
	     cards :: 5
	     cardi :: 5
	     caird :: 6
	     cadre :: 7
	      carr :: 5
	      cads :: 5
	      cade :: 5
	    cadres :: 6
	    cadger :: 5
	       rad :: 5
	       car :: 5
	       cad :: 6
         }
const gcry sexp t list this function is used to get data from a list a pointer to the actual data with index number is returned and the length of this data will be stored to datalen  {
	                            eastland :: 9
	                             lanated :: 10
	                             canaled :: 9
	                             datable :: 9
	                            divalent :: 9
	                               natal :: 9
                                   }
if there is no data at the given index or the index represents another list null is returned note the returned pointer is valid as long as list is not modified or released  {
	                        released :: -1000
                               }
const char gcry sexp nth data const gcry sexp t list int number size t datalen this function is used to get and convert data from a list the data is assumed to be a nul terminated string the caller must release the returned value using gcry free if there is no data at the given index the index represents a list or the value can t be converted  {
	                                                             geckoes :: -1000
                                                                   }
to a string null is returned char gcry sexp nth string gcry sexp t list int number this function is used to get and convert data from a list this data is assumed to be an mpi stored in the format described by mpifmt  {
                                          }
and returned as a standard libgcrypt mpi the caller must release this returned value using gcry mpi release if there is no data at the given index the index represents a list or the value can t be converted to an mpi null is returned gcry mpi t gcry sexp nth mpi gcry sexp t list int number int mpifmt multi precision integer functions different formats  {
	                                                          formats :: -1000
                                                                }
of external big integer representation enum gcry mpi format gcrympi fmt none gcrympi fmt std twos  {
	           twos :: -1000
              }
complement stored without length gcrympi fmt pgp  {
	fulgent :: -1000
     }
as used by openpgp  {
  }
unsigned only gcrympi fmt ssh  {
	sohs :: 4
	shes :: 3
	sash :: 3
	 ish :: 3
	 ash :: 3
   }
as used by ssh like std but with length gcrympi fmt hex hex format gcrympi fmt usg  {
	           using :: 3
	           usage :: 3
	           urges :: 3
	            yugs :: 3
	            vugs :: 3
	            ughs :: 3
	            tugs :: 3
	            sugh :: 3
	            pugs :: 3
	            mugs :: 3
	            lugs :: 3
	            hugs :: 3
	            dugs :: 3
	            bugs :: 3
	             use :: 3
	             ugs :: 4
	              us :: 4
	              ug :: 3
               }
like std but unsigned flags used for creating  {
	creating :: -1000
      }
big integers enum gcry mpi flag gcrympi flag secure allocate the number in secure memory gcrympi flag opaque the number is not a real one but just a way to store some bytes this is useful for encrypted  {
	                            encrypted :: -1000
                                    }
big integers allocate a new big integer object initialize it with and initially  {
	   initially :: -1000
           }
allocate memory for a number of at least nbits  {
	   knits :: 6
	   brits :: 6
	   units :: 6
	    snit :: 6
	   snits :: 6
	   obits :: 7
       }
gcry mpi t gcry mpi new unsigned int nbits same as gcry mpi new but allocate in secure memory gcry mpi t gcry mpi snew  {
	                   enows :: 5
	                    stew :: 5
	                    spew :: 5
	                    snow :: 5
	                    sned :: 5
	                    sneb :: 5
	                    snaw :: 5
	                    smew :: 5
	                    slew :: 5
	                    skew :: 5
	                    shew :: 5
	                    sewn :: 5
	                    knew :: 5
	                   shewn :: 6
	                    anew :: 5
	                  snowed :: 5
                       }
unsigned int nbits release the number a and free all associated resources  {
	  resources :: -1000
          }
void gcry mpi release gcry mpi t a create a new number with the same value as a gcry mpi t gcry mpi copy const gcry mpi t a store the big integer value u in w gcry mpi t gcry mpi set gcry mpi t w const gcry mpi t u store the unsigned integer value u in w gcry mpi t gcry mpi set ui gcry mpi t w unsigned long u swap the values of a and b void gcry mpi swap gcry mpi t a gcry mpi t b compare the big integer number u and v returning for equality  {
	                                                                                               equality :: -1000
                                                                                                      }
a positive  {
	positive :: -1000
 }
value for u v and a negative for u v int gcry mpi cmp const gcry mpi t u const gcry mpi t v compare the big integer number u with the unsigned integer v returning for equality a positive value for u v and a negative for u v int gcry mpi cmp ui const gcry mpi t u unsigned long v convert the external representation of an integer stored in buffer with a length of buflen into a newly create mpi returned in ret mpi if nscanned  {
                                                                                       }
is not null it will receive the number of bytes actually scanned  {
	    scanned :: -1000
          }
after a successful operation gcry error t gcry mpi scan gcry mpi t ret mpi enum gcry mpi format format const void buffer size t buflen size t nscanned convert the big integer a into the external representation described by format and store it in the provided buffer which has been allocated by the user with a size of buflen bytes nwritten  {
                                                            }
receives  {
	receives :: -1000
 }
the actual length of the external representation unless it has been passed as null gcry error t gcry mpi print enum gcry mpi format format unsigned char buffer size t buflen size t nwritten const gcry mpi t a convert the big integer a int the external representation described by format and store it in a newly allocated buffer which address will be put into buffer nwritten receives the actual lengths  {
	                                                               lengths :: -1000
                                                                     }
of the external representation gcry error t gcry mpi aprint  {
	   plaint :: 7
	    atrip :: 8
	    apron :: 7
	    agrin :: 7
	   arpent :: 7
	   aroint :: 8
	    abrin :: 7
	  apricot :: 7
	 sprinted :: 7
	   paring :: 7
	   parent :: 7
	  aroints :: 7
	  atropin :: 7
	    train :: 7
	   taring :: 7
	   sprint :: 9
	    patin :: 7
	  puritan :: 7
	  sprints :: 8
	  spraint :: 7
        }
enum gcry mpi format format unsigned char buffer size t nwritten const gcry mpi t a dump the value of a in a format suitable for debugging to libgcrypt s logging stream note that one leading space but no trailing  {
	                               trailing :: -1000
                                      }
space or linefeed  {
	linefeed :: -1000
 }
will be printed it is okay  {
	superserviceable :: -1000
    }
to pass null for a void gcry mpi dump const gcry mpi t a w u v void gcry mpi add gcry mpi t w gcry mpi t u gcry mpi t v w u v v is an unsigned integer void gcry mpi add ui gcry mpi t w gcry mpi t u unsigned long v w u v mod m void gcry mpi addm  {
	                                                           addoom :: 5
	                                                           addeem :: 5
	                                                             adds :: 5
	                                                              add :: 6
                                                                }
gcry mpi t w gcry mpi t u gcry mpi t v gcry mpi t m w u v void gcry mpi sub gcry mpi t w gcry mpi t u gcry mpi t v w u v v is an unsigned integer void gcry mpi sub ui gcry mpi t w gcry mpi t u unsigned long v w u v mod m void gcry mpi subm gcry mpi t w gcry mpi t u gcry mpi t v gcry mpi t m w u v void gcry mpi mul gcry mpi t w gcry mpi t u gcry mpi t v w u v v is an unsigned integer void gcry mpi mul ui gcry mpi t w gcry mpi t u unsigned long v w u v mod m void gcry mpi mulm  {
	                                                                                                                                   malm :: 5
	                                                                                                                                   culm :: 5
	                                                                                                                                  lumme :: 5
	                                                                                                                                    mum :: 5
                                                                                                                                      }
gcry mpi t w gcry mpi t u gcry mpi t v gcry mpi t m w u cnt void gcry mpi mul exp gcry mpi t w gcry mpi t u unsigned long cnt q dividend  {
	                            dividend :: -1000
                                   }
divisor  {
	divisor :: -1000
 }
r dividend divisor q or r may be passed as null round should be negative or void gcry mpi div gcry mpi t q gcry mpi t r gcry mpi t dividend gcry mpi t divisor int round r dividend divisor void gcry mpi mod gcry mpi t r gcry mpi t dividend gcry mpi t divisor w b e mod m void gcry mpi powm  {
	                                                             pows :: 5
	                                                             poem :: 5
	                                                              pow :: 6
	                                                              pom :: 5
	                                                              mow :: 5
                                                                }
gcry mpi t w const gcry mpi t b const gcry mpi t e const gcry mpi t m set g to the greatest  {
	               greatest :: -1000
                      }
common divisor of a and b return true if the g is int gcry mpi gcd  {
	    awfulnesses :: -1000
              }
gcry mpi t g gcry mpi t a gcry mpi t b set x to the multiplicative  {
	  multiplicative :: -1000
               }
inverse  {
	inverse :: -1000
 }
of a mod m return true if the value exists int gcry mpi invm  {
            }
gcry mpi t x gcry mpi t a gcry mpi t m return the number of bits required to represent a unsigned int gcry mpi get nbits gcry mpi t a return true when bit number n counting  {
	                             counting :: -1000
                                    }
from is set in a int gcry mpi test bit gcry mpi t a unsigned int n set bit number n in a void gcry mpi set bit gcry mpi t a unsigned int n clear bit number n in a void gcry mpi clear bit gcry mpi t a unsigned int n set bit number n in a and clear all bits greater  {
	                                                        greater :: -1000
                                                              }
than n void gcry mpi set highbit  {
	nuncupate :: -1000
     }
gcry mpi t a unsigned int n clear bit number n in a and all bits greater than n void gcry mpi clear highbit gcry mpi t a unsigned int n shift the value of a by n bits to the right and store the result in x void gcry mpi rshift  {
	                                             shrift :: 9
	                                            resifts :: 7
	                                             resift :: 8
	                                             thrift :: 7
	                                            thrifts :: 8
	                                             strift :: 7
                                                  }
gcry mpi t x gcry mpi t a unsigned int n shift the value of a by n bits to the left and store the result in x void gcry mpi lshift  {
	               curvilinearities :: -1000
                              }
gcry mpi t x gcry mpi t a unsigned int n store nbits of the value p points to in a and mark a as an opaque value warning never use an opaque mpi for anything thing else then gcry mpi release gcry mpi get opaque gcry mpi t gcry mpi set opaque gcry mpi t a void p unsigned int nbits return a pointer to an opaque value stored in a and return its size in nbits note that the returned pointer is still owned  {
	                                                                                owned :: -1000
                                                                                    }
by a and that the function should never be used for an non opaque mpi void gcry mpi get opaque gcry mpi t a unsigned int nbits set the flag for the big integer a currently only the flag gcrympi flag secure is allowed to convert a into an big intger  {
	                                            singer :: 7
	                                            ginger :: 7
	                                            inters :: 7
	                                            uniter :: 7
	                                          interage :: 7
	                                             inter :: 8
	                                             inert :: 7
	                                          integral :: 8
	                                          integers :: 7
	                                            zinger :: 7
	                                           gittern :: 7
	                                            nigger :: 7
	                                            binger :: 7
	                                         integrals :: 7
	                                            pinger :: 7
	                                            dinger :: 7
	                                            winger :: 7
	                                            ringer :: 7
	                                            tonger :: 7
	                                            finger :: 7
	                                            hinger :: 7
	                                           integer :: 8
	                                           ringent :: 7
	                                            engirt :: 7
	                                             tinge :: 7
	                                              inte :: 7
	                                            linger :: 7
	                                             nitre :: 7
	                                           ingrate :: 7
                                                 }
stored in secure memory void gcry mpi set flag gcry mpi t a enum gcry mpi flag flag clear flag for the big integer a note that this function is currently useless  {
	                        useless :: -1000
                              }
as no flags are allowed void gcry mpi clear flag gcry mpi t a enum gcry mpi flag flag return true when the flag is set for a int gcry mpi get flag gcry mpi t a enum gcry mpi flag flag unless the gcrypt no mpi macros is used provide a couple  {
	                                          restorable :: -1000
                                                   }
of convenience macros for the big integer functions ifndef gcrypt no mpi macros define mpi new n gcry mpi new n define mpi secure new n gcry mpi snew n define mpi release a do gcry mpi release a a null while define mpi copy a gcry mpi copy a define mpi set w u gcry mpi set w u define mpi set ui w u gcry mpi set ui w u define mpi cmp u v gcry mpi cmp u v define mpi cmp ui u v gcry mpi cmp ui u v define mpi add ui w u v gcry mpi add ui w u v define mpi add w u v gcry mpi add w u v define mpi addm w u v m gcry mpi addm w u v m define mpi sub ui w u v gcry mpi sub ui w u v define mpi sub w u v gcry mpi sub w u v define mpi subm w u v m gcry mpi subm w u v m define mpi mul ui w u v gcry mpi mul ui w u v define mpi mul exp w u v gcry mpi mul exp w u v define mpi mul w u v gcry mpi mul w u v define mpi mulm w u v m gcry mpi mulm w u v m define mpi powm w b e m gcry mpi powm w b e m define mpi tdiv  {
                                                                                                                                                                                                                                                   }
q r a m gcry mpi div q r a m define mpi fdiv  {
            }
q r a m gcry mpi div q r a m define mpi mod r a m gcry mpi mod r a m define mpi gcd g a b gcry mpi gcd g a b define mpi invm g a b gcry mpi invm g a b define mpi get nbits a gcry mpi get nbits a define mpi test bit a b gcry mpi test bit a b define mpi set bit a b gcry mpi set bit a b define mpi set highbit a b gcry mpi set highbit a b define mpi clear bit a b gcry mpi clear bit a b define mpi clear highbit a b gcry mpi clear highbit a b define mpi rshift a b c gcry mpi rshift a b c define mpi lshift a b c gcry mpi lshift a b c define mpi set opaque a b c gcry mpi set opaque a b c define mpi get opaque a b gcry mpi get opaque a b endif gcrypt no mpi macros symmetric  {
	                                                                                                                                                                   symmetric :: -1000
                                                                                                                                                                           }
cipher  {
	newsweeklies :: -1000
 }
functions the data object used to hold a handle to an encryption  {
	 encryption :: -1000
          }
object struct gcry cipher handle typedef struct gcry cipher handle gcry cipher hd t ifndef gcrypt no deprecated typedef struct gcry cipher handle gcry cipher hd gcry gcc attr deprecated typedef struct gcry cipher handle gcrycipherhd  {
	                    trivializations :: -1000
                                  }
gcry gcc attr deprecated endif all symmetric encryption algorithms  {
	algorithms :: -1000
       }
are identified by their ids more ids may be registered  {
	registered :: -1000
        }
at runtime enum gcry cipher algos  {
	kagos :: 6
	goals :: 6
	gaols :: 6
	dagos :: 6
	galosh :: 6
	aulos :: 6
	argol :: 6
	aloes :: 6
	alods :: 6
	algor :: 7
	algas :: 6
	agios :: 6
	argols :: 7
	almost :: 6
	algors :: 8
	algoid :: 6
	aldose :: 6
	algorism :: 6
	 sago :: 6
	 also :: 7
	glossa :: 6
	logos :: 6
    }
gcry cipher none gcry cipher idea  {
	 idea :: -1000
    }
gcry cipher des gcry cipher cast gcry cipher blowfish  {
	blowfish :: -1000
       }
gcry cipher safer  {
	safer :: -1000
 }
sk gcry cipher des sk gcry cipher aes  {
	  festa :: 3
	  cesta :: 3
	  besat :: 3
	  asset :: 3
	  aisle :: 3
	  aesir :: 4
	  aegis :: 3
	  absey :: 3
	  vesta :: 3
	  vespa :: 3
	   yeas :: 3
	  testa :: 3
	  tesla :: 3
	   wase :: 3
	   vase :: 3
	   teas :: 3
	   seta :: 3
	   sera :: 3
	   sena :: 3
	   seat :: 3
	   seas :: 3
	   sear :: 3
	   sean :: 3
	   seam :: 3
	   seal :: 3
	   rase :: 3
	   peas :: 3
	   pase :: 3
	   mesa :: 4
	   mase :: 3
	   leas :: 3
	   lase :: 3
	   keas :: 3
	   easy :: 3
	   east :: 3
	   ease :: 3
	   ceas :: 3
	   case :: 3
	   ayes :: 3
	   axes :: 3
	   awes :: 3
	   aves :: 3
	   ates :: 3
	   arse :: 4
	   ares :: 3
	   base :: 3
	   apes :: 3
	   anes :: 3
	   ales :: 3
	   akes :: 3
	   ages :: 3
	   aesc :: 5
	   aces :: 3
	  resay :: 3
	  resaw :: 3
	  resat :: 3
	  mesal :: 3
	    yes :: 3
	    tes :: 3
	    ses :: 3
	    sea :: 4
	    sae :: 3
	    res :: 3
	    pes :: 3
	    oes :: 3
	    mes :: 3
	    les :: 3
	    hes :: 3
	    ges :: 3
	    eas :: 4
	    aws :: 3
	    ats :: 3
	    ass :: 3
	    ars :: 3
	    als :: 3
	    ais :: 3
	    ahs :: 3
	    ads :: 3
	    abs :: 3
	     as :: 3
	     ae :: 4
      }
gcry cipher aes gcry cipher aes gcry cipher twofish  {
	 toffish :: 10
	 cowfish :: 9
	 townish :: 9
	 outfish :: 9
	 wolfish :: 9
       }
other cipher numbers are above for openpgp reasons gcry cipher arcfour  {
         }
fully compatible with rsa  {
	tsar :: 4
	star :: 3
	spar :: 3
	soar :: 3
	ryas :: 4
	rusa :: 3
	sear :: 3
	scar :: 3
	rays :: 3
	raws :: 3
	rats :: 3
	rasp :: 3
	rash :: 3
	rase :: 3
	raps :: 3
	rams :: 3
	rahs :: 3
	rags :: 3
	rads :: 3
	osar :: 4
	ksar :: 4
	eras :: 3
	bras :: 3
	roast :: 3
	roans :: 3
	roams :: 3
	roads :: 3
	rials :: 3
	reast :: 3
	reaps :: 3
	reans :: 3
	reams :: 3
	reals :: 3
	reaks :: 3
	reads :: 3
	rya :: 3
	sar :: 3
	ria :: 3
	ras :: 4
	ars :: 3
	 as :: 3
  }
s rc tm gcry cipher des yes this is single key bit des gcry cipher twofish gcry cipher serpent  {
	           serpent :: -1000
                 }
gcry cipher serpent gcry cipher serpent gcry cipher rfc  {
	     res :: -1000
       }
ron  {
	unhindered :: -1000
 }
s cipher bit gcry cipher rfc ron s cipher bit gcry cipher seed bit cipher described in rfc gcry cipher camellia  {
	            camellia :: -1000
                   }
gcry cipher camellia gcry cipher camellia the rijndael  {
      }
algorithm is basically  {
	basically :: -1000
 }
aes so provide some macros define gcry cipher aes gcry cipher aes define gcry cipher rijndael gcry cipher aes define gcry cipher rijndael gcry cipher aes define gcry cipher rijndael gcry cipher aes define gcry cipher rijndael gcry cipher aes the supported encryption modes note that not all of them are supported for each algorithm enum gcry cipher modes gcry cipher mode none not yet specified gcry cipher mode ecb  {
	                                                                 cube :: 3
	                                                                  ecu :: 3
	                                                                  ebb :: 3
                                                                    }
electronic  {
	electronic :: -1000
 }
codebook  {
	codebook :: -1000
 }
gcry cipher mode cfb cipher feedback  {
	feedback :: -1000
    }
gcry cipher mode cbc cipher block chaining  {
	chaining :: -1000
     }
gcry cipher mode stream used with stream ciphers  {
	ciphers :: -1000
      }
gcry cipher mode ofb  {
	nur :: -1000
  }
outer  {
	peter :: -1000
 }
feedback gcry cipher mode ctr counter gcry cipher mode aeswrap  {
        }
aes wrap algorithm flags used with the open function enum gcry cipher flags gcry cipher secure allocate in secure memory gcry cipher enable sync enable cfb sync mode gcry cipher cbc cts enable cbc cipher text stealing  {
	                            stealing :: -1000
                                   }
cts gcry cipher cbc mac enable cbc message auth  {
	    beth :: -1000
       }
code mac create a handle for algorithm algo to be used in mode flags may be given as an bitwise or of the gcry cipher flags values gcry error t gcry cipher open gcry cipher hd t handle int algo int mode unsigned int flags close the cioher  {
	                                    sarcolemmal :: -1000
                                              }
handle h and release all resource void gcry cipher close gcry cipher hd t h perform various operations on the cipher object h gcry error t gcry cipher ctl gcry cipher hd t h int cmd void buffer size t buflen retrieve various information about the cipher object h gcry error t gcry cipher info gcry cipher hd t h int what void buffer size t nbytes retrieve various information about the cipher algorithm algo gcry error t gcry cipher algo info int algo int what void buffer size t nbytes map the cipher algorithm whose id is contained  {
	                                                                                         contained :: -1000
                                                                                                 }
in algorithm to a string representation of the algorithm name for unknown algorithm ids this function returns const char gcry cipher algo name int algorithm gcry gcc attr pure map the algorithm name name to an cipher algorithm id return if the algorithm name is not known int gcry cipher map name const char name gcry gcc attr pure given an asn object identifier in standard ietf  {
	                                                             fetid :: 5
	                                                             metif :: 5
	                                                               fet :: 5
                                                                 }
dotted  {
	dotted :: -1000
 }
decimal format in string return the encryption mode associated with that oid  {
	      fidos :: 3
	      eidos :: 3
	      didos :: 3
	      bidon :: 3
	      widow :: 3
	      video :: 3
	       oxid :: 3
	       olid :: 3
	       odic :: 3
	       nodi :: 3
	       modi :: 3
	       fido :: 4
	       diol :: 3
	       dido :: 4
	      oldie :: 3
	      oiled :: 3
	      oidia :: 3
	      nidor :: 3
	        yid :: 3
	        vid :: 3
	        tid :: 3
	        rid :: 3
	        old :: 3
	        ois :: 3
	        oil :: 3
	        oik :: 3
	        odd :: 3
	        nid :: 3
	        mid :: 3
	        lid :: 3
	        kid :: 3
	        hid :: 3
	        gid :: 3
	        fid :: 3
	        did :: 3
	        bid :: 3
	        aid :: 3
	      lidos :: 3
	         oi :: 4
	         od :: 3
	         di :: 3
          }
or if not known or applicable int gcry cipher mode from oid const char string gcry gcc attr pure encrypt the plaintext  {
	            plaintext :: -1000
                    }
of size inlen  {
	invent :: 6
	unline :: 7
	intent :: 6
	intend :: 6
	inline :: 7
	inned :: 6
	intently :: 6
	inlet :: 6
	indent :: 6
	inbent :: 6
	inlander :: 6
	unlined :: 6
	unlines :: 6
	innerly :: 6
	silen :: 6
	lineny :: 6
	linens :: 6
	linen :: 7
 }
in in using the cipher handle h into the buffer out which has an allocated length of outsize  {
	          outsize :: -1000
                }
for most algorithms it is possible to pass null for in and for inlen and do a in place decryption  {
	         decryption :: -1000
                  }
of the data provided in out gcry error t gcry cipher encrypt gcry cipher hd t h void out size t outsize const void in size t inlen the counterpart  {
	                  counterpart :: -1000
                            }
to gcry cipher encrypt gcry error t gcry cipher decrypt gcry cipher hd t h void out size t outsize const void in size t inlen set key of length keylen bytes for the cipher handle hd gcry error t gcry cipher setkey gcry cipher hd t hd const void key size t keylen set initialization vector iv of length ivlen  {
	                                                       levin :: 6
	                                                       inlet :: 6
	                                                        vile :: 6
	                                                       silen :: 6
	                                                      livens :: 6
	                                                      valine :: 6
	                                                       liven :: 7
                                                           }
for the cipher handle hd gcry error t gcry cipher setiv  {
	    sative :: 8
	   stuiver :: 6
	   estival :: 6
	   striven :: 6
	   strived :: 6
	   striver :: 6
	   motives :: 6
	   datives :: 6
	   natives :: 6
	     yetis :: 6
	    strive :: 7
	   actives :: 6
	     stive :: 6
	      vets :: 6
	    soviet :: 6
	    verist :: 6
	     metis :: 6
	       set :: 6
         }
gcry cipher hd t hd const void iv size t ivlen reset the handle to the state after open define gcry cipher reset h gcry cipher ctl h gcryctl reset null perform the openpgp sync operation if this is enabled for the cipher handle h define gcry cipher sync h gcry cipher ctl h gcryctl cfb sync null enable or disable cts in future calls to gcry encrypt cbc mode only define gcry cipher cts h on gcry cipher ctl h gcryctl set cbc cts null on set counter for ctr mode ctr ctrlen  {
	                                                                                  perquisites :: -1000
                                                                                            }
must denote  {
	denote :: -1000
 }
a buffer of block size length or null to set the ctr to the all zero block gpg error t gcry cipher setctr  {
	                setter :: 7
	                sector :: 7
	              teacarts :: 7
	               stretch :: 7
	               scutter :: 7
	               cotters :: 7
	               spectre :: 7
	               spectra :: 7
	                  sett :: 7
	               cutters :: 7
	               scatter :: 7
	                sitter :: 7
                     }
gcry cipher hd t hd const void ctr size t ctrlen retrieved  {
	  retrieved :: -1000
          }
the key length in bytes used with algorithm a size t gcry cipher get algo keylen int algo retrieve the block length in bytes used with algorithm a size t gcry cipher get algo blklen int algo return if the algorithm a is available for use define gcry cipher test algo a gcry cipher algo info a gcryctl test algo null null get a list consisting of the ids of the loaded cipher modules if list is zero write the number of loaded cipher modules to list length and return if list is non zero the first list length algorithm ids are stored in list which must be of according size in case there are less cipher modules than list length list length is updated to the correct number gcry error t gcry cipher list int list int list length asymmetric  {
	                                                                                                                                  asymmetric :: -1000
                                                                                                                                           }
cipher functions the algorithms and their ids we support enum gcry pk algos gcry pk rsa gcry pk rsa e deprecated gcry pk rsa s deprecated gcry pk elg  {
	                   serotyped :: -1000
                           }
e gcry pk dsa  {
	dwams :: 3
	duans :: 3
	duals :: 3
	drays :: 3
	draws :: 3
	draps :: 3
	drams :: 3
	drags :: 3
	drabs :: 3
	doats :: 3
	doabs :: 3
	dials :: 3
	dhals :: 3
	dhaks :: 3
	deash :: 3
	dears :: 3
	deans :: 3
	deals :: 3
	tsadi :: 3
	tsade :: 3
	swad :: 3
	shad :: 3
	scad :: 3
	odas :: 3
	days :: 3
	daws :: 3
	dash :: 3
	daps :: 3
	dans :: 3
	dams :: 3
	dals :: 3
	daks :: 3
	dais :: 3
	dahs :: 3
	dags :: 3
	dabs :: 3
	adas :: 3
	sad :: 3
	dso :: 3
	das :: 4
	ads :: 3
	 da :: 3
	 as :: 3
  }
gcry pk elg gcry pk ecdsa  {
	ecads :: 7
	cades :: 6
	 ecad :: 6
	 cads :: 6
	 aces :: 6
    }
gcry pk ecdh  {
 }
flags describing usage capabilities of a pk algorithm define gcry pk usage sign good for signatures  {
	     signatures :: -1000
              }
define gcry pk usage encr good for encryption define gcry pk usage cert good to certify  {
	        certify :: -1000
              }
other keys define gcry pk usage auth good for authentication  {
	authentication :: -1000
        }
define gcry pk usage unkn unknown usage flag encrypt the data using the public key pkey  {
	           prey :: 5
	            pye :: 5
              }
and store the result as a newly created s expression at result gcry error t gcry pk encrypt gcry sexp t result gcry sexp t data gcry sexp t pkey decrypt the data using the private key skey  {
	                                 stey :: 5
	                                 sley :: 5
	                                 skew :: 5
	                                 sker :: 5
	                                 skep :: 5
	                                 skeo :: 5
	                                 skeg :: 5
	                                skyre :: 5
	                                skyey :: 5
	                                skyed :: 5
	                                skiey :: 5
	                               skerry :: 5
	                               skelly :: 5
	                                  sky :: 5
                                    }
and store the result as a newly created s expression at result gcry error t gcry pk decrypt gcry sexp t result gcry sexp t data gcry sexp t skey sign the data using the private key skey and store the result as a newly created s expression at result gcry error t gcry pk sign gcry sexp t result gcry sexp t data gcry sexp t skey check the signature sigval  {
	                                                                 silvas :: 7
	                                                                 silvan :: 8
	                                                                 silvae :: 8
	                                                                 signal :: 9
	                                                                slaving :: 7
	                                                                signals :: 7
	                                                                salving :: 7
	                                                                gavials :: 7
	                                                                  vigas :: 7
	                                                               signaler :: 7
	                                                               signaled :: 7
	                                                                 ogival :: 7
	                                                                 visual :: 7
	                                                                 vistal :: 7
	                                                                  silva :: 9
	                                                                  sigma :: 7
	                                                                  sigla :: 9
                                                                      }
on data using the public key pkey gcry error t gcry pk verify  {
	      verify :: -1000
           }
gcry sexp t sigval gcry sexp t data gcry sexp t pkey check that private key is sane  {
	             sane :: -1000
                }
gcry error t gcry pk testkey  {
	testae :: 9
	teste :: 9
    }
gcry sexp t key generate a new key pair according to the parameters given in s parms  {
	          primas :: 6
	           harps :: 6
	           harms :: 7
	           farms :: 7
	           carps :: 6
	           barms :: 7
	         palmers :: 6
	          parish :: 6
	         warmups :: 6
	           warps :: 6
	           warms :: 7
	           tarps :: 6
	            pram :: 6
	            pars :: 7
	            pams :: 6
	            mars :: 6
	           ramps :: 7
	           proms :: 6
	           prims :: 6
	           prams :: 8
	           perms :: 7
	           parts :: 7
	           parse :: 6
	           parrs :: 6
	           parps :: 6
	           parks :: 7
	           paris :: 7
	           pares :: 7
	           pards :: 7
	           paras :: 6
	           palms :: 7
	           pairs :: 6
	           marts :: 6
	           marms :: 7
	           marls :: 6
	           marks :: 6
	           margs :: 6
	           mares :: 6
	           marcs :: 6
	             par :: 6
               }
the new key pair is returned in as an s expression in r key gcry error t gcry pk genkey  {
	              genre :: 7
	              genie :: 7
	              geeky :: 8
	               gene :: 7
	               geek :: 7
                  }
gcry sexp t r key gcry sexp t s parms catch all function for miscellaneous operations gcry error t gcry pk ctl int cmd void buffer size t buflen retrieve information about the public key algorithm algo gcry error t gcry pk algo info int algo int what void buffer size t nbytes map the public key algorithm whose id is contained in algorithm to a string representation of the algorithm name for unknown algorithm ids this functions returns const char gcry pk algo name int algorithm gcry gcc attr pure map the algorithm name to a public key algorithm id return if the algorithm name is not known int gcry pk map name const char name gcry gcc attr pure return what is commonly  {
	                                                                                                                    commonly :: -1000
                                                                                                                           }
referred as the key length for the given public or private key unsigned int gcry pk get nbits gcry sexp t key gcry gcc attr pure please note that keygrip  {
                            }
is still experimental  {
	experimental :: -1000
 }
and should not be used without contacting  {
	contacting :: -1000
     }
the author  {
	author :: -1000
 }
unsigned char gcry pk get keygrip gcry sexp t key unsigned char array return the name of the curve  {
	             curve :: -1000
                 }
matching key const char gcry pk get curve gcry sexp t key int iterator  {
	     titrator :: 11
	     nitrator :: 11
	     operator :: 10
	    titrators :: 10
	    nitrators :: 10
            }
unsigned int r nbits return an s expression with the parameters of the named ecc  {
	          ecco :: 5
	          ecce :: 4
	          ceca :: 3
             }
curve name algo must be set to an ecc algorithm gcry sexp t gcry pk get param int algo const char name return if the public key algorithm a is available for use define gcry pk test algo a gcry pk algo info a gcryctl test algo null null get a list consisting of the ids of the loaded pubkey  {
	                                                    punkeys :: 8
	                                                    puckery :: 7
	                                                      upbye :: 7
	                                                     punkey :: 9
                                                          }
modules if list is zero write the number of loaded pubkey modules to list length and return if list is non zero the first list length algorithm ids are stored in list which must be of according size in case there are less pubkey modules than list length list length is updated to the correct number gcry error t gcry pk list int list int list length cryptograhic  {
	                                                        cryptograms :: 15
	                                                        cryptograph :: 16
	                                                       cryptographs :: 15
	                                                      cryptographic :: 19
	                                                     cryptographies :: 15
	                                                        cryptorchid :: 15
	                                                         cryptogram :: 16
	                                                        cryptogamic :: 15
                                                                  }
hash functions algorithm ids for the hash functions we know about not all of them are implemnted  {
	       implement :: 15
	    implementors :: 12
	        impleted :: 12
	      implements :: 14
	     implementor :: 13
	     implementer :: 12
	     implemented :: 14
               }
enum gcry md algos gcry md none gcry md md gcry md sha gcry md rmd  {
	            rod :: 3
	            rid :: 3
	            red :: 3
	            rad :: 3
	             rd :: 3
              }
gcry md md gcry md tiger  {
	tiger :: -1000
    }
tiger as used by gpg gcry md haval  {
	  lavas :: 6
	havildar :: 6
	  halva :: 7
	  hamal :: 7
	  halal :: 7
	  hadal :: 7
	  arval :: 6
	  vasal :: 6
	  vagal :: 6
	   lava :: 7
	 halvas :: 6
	 hamals :: 6
	 halals :: 6
	  naval :: 7
	  nahal :: 6
      }
haval pass bit gcry md sha gcry md sha gcry md sha gcry md sha gcry md md gcry md crc  {
	                 das :: -1000
                   }
gcry md crc rfc gcry md crc rfc gcry md whirlpool  {
	 whirlpool :: -1000
         }
gcry md tiger tiger fixed gcry md tiger tiger variant flags used with the open function enum gcry md flags gcry md flag secure allocate all buffers  {
	                   buffers :: -1000
                         }
in secure memory gcry md flag hmac  {
	  cham :: 5
     }
make an hmac out of this algorithm forward declaration struct gcry md context this object is used to hold a handle to a message digest  {
	                  digest :: -1000
                       }
object this structure is private only to be used by the public gcry md macros typedef struct gcry md handle actual context struct gcry md context ctx  {
	                       cox :: 3
                         }
buffer management int bufpos  {
	buffos :: 8
	bufo :: 7
  }
int bufsize  {
	uranographies :: -1000
 }
unsigned char buf gcry md hd t compatibility types do not use them ifndef gcrypt no deprecated typedef struct gcry md handle gcry md hd gcry gcc attr deprecated typedef struct gcry md handle gcrymdhd  {
                                 }
gcry gcc attr deprecated endif create a message digest object for algorithm algo flags may be given as an bitwise or of the gcry md flags values algo may be given as if the algorithms to be used are later set using gcry md enable gcry error t gcry md open gcry md hd t h int algo unsigned int flags release the message digest object hd void gcry md close gcry md hd t hd add the message digest algorithm algo to the digest object hd gcry error t gcry md enable gcry md hd t hd int algo create a new digest object as an exact copy of the object hd gcry error t gcry md copy gcry md hd t bhd  {
	                                                                                                                      bodhr :: 3
	                                                                                                                        bud :: 3
	                                                                                                                        bod :: 3
	                                                                                                                        bid :: 3
	                                                                                                                        bed :: 3
	                                                                                                                        bad :: 3
                                                                                                                          }
gcry md hd t ahd  {
	ahold :: 3
	ahind :: 3
	shad :: 3
	hade :: 3
	dhal :: 3
	dhak :: 3
	chad :: 3
	 had :: 4
	 dah :: 3
	 and :: 3
	 aid :: 3
	 ahs :: 3
	 add :: 3
	  ad :: 3
   }
reset the digest object hd to its initial state void gcry md reset gcry md hd t hd perform various operations on the digest object hd gcry error t gcry md ctl gcry md hd t hd int cmd void buffer size t buflen pass length bytes of data in buffer to the digest object hd so that it can update the digest values this is the actual hash function void gcry md write gcry md hd t hd const void buffer size t length read out the final digest from hd return the digest value for algorithm algo unsigned char gcry md read gcry md hd t hd int algo convenience function to calculate the hash from the data in buffer of size length using the algorithm algo avoiding  {
	                                                                                                                         avoiding :: -1000
                                                                                                                                }
the creating of a hash object the hash is returned in the caller provided buffer digest which must be large enough to hold the digest of the given algorithm void gcry md hash buffer int algo void digest const void buffer size t length retrieve the algorithm used with hd this does not work reliable  {
	                                              reliable :: -1000
                                                     }
if more than one algorithm is enabled in hd int gcry md get algo gcry md hd t hd retrieve the length in bytes of the digest yielded  {
	                    yielded :: -1000
                          }
by algorithm algo unsigned int gcry md get algo dlen  {
	   blends :: 5
	    eland :: 5
	    blend :: 6
	     glen :: 5
        }
int algo return true if the the algorithm algo is enabled in the digest object a int gcry md is enabled gcry md hd t a int algo return true if the digest object a is allocated in secure memory int gcry md is secure gcry md hd t a retrieve various information about the object h gcry error t gcry md info gcry md hd t h int what void buffer size t nbytes retrieve various information about the algorithm algo gcry error t gcry md algo info int algo int what void buffer size t nbytes map the digest algorithm id algo to a string representation of the algorithm name for unknown algorithms this function returns const char gcry md algo name int algo gcry gcc attr pure map the algorithm name to a digest algorithm id return if the algorithm name is not known int gcry md map name const char name gcry gcc attr pure for use with the hmac feature the set mac key to the key of keylen bytes gcry error t gcry md setkey gcry md hd t hd const void key size t keylen start or stop debugging for digest handle hd i e create a file named dbgmd  {
	                                                                                                                                                                                                  decelerating :: -1000
                                                                                                                                                                                                             }
n suffix while hashing  {
	hashing :: -1000
  }
if suffix is null debugging stops and the file will be closed void gcry md debug gcry md hd t hd const char suffix update the hash s of h with the character c this is a buffered  {
	                             epulises :: -1000
                                    }
version of the gcry md write function define gcry md putc  {
	      puss :: -1000
         }
h c do gcry md hd t h h if h bufpos h bufsize gcry md write h null h buf h bufpos c xff while finalize the digest calculation this is not really needed because gcry md read does this implicitly define gcry md final a gcry md ctl a gcryctl finalize null return if the algorithm a is available for use define gcry md test algo a gcry md algo info a gcryctl test algo null null return an der encoded asn oid for the algorithm a in buffer b n must point to size t variable with the available size of buffer b after return it will receive the actual size of the returned oid define gcry md get asnoid a b n gcry md algo info a gcryctl get asnoid b n enable debugging for digest object a i e create files named dbgmd n string while hashing b is a string used as the suffix for the filename this macro is deprecated use gcry md debug ifndef gcrypt no deprecated define gcry md start debug a b gcry md ctl a gcryctl start dump b disable the debugging of a this macro is deprecated use gcry md debug define gcry md stop debug a b gcry md ctl a gcryctl stop dump b endif get a list consisting of the ids of the loaded message digest modules if list is zero write the number of loaded message digest modules to list length and return if list is non zero the first list length algorithm ids are stored in list which must be of according size in case there are less message digest modules than list length list length is updated to the correct number gcry error t gcry md list int list int list length alternative interface for asymmetric cryptography  {
	                                                                                                                                                                                                                                                                                                    cryptography :: -1000
                                                                                                                                                                                                                                                                                                               }
this interface is deprecated the algorithm ids typedef enum gcry ac id gcry ac rsa gcry ac dsa gcry ac elg gcry ac elg e gcry ac id t gcry attr internal key types typedef enum gcry ac key type gcry ac key secret  {
	                                     secret :: -1000
                                          }
gcry ac key public gcry ac key type t gcry attr internal encoding methods  {
	      methods :: -1000
            }
typedef enum gcry ac em gcry ac eme  {
	    eme :: -1000
      }
pkcs  {
	pics :: 5
	pacs :: 5
	pucks :: 5
	pocks :: 5
	picks :: 5
	pecks :: 5
	packs :: 5
 }
v gcry ac emsa  {
	emmas :: 5
	embays :: 5
	embars :: 5
	smear :: 5
	mesa :: 6
	mase :: 5
	mesal :: 5
	ems :: 6
	eas :: 5
  }
pkcs v gcry ac em t gcry attr internal encryption and signature schemes  {
	     schemes :: -1000
           }
typedef enum gcry ac scheme gcry ac es pkcs v gcry ac ssa  {
	       sways :: 3
	       swats :: 3
	       swash :: 3
	       swaps :: 3
	       swans :: 3
	       swags :: 3
	       swads :: 3
	       swabs :: 3
	       stays :: 3
	       staws :: 3
	       stats :: 3
	       stash :: 3
	       stars :: 3
	       staps :: 3
	       stags :: 3
	       stabs :: 3
	        spas :: 4
	        skas :: 4
	        seas :: 4
	        says :: 3
	        saws :: 3
	        sash :: 3
	        sars :: 3
	        saps :: 3
	        sans :: 3
	        sals :: 3
	        sais :: 3
	        sags :: 3
	        sacs :: 3
	        sabs :: 3
	       spays :: 3
	       spats :: 3
	       spasm :: 3
	       spars :: 3
	       spans :: 3
	       spams :: 3
	       spaes :: 3
	       soars :: 3
	       soaps :: 3
	       soaks :: 3
	       snaws :: 3
	       snash :: 3
	       snaps :: 3
	       snags :: 3
	       snabs :: 3
	       smash :: 3
	       slays :: 3
	       slaws :: 3
	       slats :: 3
	       slash :: 3
	       slaps :: 3
	       slams :: 3
	       slags :: 3
	       slaes :: 3
	       slabs :: 3
	       skaws :: 3
	       skats :: 3
	       skags :: 3
	       sials :: 3
	       shays :: 3
	       shash :: 3
	       shaps :: 3
	       shans :: 3
	       shams :: 3
	       shahs :: 3
	       shags :: 3
	       shads :: 3
	       seats :: 3
	       sears :: 3
	       seans :: 3
	       seams :: 3
	       seals :: 3
	       scaws :: 3
	       scats :: 3
	       scars :: 3
	       scans :: 3
	       scags :: 3
	       scads :: 3
	       scabs :: 3
	         ass :: 3
	          as :: 3
           }
pkcs v gcry ac scheme t gcry attr internal ac data define gcry ac flag dealloc  {
	      scalloped :: 9
	       headlock :: 9
	       deadlock :: 9
	        decalog :: 9
	     gralloched :: 9
              }
define gcry ac flag copy define gcry ac flag no blinding  {
	  blinding :: -1000
         }
this type represents a data set typedef struct gcry ac data gcry ac data t gcry attr internal this type represents a single key either a secret one or a public one typedef struct gcry ac key gcry ac key t gcry attr internal this type represents a key pair containing a secret and a public key typedef struct gcry ac key pair gcry ac key pair t gcry attr internal this type represents a handle that is needed by functions performing  {
	                                                                       performing :: -1000
                                                                                }
cryptographic operations typedef struct gcry ac handle gcry ac handle t gcry attr internal typedef gpg error t gcry ac data read cb t void opaque unsigned char buffer size t buffer n gcry attr internal typedef gpg error t gcry ac data write cb t void opaque unsigned char buffer size t buffer n gcry attr internal typedef enum gcry ac io readable gcry ac io writable gcry ac io mode t gcry attr internal typedef enum gcry ac io string gcry ac io callback gcry ac io type t gcry attr internal typedef struct gcry ac io this is an internal structure do not use manually  {
	                                                                                                   manually :: -1000
                                                                                                          }
gcry ac io mode t mode gcry attr internal gcry ac io type t type gcry attr internal union union struct gcry ac data read cb t cb void opaque callback struct unsigned char data size t data n string void opaque readable union struct gcry ac data write cb t cb void opaque callback struct unsigned char data size t data n string void opaque writable io gcry attr internal gcry ac io t gcry attr internal the caller of gcry ac key pair generate can provide one of these structures in order to influence  {
	                                                                                      influence :: -1000
                                                                                              }
the key generation  {
	generation :: -1000
 }
process in an algorithm specific way typedef struct gcry ac key spec rsa gcry mpi t e e to use gcry ac key spec rsa t gcry attr internal structure used for passing data to the implementation of the eme pkcs v encoding method typedef struct gcry ac eme pkcs v size t key size gcry ac eme pkcs v t gcry attr internal typedef enum gcry md algos gcry md algo t gcry attr internal structure used for passing data to the implementation of the emsa pkcs v encoding method typedef struct gcry ac emsa pkcs v gcry md algo t md size t em n gcry ac emsa pkcs v t gcry attr internal structure used for passing data to the implementation of the ssa pkcs v signature scheme typedef struct gcry ac ssa pkcs v gcry md algo t md gcry ac ssa pkcs v t gcry attr internal ifndef gcrypt no deprecated returns a new empty data set in data gcry error t gcry ac data new gcry ac data t data gcry attr internal destroy the data set data void gcry ac data destroy gcry ac data t data gcry attr internal create a copy of the data set data and store it in data cp gcry error t gcry ac data copy gcry ac data t data cp gcry ac data t data gcry attr internal return the number of named mpi values inside  {
	                                                                                                                                                                                                                                         inside :: -1000
                                                                                                                                                                                                                                              }
of the data set data unsigned int gcry ac data length gcry ac data t data gcry attr internal destroy any values contained in the data set data void gcry ac data clear gcry ac data t data gcry attr internal add the value mpi to data with the label name if flags contains gcry ac flag data copy the data set will contain copies of name and mpi if flags contains gcry ac flag data dealloc or gcry ac flag data copy the values contained in the data set will be deallocated  {
	                                                                                 reallocates :: 16
	                                                                                 reallocated :: 19
	                                                                                  reallocate :: 17
	                                                                                 unallocated :: 16
                                                                                           }
when they are to be removed from the data set gcry error t gcry ac data set gcry ac data t data unsigned int flags const char name gcry mpi t mpi gcry attr internal store the value labelled  {
	                              labelled :: -1000
                                     }
with name found in data in mpi if flags contains gcry ac flag copy store a copy of the mpi value contained in the data set mpi may be null gcry error t gcry ac data get name gcry ac data t data unsigned int flags const char name gcry mpi t mpi gcry attr internal stores  {
	                                                  stores :: -1000
                                                       }
in name and mpi the named mpi value contained in the data set data with the index idx  {
	              huh :: -1000
                }
if flags contains gcry ac flag copy store copies of the values contained in the data set name or mpi may be null gcry error t gcry ac data get index gcry ac data t data unsigned int flags unsigned int idx const char name gcry mpi t mpi gcry attr internal convert the data set data into a new s expression which is to be stored in sexp according to the identifiers contained in identifiers gcry error t gcry ac data to sexp gcry ac data t data gcry sexp t sexp const char identifiers gcry attr internal create a new data set which is to be stored in data set from the s expression sexp according to the identifiers contained in identifiers gcry error t gcry ac data from sexp gcry ac data t data gcry sexp t sexp const char identifiers gcry attr internal initialize ac io according to mode type and the variable list of arguments the list of variable arguments to specify depends on the given type void gcry ac io init gcry ac io t ac io gcry ac io mode t mode gcry ac io type t type gcry attr internal initialize ac io according to mode type and the variable list of arguments ap the list of variable arguments to specify depends on the given type void gcry ac io init va gcry ac io t ac io gcry ac io mode t mode gcry ac io type t type va list ap gcry attr internal create a new ac handle gcry error t gcry ac open gcry ac handle t handle gcry ac id t algorithm unsigned int flags gcry attr internal destroy an ac handle void gcry ac close gcry ac handle t handle gcry attr internal initialize a key from a given data set gcry error t gcry ac key init gcry ac key t key gcry ac handle t handle gcry ac key type t type gcry ac data t data gcry attr internal generates  {
	                                                                                                                                                                                                                                                                                                                                       generates :: -1000
                                                                                                                                                                                                                                                                                                                                               }
a new key pair via the handle handle of nbits bits and stores it in key pair in case non standard settings  {
	             settings :: -1000
                    }
are wanted a pointer to a structure of type gcry ac key spec algorithm t matching the selected algorithm can be given as key spec misc data is not used yet gcry error t gcry ac key pair generate gcry ac handle t handle unsigned int nbits void spec gcry ac key pair t key pair gcry mpi t misc data gcry attr internal returns the key of type which out of the key pair key pair gcry ac key t gcry ac key pair extract gcry ac key pair t key pair gcry ac key type t which gcry attr internal returns the data set contained in the key key gcry ac data t gcry ac key data get gcry ac key t key gcry attr internal verifies  {
	                                                                                                                        verifies :: -1000
                                                                                                                               }
that the key key is sane via handle gcry error t gcry ac key test gcry ac handle t handle gcry ac key t key gcry attr internal stores the number of bits of the key key in nbits via handle gcry error t gcry ac key get nbits gcry ac handle t handle gcry ac key t key unsigned int nbits gcry attr internal writes the byte long key grip  {
	                                                                 runny :: -1000
                                                                     }
of the key key to key grip via handle gcry error t gcry ac key get grip gcry ac handle t handle gcry ac key t key unsigned char key grip gcry attr internal destroy a key void gcry ac key destroy gcry ac key t key gcry attr internal destroy a key pair void gcry ac key pair destroy gcry ac key pair t key pair gcry attr internal encodes a message according to the encoding method method options must be a pointer to a method specific structure gcry ac em t gcry error t gcry ac data encode gcry ac em t method unsigned int flags void options gcry ac io t io read gcry ac io t io write gcry attr internal decodes  {
	                                                                                                                      decodes :: -1000
                                                                                                                            }
a message according to the encoding method method options must be a pointer to a method specific structure gcry ac em t gcry error t gcry ac data decode gcry ac em t method unsigned int flags void options gcry ac io t io read gcry ac io t io write gcry attr internal encrypt the plain text mpi value data plain with the key key under the control of the flags flags and store the resulting  {
	                                                                   resulting :: -1000
                                                                           }
data set into data encrypted gcry error t gcry ac data encrypt gcry ac handle t handle unsigned int flags gcry ac key t key gcry mpi t data plain gcry ac data t data encrypted gcry attr internal decrypt the decrypted  {
	                                decrypted :: -1000
                                        }
data contained in the data set data encrypted with the key key under the control of the flags flags and store the resulting plain text mpi value in data plain gcry error t gcry ac data decrypt gcry ac handle t handle unsigned int flags gcry ac key t key gcry mpi t data plain gcry ac data t data encrypted gcry attr internal sign the data contained in data with the key key and store the resulting signature in the data set data signature gcry error t gcry ac data sign gcry ac handle t handle gcry ac key t key gcry mpi t data gcry ac data t data signature gcry attr internal verify that the signature contained in the data set data signature is indeed  {
	                                                                                                                         indeed :: -1000
                                                                                                                              }
the result of signing  {
	signing :: -1000
  }
the data contained in data with the secret key belonging  {
	belonging :: -1000
        }
to the public key key gcry error t gcry ac data verify gcry ac handle t handle gcry ac key t key gcry mpi t data gcry ac data t data signature gcry attr internal encrypts  {
	                               kerf :: -1000
                                  }
the plain text readable from io message through handle with the public key key according to scheme flags and opts if opts is not null it has to be a pointer to a structure specific to the chosen scheme gcry ac es t the encrypted message is written to io cipher gcry error t gcry ac data encrypt scheme gcry ac handle t handle gcry ac scheme t scheme unsigned int flags void opts gcry ac key t key gcry ac io t io message gcry ac io t io cipher gcry attr internal decrypts  {
	                                                                                      decrypts :: -1000
                                                                                             }
the cipher text readable from io cipher through handle with the secret key key according to scheme var flags and opts if opts is not null it has to be a pointer to a structure specific to the chosen scheme gcry ac es t the decrypted message is written to io message gcry error t gcry ac data decrypt scheme gcry ac handle t handle gcry ac scheme t scheme unsigned int flags void opts gcry ac key t key gcry ac io t io cipher gcry ac io t io message gcry attr internal signs  {
	                                                                                          signs :: -1000
                                                                                              }
the message readable from io message through handle with the secret key key according to scheme flags and opts if opts is not null it has to be a pointer to a structure specific to the chosen scheme gcry ac ssa t the signature is written to io signature gcry error t gcry ac data sign scheme gcry ac handle t handle gcry ac scheme t scheme unsigned int flags void opts gcry ac key t key gcry ac io t io message gcry ac io t io signature gcry attr internal verifies through handle that the signature readable from io signature is indeed the result of signing the message readable from io message with the secret key belonging to the public key key according to scheme and opts if opts is not null it has to be an anonymous  {
	                                                                                                                                  anonymous :: -1000
                                                                                                                                          }
structure gcry ac ssa t specific to the chosen scheme gcry error t gcry ac data verify scheme gcry ac handle t handle gcry ac scheme t scheme unsigned int flags void opts gcry ac key t key gcry ac io t io message gcry ac io t io signature gcry attr internal store the textual  {
	                                                textual :: -1000
                                                      }
representation of the algorithm whose id is given in algorithm in name this function is deprecated use gcry pk algo name gcry error t gcry ac id to name gcry ac id t algorithm const char name gcry gcc attr deprecated store the numeric id of the algorithm whose textual representation is contained in name in algorithm this function is deprecated use gcry pk map name gcry error t gcry ac name to id const char name gcry ac id t algorithm gcry gcc attr deprecated endif gcrypt no deprecated key derivation  {
	                                                                                 derivation :: -1000
                                                                                          }
functions algorithm ids for the kdfs  {
	 kifs :: 5
	 kefs :: 5
	 kafs :: 5
    }
enum gcry kdf algos gcry kdf none gcry kdf simple s k gcry kdf salted  {
	        salted :: -1000
             }
s k gcry kdf itersalted  {
	oversalted :: 14
	oversailed :: 12
	reinstated :: 12
	eternalist :: 12
	overstated :: 12
	misrelated :: 12
	disrelated :: 12
	iterates :: 12
	iterated :: 12
   }
s k gcry kdf pbkdf  {
   }
gcry kdf pbkdf derive a key from a passphrase  {
	ascorbate :: -1000
       }
gpg error t gcry kdf derive const void passphrase size t passphraselen  {
          }
int algo int subalgo  {
	lumbagos :: 9
	subgoal :: 10
  }
const void salt size t saltlen  {
	tallness :: 9
	saltly :: 9
	sallet :: 9
	cantles :: 9
	stollen :: 9
	saltern :: 9
	mantles :: 9
	hantles :: 9
	saltless :: 9
	haltless :: 9
	saltlike :: 9
    }
unsigned long iterations  {
	iterations :: -1000
 }
size t keysize  {
 }
void keybuffer  {
 }
random generating  {
	generating :: -1000
 }
functions the possible values for the random quality  {
	reality :: -1000
      }
the rule of thumb is to use strong  {
	 strong :: -1000
      }
for session  {
	session :: -1000
 }
keys and very strong for key material weak is usually an alias for strong and should not be used anymore except with gcry mpi randomize  {
	               randomize :: -1000
                       }
use gcry create nonce  {
	nonce :: -1000
  }
instead typedef enum gcry random level gcry weak random gcry strong random gcry very strong random gcry random level t fill buffer with length bytes of random using random numbers of quality level void gcry randomize void buffer size t length enum gcry random level level add the external random from buffer with length bytes into the pool  {
	                                                     pool :: -1000
                                                        }
quality should either be for unknown or in the range of to gcry error t gcry random add bytes const void buffer size t length int quality if random numbers are used in an application this macro should be called from time to time so that new stuff  {
	                                          stuff :: -1000
                                              }
gets added to the internal pool of the rng  {
	   angry :: 3
	   anger :: 3
	    rung :: 3
	    rong :: 3
	    ring :: 3
	    rang :: 3
	    gnar :: 3
	   regna :: 3
	     rig :: 3
	     reg :: 3
	     rag :: 3
	     eng :: 3
       }
define gcry fast random poll gcry control gcryctl fast poll null return nbytes of allocated random using a random numbers of quality level void gcry random bytes size t nbytes enum gcry random level level gcry gcc attr malloc return nbytes of allocated random using a random numbers of quality level the random numbers are created returned in secure memory void gcry random bytes secure size t nbytes enum gcry random level level gcry gcc attr malloc set the big integer w to a random value of nbits using a random generator  {
	                                                                                  generator :: -1000
                                                                                          }
with quality level note that by using a level of gcry weak random gcry create nonce is used internally void gcry mpi randomize gcry mpi t w unsigned int nbits enum gcry random level level create an unpredicable  {
	                         unbridgeable :: 16
	                        unpredictable :: 19
	                        unpredictably :: 16
	                         unprofitable :: 15
	                         reproducible :: 15
	                         ineradicable :: 17
	                           uncredible :: 16
	                       unpredictables :: 18
                                    }
nonce of length bytes in buffer void gcry create nonce void buffer size t length prime number functions mode values passed to a gcry prime check func t define gcry prime check at finish define gcry prime check at got prime define gcry prime check at maybe  {
	                                         maybe :: -1000
                                             }
prime the function should return if the operation shall continue to reject the prime candidate  {
	     candidate :: -1000
             }
typedef int gcry prime check func t void arg int mode gcry mpi t candidate flags for gcry prime generate allocate prime numbers and factors  {
	                 factors :: -1000
                       }
in secure memory define gcry prime flag secret make sure that at least one prime factor is of size factor bits define gcry prime flag special factor generate a new prime number of prime bits bits and store it in prime if factor bits is non zero one of the prime factors of prime must be factor bits bits long if factors is non zero allocate a new null terminated array holding  {
	                                                                holding :: -1000
                                                                      }
the prime factors and store it in factors flags might be used to influence the prime number generation process gcry error t gcry prime generate gcry mpi t prime unsigned int prime bits unsigned int factor bits gcry mpi t factors gcry prime check func t cb func void cb arg gcry random level t random level unsigned int flags find a generator for prime where the factorization  {
	                                                      factorization :: -1000
                                                                  }
of prime is in the null terminated array factors return the generator as a newly allocated mpi in r g if start g is not null use this as teh  {
	                        teugh :: 3
	                        teuch :: 3
	                        tench :: 3
	                        techy :: 3
	                        techs :: 3
	                        teach :: 3
	                         they :: 3
	                         thew :: 3
	                         then :: 3
	                         them :: 3
	                         thee :: 3
	                         thae :: 3
	                         teth :: 3
	                         tech :: 4
	                         meth :: 3
	                         hets :: 3
	                         heth :: 3
	                         hest :: 3
	                         hent :: 3
	                         heft :: 3
	                         heat :: 3
	                         ethe :: 3
	                         echt :: 3
	                         beth :: 3
	                          yeh :: 3
	                          the :: 4
	                          tew :: 3
	                          tes :: 3
	                          ten :: 3
	                          tel :: 3
	                          teg :: 3
	                          tef :: 3
	                          ted :: 3
	                          tea :: 3
	                          reh :: 3
	                          peh :: 3
	                          heh :: 3
	                          feh :: 3
	                          eth :: 4
	                           te :: 4
	                           he :: 3
                            }
start for the search gcry error t gcry prime group generator gcry mpi t r g gcry mpi t prime gcry mpi t factors gcry mpi t start g convenience function to release the factors array void gcry prime release factors gcry mpi t factors check wether  {
	                                        wether :: -1000
                                             }
the number x is prime gcry error t gcry prime check gcry mpi t x unsigned int flags miscellaneous stuff log levels used by the internal logging facility enum gcry log levels gcry log cont continue the last log line gcry log info gcry log warn gcry log error gcry log fatal gcry log bug gcry log debug type for progress  {
	                                                    progress :: -1000
                                                           }
handlers typedef void gcry handler progress t void const char int int int type for memory allocation handlers typedef void gcry handler alloc t size t n type for secure memory check handlers typedef int gcry handler secure check t const void type for memory reallocation  {
	                                 reallocation :: -1000
                                            }
handlers typedef void gcry handler realloc t void p size t n type for memory free handlers typedef void gcry handler free t void type for out of memory handlers typedef int gcry handler no mem t void size t unsigned int type for fatal error handlers typedef void gcry handler error t void int const char type for logging handlers typedef void gcry handler log t void int const char va list certain operations can provide progress information this function is used to register a handler for retrieving  {
	                                                                              retrieving :: -1000
                                                                                       }
these information void gcry set progress handler gcry handler progress t cb void cb data register a custom memory allocation functions void gcry set allocation handler gcry handler alloc t func alloc gcry handler alloc t func alloc secure gcry handler secure check t func secure check gcry handler realloc t func realloc gcry handler free t func free register a function used instead of the internal out of memory handler void gcry set outofcore  {
                                                                         }
handler gcry handler no mem t h void opaque register a function used instead of the internal fatal error handler void gcry set fatalerror  {
                      }
handler gcry handler error t fnc  {
	ficin :: 3
    }
void opaque register a function used instead of the internal logging facility void gcry set log handler gcry handler log t f void opaque reserved for future use void gcry set gettext handler const char f const char libgcrypt uses its own memory allocation it is important to use gcry free to release memory allocated by libgcrypt void gcry malloc size t n gcry gcc attr malloc void gcry calloc  {
	                                                                hallo :: 7
	                                                             ballocks :: 7
	                                                             ballcock :: 7
	                                                              carlock :: 8
	                                                              callose :: 7
	                                                              callous :: 7
	                                                              callows :: 7
	                                                           collocates :: 7
	                                                           collocated :: 7
	                                                            collocate :: 8
	                                                              collect :: 7
	                                                                 call :: 7
	                                                               callow :: 8
	                                                               callop :: 8
                                                                    }
size t n size t m gcry gcc attr malloc void gcry malloc secure size t n gcry gcc attr malloc void gcry calloc secure size t n size t m gcry gcc attr malloc void gcry realloc void a size t n char gcry strdup  {
	                                      disrupt :: 7
	                                     sprouted :: 7
	                                      stroups :: 7
	                                       perdus :: 7
	                                       stroup :: 9
	                                       stroud :: 8
	                                        turds :: 7
	                                         surd :: 7
	                                       sprout :: 7
                                            }
const char string gcry gcc attr malloc void gcry xmalloc  {
        }
size t n gcry gcc attr malloc void gcry xcalloc  {
        }
size t n size t m gcry gcc attr malloc void gcry xmalloc secure size t n gcry gcc attr malloc void gcry xcalloc secure size t n size t m gcry gcc attr malloc void gcry xrealloc  {
	                             preallot :: 10
                                    }
void a size t n char gcry xstrdup  {
      }
const char a gcry gcc attr malloc void gcry free void a return true if a is allocated in secure memory int gcry is secure const void a gcry gcc attr pure return true if libgcrypt is in fips mode define gcry fips mode active gcry control gcryctl fips mode p include support for libgcrypt modules include gcrypt module h if keep emacsens auto indent happy endif ifdef cplusplus endif endif gcrypt h local variables buffer read only t end gcrypt module h gnu cryptographic library interface copyright c free software foundation inc this file is part of libgcrypt libgcrypt is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version libgcrypt is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with this program if not see http www gnu org licenses this file contains the necessary declarations definitions for working with libgcrypt modules ifndef gcrypt module h define gcrypt module h ifdef cplusplus extern c if keep emacsens s auto indent happy endif endif the interfaces using the module system reserve a certain range of ids for application use these ids are not valid within libgcrypt but libgcrypt makes sure never to allocate such a module id define gcry module id user define gcry module id user last this type represents a module typedef struct gcry module gcry module t check that the library fulfills the version requirement type for the cipher setkey function typedef gcry err code t gcry cipher setkey t void c const unsigned char key unsigned keylen type for the cipher encrypt function typedef void gcry cipher encrypt t void c unsigned char outbuf const unsigned char inbuf  {
                                                                                                                                                                                                                                                                                                                                                      }
type for the cipher decrypt function typedef void gcry cipher decrypt t void c unsigned char outbuf const unsigned char inbuf type for the cipher stencrypt  {
	                  sceptry :: 11
                        }
function typedef void gcry cipher stencrypt t void c unsigned char outbuf const unsigned char inbuf unsigned int n type for the cipher stdecrypt  {
                      }
function typedef void gcry cipher stdecrypt t void c unsigned char outbuf const unsigned char inbuf unsigned int n typedef struct gcry cipher oid spec const char oid int mode gcry cipher oid spec t module specification structure for ciphers typedef struct gcry cipher spec const char name const char aliases gcry cipher oid spec t oids  {
	                                                   fidos :: 5
	                                                   eidos :: 5
	                                                   dipso :: 5
	                                                   didos :: 5
	                                                    yids :: 5
	                                                    vids :: 5
	                                                    tids :: 5
	                                                    rids :: 5
	                                                    olds :: 5
	                                                    oils :: 5
	                                                    odds :: 5
	                                                    nids :: 5
	                                                    mids :: 5
	                                                    lids :: 5
	                                                    kids :: 5
	                                                    gids :: 5
	                                                    fids :: 5
	                                                    bids :: 5
	                                                    aids :: 5
	                                                   odist :: 5
	                                                   odism :: 5
	                                                     ois :: 5
	                                                   lidos :: 5
                                                       }
size t blocksize  {
	blocks :: 12
	clockwise :: 11
	blockiest :: 12
	blockish :: 11
	blockers :: 11
	blockier :: 11
 }
size t keylen size t contextsize  {
	contexts :: 15
	contextualizes :: 15
	contextualize :: 14
	contextures :: 14
	contextless :: 14
    }
gcry cipher setkey t setkey gcry cipher encrypt t encrypt gcry cipher decrypt t decrypt gcry cipher stencrypt t stencrypt gcry cipher stdecrypt t stdecrypt gcry cipher spec t register a new cipher module whose specification can be found in cipher on success a new algorithm id is stored in algorithm id and a pointer representing this module is stored in module gcry error t gcry cipher register gcry cipher spec t cipher int algorithm id gcry module t module gcry attr internal unregister  {
	                                                                       unregistered :: 16
	                                                                         scrutineer :: 12
	                                                                         unresisted :: 13
	                                                                        reregisters :: 12
	                                                                         reregister :: 14
	                                                                         enregister :: 17
	                                                                         deregister :: 14
	                                                                        enregisters :: 15
	                                                                         undigested :: 12
	                                                                       enregistered :: 13
                                                                                  }
the cipher identified by module which must have been registered with gcry cipher register void gcry cipher unregister gcry module t module gcry attr internal type for the pk generate function typedef gcry err code t gcry pk generate t int algo unsigned int nbits unsigned long use e gcry mpi t skey gcry mpi t retfactors  {
	                                                 retract :: 13
	                                             tetrachords :: 12
	                                              infractors :: 12
	                                              refractory :: 12
	                                              refractors :: 15
	                                              retractors :: 16
	                                              retraction :: 12
	                                              formatters :: 12
	                                              attractors :: 13
	                                              detractory :: 13
	                                              detractors :: 16
	                                               refractor :: 13
	                                               retroacts :: 12
	                                                 refract :: 12
	                                              reflectors :: 12
	                                             refractions :: 12
	                                             retractions :: 13
	                                                refracts :: 13
	                                              perfectors :: 12
	                                               retractor :: 14
	                                               extractor :: 13
	                                               detractor :: 14
	                                                retracts :: 14
                                                       }
type for the pk check secret key function typedef gcry err code t gcry pk check secret key t int algo gcry mpi t skey type for the pk encrypt function typedef gcry err code t gcry pk encrypt t int algo gcry mpi t resarr  {
	                                    recarries :: 7
	                                    remarries :: 7
	                                      remarry :: 8
	                                      recarry :: 8
	                                      rearers :: 7
                                            }
gcry mpi t data gcry mpi t pkey int flags type for the pk decrypt function typedef gcry err code t gcry pk decrypt t int algo gcry mpi t result gcry mpi t data gcry mpi t skey int flags type for the pk sign function typedef gcry err code t gcry pk sign t int algo gcry mpi t resarr gcry mpi t data gcry mpi t skey type for the pk verify function typedef gcry err code t gcry pk verify t int algo gcry mpi t hash gcry mpi t data gcry mpi t pkey int cmp void gcry mpi t void opaquev  {
	                                                                                                   opaqued :: 11
	                                                                                                   opaques :: 11
	                                                                                                   opaquer :: 11
	                                                                                                  opaquely :: 10
	                                                                                                  opaquest :: 10
	                                                                                                    opaque :: 12
                                                                                                         }
type for the pk get nbits function typedef unsigned gcry pk get nbits t int algo gcry mpi t pkey module specification structure for message digests  {
	                  digests :: -1000
                        }
typedef struct gcry pk spec const char name const char aliases const char elements pkey const char elements skey const char elements enc const char elements sig const char elements grip int use gcry pk generate t generate gcry pk check secret key t check secret key gcry pk encrypt t encrypt gcry pk decrypt t decrypt gcry pk sign t sign gcry pk verify t verify gcry pk get nbits t get nbits gcry pk spec t register a new pubkey module whose specification can be found in pubkey on success a new algorithm id is stored in algorithm id and a pointer representhing  {
	                                                                                           reprehensions :: 17
	                                                                                          representation :: 16
	                                                                                            representing :: 21
	                                                                                               represent :: 17
	                                                                                            reprehension :: 18
	                                                                                            reprehending :: 17
                                                                                                       }
this module is stored in module gcry error t gcry pk register gcry pk spec t pubkey unsigned int algorithm id gcry module t module gcry attr internal unregister the pubkey identified by id which must have been registered with gcry pk register void gcry pk unregister gcry module t module gcry attr internal type for the md init function typedef void gcry md init t void c type for the md write function typedef void gcry md write t void c const void buf size t nbytes type for the md final function typedef void gcry md final t void c type for the md read function typedef unsigned char gcry md read t void c typedef struct gcry md oid spec const char oidstring  {
	                                                                                                                    outspring :: 11
	                                                                                                                    disrobing :: 11
	                                                                                                                    firstling :: 11
	                                                                                                                    riposting :: 11
	                                                                                                                  constringed :: 11
	                                                                                                                    maistring :: 11
	                                                                                                                    disrating :: 11
	                                                                                                                    indorsing :: 11
	                                                                                                                    outriding :: 11
	                                                                                                                    bowstring :: 11
	                                                                                                                  outstriding :: 11
                                                                                                                            }
gcry md oid spec t module specification structure for message digests typedef struct gcry md spec const char name unsigned char asnoid int asnlen  {
	                lanners :: 7
	                asklent :: 8
	                fannels :: 7
	               eanlings :: 7
	                cannels :: 7
	                 anoles :: 7
	                 ankles :: 7
	                 angles :: 7
	                 aneles :: 7
	                 ancles :: 7
	               anilines :: 7
                      }
gcry md oid spec t oids int mdlen  {
	  admen :: 6
	 milden :: 6
	   meld :: 6
	  muled :: 6
	  ndler :: 6
	  melon :: 6
      }
gcry md init t init gcry md write t write gcry md final t final gcry md read t read size t contextsize allocate this amount  {
	                   amount :: -1000
                        }
of context gcry md spec t register a new digest module whose specification can be found in digest on success a new algorithm id is stored in algorithm id and a pointer representhing this module is stored in module gcry error t gcry md register gcry md spec t digest unsigned int algorithm id gcry module t module gcry attr internal unregister the digest identified by id which must have been registered with gcry digest register void gcry md unregister gcry module t module gcry attr internal if keep emacsens s auto indent happy endif ifdef cplusplus endif endif declarations for getopt copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef getopt h ifndef need getopt define getopt h endif if gnu library is not already defined either we are being used standalone or this is the first header included in the source file if we are being used with glibc we need to include features h but that does not exist if we are standalone so if gnu library is not defined include ctype h which will pull  {
	                                                                                                                                                                                                                                                                                                            pull :: -1000
                                                                                                                                                                                                                                                                                                               }
in features h for us if it s from glibc why  {
	       why :: -1000
         }
ctype h it s guaranteed to exist and it doesn t flood  {
	      flood :: -1000
          }
the namespace with stuff the way some other headers do if defined gnu library include ctype h endif ifndef throw ifndef gnuc prereq define gnuc prereq maj min endif if defined cplusplus gnuc prereq define throw throw else define throw endif endif ifdef cplusplus extern c endif for communication from getopt to the caller when getopt finds  {
	                                                   finds :: -1000
                                                       }
an option that takes an argument the argument value is returned here also when ordering is return in order each non option argv element is returned here extern char optarg index in argv of the next element to be scanned this is used for communication to and from the caller and for communication between successive  {
	                                            successive :: -1000
                                                     }
calls to getopt on entry to getopt zero means this is the first call initialize when getopt returns this is the index of the first of the non option elements that the caller should itself scan otherwise optind  {
	                               poting :: 7
	                               doting :: 7
	                               option :: 7
	                               opting :: 9
	                               opined :: 7
	                             optioned :: 7
	                                piton :: 7
	                             satinpod :: 7
	                                optic :: 7
	                                opsin :: 7
                                    }
communicates  {
	communicates :: -1000
 }
from one call to the next how much of argv has been scanned so far extern int optind callers  {
	           callers :: -1000
                 }
store zero here to inhibit the error message getopt prints for unrecognized options extern int opterr  {
	         pretor :: 7
	         porter :: 7
	          opted :: 7
              }
set to an option character which was unrecognized extern int optopt  {
	      oppo :: 7
         }
ifndef need getopt describe the long named options requested by the application the long options argument to getopt long or getopt long only is a vector of struct option terminated by an element containing a name which is zero the field has arg is no argument or if the option does not take an argument required argument or if the option requires an argument optional argument or if the option takes an optional argument if the field flag is not null it points to a variable that is set to the value given in the field val when the option is found but left unchanged  {
	                                                                                               unchanged :: -1000
                                                                                                       }
if the option is not found to have a long named option do something other than set an int to a compiled in constant such as set a value from optarg set the option s flag field to zero and its val field to a nonzero value the equivalent single letter  {
	                                            letter :: -1000
                                                 }
option character if there is one for long options that have a zero flag field getopt returns the contents of the val field struct option const char name has arg can t be an enum because some compilers complain  {
	                              complain :: -1000
                                     }
about type mismatches  {
	mismatches :: -1000
 }
in all the code that assumes it is an int int has arg int flag int val names for the values of the has arg field of struct option define no argument define required argument define optional argument endif need getopt get definitions and prototypes for functions to process the arguments in argv argc of them minus  {
	                                                   minus :: -1000
                                                       }
the program name for options given in opts return the option character from opts just read return when there are no more options for unrecognized options or options missing arguments optopt is set to the option letter and is returned the opts string is a list of characters which are recognized  {
	                                        recognized :: -1000
                                                 }
option letters  {
	letters :: -1000
 }
optionally  {
	optionally :: -1000
 }
followed by colons  {
	colons :: -1000
 }
specifying that that letter takes an argument to be placed in optarg if a letter in opts is followed by two colons its argument is optional this behavior is specific to the gnu getopt the argument causes premature termination of argument scanning  {
	                                 scanning :: -1000
                                        }
explicitly telling  {
	telling :: -1000
 }
getopt that there are no more options if opts begins with then non option arguments are treated  {
	         treated :: -1000
               }
as arguments to the option this behavior is specific to the gnu getopt ifdef gnu library many other libraries have conflicting prototypes for getopt with differences  {
	              differences :: -1000
                        }
in the consts  {
	coastings :: 7
	construes :: 8
	tocsins :: 7
	constates :: 7
	construers :: 7
	crestons :: 7
	costs :: 7
	consisted :: 8
	tonics :: 7
	contuse :: 7
	consist :: 10
	contuses :: 7
	congest :: 7
	confest :: 7
	conatus :: 7
	contessa :: 7
	contests :: 7
	consults :: 8
	consorts :: 7
	counts :: 8
	costes :: 7
	consists :: 7
	contos :: 7
	contes :: 8
	consents :: 7
	coasts :: 9
	countess :: 7
	centos :: 7
	cons :: 7
	congests :: 7
	sonics :: 7
	cantos :: 7
	cansos :: 8
	constables :: 7
 }
in stdlib h to avoid compilation errors only prototype getopt for the gnu c library extern int getopt int argc char const argv const char shortopts  {
	                 shootist :: 11
	                shootouts :: 11
	                photosets :: 11
	                stolports :: 12
	                shortstop :: 14
	                shortcuts :: 11
	               shortstops :: 12
                        }
throw if defined need getopt defined use posix defined use posix implicitly defined use gnu the gnu getopt has more functionality than the standard version the additional functionality can be disable at runtime this redirection  {
	                       redirection :: -1000
                                 }
helps to also do this at runtime ifdef redirect extern int redirect nth getopt int argc char const argv const char shortopts posix getopt else extern int posix getopt int argc char const argv const char shortopts throw define getopt posix getopt endif endif else not gnu library extern int getopt endif gnu library ifndef need getopt extern int getopt long int argc char const argv const char shortopts const struct option longopts  {
	                                                                  pongos :: 10
	                                                               longstops :: 11
	                                                                longstop :: 12
                                                                       }
int longind  {
	landing :: 9
	bonding :: 9
	lording :: 9
	longing :: 10
	fonding :: 9
	lending :: 9
	ponding :: 9
	lodging :: 9
	loaning :: 9
	loading :: 9
	longan :: 9
	donging :: 9
	longings :: 9
 }
throw extern int getopt long only int argc char const argv const char shortopts const struct option longopts int longind throw endif ifdef cplusplus endif make sure we later can get all the definitions and declarations undef need getopt endif getopt h public api for gnu gettext po files contained in libgettextpo  {
                                                  }
copyright c free software foundation inc written by bruno  {
	   brunt :: 7
	   bruin :: 6
	   bourn :: 7
	   bound :: 6
	 burnout :: 6
	 burnous :: 6
	  burton :: 6
	    burn :: 6
	    born :: 6
	  brunts :: 6
	  brunet :: 6
	  brunch :: 6
	  brulot :: 6
	  bourns :: 6
	  bourne :: 6
	 bounder :: 6
	 bouncer :: 6
       }
haible  {
	hable :: 7
	lambie :: 7
	labile :: 7
	hairless :: 7
	hairbell :: 8
	bailee :: 7
	hairbells :: 7
	alible :: 8
	viable :: 7
	hamble :: 9
	halite :: 7
	halide :: 7
	hail :: 7
	hailer :: 7
	hailed :: 7
	habile :: 10
	hambled :: 8
	hambles :: 8
	liable :: 7
 }
bruno clisp  {
	clasping :: 6
	crisp :: 7
	clipt :: 6
	clips :: 8
	clies :: 6
	clasp :: 7
	crisply :: 7
	crispy :: 6
	claspt :: 6
	clippers :: 6
	slip :: 6
	clip :: 7
 }
org this program is free software you can redistribute it and or modify it under the terms of the gnu general public license as published by the free software foundation either version of the license or at your option any later version this program is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu general public license for more details you should have received a copy of the gnu general public license along with this program if not see http www gnu org licenses ifndef gettext po h define gettext po h include stdlib h ifdef cplusplus extern c endif meta  {
	                                                                                                                    meta :: -1000
                                                                                                                       }
information version number major minor subminor define libgettextpo version x extern int libgettextpo version types a po file t represents the contents of a po file typedef struct po file po file t a po message iterator t represents an iterator through a domain of a po file typedef struct po message iterator po message iterator t a po message t represents a message in a po file typedef struct po message po message t a po filepos  {
	                                                                      pileous :: 9
	                                                                        files :: 9
	                                                                     firepots :: 9
	                                                                    fishpoles :: 9
	                                                                       filose :: 9
	                                                                     fishpole :: 10
	                                                                     milepost :: 10
                                                                            }
t represents a string s position within a source file typedef struct po filepos po filepos t a po error handler handles  {
	              handles :: -1000
                    }
error situations struct po error handler signal an error the error message is built from format and the following arguments errnum if nonzero is an errno value must increment the error message count variable declared in error h must not return if status is nonzero void error int status int errnum const char format if gnuc gnuc minor gnuc strict ansi attribute format printf endif signal an error the error message is built from format and the following arguments the error location is at filename line lineno errnum if nonzero is an errno value must increment the error message count variable declared in error h must not return if status is nonzero void error at line int status int errnum const char filename unsigned int lineno const char format if gnuc gnuc minor gnuc strict ansi attribute format printf endif signal a multiline  {
	                                                                                                                                     multiline :: -1000
                                                                                                                                             }
warning the prefix applies to all lines of the message free the prefix and message when done void multiline warning char prefix char message signal a multiline error the prefix applies to all lines of the message free the prefix and message when done must increment the error message count variable declared in error h if prefix is non null void multiline error char prefix char message typedef const struct po error handler po error handler t a po xerror  {
	                                                                         terror :: 9
	                                                                        terrors :: 8
                                                                              }
handler handles warnings  {
	warnings :: -1000
 }
error and fatal error situations define po severity warning just a warning tell the user define po severity error an error the operation cannot complete define po severity fatal error an error the operation must be aborted struct po xerror handler signal a problem of the given severity message and or filename lineno indicate where the problem occurred  {
	                                                 occurred :: -1000
                                                        }
if filename is null filename and lineno and column should be ignored if lineno is size t lineno and column should be ignored if column is size t it should be ignored message text is the problem description if multiline p is true multiple lines of text each terminated with a newline otherwise usually a single line must not return if severity is po severity fatal error void xerror int severity po message t message const char filename size t lineno size t column int multiline p const char message text signal a problem that refers to two messages similar to two calls to xerror if possible a can be appended to message text and prepended  {
	                                                                                                          propended :: 15
	                                                                                                        pretendedly :: 12
	                                                                                                          prehended :: 14
	                                                                                                           prepense :: 13
	                                                                                                          precented :: 11
	                                                                                                          protended :: 11
	                                                                                                          prevented :: 11
	                                                                                                          presented :: 11
	                                                                                                         prepensely :: 11
	                                                                                                          perpended :: 16
                                                                                                                  }
to message text void xerror int severity po message t message const char filename size t lineno size t column int multiline p const char message text po message t message const char filename size t lineno size t column int multiline p const char message text typedef const struct po xerror handler po xerror handler t memory allocation the memory allocations  {
	                                                  allocations :: -1000
                                                            }
performed by these functions use xmalloc therefore will cause a program exit if memory is exhausted  {
	      exhausted :: -1000
              }
the memory allocated by po file read and implicitly returned through the po message functions lasts  {
	          lasts :: -1000
              }
until freed with po file free po file t api create an empty po file representation in memory extern po file t po file create void read a po file into memory return its contents upon failure return null and set errno define po file read po file read v extern po file t po file read const char filename po xerror handler t handler write an in memory po file to a file upon failure return null and set errno define po file write po file write v extern po file t po file write po file t file const char filename po xerror handler t handler free a po file from memory extern void po file free po file t file return the names of the domains  {
	                                                                                                                         domains :: -1000
                                                                                                                               }
covered  {
	covered :: -1000
 }
by a po file in memory extern const char const po file domains po file t file header entry api return the header entry of a domain of a po file in memory the domain null denotes  {
	                             denotes :: -1000
                                   }
the default domain return null if there is no header entry extern const char po file domain header po file t file const char domain return the value of a field in a header entry the return value is either a freshly  {
	                                  freshly :: -1000
                                        }
allocated string to be freed by the caller or null extern char po header field const char header const char field return the header entry with a given field set to a given value the field is added if necessary the return value is a freshly allocated string extern char po header set field const char header const char field const char value po message iterator t api create an iterator for traversing  {
	                                                              traversing :: -1000
                                                                       }
a domain of a po file in memory the domain null denotes the default domain extern po message iterator t po message iterator po file t file const char domain free an iterator extern void po message iterator free po message iterator t iterator return the next message and advance the iterator return null at the end of the message list extern po message t po next message po message iterator t iterator insert a message in a po file in memory in the domain and at the position indicated by the iterator the iterator thereby  {
	                                                                                        thereby :: -1000
                                                                                              }
advances  {
	advances :: -1000
 }
past the freshly inserted  {
	inserted :: -1000
  }
message extern void po message insert po message iterator t iterator po message t message po message t api return a freshly constructed  {
	           constructed :: -1000
                     }
message to finish initializing the message you must set the msgid  {
	      migs :: 6
	     mysid :: 6
         }
and msgstr  {
 }
extern po message t po message create void return the context of a message or null for a message not restricted  {
	          restricted :: -1000
                   }
to a context extern const char po message msgctxt  {
       }
po message t message change the context of a message null means a message not restricted to a context extern void po message set msgctxt po message t message const char msgctxt return the msgid untranslated  {
	                       untranslated :: -1000
                                  }
english  {
	english :: -1000
 }
string of a message extern const char po message msgid po message t message change the msgid untranslated english string of a message extern void po message set msgid po message t message const char msgid return the msgid plural  {
	                                 plural :: -1000
                                      }
untranslated english plural string of a message or null for a message without plural extern const char po message msgid plural po message t message change the msgid plural untranslated english plural string of a message null means a message without plural extern void po message set msgid plural po message t message const char msgid plural return the msgstr translation of a message return the empty string for an untranslated message extern const char po message msgstr po message t message change the msgstr translation of a message use an empty string to denote an untranslated message extern void po message set msgstr po message t message const char msgstr return the msgstr index for a message with plural handling or null when the index is out of range or for a message without plural extern const char po message msgstr plural po message t message int index change the msgstr index for a message with plural handling use a null value at the end to reduce  {
	                                                                                                                                                                 reduce :: -1000
                                                                                                                                                                      }
the number of plural forms extern void po message set msgstr plural po message t message int index const char msgstr return the comments for a message extern const char po message comments po message t message change the comments for a message comments should be a multiline string ending  {
	                                           ending :: -1000
                                                }
in a newline or empty extern void po message set comments po message t message const char comments return the extracted  {
	           extracted :: -1000
                   }
comments for a message extern const char po message extracted comments po message t message change the extracted comments for a message comments should be a multiline string ending in a newline or empty extern void po message set extracted comments po message t message const char comments return the i th file position for a message or null if i is out of range extern po filepos t po message filepos po message t message int i remove the i th file position from a message the indices of all following file positions for the message are decremented  {
	                                                                                       decremented :: -1000
                                                                                                 }
by one extern void po message remove filepos po message t message int i add a file position to a message if it is not already present for the message file is the file name start line is the line number where the string starts or size t if no line number is available extern void po message add filepos po message t message const char file size t start line return the previous context of a message or null for none extern const char po message prev msgctxt po message t message change the previous context of a message null is allowed extern void po message set prev msgctxt po message t message const char prev msgctxt return the previous msgid untranslated english string of a message or null for none extern const char po message prev msgid po message t message change the previous msgid untranslated english string of a message null is allowed extern void po message set prev msgid po message t message const char prev msgid return the previous msgid plural untranslated english plural string of a message or null for none extern const char po message prev msgid plural po message t message change the previous msgid plural untranslated english plural string of a message null is allowed extern void po message set prev msgid plural po message t message const char prev msgid plural return true if the message is marked obsolete extern int po message is obsolete po message t message change the obsolete mark of a message extern void po message set obsolete po message t message int obsolete return true if the message is marked fuzzy  {
	                                                                                                                                                                                                                                                                           matachin :: -1000
                                                                                                                                                                                                                                                                                  }
extern int po message is fuzzy po message t message change the fuzzy mark of a message extern void po message set fuzzy po message t message int fuzzy return true if the message is marked as being a format string of the given type e g c format extern int po message is format po message t message const char format type change the format string mark for a given type of a message extern void po message set format po message t message const char format type bool int value if a numeric range of a message is set return true and store the minimum  {
	                                                                                                   minimum :: -1000
                                                                                                         }
and maximum  {
	maximum :: -1000
 }
value in minp  {
	mispen :: 5
	miny :: 5
	minx :: 5
	mint :: 5
	mino :: 5
	mink :: 5
	ming :: 5
	mine :: 5
	mind :: 5
	mina :: 5
	pin :: 5
 }
and maxp  {
	maxi :: 5
	pax :: 5
	max :: 6
	map :: 5
 }
extern int po message is range po message t message int minp int maxp change the numeric range of a message min and max must be non negative with min max use min max to remove the numeric range of a message extern void po message set range po message t message int min int max po filepos t api return the file name extern const char po filepos file po filepos t filepos return the line number where the string starts or size t if no line number is available extern size t po filepos start line po filepos t filepos format type api return a null terminated array of the supported format types extern const char const po format list void return the pretty name associated with a format type for example for csharp  {
	                                                                                                                                carhops :: 7
	                                                                                                                                 escarp :: 8
                                                                                                                                      }
format return c return null if the argument is not a supported format type extern const char po format pretty name const char format type checking api test whether an entire file po file is valid like msgfmt  {
                                    }
does it if it is invalid pass the reasons to the handler extern void po file check all po file t file po xerror handler t handler test a single message to be inserted in a po file in memory like msgfmt does it if it is invalid pass the reasons to the handler the iterator is not modified by this call it only specifies the file and the domain extern void po message check all po message t message po message iterator t iterator po xerror handler t handler test whether the message translation is a valid format string if the message is marked as being a format string if it is invalid pass the reasons to the handler define po message check format po message check format v extern void po message check format po message t message po xerror handler t handler ifdef cplusplus endif endif gettext po h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef glob h define glob h include sys cdefs h begin decls we need size t for the following definitions ifndef size t typedef size type size t if defined use xopen use xopen k typedef size type size t endif else the gnu cc  {
                                                                                                                                                                                                                                                                                                                                         }
stddef h version defines size t as empty we need a real definition undef size t define size t size t endif bits set in the flags argument to glob define glob err return on read errors define glob mark append a slash to each name define glob nosort  {
	                                        notornis :: 7
	                                          donors :: 7
	                                          rotors :: 7
	                                          motors :: 7
	                                          tonsor :: 7
	                                          honors :: 7
	                                        sonority :: 7
	                                        sonorant :: 7
	                                         cohorts :: 7
	                                           toros :: 7
	                                           stoor :: 7
	                                           rotos :: 7
	                                          notour :: 7
	                                          nostoc :: 7
                                               }
don t sort the names define glob dooffs  {
	 doofus :: 8
	  foods :: 7
	   doos :: 7
      }
insert pglob  {
 }
gl offs nulls define glob nocheck  {
	conteck :: 9
	uncheck :: 10
    }
if nothing matches return the pattern define glob append append to results of a previous call define glob noescape backslashes don t quote metacharacters  {
                      }
define glob period leading can be matched by metachars  {
	megastars :: 11
	metaphors :: 11
	metaphrase :: 11
	metaphrast :: 11
	megastar :: 11
	attachers :: 12
       }
if defined use posix defined use bsd defined use gnu define glob magchar  {
           }
set in gl flags if any metachars seen define glob altdirfunc  {
         }
use gl opendir et al functions define glob brace  {
	   brace :: -1000
       }
expand a b to a b define glob nomagic  {
	comaking :: 10
	 monadic :: 9
	 gonadic :: 9
	 nomadic :: 11
       }
if no magic chars return the pattern define glob tilde  {
	    tilde :: -1000
        }
expand user and to home  {
	home :: -1000
   }
directories define glob onlydir  {
  }
match only directories define glob tilde check like glob tilde but return an error if the user name is not available define glob flags glob err glob mark glob nosort glob dooffs glob noescape glob nocheck glob append glob period glob altdirfunc glob brace glob nomagic glob tilde glob onlydir glob tilde check else define glob flags glob err glob mark glob nosort glob dooffs glob noescape glob nocheck glob append glob period endif error returns from glob define glob nospace  {
                                                                               }
ran out of memory define glob aborted read error define glob nomatch no matches found define glob nosys not implemented  {
	        implemented :: -1000
                  }
ifdef use gnu previous versions of this file defined glob abend  {
	     blend :: 6
	     baned :: 6
	     amend :: 7
	     abune :: 6
	    amends :: 6
	   abidden :: 6
	      abed :: 7
         }
instead of glob aborted provide a compatibility definition here define glob abend glob aborted endif structure describing a globbing  {
	          grubbing :: 10
	          swobbing :: 10
	          glouting :: 10
	          clubbing :: 10
	          blubbing :: 10
	          flubbing :: 10
	          stobbing :: 10
	          glossing :: 10
	          glorying :: 10
	          glopping :: 10
	          glomming :: 10
	          grabbing :: 10
	          blabbing :: 10
	          slabbing :: 10
	          gabbling :: 10
	          gloating :: 10
	          blobbing :: 13
	          gloaming :: 10
	          gobbling :: 12
	           globing :: 10
                 }
run ifdef use gnu struct stat endif typedef struct size t gl pathc  {
	     pathics :: 7
	     patched :: 6
	     patches :: 6
	     patcher :: 6
	      pathos :: 6
	      pathic :: 8
	      patchy :: 7
	        tach :: 6
	        path :: 8
	        pact :: 6
	        caph :: 6
	       paths :: 7
	       patch :: 8
	         pat :: 6
           }
count of paths  {
	paths :: -1000
 }
matched by the pattern char gl pathv  {
	pathos :: 6
	pathic :: 6
	  path :: 8
	 paths :: 7
	 patch :: 6
	   pat :: 6
     }
list of matched pathnames  {
	paginates :: 11
	patinates :: 11
	nametapes :: 11
  }
size t gl offs slots to reserve in gl pathv int gl flags set to flags maybe glob magchar if the glob altdirfunc flag is set the following functions are used instead of the normal file access functions void gl closedir void ifdef use gnu struct dirent gl readdir void else void gl readdir void endif void gl opendir const char ifdef use gnu int gl lstat  {
	                                                            lattes :: 6
	                                                            latest :: 6
	                                                            lyttas :: 6
	                                                            estate :: 6
                                                                 }
const char restrict struct stat restrict int gl stat const char restrict struct stat restrict else int gl lstat const char restrict void restrict int gl stat const char restrict void restrict endif glob t ifdef use largefile ifdef use gnu struct stat endif typedef struct size t gl pathc char gl pathv size t gl offs int gl flags if the glob altdirfunc flag is set the following functions are used instead of the normal file access functions void gl closedir void ifdef use gnu struct dirent gl readdir void else void gl readdir void endif void gl opendir const char ifdef use gnu int gl lstat const char restrict struct stat restrict int gl stat const char restrict struct stat restrict else int gl lstat const char restrict void restrict int gl stat const char restrict void restrict endif glob t endif do glob searching  {
	                                                                                                                                         searching :: -1000
                                                                                                                                                 }
for pattern placing  {
	placing :: -1000
 }
results in pglob the bits defined above may be set in flags if a directory cannot be opened or read and errfunc  {
                    }
is not nil it is called with the pathname that caused the error and the errno value from the failing  {
	            failing :: -1000
                  }
call if it returns non zero glob returns glob abend if it returns zero the error is ignored if memory cannot be allocated for pglob glob nospace is returned otherwise glob returns zero if defined use file offset extern int glob const char restrict pattern int flags int errfunc const char int glob t restrict pglob throw free storage allocated in pglob by a previous glob call extern void globfree  {
                                                                    }
glob t pglob throw else extern int redirect nth glob const char restrict pattern int flags int errfunc const char int glob t restrict pglob glob extern void redirect nth globfree glob t pglob globfree endif ifdef use largefile extern int glob const char restrict pattern int flags int errfunc const char int glob t restrict pglob throw extern void globfree glob t pglob throw endif ifdef use gnu return nonzero if pattern contains any metacharacters metacharacters can be quoted with backslashes if quote is nonzero this function is not part of the interface specified by posix but several programs want to use it extern int glob pattern p const char pattern int quote throw endif end decls endif glob h header with interface version macros for library pieces  {
	                                                                                                                          pieces :: -1000
                                                                                                                               }
copied elsewhere  {
	elsewhere :: -1000
 }
copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef gnu versions h define gnu versions h this file exists to define these few  {
	                                                                                                                                                 few :: -1000
                                                                                                                                                   }
macros each specifies a version number associated with the library interface of a piece of the c library which is also distributed with other gnu packages  {
	                 packages :: -1000
                        }
these pieces are both part of the gnu c library and also distributed with other gnu packages so those packages may use their facilities on systems lacking  {
	                   lacking :: -1000
                         }
the gnu c library the source files for each piece surround  {
	  surround :: -1000
         }
all their code with ifndef elide  {
	elide :: -1000
    }
code after defining it with this define obstack  {
	subtack :: 9
	outbacks :: 10
	obstacle :: 10
	tombacks :: 9
	outback :: 9
      }
interface version if defined libc defined gnu library gnu library include gnu versions h if gnu obstack interface version obstack interface version define elide code endif endif this allows those one to avoid compiling  {
	                        compiling :: -1000
                                }
those files when part of a gnu package not libc on a system using a gnu c library that supports the same interface please preserve the format of the comments after each macro and remember  {
	                          remember :: -1000
                                 }
if any of these versions change the libc so major version number must change too so avoid it define gnu obstack interface version vs malloc obstack c define gnu regex  {
	                        leger :: 6
	                       regest :: 6
	                       regent :: 6
	                         gere :: 6
	                        rexes :: 6
	                        repeg :: 6
	                        remex :: 7
	                        reges :: 7
                            }
interface version vs posix regex c define gnu glob interface version vs posix glob c define gnu getopt interface version vs posix getopt c and posix getopt c endif gnu versions h output of mkheader  {
                                 }
awk  {
	awork :: 3
	weka :: 3
	wakf :: 3
	wake :: 3
	waka :: 3
	kaw :: 3
	ewk :: 3
	aws :: 3
	awn :: 3
	awl :: 3
	awe :: 3
	auk :: 3
	ask :: 3
	ark :: 3
	aw :: 4
 }
do not edit  {
	edit :: -1000
 }
buffer read only t gpg error h public interface to libgpg error copyright c g code gmbh  {
               }
this file is part of libgpg error libgpg error is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version libgpg error is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with this program if not see http www gnu org licenses ifndef gpg error h define gpg error h include stddef h ifdef gnuc define gpg err inline inline elif stdc version l define gpg err inline inline else ifndef gpg err inline define gpg err inline endif endif ifdef cplusplus extern c if just to make emacs auto indent happy endif endif cplusplus the gnupg  {
	                                                                                                                                                                gauping :: 6
                                                                                                                                                                      }
project consists of many components  {
	components :: -1000
   }
error codes are exchanged  {
	exchanged :: -1000
  }
between all components the common error codes and their user presentable  {
	presentable :: -1000
         }
descriptions  {
	descriptions :: -1000
 }
are kept  {
	kept :: -1000
 }
into a shared library to allow adding new error codes and components without recompiling  {
	  recompiling :: -1000
            }
any of the other components the interface will not change in a backward incompatible way an error code together with an error source build up an error value as the error value is been passed from one component to another it preserver  {
	                                preserver :: -1000
                                        }
the information about the source and nature  {
	nature :: -1000
     }
of the error a component of the gnupg project can define the following macros to tune  {
	           tune :: -1000
              }
the behaviour of the library gpg err source default define to an error source of type gpg err source t to make that source the default for gpg error otherwise gpg err source unknown is used as default gpg err enable gettext macros define to provide macros to map the internal gettext api to standard names this has only an effect on windows  {
	                                                       windows :: -1000
                                                             }
platforms the error source type gpg err source t where as the poo out of a welle  {
	          wulled :: 6
	          selles :: 6
	          seller :: 6
	          gelled :: 6
	          belles :: 6
	          belled :: 6
	          willey :: 6
	          willet :: 6
	          willer :: 6
	          willed :: 6
	          pellet :: 6
	        wellsite :: 6
	        wellness :: 6
	        wellhead :: 6
	        welldoer :: 6
	          wellie :: 8
	          welled :: 9
	          feller :: 6
	          felled :: 6
	          wallet :: 6
	          waller :: 6
	          walled :: 6
	          yeller :: 6
	          yelled :: 6
	          melled :: 6
	         walleye :: 6
	          teller :: 6
	          tellen :: 6
	          heller :: 6
	          helled :: 6
	           welly :: 6
	           wells :: 6
	           weels :: 6
	            well :: 7
	            weel :: 7
	          celled :: 6
	           selle :: 7
	          jelled :: 6
	         wellies :: 7
               }
small taketh  {
	takeout :: 7
	tapet :: 7
	tate :: 7
	take :: 7
	tacet :: 7
	hake :: 7
 }
his firste  {
	sifter :: 7
	frostier :: 7
	snifter :: 7
	forkiest :: 7
	minster :: 7
	fighter :: 7
	frist :: 8
	frise :: 7
	freit :: 7
	frosted :: 7
	first :: 10
	fires :: 8
	feist :: 8
	frisee :: 7
	freits :: 8
	fibster :: 10
	tipster :: 7
	swifter :: 7
	fritzes :: 7
	frisket :: 8
	strifes :: 7
	forties :: 8
	firepots :: 7
	fainters :: 7
	triste :: 7
	firths :: 7
	firsts :: 8
	rifest :: 7
	filets :: 7
	fiesta :: 8
	fiercest :: 7
	feistier :: 7
	fluster :: 7
	hipster :: 7
	fritters :: 7
	diester :: 7
	ferity :: 7
	refits :: 7
	foisted :: 7
	foister :: 9
	feisty :: 7
	shifter :: 7
	furziest :: 7
	foisters :: 7
	flitters :: 7
	diaster :: 7
	fibsters :: 8
	flirters :: 7
	fixates :: 7
	kiester :: 7
	strife :: 8
	fitters :: 7
	fustier :: 7
	tires :: 7
	fruiters :: 7
	sprite :: 7
	fits :: 7
	fies :: 7
	firstly :: 8
	firmest :: 8
	reist :: 7
	fighters :: 8
	ferniest :: 7
	feaster :: 7
	pirates :: 7
	ferities :: 7
 }
springing  {
	springing :: -1000
 }
and his sours  {
	sours :: -1000
 }
chaucer  {
	chaufers :: 9
	chance :: 9
	chaufer :: 10
	chancre :: 9
	chancer :: 11
	coacher :: 9
	chancery :: 10
	chancers :: 10
 }
only use free slots never change or reorder  {
	reorder :: -1000
      }
the existing entries typedef enum gpg err source unknown gpg err source gcrypt gpg err source gpg gpg err source gpgsm  {
	            sacellum :: -1000
                   }
gpg err source gpgagent  {
  }
gpg err source pinentry  {
	pinnet :: 10
	nonentry :: 10
	misentry :: 10
  }
gpg err source scd  {
	scud :: 4
	scad :: 4
	sodic :: 3
	scudo :: 3
	scudi :: 3
	scrod :: 3
	scold :: 3
	scend :: 3
	scaud :: 3
	scald :: 3
	cuds :: 3
	cods :: 3
	cads :: 3
	sod :: 3
	sed :: 3
	sad :: 3
  }
gpg err source gpgme  {
	gigmen :: 6
	gagmen :: 6
  }
gpg err source keybox  {
	skyboxes :: 8
	keyboard :: 7
	skybox :: 8
  }
gpg err source ksba  {
	kobans :: 5
	kebars :: 5
	kabars :: 5
	kabs :: 6
	isba :: 5
	kab :: 5
  }
gpg err source dirmngr  {
  }
gpg err source gsti  {
	gites :: 5
	gits :: 6
	gist :: 5
	git :: 5
  }
gpg err source gpa  {
	grasp :: 3
	grapy :: 3
	grape :: 3
	gramp :: 3
	graip :: 3
	spang :: 3
	peag :: 3
	igap :: 3
	gawp :: 3
	gaup :: 3
	gasp :: 3
	gapy :: 3
	gaps :: 3
	gape :: 3
	gamp :: 3
	spa :: 3
	goa :: 3
	gap :: 4
  }
gpg err source kleo  {
	koels :: 5
	ketol :: 5
	oleo :: 5
	koel :: 6
	ole :: 5
	kyloe :: 5
  }
gpg err source g gpg err source any gpg err source user gpg err source user gpg err source user gpg err source user this is one more than the largest  {
	                       largest :: -1000
                             }
allowed entry gpg err source dim  {
	  dim :: -1000
    }
gpg err source t the error code type gpg err code t only use free slots never change or reorder the existing entries typedef enum gpg err no error gpg err general gpg err unknown packet  {
	                             packet :: -1000
                                  }
gpg err unknown version gpg err pubkey algo gpg err digest algo gpg err bad pubkey gpg err bad seckey  {
	            peckers :: 7
	             sickee :: 7
	             seckel :: 9
	            deckers :: 7
	            deckels :: 7
	           cockeyes :: 7
	           sockeyes :: 7
	            hockeys :: 7
	            neckers :: 7
	            mickeys :: 7
	            lackeys :: 7
	             kersey :: 7
	             kecksy :: 7
	            dickeys :: 7
	            beckets :: 7
	            sockeye :: 9
	              sycee :: 8
	               seek :: 7
	            hickeys :: 7
	            jockeys :: 7
	            seckels :: 7
	            rickeys :: 7
                  }
gpg err bad signature gpg err no pubkey gpg err checksum gpg err bad passphrase gpg err cipher algo gpg err keyring  {
	              kerving :: 10
	              kerning :: 10
	              kerfing :: 10
	              kerbing :: 10
	              revying :: 9
	              retying :: 9
	              renying :: 9
	              yeuking :: 9
	               keying :: 9
	              yerking :: 11
	              yerding :: 9
	              perking :: 9
	              recking :: 9
	              jerking :: 9
	              skyring :: 10
                    }
open gpg err inv packet gpg err inv armor  {
	   armor :: -1000
       }
gpg err no user id gpg err no seckey gpg err wrong  {
	      wrong :: -1000
          }
seckey gpg err bad key gpg err compr  {
	computer :: 6
	comprize :: 7
	comprise :: 7
	comprint :: 7
	compress :: 7
	complier :: 6
	compiler :: 6
	comperes :: 6
	compered :: 6
	compeers :: 6
	comparts :: 6
	compares :: 6
	comparer :: 6
	compared :: 6
	compadre :: 6
	comprized :: 6
	comprizes :: 6
	comprised :: 6
	comprises :: 6
	comprisal :: 6
	comprints :: 6
	  corps :: 6
	  coper :: 6
	  compt :: 7
	  comps :: 7
	  compo :: 6
	  comer :: 7
	  campo :: 6
	camphor :: 6
	compter :: 7
	comport :: 6
	compers :: 7
	compere :: 7
	compeer :: 7
	compare :: 7
	 compts :: 6
	 comply :: 6
	 comper :: 8
	 compel :: 6
	 comped :: 6
	 comers :: 6
	 comart :: 6
	   romp :: 7
	   crop :: 6
	   corm :: 6
	   comp :: 8
	  romps :: 6
      }
algo gpg err no prime gpg err no encoding method gpg err no encryption scheme gpg err no signature scheme gpg err inv attr gpg err no value gpg err not found gpg err value not found gpg err syntax gpg err bad mpi gpg err inv passphrase gpg err sig class gpg err resource limit gpg err inv keyring gpg err trustdb  {
	                                                         brust :: 9
	                                                     trustable :: 9
	                                                        trusty :: 9
	                                                       trusted :: 10
	                                                      trusteed :: 9
	                                                         trust :: 10
                                                             }
gpg err bad cert gpg err inv user id gpg err unexpected gpg err time conflict gpg err keyserver  {
	         preserver :: 11
	         berserker :: 11
                 }
gpg err wrong pubkey algo gpg err tribute  {
	tribute :: -1000
      }
to d a gpg err weak key gpg err inv keylen gpg err inv arg gpg err bad uri gpg err inv uri gpg err network gpg err unknown host  {
	                         host :: -1000
                            }
gpg err selftest failed gpg err not encrypted gpg err not processed gpg err unusable  {
	      unusable :: -1000
             }
pubkey gpg err unusable seckey gpg err inv value gpg err bad cert chain gpg err missing cert gpg err no data gpg err bug gpg err not supported gpg err inv op gpg err timeout gpg err internal gpg err eof gcrypt gpg err inv obj gpg err too short gpg err too large gpg err no obj gpg err not implemented gpg err conflict gpg err inv cipher mode gpg err inv flag gpg err inv handle gpg err truncated gpg err incomplete line gpg err inv response gpg err no agent  {
	                                                                                        agent :: -1000
                                                                                            }
gpg err agent gpg err inv data gpg err assuan  {
	  assuage :: 8
	   saunas :: 7
	assuaging :: 8
	  ashcans :: 7
	  ascians :: 7
	  issuant :: 8
	 issuance :: 7
	 assuaged :: 7
	assurance :: 7
        }
server fault gpg err assuan gpg err inv session key gpg err inv sexp gpg err unsupported algorithm gpg err no pin entry gpg err pin entry gpg err bad pin gpg err inv name gpg err bad data gpg err inv parameter gpg err wrong card  {
	                                       phaeton :: -1000
                                             }
gpg err no dirmngr gpg err dirmngr gpg err cert revoked  {
	   revoked :: -1000
         }
gpg err no crl  {
	cruel :: 3
	creel :: 3
	crawl :: 3
	craal :: 3
	color :: 3
	curl :: 3
	crlf :: 5
	cirl :: 3
	carl :: 3
	cru :: 3
	cro :: 3
	col :: 3
	cel :: 3
	 cr :: 4
  }
known gpg err crl too old gpg err line too long gpg err not trusted  {
	       trusted :: -1000
             }
gpg err canceled gpg err bad ca cert gpg err cert expired  {
	    expired :: -1000
          }
gpg err cert too young  {
	young :: -1000
   }
gpg err unsupported cert gpg err unknown sexp gpg err unsupported protection gpg err corrupted  {
	     corrupted :: -1000
             }
protection gpg err ambiguous  {
	ambiguous :: -1000
  }
name gpg err card gpg err card reset gpg err card removed gpg err inv card gpg err card not present gpg err no pkcs app gpg err not confirmed  {
	                    confirmed :: -1000
                            }
gpg err configuration gpg err no policy match gpg err inv index gpg err inv id gpg err no scdaemon  {
	         eudaemonic :: 10
	           eudaemon :: 10
	          sciaenoid :: 10
	          eudaemons :: 11
                  }
gpg err scdaemon gpg err unsupported protocol gpg err bad pin method gpg err card not initialized gpg err unsupported operation gpg err wrong key usage gpg err nothing found gpg err wrong blob  {
	                             blob :: -1000
                                }
type gpg err missing value gpg err hardware gpg err pin blocked  {
	    blocked :: -1000
          }
gpg err use conditions gpg err pin not synced  {
	  synced :: -1000
       }
gpg err inv crl gpg err bad ber gpg err inv ber gpg err element not found gpg err identifier not found gpg err inv tag gpg err inv length gpg err inv keyinfo  {
	                           keying :: 9
                                }
gpg err unexpected tag gpg err not der encoded gpg err no cms  {
	        cwms :: 3
	        coms :: 3
	        cams :: 3
	         ums :: 3
	         oms :: 3
	         ems :: 3
	         cis :: 3
	          sm :: 3
	          cs :: 3
           }
obj gpg err inv cms obj gpg err unknown cms obj gpg err unsupported cms obj gpg err unsupported encoding gpg err unsupported cms version gpg err unknown algorithm gpg err inv engine  {
	                          engine :: -1000
                               }
gpg err pubkey not trusted gpg err decrypt failed gpg err key expired gpg err sig expired gpg err encoding problem gpg err inv state gpg err dup value gpg err missing action gpg err module not found gpg err inv oid string gpg err inv time gpg err inv crl obj gpg err unsupported crl version gpg err inv cert obj gpg err unknown name gpg err locale problem gpg err not locked gpg err protocol violation  {
	                                                                    violation :: -1000
                                                                            }
gpg err inv mac gpg err inv request gpg err unknown extn  {
	       exon :: 5
          }
gpg err unknown crit extn gpg err locked gpg err unknown option gpg err unknown command gpg err not operational gpg err no passphrase gpg err no pin gpg err not enabled gpg err no engine gpg err missing key gpg err too many gpg err limit reached  {
	                                        reached :: -1000
                                              }
gpg err not initialized gpg err missing issuer  {
	 issuer :: -1000
      }
cert gpg err fully canceled gpg err unfinished  {
	unfinished :: -1000
      }
gpg err buffer too short gpg err sexp inv len spec gpg err sexp string too long gpg err sexp unmatched  {
	           unmatched :: -1000
                   }
paren gpg err sexp not canonical gpg err sexp bad character gpg err sexp bad quotation  {
	      quotation :: -1000
              }
gpg err sexp zero prefix gpg err sexp nested dh  {
	     dhow :: 2
	     dhal :: 2
	     dhak :: 2
	      doh :: 2
	      dah :: 2
	        d :: 2
        }
gpg err sexp unmatched dh gpg err sexp unexpected punc gpg err sexp bad hex char gpg err sexp odd hex numbers gpg err sexp bad oct char gpg err ass general gpg err ass accept failed gpg err ass connect failed gpg err ass inv response gpg err ass inv value gpg err ass incomplete line gpg err ass line too long gpg err ass nested commands  {
	                                                           commands :: -1000
                                                                  }
gpg err ass no data cb gpg err ass no inquire  {
	   inquire :: -1000
         }
cb gpg err ass not a server gpg err ass not a client gpg err ass server start gpg err ass read error gpg err ass write error gpg err ass too much data gpg err ass unexpected cmd gpg err ass unknown cmd gpg err ass syntax gpg err ass canceled gpg err ass no input gpg err ass no output gpg err ass parameter gpg err ass unknown inquire gpg err user gpg err user gpg err user gpg err user gpg err user gpg err user gpg err user gpg err user gpg err user gpg err user gpg err user gpg err user gpg err user gpg err user gpg err user gpg err user gpg err missing errno gpg err unknown errno gpg err eof the following error codes are used to map system errors define gpg err system error gpg err e big gpg err system error gpg err eacces  {
	                                                                                                                                                     peaces :: 7
	                                                                                                                                                     recces :: 8
	                                                                                                                                                   ecclesia :: 7
	                                                                                                                                                     aesces :: 7
	                                                                                                                                                     meccas :: 7
	                                                                                                                                                     faeces :: 8
	                                                                                                                                                     calces :: 8
	                                                                                                                                                     cadees :: 7
	                                                                                                                                                     caches :: 7
                                                                                                                                                          }
gpg err system error gpg err eaddrinuse  {
	viruses :: -1000
     }
gpg err system error gpg err eaddrnotavail  {
     }
gpg err system error gpg err eadv  {
	  vade :: 6
     }
gpg err system error gpg err eafnosupport  {
     }
gpg err system error gpg err eagain  {
	nagari :: 7
	vaginae :: 7
	magazine :: 7
	regain :: 8
	paganize :: 7
	paganise :: 7
	regains :: 7
	canaigre :: 7
	magian :: 7
	  naga :: 7
     }
gpg err system error gpg err ealready  {
     }
gpg err system error gpg err eauth  {
	earthy :: 6
	earths :: 6
	 haute :: 8
	 earth :: 7
	mauthers :: 6
	mauther :: 7
	  haut :: 7
	  haet :: 6
	  eath :: 6
	 saute :: 6
	   eau :: 6
     }
gpg err system error gpg err ebackground  {
	aboveground :: 14
     }
gpg err system error gpg err ebade  {
	seabed :: 6
	 evade :: 7
	beaned :: 6
	beamed :: 6
	beaked :: 6
	beadle :: 6
	beaded :: 6
	 blade :: 6
	 abide :: 6
	evades :: 6
	evader :: 6
	 teade :: 6
	  bead :: 6
	  abed :: 6
     }
gpg err system error gpg err ebadf  {
	  bead :: 6
	  abed :: 6
     }
gpg err system error gpg err ebadfd  {
	bladed :: 7
	beaded :: 7
	aboded :: 7
	abided :: 7
     }
gpg err system error gpg err ebadmsg  {
     }
gpg err system error gpg err ebadr  {
	 debar :: 6
	 barde :: 6
	abider :: 6
	  read :: 6
	  brad :: 6
	  bead :: 6
	  abed :: 6
     }
gpg err system error gpg err ebadrpc  {
     }
gpg err system error gpg err ebadrqc  {
	rumplier :: -1000
     }
gpg err system error gpg err ebadslt  {
	overlusty :: -1000
     }
gpg err system error gpg err ebfont  {
	windbags :: -1000
     }
gpg err system error gpg err ebusy  {
	 drusy :: -1000
     }
gpg err system error gpg err ecanceled  {
	washhouse :: -1000
     }
gpg err system error gpg err echild  {
	echidna :: 7
	chields :: 7
	chield :: 8
     }
gpg err system error gpg err echrng  {
	eching :: 9
	rehung :: 7
	rehang :: 7
     }
gpg err system error gpg err ecomm  {
	reinserting :: -1000
     }
gpg err system error gpg err econnaborted  {
     }
gpg err system error gpg err econnrefused  {
     }
gpg err system error gpg err econnreset  {
     }
gpg err system error gpg err ed gpg err system error gpg err edeadlk  {
            }
gpg err system error gpg err edeadlock  {
	dreadlock :: 14
	dreadlocks :: 13
     }
gpg err system error gpg err edestaddrreq  {
     }
gpg err system error gpg err edied  {
	eddies :: 6
	 idled :: 6
	 ended :: 6
	 edged :: 7
	 dried :: 6
	elided :: 6
	  eide :: 6
	edited :: 7
     }
gpg err system error gpg err edom gpg err system error gpg err edotdot  {
	     darksome :: -1000
            }
gpg err system error gpg err edquot  {
	requoted :: 8
	roqueted :: 7
	roquet :: 7
	requote :: 7
	toquet :: 7
	unquote :: 7
	coquet :: 7
	 toque :: 7
	unquoted :: 8
     }
gpg err system error gpg err eexist  {
	 lexis :: 7
	sexist :: 9
	 exies :: 7
	extines :: 7
	sexists :: 7
	sexiest :: 7
	excise :: 7
	excites :: 7
	expiates :: 7
     }
gpg err system error gpg err efault  {
	flaunt :: 7
	flaunted :: 7
	flaunter :: 7
     }
gpg err system error gpg err efbig  {
     }
gpg err system error gpg err eftype  {
	ectype :: 9
	retyped :: 7
	retypes :: 7
	retype :: 8
	ectypes :: 8
     }
gpg err system error gpg err egratuitous  {
     }
gpg err system error gpg err egregious  {
	egregious :: -1000
     }
gpg err system error gpg err ehostdown  {
	phasedown :: 11
	closedown :: 11
     }
gpg err system error gpg err ehostunreach  {
     }
gpg err system error gpg err eidrm  {
	 dimer :: 6
	mitred :: 6
	  ride :: 6
	  emir :: 6
	 rimed :: 6
	 mired :: 6
     }
gpg err system error gpg err eieio  {
	physeds :: -1000
     }
gpg err system error gpg err eilseq  {
	 esile :: 7
	diesel :: 7
	  eels :: 7
     }
gpg err system error gpg err einprogress  {
	nonprogressive :: 16
     }
gpg err system error gpg err eintr  {
	sinter :: 7
	 inter :: 6
	nitery :: 6
	niters :: 6
	nipter :: 6
	minters :: 6
	minaret :: 6
	 finer :: 6
	 diner :: 6
	wintery :: 6
	winters :: 6
	tinters :: 6
	wintry :: 6
	winter :: 7
	minter :: 7
	hinters :: 6
	tinter :: 7
	tinker :: 6
	tinder :: 6
	hinter :: 7
	centric :: 6
	 viner :: 6
	engirt :: 6
	vintry :: 6
	linters :: 6
	  tine :: 6
	  rine :: 6
	  rent :: 6
	linter :: 7
	 nitre :: 6
	 niter :: 7
	 miner :: 6
	sinters :: 6
	 liner :: 6
     }
gpg err system error gpg err einval gpg err system error gpg err eio  {
	        euois :: 3
	        enoki :: 3
	        eloin :: 3
	        eikon :: 3
	        eidos :: 3
	        diode :: 3
	        biome :: 3
	         euoi :: 4
	        pioye :: 3
	          gio :: 3
	          ego :: 3
	          bio :: 3
	           oi :: 3
            }
gpg err system error gpg err eisconn  {
	misconnect :: 9
	discontent :: 9
	miscontent :: 9
     }
gpg err system error gpg err eisdir  {
	misdiet :: 7
	bridies :: 7
	birdie :: 7
	dishier :: 8
	dirties :: 7
	misdirect :: 8
	inspired :: 7
	kiddiers :: 7
	iridise :: 7
	airside :: 7
	pierids :: 7
	tidiers :: 7
	birdies :: 8
	diarise :: 7
	diaries :: 7
	disliker :: 7
	disherit :: 7
	misfired :: 8
	pismire :: 7
	misdrive :: 7
	irides :: 7
	misfire :: 7
     }
gpg err system error gpg err eisnam  {
	unseam :: 7
	inseam :: 9
	disman :: 7
	amines :: 7
	miseat :: 7
	mistaken :: 7
	mesian :: 8
	inseams :: 7
	misnamed :: 9
	misnames :: 8
	miseaten :: 7
	 miens :: 7
	misname :: 10
     }
gpg err system error gpg err el hlt  {
	  hotly :: 3
	  hotel :: 3
	  altho :: 3
	   loth :: 3
	   lith :: 3
	   lath :: 3
	   holt :: 3
	   hilt :: 3
	   halt :: 3
	    ult :: 3
	    hut :: 3
	    hot :: 3
	    hit :: 3
	    hat :: 3
	    elt :: 3
	    alt :: 3
      }
gpg err system error gpg err el nsync  {
      }
gpg err system error gpg err el hlt gpg err system error gpg err el rst  {
	          estro :: 3
	          ester :: 3
	          astir :: 3
	          aster :: 3
	           tsar :: 3
	           rust :: 3
	           rots :: 4
	           rits :: 4
	           rets :: 4
	           rest :: 3
	           rats :: 4
	           orts :: 3
	          ruths :: 3
	          rotos :: 3
	          rotls :: 3
	          rotis :: 3
	          rotes :: 3
	          rotas :: 3
	           arts :: 3
	          rites :: 3
	          retes :: 3
	          ratos :: 3
	          raths :: 3
	          rates :: 3
	          ratas :: 3
	            rot :: 3
	            rit :: 3
	            ret :: 3
	            rat :: 3
	            pst :: 3
	            est :: 3
	             ts :: 3
              }
gpg err system error gpg err elibacc  {
     }
gpg err system error gpg err elibbad  {
	slabbed :: 9
	blabbed :: 9
     }
gpg err system error gpg err elibexec  {
     }
gpg err system error gpg err elibmax  {
	peregrins :: -1000
     }
gpg err system error gpg err elibscn  {
	maculation :: -1000
     }
gpg err system error gpg err elnrng  {
	erning :: 8
     }
gpg err system error gpg err eloop  {
	bloops :: 6
	 gloop :: 7
	 cloop :: 7
	 bloop :: 7
	bloopers :: 6
	blooped :: 7
	blooper :: 7
	cloops :: 6
	plookie :: 6
	  oleo :: 6
	 sloop :: 7
	 plook :: 6
	sloops :: 6
	gloopy :: 6
	gloops :: 6
	glooped :: 7
     }
gpg err system error gpg err emediumtype  {
     }
gpg err system error gpg err emfile  {
	refilmed :: 7
	defiled :: 7
	defiles :: 7
	defiler :: 7
	defile :: 8
	refilm :: 7
	refile :: 8
	refiled :: 7
	refiles :: 7
	enfiled :: 8
     }
gpg err system error gpg err emlink  {
	 kelim :: 7
	moline :: 7
	relinks :: 7
	milken :: 7
	relink :: 8
	maline :: 7
	 melik :: 7
     }
gpg err system error gpg err emsgsize  {
     }
gpg err system error gpg err emultihop  {
     }
gpg err system error gpg err enametoolong  {
     }
gpg err system error gpg err enavail  {
	reavail :: 10
	reavails :: 9
     }
gpg err system error gpg err eneedauth  {
     }
gpg err system error gpg err enetdown  {
	endowment :: 10
     }
gpg err system error gpg err enetreset  {
	exenterates :: 11
     }
gpg err system error gpg err enetunreach  {
     }
gpg err system error gpg err enfile  {
	enfiladed :: 8
	enfilades :: 8
	infelt :: 7
	senile :: 7
	 elfin :: 7
	defiled :: 7
	defiles :: 7
	defiler :: 7
	penile :: 7
	define :: 7
	defile :: 8
	ensiled :: 8
	ensiles :: 8
	refine :: 7
	refile :: 8
	feline :: 8
	refiled :: 7
	refiles :: 7
	enisled :: 7
	enisles :: 7
	felines :: 7
	ensile :: 9
	enisle :: 8
	enfire :: 9
	enfixed :: 8
	enfixes :: 8
	enfiled :: 11
	unfiled :: 8
	enfilade :: 9
     }
gpg err system error gpg err enoano  {
	entozoan :: 7
     }
gpg err system error gpg err enobufs  {
     }
gpg err system error gpg err enocsi  {
	 icons :: 7
	 enows :: 7
	 enols :: 7
	excision :: 7
	 cions :: 7
	icones :: 7
	croceins :: 7
	eclosion :: 7
	enolic :: 7
	enokis :: 7
	isocline :: 7
	eosinic :: 7
     }
gpg err system error gpg err enodata  {
     }
gpg err system error gpg err enodev  {
	 exode :: 7
	 erode :: 7
	 epode :: 7
	 anode :: 7
	evoked :: 7
	envied :: 7
	endeavor :: 7
	erodent :: 7
     }
gpg err system error gpg err enoent  {
	enterons :: 7
	neonate :: 7
	ponent :: 7
	envenom :: 7
	enteron :: 8
	enounce :: 7
	endnotes :: 7
	endnote :: 8
	nocent :: 7
     }
gpg err system error gpg err enoexec  {
     }
gpg err system error gpg err enolck  {
	unlock :: 7
	unlocked :: 7
	 enols :: 7
	enolic :: 8
	  enol :: 8
     }
gpg err system error gpg err enolink  {
	riverboat :: -1000
     }
gpg err system error gpg err enomedium  {
	neodymium :: 11
     }
gpg err system error gpg err enomem gpg err system error gpg err enomsg  {
	        gnome :: 8
	        enows :: 7
	        enols :: 7
	        emong :: 7
	       gnomes :: 9
	       gnomae :: 7
	       egoism :: 7
            }
gpg err system error gpg err enonet  {
	neoteny :: 7
	neonate :: 8
	sennet :: 7
	gennet :: 7
	neonates :: 7
	neoned :: 7
	bennet :: 7
	dennet :: 7
	enteron :: 7
	endnotes :: 8
	ebonite :: 7
	rennet :: 7
	 tonne :: 7
	endnote :: 9
	sonnet :: 7
	jennet :: 7
	bonnet :: 7
     }
gpg err system error gpg err enopkg  {
	arthrospores :: -1000
     }
gpg err system error gpg err enoprotoopt  {
     }
gpg err system error gpg err enospc  {
	 knosp :: 7
	uncopes :: 7
	  epos :: 7
     }
gpg err system error gpg err enosr  {
	 enows :: 6
	 enorm :: 6
	 enols :: 6
	oncers :: 6
	enrols :: 6
	enduros :: 6
	 snore :: 7
	  ones :: 6
	 senor :: 6
	  eros :: 7
	  erns :: 6
	snores :: 6
	snorer :: 6
	snored :: 6
	 oners :: 6
	 noser :: 6
	nooser :: 6
     }
gpg err system error gpg err enostr  {
	enactors :: 7
	frontes :: 7
	nestor :: 7
	trones :: 7
	stoners :: 7
	shorten :: 7
	enroots :: 7
	creston :: 7
	construe :: 7
	monster :: 7
	tensor :: 8
	stoner :: 8
	snoutier :: 7
	atoners :: 7
	knotters :: 7
	snotters :: 7
	snottier :: 7
	tonsure :: 7
	 snort :: 8
	 snore :: 7
	snorters :: 7
	snortier :: 7
	  eros :: 7
	snotter :: 8
	snorted :: 8
	snorter :: 8
	snorty :: 7
	snorts :: 7
	snorer :: 7
	 onset :: 7
	nooser :: 7
     }
gpg err system error gpg err enosys gpg err system error gpg err enotblk  {
	      knobble :: 9
            }
gpg err system error gpg err enotconn  {
     }
gpg err system error gpg err enotdir  {
     }
gpg err system error gpg err enotempty  {
	contempt :: 11
     }
gpg err system error gpg err enotnam  {
     }
gpg err system error gpg err enotsock  {
     }
gpg err system error gpg err enotsup  {
     }
gpg err system error gpg err enotty  {
	knotty :: 9
	knotted :: 7
	knotter :: 7
	snotted :: 7
	snotter :: 7
	snotty :: 9
     }
gpg err system error gpg err enotuniq  {
     }
gpg err system error gpg err enxio  {
	 enfix :: 6
	toxine :: 6
     }
gpg err system error gpg err eopnotsupp  {
     }
gpg err system error gpg err eoverflow  {
     }
gpg err system error gpg err eperm  {
	 emery :: 6
	epimer :: 6
	 sperm :: 7
	  peer :: 6
	  meer :: 6
	sperms :: 6
     }
gpg err system error gpg err epfnosupport  {
     }
gpg err system error gpg err epipe  {
	epiphyte :: 6
	epilepsy :: 6
     }
gpg err system error gpg err eproclim  {
     }
gpg err system error gpg err eprocunavail  {
     }
gpg err system error gpg err eprogmismatch  {
     }
gpg err system error gpg err eprogunavail  {
     }
gpg err system error gpg err eproto  {
	foretops :: 7
	uprooted :: 7
	foretop :: 8
	overtop :: 7
	enroot :: 7
	uproot :: 7
     }
gpg err system error gpg err eprotonosupport  {
     }
gpg err system error gpg err eprototype  {
     }
gpg err system error gpg err erange gpg err system error gpg err eremchg  {
            }
gpg err system error gpg err eremote  {
	erotemes :: 9
	eremite :: 11
	geometer :: 9
	eremites :: 10
	eroteme :: 10
     }
gpg err system error gpg err eremoteio  {
	eremite :: 13
	eremites :: 12
     }
gpg err system error gpg err erestart  {
	erostrate :: 12
	redstart :: 11
	treaters :: 10
     }
gpg err system error gpg err erofs  {
	 frows :: 6
	 frons :: 6
	 frogs :: 6
	 froes :: 8
	 fores :: 6
	froise :: 7
	profuse :: 6
	profess :: 6
	  froe :: 6
	  eros :: 7
	 roofs :: 6
	 profs :: 7
     }
gpg err system error gpg err erpcmismatch  {
     }
gpg err system error gpg err eshutdown  {
     }
gpg err system error gpg err esocktnosupport  {
     }
gpg err system error gpg err espipe  {
	espied :: 7
	yippees :: 7
	episperm :: 7
	eupepsia :: 7
     }
gpg err system error gpg err esrch  {
	larches :: 6
	parches :: 6
	marches :: 6
	porches :: 6
	birches :: 6
	eschar :: 6
	perches :: 6
	lurches :: 6
	torches :: 6
	curches :: 6
	 perch :: 6
     }
gpg err system error gpg err esrmnt  {
	sarment :: 7
	remints :: 7
	errants :: 7
	 terms :: 7
	sprent :: 7
     }
gpg err system error gpg err estale  {
	pancakes :: -1000
     }
gpg err system error gpg err estrpipe  {
     }
gpg err system error gpg err etime  {
	eminent :: 6
	 evite :: 6
	 elite :: 6
	 edite :: 6
	etamine :: 6
	epimer :: 6
	stimes :: 6
	stimed :: 6
	 stime :: 7
	  item :: 6
	itemed :: 7
     }
gpg err system error gpg err etimedout  {
	fullered :: -1000
     }
gpg err system error gpg err etoomanyrefs  {
     }
gpg err system error gpg err etxtbsy  {
     }
gpg err system error gpg err euclean  {
	uncleaned :: 9
	uncleaner :: 9
	nucleate :: 10
	nucleary :: 9
	nuclease :: 10
	recleans :: 9
	exultance :: 9
	reclean :: 10
	nuclear :: 10
	nucleal :: 9
	euglena :: 9
	unclear :: 9
	unclean :: 10
	euclidean :: 9
	euclase :: 9
	nucleates :: 9
	nucleated :: 9
	nucleases :: 9
     }
gpg err system error gpg err eunatch  {
	unmatched :: 9
	unteach :: 9
	unwatched :: 9
	unlatch :: 9
	unhatched :: 9
	unlatched :: 9
	unlatches :: 9
     }
gpg err system error gpg err eusers  {
	resketch :: -1000
     }
gpg err system error gpg err ewouldblock  {
     }
gpg err system error gpg err exdev  {
	 vexed :: 6
     }
gpg err system error gpg err exfull  {
     }
gpg err system error this is one more than the largest allowed entry gpg err code dim gpg err code t the error value type gpg error t we would really like to use bit fields in a struct but using structs as return values can cause binary compatibility issues  {
	                                           issues :: -1000
                                                }
in particular if you want to do it effeciently  {
	efficiently :: 18
	efficient :: 14
	effectively :: 16
	effeminately :: 14
	deficiently :: 15
       }
also see freg  {
	forge :: 5
	frug :: 5
	frog :: 5
	frig :: 5
	fret :: 5
	frag :: 5
	areg :: 5
 }
struct return option to gcc typedef unsigned int gpg error t we use the lowest bits of gpg error t for error codes the th bit indicates system errors define gpg err code mask gpg err code dim bits to are reserved we use the upper bits of gpg error t for error sources define gpg err source mask gpg err source dim define gpg err source shift the highest bit is reserved it shouldn t be used to prevent potential  {
	                                                                       potential :: -1000
                                                                               }
negative numbers when transmitting  {
	transmitting :: -1000
  }
error values as text gcc feature test undef gpg err have constructor if gnuc define gpg err gcc version gnuc gnuc minor gnuc patchlevel if gpg err gcc version define gpg err constructor attribute constructor define gpg err have constructor endif endif ifndef gpg err constructor define gpg err constructor endif initialization function initialize the library this function should be run early gpg error t gpg err init void gpg err constructor if this is defined the library is already initialized by the constructor and does not need to be initialized explicitely  {
	                                                                              antimetabolic :: -1000
                                                                                          }
undef gpg err initialized ifdef gpg err have constructor define gpg err initialized endif see the source on how to use the deinit  {
	               inedita :: 7
	               deicing :: 7
	               bainite :: 7
	                dipnet :: 7
	               dunnite :: 7
	              dainties :: 7
	              daintier :: 7
	               crinite :: 7
	                detain :: 7
	                dentin :: 7
	                dentil :: 7
	               dignity :: 7
	               dieting :: 7
	                tineid :: 7
	              reindict :: 7
	                 teiid :: 7
	               edition :: 7
	               editing :: 7
	               kainite :: 7
	               density :: 7
	               erinite :: 7
                     }
function it is usually not required void gpg err deinit int mode constructor and accessor functions construct an error value from an error code and source within a subsystem  {
	                   subsystem :: -1000
                           }
use gpg error static gpg err inline gpg error t gpg err make gpg err source t source gpg err code t code return code gpg err no error gpg err no error source gpg err source mask gpg err source shift code gpg err code mask the user should define gpg err source default before including this file to specify a default source for gpg error ifndef gpg err source default define gpg err source default gpg err source unknown endif static gpg err inline gpg error t gpg error gpg err code t code return gpg err make gpg err source default code retrieve the error code from an error value static gpg err inline gpg err code t gpg err code gpg error t err return gpg err code t err gpg err code mask retrieve the error source from an error value static gpg err inline gpg err source t gpg err source gpg error t err return gpg err source t err gpg err source shift gpg err source mask string functions return a pointer to a string containing a description of the error code in the error value err this function is not thread safe const char gpg strerror gpg error t err return the error string for err in the user supplied buffer buf of size buflen this function is in contrast  {
	                                                                                                                                                                                                                            contrast :: -1000
                                                                                                                                                                                                                                   }
to gpg strerror thread safe if a thread safe strerror r function is provided by the system if the function succeeds  {
	            succeeds :: -1000
                   }
is returned and buf contains the string describing the error if the buffer was not large enough erange is returned and buf contains as much of the beginning of the error string as fits  {
	                             fits :: -1000
                                }
into the buffer int gpg strerror r gpg error t err char buf size t buflen return a pointer to a string containing a description of the error source in the error value err const char gpg strsource gpg error t err mapping of system errors errno retrieve the error code for the system error err this returns gpg err unknown errno if the system error is not mapped report this gpg err code t gpg err code from errno int err retrieve the system error for the error code code this returns if code is not a system error code int gpg err code to errno gpg err code t code retrieve the error code directly from the errno variable this returns gpg err unknown errno if the system error is not mapped report this and gpg err missing errno if errno has the value gpg err code t gpg err code from syserror  {
                                                                                                                                                         }
void set the errno variable this function is the preferred way to set errno due to peculiarities  {
	   peculiarities :: -1000
               }
on windowsce  {
	windowed :: 11
	windows :: 14
	window :: 12
	windowless :: 12
 }
void gpg err set errno int err self documenting  {
	documenting :: -1000
       }
convenience functions static gpg err inline gpg error t gpg err make from errno gpg err source t source int err return gpg err make source gpg err code from errno err static gpg err inline gpg error t gpg error from errno int err return gpg error gpg err code from errno err static gpg err inline gpg error t gpg error from syserror void return gpg error gpg err code from syserror ifdef cplusplus endif endif gpg error h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa posix standard group database  {
	                                                                                                                                                                                                                  database :: -1000
                                                                                                                                                                                                                         }
access grp h ifndef grp h define grp h include features h begin decls include bits types h define need size t include stddef h for the single unix specification we must define this type here if defined use xopen defined use xopen k defined gid t defined typedef gid t gid t define gid t defined endif the group structure struct group char gr name group name char gr passwd  {
	                                                              password :: 9
	                                                               passado :: 7
	                                                               passade :: 7
	                                                                passed :: 9
	                                                                 wasps :: 7
	                                                                  paws :: 7
	                                                                  pass :: 8
	                                                                  pads :: 7
	                                                                 passe :: 7
                                                                     }
password  {
	password :: -1000
 }
gid t gr gid group id char gr mem member list if defined use svid defined use gnu define need file include stdio h endif if defined use svid defined use bsd defined use xopen extended rewind the group file stream this function is a possible cancellation point and therefore not marked with throw extern void setgrent  {
	                                                interest :: 10
	                                                sergeant :: 11
	                                                segreant :: 10
	                                                strepent :: 10
	                                               sergeanty :: 10
                                                       }
void endif if defined use svid defined use bsd defined use xopen extended defined use xopen k close the group file stream this function is a possible cancellation point and therefore not marked with throw extern void endgrent  {
	                             entering :: 10
	                          undereating :: 10
	                              endogen :: 10
                                    }
void read an entry from the group file stream opening  {
	  opening :: -1000
        }
it if necessary this function is a possible cancellation point and therefore not marked with throw extern struct group getgrent  {
	          gettering :: 10
                  }
void endif ifdef use svid read a group entry from stream this function is not part of posix and therefore no official cancellation point but due to similarity  {
	                 similarity :: -1000
                          }
with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern struct group fgetgrent  {
                      }
file stream endif ifdef use gnu write the given entry onto  {
	  upbuilds :: -1000
         }
the given stream this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int putgrent  {
	                                 puttering :: 10
                                         }
const struct group restrict p file restrict f endif search for an entry with a matching group id this function is a possible cancellation point and therefore not marked with throw extern struct group getgrgid  {
                                 }
gid t gid search for an entry with a matching group name this function is a possible cancellation point and therefore not marked with throw extern struct group getgrnam  {
                           }
const char name if defined use posix defined use misc ifdef use misc reasonable  {
	   reasonable :: -1000
            }
value for the buffer sized  {
	sized :: -1000
   }
used in the reentrant functions below but better  {
	 better :: -1000
      }
use sysconf  {
	syncoms :: 9
 }
define nss  {
	ness :: 3
	nos :: 3
	nis :: 3
	nas :: 3
	ess :: 3
	ass :: 3
	ns :: 3
 }
buflen group endif reentrant versions of some of the functions above please note the getgrent r function is not yet standardized the interface may change in later versions of this library but the interface is designed  {
	                           designed :: -1000
                                  }
following the principals  {
	principals :: -1000
 }
used for the other reentrant functions so the chances are good this is what the posix people  {
	          people :: -1000
               }
would choose  {
	choose :: -1000
 }
this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw ifdef use gnu extern int getgrent r struct group restrict resultbuf  {
	                                      resultful :: 13
	                                         result :: 11
                                              }
char restrict buffer size t buflen struct group restrict result endif search for an entry with a matching group id this function is a possible cancellation point and therefore not marked with throw extern int getgrgid r gid t gid struct group restrict resultbuf char restrict buffer size t buflen struct group restrict result search for an entry with a matching group name this function is a possible cancellation point and therefore not marked with throw extern int getgrnam r const char restrict name struct group restrict resultbuf char restrict buffer size t buflen struct group restrict result ifdef use svid read a group entry from stream this function is not standardized an probably never will this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int fgetgrent r file restrict stream struct group restrict resultbuf char restrict buffer size t buflen struct group restrict result endif endif posix or reentrant ifdef use bsd define need size t include stddef h set the group set for the current user to groups n of them extern int setgroups  {
	                                                                                                                                                                                                   outgroups :: 12
	                                                                                                                                                                                                   subgroups :: 12
	                                                                                                                                                                                                    septuors :: 11
	                                                                                                                                                                                                   resprouts :: 12
                                                                                                                                                                                                           }
size t n const gid t groups throw store at most ngroups  {
          }
members of the group set for user into groups also include group the actual number of groups found is returned in ngroups return if the if ngroups is too small this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int getgrouplist  {
                                                                    }
const char user gid t group gid t groups int ngroups initialize the group set for the current user by reading the group database and using all groups of which user is a member also include group this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int initgroups  {
                                                                           }
const char user gid t group endif use bsd end decls endif grp h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa declaration of types and functions for shadow  {
	                                                                                                                                                    shadow :: -1000
                                                                                                                                                         }
group suite ifndef gshadow  {
  }
h define gshadow h include features h include paths h define need file include stdio h define need size t include stddef h path to the user database files define gshadow path gshadow begin decls structure of the group file struct sgrp  {
	                                    gorps :: 5
	                                    sprug :: 5
	                                    sprog :: 5
	                                    sprig :: 5
	                                    sprag :: 5
                                        }
char sg namp  {
	dampen :: 5
	nympha :: 5
	vamp :: 5
	tamp :: 5
	tampon :: 5
	samp :: 5
	nams :: 5
	name :: 5
	lamp :: 5
	gamp :: 5
	damp :: 5
	camp :: 5
	pam :: 5
	nap :: 5
	nam :: 6
 }
group name char sg passwd encrypted password char sg adm  {
	    almud :: 3
	    aimed :: 3
	    adsum :: 3
	    admix :: 4
	    admit :: 4
	    admin :: 4
	    admen :: 4
	    adman :: 3
	    adeem :: 3
	   admixt :: 3
	   admits :: 3
	   admire :: 3
	   admins :: 3
	     duma :: 3
	     dams :: 3
	     damp :: 3
	     damn :: 3
	     dame :: 3
	     amid :: 3
	      mad :: 3
	      dam :: 4
	      arm :: 3
	      aim :: 3
	      ads :: 3
	      ado :: 3
	      adi :: 3
	       am :: 3
	       ad :: 4
        }
group administrator  {
	eclectics :: -1000
 }
list char sg mem group member list open database for reading this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern void setsgent  {
	                                         setenants :: 10
	                                         sentients :: 10
                                                 }
void close database this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern void endsgent  {
	                                  endogeny :: 10
	                                  endogens :: 12
	                                 indigents :: 11
	                                  indigent :: 10
	                                endogenous :: 10
	                                   endogen :: 11
                                         }
void get next entry from database perhaps after opening the file this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern struct sgrp getsgent  {
                                                  }
void get shadow entry matching name this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern struct sgrp getsgnam  {
                                             }
const char name read shadow entry from string this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern struct sgrp sgetsgent  {
                                               }
const char string read next shadow entry from stream this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern struct sgrp fgetsgent  {
                                                }
file stream write line containing shadow password entry to stream this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int putsgent  {
	                                         outspent :: 12
                                                }
const struct sgrp g file stream ifdef use misc reentrant versions of some of the functions above these functions are not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation they are cancellation points and therefore not marked with throw extern int getsgent r struct sgrp result buf char buffer size t buflen struct sgrp result extern int getsgnam r const char name struct sgrp result buf char buffer size t buflen struct sgrp result extern int sgetsgent r const char string struct sgrp result buf char buffer size t buflen struct sgrp result extern int fgetsgent r file stream struct sgrp result buf char buffer size t buflen struct sgrp result endif misc end decls endif gshadow h mode c c basic offset indent tabs  {
	                                                                                                                                      tabs :: -1000
                                                                                                                                         }
mode nil wrapper so that include gssapi  {
	gaposis :: 7
     }
h will work without special include paths include gssapi gssapi h header file guard bands  {
	         bands :: -1000
             }
ifndef icc  {
 }
h define icc h copyright c sunsoft  {
	sunspot :: 10
	sunfast :: 9
     }
inc rights reserved permission is hereby  {
	hereby :: -1000
    }
granted  {
	granted :: -1000
 }
free of charge  {
	charge :: -1000
 }
to any person  {
	person :: -1000
 }
obtaining  {
	prebendal :: -1000
 }
a copy of this software and associated documentation files the software to deal in the software without restrict ion  {
	               ion :: -1000
                 }
including without limitation the rights to use copy modify merge publish distribute sublicense  {
	  sublicense :: -1000
           }
and or sell  {
	sell :: -1000
 }
copies of the software and to permit persons  {
	persons :: -1000
      }
to whom  {
	whom :: -1000
 }
the software is furnished  {
	furnished :: -1000
  }
to do so subject to the following conditions the above copyright notice and this permission notice shall be included in all copies or substantial  {
	            substantial :: -1000
                      }
portions  {
	portions :: -1000
 }
of the software the software is provided as is without warranty of any kind express or implied including but not limited to the warranties of merchantability fitness for a particular purpose and non infringement  {
	                     infringement :: -1000
                                }
in no event shall sunsoft inc or its parent company  {
	  company :: -1000
        }
be liable for any claim  {
	claim :: -1000
   }
damages or other liability whether in an action of contract tort or otherwise arising from out of or in connection  {
	         connection :: -1000
                  }
with the software or the use or other dealings  {
	dealings :: -1000
       }
in the software except as contained in this notice the name of sunsoft inc shall not be used in advertising  {
	        advertising :: -1000
                  }
or otherwise to promote the sale  {
	 sale :: -1000
    }
use or other dealings in this software without written authorization  {
	authorization :: -1000
        }
from sunsoft inc this version of the header file corresponds to the profile specification version all header file entries are pre fixed with ic to help avoid name space collisions  {
	                   collisions :: -1000
                            }
signatures are pre fixed with icsig  {
	icing :: 6
	icings :: 7
    }
the structures defined in this header file were created to represent a description of an icc profile on disk  {
	              disk :: -1000
                 }
rather than use pointers a technique  {
	technique :: -1000
    }
is used where a single byte array was placed at the end of each structure this allows us in c to extend the structure by allocating  {
	               allocating :: -1000
                        }
more data than is needed to account  {
	account :: -1000
     }
for variable length structures this also ensures  {
	ensures :: -1000
     }
that data following is allocated contiguously  {
	contiguously :: -1000
    }
and makes it easier  {
	inconsequent :: -1000
  }
to write and read data from the file for example to allocate space for a count length ucr  {
	            ecrus :: 3
	             uric :: 3
	             scur :: 3
	            scrum :: 3
	            scrub :: 3
	             ecru :: 4
	             curt :: 3
	             curs :: 3
	             curl :: 3
	             curd :: 3
	             curb :: 3
	             cura :: 3
	              cur :: 4
	              cru :: 3
	               ur :: 3
                }
and bg  {
	aw :: -1000
 }
array and fill the allocated data note strlen to remember null terminator  {
	 terminator :: -1000
          }
icucrbgcurve  {
 }
ucrcurve  {
 }
bgcurve  {
	weld :: -1000
 }
int ucr nbytes bg nbytes string bytes icucrbg ucrbgwrite  {
       }
char ucr string ucr char strcpy  {
	script :: 7
	stripy :: 9
	strop :: 7
	strip :: 7
	strep :: 7
	strap :: 7
	sprucy :: 7
    }
ucr string example ucrbg curves  {
	curves :: -1000
   }
ucr nbytes sizeof icuint  {
	indict :: 7
	cutin :: 7
  }
number ucr curve size sizeof icuint number bg nbytes sizeof icuint number bg curve size sizeof icuint number string bytes strlen ucr string ucrbgwrite icucrbg malloc ucr nbytes bg nbytes string bytes ucrcurve icucrbgcurve ucrbgwrite data ucrcurve count ucr curve size for i i ucrcurve count i ucrcurve curve i icuint number i bgcurve icucrbgcurve char ucrcurve ucr nbytes bgcurve count bg curve size for i i bgcurve count i bgcurve curve i icuint number i ucr char char char bgcurve bg nbytes memcpy  {
                                                                                  }
ucr char ucr string string bytes many of the structures contain variable length arrays this is represented by the use of the convention type data icany  {
	                   cyanic :: 6
	                   riancy :: 6
	                     cyan :: 6
                        }
defines used in the specification define icmagicnumber  {
	citing :: -1000
     }
x l acsp  {
	scopa :: 5
	scapi :: 5
	scape :: 5
	scapa :: 5
 }
define icversionnumber  {
 }
x l bcd  {
	art :: -1000
 }
screening  {
	screening :: -1000
 }
encodings define icprtrdefaultscreensfalse  {
 }
x l bit pos define icprtrdefaultscreenstrue  {
    }
x l bit pos define iclinesperinch  {
    }
x l bit pos define iclinespercm  {
    }
x l bit pos device attributes currently defined values correspond to the low bytes of the byte attribute quantity see the header for their location define icreflective  {
	             imperfectives :: 15
	              unreflective :: 18
	              imperfective :: 16
	              intellective :: 15
                         }
x l bit pos define ictransparency  {
    }
x l bit pos define icglossy  {
	preemployments :: -1000
    }
x l bit pos define icmatte  {
    }
x l bit pos profile header flags the low bits are reserved for consortium  {
	   consortium :: -1000
            }
use define icembeddedprofilefalse  {
 }
x l bit pos define icembeddedprofiletrue  {
    }
x l bit pos define icuseanywhere  {
    }
x l bit pos define icusewithembeddeddataonly  {
    }
x l bit pos ascii or binary data define icasciidata  {
        }
x l define icbinarydata  {
  }
x l define used to indicate that this is a variable length array define icany use this area to translate platform definitions of long etc into icxxx  {
                         }
form the rest of the header uses the icxxx typedefs  {
        }
signatures are byte quantities ifdef package name june  {
	 junkie :: 5
	 junket :: 5
	 junker :: 5
	 junked :: 5
	 jungle :: 5
	   tune :: 5
	   juve :: 5
	   jute :: 5
	   jure :: 5
	   jupe :: 5
	   junk :: 5
	   juke :: 5
	   jube :: 5
	   jane :: 5
	   dune :: 5
      }
adapted  {
	adapted :: -1000
 }
for use with configure by bob  {
	  bob :: -1000
    }
friesenhahn  {
 }
added the stupid  {
	stupid :: -1000
 }
check for autoconf by marti  {
	ramtils :: 6
	meatier :: 6
	varmint :: 6
	ragtime :: 6
	airtime :: 6
	amrit :: 6
	matrice :: 6
	matrics :: 6
	martini :: 7
	marting :: 8
	martins :: 8
	martian :: 7
	martial :: 7
	marlite :: 7
	mantric :: 6
	martinis :: 6
	wartimes :: 6
	martinet :: 6
	martians :: 6
	partim :: 8
	wartime :: 7
	maltier :: 7
	ramtil :: 7
	maftirs :: 7
	marlites :: 6
	marliest :: 6
	mattin :: 6
	matrix :: 7
	matric :: 7
	matier :: 6
	mastix :: 6
	mastic :: 6
	martin :: 9
	marten :: 6
	martel :: 6
	marted :: 6
	marlin :: 6
	margin :: 6
	mantis :: 6
	mantid :: 6
	mantic :: 6
	maftir :: 8
	tarsi :: 6
	rait :: 6
	mart :: 8
	mair :: 6
	airt :: 6
	parti :: 7
	mirth :: 6
	marts :: 7
	marid :: 6
	 mar :: 6
   }
maria  {
	maria :: -1000
 }
package name is defined if autoconf is being used typedef unsigned char icuint number typedef unsigned short icuint number typedef unsigned int icuint number typedef unsigned int icuint number typedef char icint  {
	                         incite :: 6
	                          icing :: 7
	                        identic :: 6
	                          clint :: 6
	                         icings :: 6
	                        ichnite :: 6
                              }
number typedef short icint number typedef int icint number typedef int icint number else apr modified by marti maria in order to provide wider  {
	                  wider :: -1000
                      }
portability if defined digital defined unix tru include inttypes h typedef uint t icuint number typedef uint t icuint number typedef uint t icuint number typedef uint t icuint number typedef int t icint number typedef int t icint number typedef int t icint number typedef int t icint number else ifdef sgi include sgidefs  {
                                                     }
h number definitions unsigned integer numbers typedef unsigned char icuint number typedef unsigned short icuint number typedef uint t icuint number typedef uint t icuint number signed numbers typedef char icint number typedef short icint number typedef int t icint number typedef int t icint number else if defined gnuc defined unix defined unix include sys types h if defined sun defined hpux defined mingw  {
	                                                          mingle :: 6
	                                                          minged :: 6
	                                                           wingy :: 6
	                                                           wings :: 6
	                                                           winge :: 6
	                                                            wing :: 7
	                                                            ming :: 8
	                                                        ringworm :: 6
	                                                           mingy :: 7
	                                                           mings :: 7
	                                                           minge :: 7
                                                               }
defined mingw if defined mingw defined mingw include stdint h endif typedef uint t icuint number typedef uint t icuint number typedef uint t icuint number typedef uint t icuint number else unsigned integer numbers typedef u int t icuint number typedef u int t icuint number typedef u int t icuint number typedef u int t icuint number endif signed numbers typedef int t icint number typedef int t icint number typedef int t icint number typedef int t icint number else default definitions number definitions unsigned integer numbers typedef unsigned char icuint number typedef unsigned short icuint number typedef unsigned long icuint number typedef unsigned long icuint number signed numbers typedef char icint number typedef short icint number typedef long icint number typedef long icint number endif default defs  {
	                                                                                                                             delfs :: 5
	                                                                                                                             defis :: 6
	                                                                                                                            defogs :: 5
	                                                                                                                            defats :: 5
	                                                                                                                              tefs :: 5
	                                                                                                                              nefs :: 5
	                                                                                                                              kefs :: 5
	                                                                                                                              feds :: 6
	                                                                                                                              deys :: 5
	                                                                                                                              dews :: 5
	                                                                                                                              devs :: 5
	                                                                                                                              deus :: 5
	                                                                                                                              dens :: 5
	                                                                                                                              dels :: 5
	                                                                                                                              defy :: 5
	                                                                                                                              deft :: 5
	                                                                                                                              defi :: 5
	                                                                                                                              debs :: 5
	                                                                                                                               def :: 6
                                                                                                                                 }
endif endif endif base types typedef icint number icsignature  {
       }
typedef icint number ics fixed number typedef icuint number icu fixed number public tags and sizes typedef enum icsigatob  {
	       iceboatings :: 11
                 }
tag x l a b icsigatob tag x l a b icsigatob tag x l a b icsigbluecoloranttag  {
                }
x al bxyz  {
 }
icsigbluetrctag  {
 }
x l btrc  {
	ceas :: -1000
 }
icsigbtoa  {
 }
tag x l b a icsigbtoa tag x l b a icsigbtoa tag x l b a icsigcalibrationdatetimetag  {
                }
x c l calt  {
	caltrop :: 5
	talc :: 6
	talcs :: 5
	salt :: 5
	malt :: 5
	halt :: 5
	cult :: 5
	dalt :: 5
	colt :: 5
	celt :: 5
	cast :: 5
	cart :: 5
	cant :: 5
	calx :: 5
	calp :: 5
	calo :: 5
	calm :: 5
	calk :: 5
	calf :: 5
	cautel :: 5
	castle :: 5
	cartel :: 5
	cantle :: 5
	caltha :: 5
	cat :: 5
  }
icsigchartargettag  {
 }
x l targ icsigcopyrighttag  {
  }
x l cprt  {
	curt :: 5
	cort :: 5
	cert :: 5
	cart :: 5
	cartop :: 5
 }
icsigcrdinfotag  {
 }
x l crdi  {
	cried :: 5
	cider :: 5
	cedi :: 5
 }
icsigdevicemfgdesctag  {
 }
x d e l dmnd  {
   }
icsigdevicemodeldesctag  {
 }
x d l dmdd  {
  }
icsiggamuttag  {
 }
x d l gamt  {
	gamut :: 6
	gamuts :: 5
	gamete :: 5
	gamest :: 5
	gambit :: 5
	gambet :: 5
	gast :: 5
	gant :: 5
	gams :: 5
	gamp :: 5
	game :: 5
	gamb :: 5
	gait :: 5
	tam :: 5
	gat :: 5
	gam :: 6
  }
icsiggraytrctag  {
 }
x b l ktrc  {
	leas :: -1000
  }
icsiggreencoloranttag  {
 }
x al gxyz  {
 }
icsiggreentrctag  {
 }
x l gtrc  {
 }
icsigluminancetag  {
 }
x c d l lumi  {
	aumils :: 5
	aumil :: 6
	lumine :: 6
	lumina :: 6
	ulmin :: 5
	lump :: 5
	lumined :: 5
	lumines :: 5
   }
icsigmeasurementtag  {
 }
x d l meas icsigmediablackpointtag  {
   }
x b l bkpt  {
	blad :: -1000
  }
icsigmediawhitepointtag  {
 }
x l wtpt  {
	wept :: 5
 }
icsignamedcolortag  {
 }
x e f cl ncol  {
	clon :: 5
   }
obsolete use ncl  {
	nil :: 3
 }
icsignamedcolor tag x e c l ncl icsigpreview  {
      }
tag x l pre icsigpreview tag x l pre icsigpreview tag x l pre icsigprofiledescriptiontag  {
             }
x l desc icsigprofilesequencedesctag  {
  }
x l pseq  {
	chargeful :: -1000
 }
icsigps  {
 }
crd tag x l psd  {
	puds :: 4
	pods :: 4
	peds :: 4
	pads :: 4
	pudus :: 3
	pudsy :: 3
	pseud :: 3
	pedes :: 3
	padis :: 3
	 pud :: 3
	 pst :: 3
	 psi :: 3
	 pod :: 3
	 ped :: 3
	 pad :: 3
   }
icsigps crd tag x l psd icsigps crd tag x l psd icsigps crd tag x l psd icsigps csatag  {
	            cartage :: 7
	           cartages :: 8
	             stalag :: 7
	             cartas :: 7
                  }
x l ps s icsigps renderingintenttag  {
    }
x l ps i icsigredcoloranttag  {
   }
x al rxyz  {
 }
icsigredtrctag  {
 }
x l rtrc  {
	seas :: -1000
 }
icsigscreeningdesctag  {
 }
x l scrd  {
	scried :: 5
	screed :: 5
	curds :: 5
	cords :: 5
	cards :: 5
	surd :: 5
	scud :: 5
	scry :: 5
	scad :: 5
	sard :: 5
	scrod :: 6
 }
icsigscreeningtag  {
 }
x el scrn  {
	scrunt :: 5
	scrine :: 5
	screen :: 5
	curns :: 5
	corns :: 5
	carns :: 5
	sorn :: 5
	scry :: 5
	scan :: 5
	scran :: 6
	scorn :: 5
 }
icsigtechnologytag  {
 }
x l tech icsigucrbgtag  {
  }
x l bfd  {
	bet :: -1000
 }
icsigviewingconddesctag  {
 }
x l vued  {
	weed :: -1000
 }
icsigviewingconditionstag  {
 }
x l view  {
	view :: -1000
 }
icmaxenumtag  {
 }
xffffffffl  {
 }
ictagsignature  {
 }
technology signature descriptions typedef enum icsigdigitalcamera  {
    }
x dl dcam  {
	scam :: 5
	dwam :: 5
	dram :: 5
 }
icsigfilmscanner  {
 }
x el fscn  {
 }
icsigreflectivescanner  {
	kalpak :: -1000
 }
x el rscn  {
 }
icsiginkjetprinter  {
	dioptre :: -1000
 }
x a l ijet  {
  }
icsigthermalwaxprinter  {
	vivifies :: -1000
 }
x l twax  {
	tway :: 5
	twas :: 5
	twal :: 5
	twae :: 5
	twa :: 6
 }
icsigelectrophotographicprinter  {
 }
x fl epho  {
	epoch :: 5
	ephor :: 7
	ephod :: 7
	ephors :: 6
	ephori :: 6
	ephods :: 6
	epha :: 5
	echo :: 5
	ephoral :: 5
	uphove :: 5
 }
icsigelectrostaticprinter  {
 }
x l esta icsigdyesublimationprinter  {
  }
x l dsub  {
	doubts :: 5
	dumbs :: 5
	drubs :: 6
	daubs :: 6
	daubes :: 5
	dubs :: 5
	drub :: 5
 }
icsigphotographicpaperprinter  {
 }
x fl rpho  {
	etherealizes :: -1000
 }
icsigfilmwriter  {
 }
x el fprn  {
	firn :: 5
	fern :: 5
 }
icsigvideomonitor  {
 }
x dl vidm  {
	vidame :: 5
	vids :: 5
	vide :: 5
	vim :: 5
	vid :: 6
	mid :: 5
 }
icsigvideocamera  {
 }
x l vidc  {
	steil :: -1000
 }
icsigprojectiontelevision  {
 }
x a l pjtv  {
  }
icsigcrtdisplay  {
 }
x l crt  {
	crypt :: 3
	crwth :: 3
	cruet :: 3
	crout :: 3
	croft :: 3
	crith :: 3
	crest :: 3
	crept :: 3
	crate :: 3
	craft :: 3
	citer :: 3
	cater :: 3
	curt :: 3
	crit :: 4
	cort :: 3
	cert :: 3
	cart :: 3
	ort :: 3
	cut :: 3
	cru :: 3
	cro :: 3
	cot :: 3
	cit :: 3
	cat :: 3
	art :: 3
	tr :: 3
	cr :: 4
 }
icsigpmdisplay  {
 }
x d l pmd  {
	pud :: 3
	pod :: 3
	ped :: 3
	pad :: 3
  }
icsigamdisplay  {
 }
x d l amd icsigphotocd  {
	brunching :: -1000
   }
x b l kpcd  {
  }
icsigphotoimagesetter  {
 }
x d l imgs  {
	migs :: 6
	imps :: 5
  }
icsiggravure  {
	gadrooned :: -1000
 }
x l grav  {
	gravy :: 7
	grave :: 7
	gravid :: 6
	graves :: 6
	graver :: 5
	graven :: 6
	gravel :: 6
	gravity :: 5
	gravies :: 5
	gravest :: 5
	gravely :: 5
	gray :: 5
	gran :: 5
	gram :: 5
	grad :: 5
 }
icsigoffsetlithography  {
 }
x f l offs icsigsilkscreen  {
   }
x c bl silk  {
	silk :: -1000
  }
icsigflexography  {
 }
x c l flex icmaxenumtechnology  {
   }
xffffffffl ictechnologysignature  {
 }
type signatures typedef enum icsigcurvetype  {
   }
x l curv icsigdatatype  {
  }
x l data icsigdatetimetype  {
  }
x dl dtim  {
	stimed :: 5
 }
icsiglut  {
 }
type x d l mft  {
	motif :: 3
	metif :: 3
	 oft :: 3
	 met :: 3
	 mat :: 3
	 eft :: 3
	 aft :: 3
   }
icsiglut type x d l mft icsigmeasurementtype  {
	adsorbate :: -1000
     }
x d l meas icsignamedcolortype  {
	ryotwari :: -1000
   }
x e f cl ncol obsolete use ncl icsigprofilesequencedesctype  {
       }
x l pseq icsigs fixed arraytype  {
    }
x l sf  {
	ifs :: 2
	efs :: 2
	 s :: 2
 }
icsigscreeningtype  {
 }
x el scrn icsigsignaturetype  {
  }
x l sig icsigtexttype  {
  }
x l text icsigtextdescriptiontype  {
  }
x l desc icsigu fixed arraytype x l uf icsigucrbgtype  {
	  accited :: -1000
        }
x l bfd icsiguint  {
  }
arraytype x l ui icsiguint arraytype x l ui icsiguint arraytype x l ui icsiguint arraytype x l ui icsigviewingconditionstype  {
	      embellishment :: -1000
                  }
x l view icsigxyztype  {
  }
x a l xyz  {
  }
icsigxyzarraytype  {
 }
x a l xyz icsignamedcolor type x e c l ncl icsigcrdinfotype  {
          }
x l crdi icmaxenumtype  {
  }
xffffffffl ictagtypesignature  {
 }
color  {
	color :: -1000
 }
space signatures note that only icsigxyzdata  {
    }
and icsiglabdata  {
 }
are valid profile connection spaces  {
	spaces :: -1000
   }
pcss  {
	bargemen :: -1000
 }
typedef enum icsigxyzdata x a l xyz icsiglabdata x c l lab icsigluvdata  {
           }
x c l luv  {
	luv :: -1000
  }
icsigycbcrdata  {
	truthless :: -1000
 }
x l ycbr  {
 }
icsigyxydata  {
 }
x l yxy  {
	yay :: 3
	oxy :: 3
 }
icsigrgbdata  {
 }
x l rgb  {
	bottomry :: -1000
 }
icsiggraydata  {
 }
x l gray  {
	gray :: -1000
 }
icsighsvdata  {
 }
x l hsv  {
	hives :: 3
	haves :: 3
 }
icsighlsdata  {
 }
x c l hls  {
	hosel :: 3
	losh :: 3
	lash :: 3
	hos :: 3
	his :: 3
	hes :: 3
	has :: 3
	els :: 3
	als :: 3
	 sl :: 3
  }
icsigcmykdata  {
 }
x d bl cmyk  {
  }
icsigcmydata  {
 }
x d l cmy icsig colordata  {
	widening :: -1000
    }
x c l clr  {
	curly :: 3
	coral :: 3
	clour :: 3
	clerk :: 3
	clear :: 3
	clary :: 3
	clart :: 3
	claro :: 3
	cirls :: 3
	carol :: 3
	carls :: 3
	carle :: 3
	curl :: 4
	crlf :: 3
	cirl :: 4
	carl :: 4
	cur :: 3
	cor :: 3
	cly :: 3
	car :: 3
	 cr :: 3
  }
icsig colordata x c l clr icsig colordata x c l clr icsig colordata x c l clr icsig colordata x c l clr icsig colordata x c l clr icsig colordata x c l clr icsig colordata x c l clr icsig colordata x c l aclr  {
                                              }
icsig colordata x c l bclr  {
    }
icsig colordata x c l cclr  {
    }
icsig colordata x c l dclr  {
    }
icsig colordata x c l eclr  {
	eclair :: 5
    }
icsig colordata x c l fclr  {
	 crlf :: 5
    }
icmaxenumdata  {
 }
xffffffffl iccolorspacesignature  {
 }
profileclass  {
 }
enumerations  {
	enumerations :: -1000
 }
typedef enum icsiginputclass  {
 }
x e l scnr  {
	scerne :: 5
	synroc :: 5
	scur :: 5
	scar :: 5
	scran :: 5
	scorn :: 6
  }
icsigdisplayclass  {
 }
x d e l mntr  {
	untrim :: 5
	antrum :: 5
	matron :: 5
   }
icsigoutputclass  {
 }
x l prtr  {
 }
icsiglinkclass  {
 }
x c e bl link icsigabstractclass  {
    }
x l abst icsigcolorspaceclass  {
  }
x l spac icsignamedcolorclass  {
  }
x e d cl nmcl  {
   }
icmaxenumclass  {
 }
xffffffffl icprofileclasssignature  {
 }
platform signatures typedef enum icsigmacintosh  {
   }
x cl appl icsigmicrosoft  {
	unbashful :: -1000
  }
x d l msft  {
	muftis :: 5
  }
icsigsolaris  {
 }
x e l sunw icsigsgi  {
   }
x l sgi icsigtaligent  {
  }
x e l tgnt  {
	tint :: 5
	tent :: 5
  }
icmaxenumplatform  {
 }
xffffffffl icplatformsignature  {
 }
other enums  {
	unmesh :: 6
	geums :: 6
	neumes :: 6
	emulsin :: 6
	neum :: 6
	emus :: 6
	neums :: 8
	menus :: 6
 }
measurement  {
	measurement :: -1000
 }
flare  {
	flare :: -1000
 }
used in the measurmenttype  {
	measurement :: 18
  }
tag typedef enum icflare  {
	inflater :: 9
	inflamer :: 9
  }
x l flare icflare x l flare icmaxflare  {
      }
xffffffffl icmeasurementflare  {
 }
measurement geometry  {
	geometry :: -1000
 }
used in the measurmenttype tag typedef enum icgeometryunknown  {
      }
x l unknown icgeometry or x l icgeometry dord  {
	  dorted :: 5
	  donder :: 5
	   dorad :: 6
	    word :: 5
	    lord :: 5
	    ford :: 5
	    dowd :: 5
	    cord :: 5
	    bord :: 5
	     dor :: 5
	     dod :: 5
       }
x l d or d icmaxgeometry  {
    }
xffffffffl icmeasurementgeometry  {
 }
rendering intents  {
	intents :: -1000
 }
used in the profile header typedef enum icperceptual  {
      }
icrelativecolorimetric  {
 }
icsaturation  {
	scatteration :: 16
	instaurations :: 17
	capitulations :: 16
	gastrulation :: 15
	articulation :: 16
	renaturation :: 15
	curarizations :: 15
	inaugurations :: 15
	reticulations :: 15
	denaturations :: 16
	incrustation :: 16
	reactivations :: 15
	articulations :: 17
	instauration :: 19
	capitulation :: 15
	scatterations :: 15
	renaturations :: 16
 }
icabsolutecolorimetric  {
 }
icmaxenumintent  {
 }
xffffffffl icrenderingintent  {
 }
different spot  {
	spot :: -1000
 }
shapes currently defined used for screeningtype  {
	screening :: 16
    }
typedef enum icspotshapeunknown  {
 }
icspotshapeprinterdefault  {
 }
icspotshaperound  {
 }
icspotshapediamond  {
 }
icspotshapeellipse  {
 }
icspotshapeline  {
 }
icspotshapesquare  {
 }
icspotshapecross  {
 }
icmaxenumspot  {
 }
xffffffffl icspotshape standard observer  {
	observer :: -1000
  }
used in the measurmenttype tag typedef enum icstdobsunknown  {
      }
x l unknown icstdobs twodegrees  {
   }
x l deg  {
	dogie :: 3
	dogey :: 3
	doges :: 3
	derig :: 3
	deign :: 3
	degum :: 4
	degas :: 4
	defog :: 3
	debug :: 3
	debag :: 3
	begad :: 3
	degust :: 3
	degami :: 3
	geld :: 3
	geds :: 3
	edgy :: 3
	edge :: 3
	doge :: 4
	veg :: 3
	teg :: 3
	seg :: 3
	reg :: 3
	peg :: 3
	leg :: 3
	keg :: 3
	ged :: 4
	dug :: 3
	dog :: 3
	dig :: 3
	dey :: 3
	dex :: 3
	dew :: 3
	dev :: 3
	dep :: 3
	den :: 3
	del :: 3
	def :: 3
	dag :: 3
	beg :: 3
	ge :: 3
	de :: 4
 }
icstdobs tendegrees  {
	tenderfeet :: 12
	nondegree :: 12
 }
x l deg icmaxstdobs  {
  }
xffffffffl icstandardobserver  {
 }
pre defined illuminants  {
	illuminants :: -1000
 }
used in measurement and viewing  {
	viewing :: -1000
   }
conditions type typedef enum icilluminantunknown  {
   }
x l icilluminantd  {
 }
x l icilluminantd x l icilluminantd x l icilluminantf  {
       }
x l icilluminantd x l icilluminanta  {
    }
x l icilluminantequipowere  {
 }
x l icilluminantf x l icmaxenumiluminant  {
    }
xffffffffl icilluminant arrays of numbers int array typedef struct icint number data icany variable array of values icint array uint array typedef struct icuint number data icany variable array of values icuint array uint array typedef struct icuint number data icany variable array of values icuint array int array typedef struct icint number data icany variable array of values icint array uint array typedef struct icuint number data icany variable array of values icuint array int array typedef struct icint number data icany variable array of values icint array uint array typedef struct icuint number data icany variable array of values icuint array int array typedef struct icint number data icany variable array of values icint array u fixed array typedef struct icu fixed number data icany variable array of values icu fixed array s fixed array typedef struct ics fixed number data icany variable array of values ics fixed array the base date time number typedef struct icuint number year  {
	                                                                                                                                                            year :: -1000
                                                                                                                                                               }
icuint number month  {
	month :: -1000
 }
icuint number day icuint number hours  {
	hours :: -1000
    }
icuint number minutes  {
	minutes :: -1000
 }
icuint number seconds icdatetimenumber  {
  }
xyz number typedef struct ics fixed number x ics fixed number y ics fixed number z icxyznumber  {
               }
xyz array typedef struct icxyznumber data icany variable array of xyz numbers icxyzarray  {
           }
curve typedef struct icuint number count number of entries icuint number data icany the actual table data real number is determined  {
	          determined :: -1000
                   }
by count interpretation depends on how data is used with a given tag iccurve  {
	      incurve :: 11
	     incurves :: 10
	     incurved :: 10
            }
data typedef struct icuint number dataflag  {
    }
ascii binary icint number data icany data size from tag icdata  {
         }
lut  {
	met :: -1000
 }
typedef struct icuint number inputchan  {
	unlatching :: 11
   }
number of input channels  {
	channels :: -1000
  }
icuint number outputchan  {
	outpunches :: 12
	outpunched :: 12
	outpunching :: 12
	outpitching :: 12
	output :: 12
	outpitch :: 12
 }
number of output channels icuint number clutpoints  {
	bluepoint :: 12
	bluepoints :: 14
	autopoints :: 12
     }
number of grid  {
	grid :: -1000
 }
points icint number pad padding for byte alignment ics fixed number e e in the ics fixed number e e in the ics fixed number e e in the ics fixed number e e in the ics fixed number e e in the ics fixed number e e in the ics fixed number e e in the ics fixed number e e in the ics fixed number e e in the icuint number inputent  {
	                                                                 impudent :: 10
	                                                                 impotent :: 10
	                                                                 inputter :: 10
	                                                                 inputted :: 10
	                                                                 penitent :: 10
                                                                        }
num of in table entries icuint number outputent  {
	outputted :: 13
	outputting :: 12
      }
num of out table entries icuint number data icany data follows see spec data that follows is of this form icuint number inputtable  {
	            insultable :: 14
	            unprizable :: 12
	            untestable :: 12
	              inputter :: 12
	              inputted :: 12
	            unpickable :: 12
	            unsuitable :: 13
	            intuitable :: 15
	            inculpable :: 13
	            impugnable :: 13
	            unlettable :: 13
                     }
inputchan icany the in table icuint number cluttable  {
	electable :: 11
	trustable :: 11
	countable :: 12
	clubbable :: 12
      }
icany the clut icuint number outputtable  {
	outputted :: 14
    }
outputchan icany the out table iclut  {
	incut :: 6
	incult :: 6
	ictus :: 6
	culti :: 6
	toluic :: 6
    }
lut input output tables are always bytes in length typedef struct icuint number inputchan num of input channels icuint number outputchan num of output channels icuint number clutpoints num of grid points icint number pad ics fixed number e e in the ics fixed number e e in the ics fixed number e e in the ics fixed number e e in the ics fixed number e e in the ics fixed number e e in the ics fixed number e e in the ics fixed number e e in the ics fixed number e e in the icuint number data icany data follows see spec data that follows is of this form icuint number inputtable inputchan the in table icuint number cluttable icany the clut icuint number outputtable outputchan the out table iclut measurement data typedef struct icstandardobserver stdobserver  {
                                                                                                                                          }
standard observer icxyznumber backing  {
	backing :: -1000
  }
xyz for backing icmeasurementgeometry geometry meas geometry icmeasurementflare flare measurement flare icilluminant illuminant illuminant icmeasurement named color icnamedcolor  {
                }
takes the place of icnamedcolor typedef struct icuint number vendorflag  {
	   redbay :: -1000
        }
bottom  {
	bottom :: -1000
 }
bits for ic use icuint number count count of named colors  {
	    colors :: -1000
         }
icuint number ndevicecoords  {
 }
num of device coordinates  {
	coordinates :: -1000
  }
icint number prefix prefix for each color name icint number suffix suffix for each color name icint number data icany named color data follows data that follows is of this form icint number root root name for st color icuint number pcscoords  {
                                        }
icany pcs coords  {
	doorns :: 8
	doors :: 8
	corso :: 7
	cooed :: 7
	chord :: 7
	cordons :: 7
	crowds :: 8
	condors :: 7
	corsos :: 7
	corody :: 7
	cooser :: 7
	cooers :: 8
	condos :: 7
	colors :: 7
	codons :: 7
	chords :: 9
	loords :: 9
	door :: 7
	coos :: 7
	roods :: 7
	corrodes :: 7
	odors :: 7
	corodies :: 7
	loord :: 7
 }
of st color icuint number devicecoords  {
    }
icany dev coords of st color icint number root root name for nd color icuint number pcscoords icany pcs coords of nd color icuint number devicecoords icany dev coords of nd color repeat for name and pcs and device color coordinates up to count notes pcs and device space can be determined from the header pcs coordinates are icuint numbers and are described in annex  {
	                                                      saleswomen :: -1000
                                                               }
a of the icc spec only bit l a b and xyz are allowed the number of coordinates is consistent with the headers pcs device coordinates are icuint numbers where x represents the minimum value and xffff represents the maximum value if the ndevicecoords value is this field is not given icnamedcolor profile sequence structure typedef struct icsignature devicemfg  {
	                                                 deviceful :: 11
	                                                    device :: 12
	                                                   devices :: 11
                                                         }
dev manufacturer  {
	manufacturer :: -1000
 }
icsignature devicemodel  {
 }
dev model icuint number attributes dev attributes ictechnologysignature technology technology sig icint number data icany desc text follows data that follows is of this form this is an icint number to avoid problems with a compiler generating bad code as these arrays are variable in length ictextdescription  {
                                             }
devicemfgdesc  {
 }
manufacturer text ictextdescription modeldesc  {
	modelled :: 11
	modelers :: 11
	modeled :: 12
  }
model text icdescstruct  {
 }
profile sequence description typedef struct icuint number count number of descriptions icuint number data icany array of desc structs icprofilesequencedesc  {
                  }
textdescription  {
 }
typedef struct icuint number count description length icint number data icany descriptions follow data that follows is of this form icint number desc count null terminated ascii string icuint number uclangcode  {
                             }
unicode language  {
	language :: -1000
 }
code icuint number uccount  {
	account :: 11
	accounted :: 9
	upcountry :: 9
	uncounted :: 9
	accounts :: 10
	uncouth :: 9
  }
unicode description length icint number ucdesc  {
	accused :: 7
	duces :: 7
    }
uccount the unicode description icuint number sccode  {
	opcodes :: 7
	second :: 7
	sconce :: 7
	accedes :: 7
	decodes :: 7
	occidents :: 7
	accosted :: 7
	sconced :: 8
	recodes :: 7
	encodes :: 7
	  ecco :: 7
     }
scriptcode  {
	scripted :: 13
	scritched :: 12
 }
code icuint number sccount  {
	recounts :: 9
	account :: 11
	coconuts :: 9
	accounted :: 9
	accourts :: 9
	accounts :: 12
  }
scriptcode count icint number scdesc  {
	sides :: 7
	sades :: 7
   }
scriptcode description ictextdescription screening data typedef struct ics fixed number frequency frequency ics fixed number angle  {
	          angle :: -1000
              }
screen angle icspotshape spotshape  {
	phosphate :: 11
	shipshape :: 11
  }
spot shape encodings below icscreeningdata  {
   }
typedef struct icuint number screeningflag  {
	screening :: 17
   }
screening flag icuint number channels number of channels icscreeningdata data icany array of screening data icscreening text data typedef struct icint number data icany variable array of chars ictext structure describing either a ucr or bg curve typedef struct icuint number count curve length icuint number curve icany the array of curve values icucrbgcurve under color removal  {
	                                                 removal :: -1000
                                                       }
black  {
	black :: -1000
 }
generation typedef struct icint number data icany the ucr bg data data that follows is of this form this is a icint number to avoid problems with a compiler generating bad code as these arrays are variable in length icucrbgcurve ucr ucr curve icucrbgcurve bg bg curve icint number string ucrbg description icucrbg viewingconditionstype  {
                                                    }
typedef struct icxyznumber illuminant in candelas  {
	candelas :: -1000
    }
per sq  {
	ta :: -1000
 }
meter  {
	meter :: -1000
 }
icxyznumber surround in candelas per sq meter icilluminant stdiluminant  {
       }
see icilluminant defines icviewingcondition  {
	unusable :: -1000
  }
crdinfo  {
 }
type typedef struct icuint number count char count includes null icint number desc icany null terminated string iccrdinfo  {
                }
tag type definitions many of the structures contain variable length arrays this is represented by the use of the convention type data icany the base part of each tag typedef struct ictagtypesignature sig signature icint number reserved reserved set to ictagbase  {
                                       }
curvetype  {
	curvet :: 11
	curveted :: 12
	curvity :: 11
 }
typedef struct ictagbase base signature curv iccurve curve the curve data iccurvetype  {
          }
datatype typedef struct ictagbase base signature data icdata data the data structure icdatatype  {
           }
datetimetype  {
 }
typedef struct ictagbase base signature dtim icdatetimenumber date the date icdatetimetype  {
         }
lut type typedef struct ictagbase base signature mft iclut lut lut data iclut type lut type input output tables are always bytes in length typedef struct ictagbase base signature mft iclut lut lut data iclut type measurement type typedef struct ictagbase base signature meas icmeasurement measurement measurement data icmeasurementtype  {
                                               }
named color type icnamedcolor type replaces  {
	replaces :: -1000
    }
icnamedcolortype  {
 }
typedef struct ictagbase base signature ncl icnamedcolor ncolor  {
      }
named color data icnamedcolor type profile sequence description type typedef struct ictagbase base signature pseq icprofilesequencedesc desc the seq description icprofilesequencedesctype  {
                   }
textdescriptiontype  {
 }
typedef struct ictagbase base signature desc ictextdescription desc the description ictextdescriptiontype  {
         }
s fixed type typedef struct ictagbase base signature sf ics fixed array data array of values ics fixed arraytype typedef struct ictagbase base signature scrn icscreening screen screening structure icscreeningtype  {
                            }
sigtype  {
	tangibilities :: -1000
 }
typedef struct ictagbase base signature sig icsignature signature the signature data icsignaturetype  {
          }
texttype  {
 }
typedef struct ictagbase base signature text ictext data variable array of chars ictexttype  {
           }
u fixed type typedef struct ictagbase base signature uf icu fixed array data variable array of values icu fixed arraytype under color removal black generation type typedef struct ictagbase base signature bfd icucrbg data ucrbg structure icucrbgtype  {
                                   }
uint type typedef struct ictagbase base signature ui icuint array data variable array of values icuint arraytype uint type typedef struct ictagbase base signature ui icuint array data variable array of values icuint arraytype uint type typedef struct ictagbase base signature ui icuint array data variable array of values icuint arraytype uint type typedef struct ictagbase base signature ui icuint array data variable array of values icuint arraytype viewingconditionstype typedef struct ictagbase base signature view icviewingcondition view viewing conditions icviewingconditiontype  {
                                                                              }
xyz type typedef struct ictagbase base signature xyz icxyzarray data variable array of xyz nums  {
	          tums :: 5
	          rums :: 5
	          nuts :: 5
	          nurs :: 5
	          numb :: 5
	          nubs :: 5
	          noms :: 5
	          nims :: 5
	          muns :: 6
	          mums :: 5
	          nams :: 5
	          hums :: 5
	          bums :: 5
	         numbs :: 6
	           sum :: 5
             }
icxyztype  {
 }
crdinfotype  {
 }
where is the crd product name count and string and are the rendering intents counts and strings typedef struct ictagbase base signature crdi iccrdinfo info sets of counts strings iccrdinfotype  {
                            }
iccrdinfo productname  {
	product :: 14
 }
ps product count string iccrdinfo crdname  {
	crena :: 9
	crenated :: 9
	craned :: 9
	crinated :: 9
    }
crd name for intent iccrdinfo crdname crd name for intent iccrdinfo crdname crd name for intent iccrdinfo crdname crd name for intent lists of tags tags profile header and profile structure a tag typedef struct ictagsignature sig the tag signature icuint number offset start of tag relative to start of header spec clause  {
	                                          pardalotes :: -1000
                                                   }
icuint number size size in bytes ictag a structure that may be used independently  {
	independently :: -1000
            }
for a list of tags typedef struct icuint number count num tags in the profile ictag tags icany variable array of tags ictaglist  {
	             tactilist :: 11
	             actualist :: 11
                     }
the profile header typedef struct icuint number size prof size in bytes icsignature cmmid  {
            }
cmm for profile icuint number version format version icprofileclasssignature deviceclass  {
        }
type of profile iccolorspacesignature colorspace  {
	crawlspace :: 12
   }
clr space of data iccolorspacesignature pcs pcs xyz or lab icdatetimenumber date creation  {
	    creation :: -1000
           }
date icsignature magic icmagicnumber icplatformsignature platform primary  {
	primary :: -1000
     }
platform icuint number flags various bits icsignature manufacturer dev manufacturer icuint number model dev model number icuint number attributes device attributes icuint number renderingintent rendering intent icxyznumber illuminant profile illuminant icsignature creator  {
	                        creator :: -1000
                              }
profile creator icint number reserved reserved icheader  {
	achiever :: 10
     }
a profile we can t use ictaglist here because its not at the end of the structure typedef struct icheader header the header icuint number count num tags in the profile icint number data icany the tagtable  {
	                            wastable :: 10
	                            tastable :: 13
	                            castable :: 10
	                            agitable :: 11
	                            testable :: 10
	                            tiltable :: 10
	                            cartable :: 10
	                            statable :: 11
	                            gettable :: 11
                                   }
and tagdata  {
	tagmata :: 11
 }
data that follows is of the form ictag tagtable icany the tag table icint number tagdata icany the tag data icprofile obsolete entries icnamedcolor was replaced  {
	                 replaced :: -1000
                        }
with icnamedcolor typedef struct icuint number vendorflag bottom bits for ic use icuint number count count of named colors icint number data icany named color data follows data that follows is of this form icint number prefix icany prefix icint number suffix icany suffix icint number root icany root name icint number coords icany color coordinates icint number root icany root name icint number coords icany color coordinates repeat for root name and color coordinates up to count icnamedcolor icnamedcolortype was replaced by icnamedcolor type typedef struct ictagbase base signature ncol icnamedcolor ncolor named color data icnamedcolortype endif icc h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef iconv h define iconv h include features h define need size t include stddef h begin decls identifier for conversion method from one codeset  {
	                                                                                                                                                                                                                                                          codeless :: 9
	                                                                                                                                                                                                                                                             codes :: 9
	                                                                                                                                                                                                                                                           tedesco :: 9
	                                                                                                                                                                                                                                                           coveted :: 9
	                                                                                                                                                                                                                                                           cotised :: 9
                                                                                                                                                                                                                                                                 }
to another typedef void iconv t allocate descriptor for code conversion from codeset fromcode  {
            }
to codeset tocode  {
	opcodes :: 7
	cooed :: 7
	vocoders :: 7
	cytode :: 7
	toledo :: 7
	coopted :: 7
	scooted :: 7
	opcode :: 8
	coyote :: 7
	vocoder :: 8
	tocos :: 7
	toco :: 8
 }
this function is a possible cancellation point and therefore not marked with throw extern iconv t iconv open const char tocode const char fromcode convert at most inbytesleft  {
	                    decoked :: -1000
                          }
bytes from inbuf according to the code conversion algorithm specified by cd and place up to outbytesleft  {
               }
bytes in buffer at outbuf extern size t iconv iconv t cd char restrict inbuf size t restrict inbytesleft char restrict outbuf size t restrict outbytesleft free resources allocated for descriptor cd for code conversion this function is a possible cancellation point and therefore not marked with throw extern int iconv close iconv t cd end decls endif iconv h idna  {
	                                                       idant :: 5
	                                                       dinar :: 5
	                                                        idea :: 5
                                                           }
h declarations for internationalized  {
	internationalized :: -1000
  }
domain name in applications copyright c simon  {
	simorg :: 6
	simoon :: 7
	simony :: 9
	inmost :: 6
	simonize :: 6
	simoniac :: 6
	 bison :: 6
	kimonos :: 6
	minors :: 6
	 vison :: 6
	 timon :: 7
	 soman :: 6
	  nims :: 6
	  miso :: 6
	  mino :: 6
	 scion :: 6
	 minos :: 7
	   sim :: 6
	 limos :: 6
     }
josefsson  {
	elutriator :: -1000
 }
this file is part of gnu libidn  {
	libidos :: 8
	libido :: 9
	 livid :: 7
	 lipid :: 7
     }
gnu libidn is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version gnu libidn is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with gnu libidn if not write to the free software foundation inc franklin street fifth floor boston ma usa ifndef idna h define idna h ifndef idnapi  {
	                                                                                                               malentendu :: -1000
                                                                                                                        }
if defined libidn building defined have visibility have visibility define idnapi attribute visibility default elif defined libidn building defined msc ver defined libidn static define idnapi declspec dllexport  {
                          }
elif defined msc ver defined libidn static define idnapi declspec dllimport else define idnapi endif endif include stddef h size t include idn int h uint t ifdef cplusplus extern c endif error codes typedef enum idna success idna stringprep  {
	                            springwater :: 12
	                               sprinter :: 13
	                               springer :: 14
	                               stronger :: 12
	                               stripper :: 13
	                               stringer :: 15
	                              springers :: 12
	                              stringers :: 13
	                              stringier :: 12
	                               stranger :: 12
                                      }
error idna punycode  {
	pounced :: 10
 }
error idna contains non ldh  {
	dahl :: 3
	 lah :: 3
	 edh :: 3
   }
workaround typo  {
	typo :: -1000
 }
in earlier  {
	earlier :: -1000
 }
versions idna contains ldh idna contains non ldh idna contains minus idna invalid length idna no ace  {
	             ace :: -1000
               }
prefix idna roundtrip  {
	rounder :: 11
 }
verify error idna contains ace prefix idna iconv error internal errors idna malloc error idna dlopen error idna rc idna flags typedef enum idna allow unassigned  {
	               unassigned :: -1000
                        }
x idna use std ascii rules x idna flags ifndef idna ace prefix define idna ace prefix xn endif extern idnapi const char idna strerror idna rc rc core functions extern idnapi int idna to ascii i const uint t in size t inlen char out int flags extern idnapi int idna to unicode i const uint t in size t inlen uint t out size t outlen  {
	                                                           outlined :: 9
	                                                           outlines :: 9
	                                                           outliner :: 9
	                                                           outlearn :: 9
	                                                           outleaps :: 7
	                                                           outlands :: 7
	                                                             runlet :: 7
	                                                         outlanders :: 7
	                                                          outlinear :: 8
	                                                          outliners :: 8
	                                                              butle :: 7
	                                                          outlearnt :: 7
	                                                          outlearns :: 8
	                                                             outlie :: 8
	                                                             outlet :: 8
	                                                             outler :: 9
	                                                          outlander :: 8
	                                                            outyell :: 7
	                                                            outyelp :: 7
	                                                            outwell :: 7
	                                                            outwent :: 7
	                                                            outsell :: 7
	                                                            outness :: 7
	                                                            outlive :: 7
	                                                            outline :: 10
	                                                            outlies :: 7
	                                                            outlier :: 7
	                                                            outlers :: 8
	                                                            outlets :: 7
	                                                            outleap :: 8
	                                                            outland :: 8
	                                                            outlain :: 7
	                                                             lutein :: 7
	                                                         outleaping :: 7
	                                                            opulent :: 9
	                                                             stolen :: 7
	                                                             nutlet :: 7
	                                                            cutline :: 7
	                                                              noule :: 7
                                                                  }
int flags wrappers that handle several labels  {
	labels :: -1000
     }
extern idnapi int idna to ascii z const uint t input char output int flags extern idnapi int idna to ascii z const char input char output int flags extern idnapi int idna to ascii lz  {
	                                lez :: 2
	                                  l :: 2
                                  }
const char input char output int flags extern idnapi int idna to unicode z z const uint t input uint t output int flags extern idnapi int idna to unicode z z const char input uint t output int flags extern idnapi int idna to unicode z z const char input char output int flags extern idnapi int idna to unicode zlz  {
	                                                        zizel :: 3
	                                                          ziz :: 3
                                                            }
const char input char output int flags extern idnapi int idna to unicode lzlz  {
            }
const char input char output int flags ifdef cplusplus endif endif idna h idn free h invoke the free function releasing  {
	           releasing :: -1000
                   }
memory allocated by libidn functions copyright c simon josefsson this file is part of gnu libidn gnu libidn is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version gnu libidn is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with gnu libidn if not write to the free software foundation inc franklin street fifth floor boston ma usa ifndef idn free h define idn free h ifndef idnapi if defined libidn building defined have visibility have visibility define idnapi attribute visibility default elif defined libidn building defined msc ver defined libidn static define idnapi declspec dllexport elif defined msc ver defined libidn static define idnapi declspec dllimport else define idnapi endif endif ifdef cplusplus extern c endif i don t recommend using this interface in general use free i m told  {
	                                                                                                                                                                                                      told :: -1000
                                                                                                                                                                                                         }
microsoft  {
	microsome :: 11
	microtone :: 11
	microvolt :: 12
	microdots :: 13
	microdot :: 12
	micros :: 11
	microtomes :: 11
	microtones :: 12
	microvolts :: 13
 }
windows may use one set of malloc and free in a library and another incompatible set in a statically  {
	        statically :: -1000
                 }
compiled application that link to the library thus creating problems if the application would invoke free on a pointer pointing to memory allocated by the library this motivated  {
	                  motivated :: -1000
                          }
adding this function the theory of isolating  {
	isolating :: -1000
     }
all memory allocations and de allocations within a code package library sounds  {
	     spends :: -1000
          }
good to simplify  {
	simplify :: -1000
 }
hunting  {
	hunting :: -1000
 }
down memory allocation related problems but i m not sure if it is worth  {
	        worth :: -1000
            }
enough to motivate recommending  {
	recommending :: -1000
  }
this interface over calling free directly though see the manual section memory handling under windows for more information extern void idnapi idn free void ptr ifdef cplusplus endif endif idn free h include stdint h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef ieee h define ieee h include features h include endian h begin decls union ieee float float f this is the ieee single precision format struct if byte order big endian unsigned int negative unsigned int exponent  {
	                                                                                                                                                                                                      exponent :: -1000
                                                                                                                                                                                                             }
unsigned int mantissa  {
	mantissa :: -1000
 }
endif big endian if byte order little endian unsigned int mantissa unsigned int exponent unsigned int negative endif little endian ieee this format makes it easier to see if a nan  {
	                           nan :: -1000
                             }
is a signalling  {
	signalling :: -1000
 }
nan struct if byte order big endian unsigned int negative unsigned int exponent unsigned int quiet  {
	          quiet :: -1000
              }
nan unsigned int mantissa endif big endian if byte order little endian unsigned int mantissa unsigned int quiet nan unsigned int exponent unsigned int negative endif little endian ieee nan define ieee float bias  {
	                             bias :: -1000
                                }
x f added to exponent union ieee double double d this is the ieee double precision format struct if byte order big endian unsigned int negative unsigned int exponent together these comprise  {
	                       comprise :: -1000
                              }
the mantissa unsigned int mantissa unsigned int mantissa endif big endian if byte order little endian if float word order big endian unsigned int mantissa unsigned int exponent unsigned int negative unsigned int mantissa else together these comprise the mantissa unsigned int mantissa unsigned int mantissa unsigned int exponent unsigned int negative endif endif little endian ieee this format makes it easier to see if a nan is a signalling nan struct if byte order big endian unsigned int negative unsigned int exponent unsigned int quiet nan together these comprise the mantissa unsigned int mantissa unsigned int mantissa else if float word order big endian unsigned int mantissa unsigned int quiet nan unsigned int exponent unsigned int negative unsigned int mantissa else together these comprise the mantissa unsigned int mantissa unsigned int mantissa unsigned int quiet nan unsigned int exponent unsigned int negative endif endif ieee nan define ieee double bias x ff added to exponent union ieee long double long double d this is the ieee double extended precision format struct if byte order big endian unsigned int negative unsigned int exponent unsigned int empty unsigned int mantissa unsigned int mantissa endif if byte order little endian if float word order big endian unsigned int exponent unsigned int negative unsigned int empty unsigned int mantissa unsigned int mantissa else unsigned int mantissa unsigned int mantissa unsigned int exponent unsigned int negative unsigned int empty endif endif ieee this is for nans  {
	                                                                                                                                                                                                                                             nans :: -1000
                                                                                                                                                                                                                                                }
in the ieee double extended precision format struct if byte order big endian unsigned int negative unsigned int exponent unsigned int empty unsigned int one unsigned int quiet nan unsigned int mantissa unsigned int mantissa endif if byte order little endian if float word order big endian unsigned int exponent unsigned int negative unsigned int empty unsigned int mantissa unsigned int quiet nan unsigned int one unsigned int mantissa else unsigned int mantissa unsigned int mantissa unsigned int quiet nan unsigned int one unsigned int exponent unsigned int negative unsigned int empty endif endif ieee nan define ieee long double bias x fff end decls endif ieee h ifaddrs  {
                                                                                                           }
h declarations for getting  {
	getting :: -1000
  }
network interface addresses copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef ifaddrs h define ifaddrs h include features h include sys socket h begin decls the getifaddrs  {
	                                                                                                                                                   radian :: -1000
                                                                                                                                                        }
function generates a linked list of these structures each element of the list describes one network interface struct ifaddrs struct ifaddrs ifa next pointer to the next structure char ifa name name of this network interface unsigned int ifa flags flags as from siocgifflags  {
                                          }
ioctl  {
	coutil :: 6
	coital :: 6
	coctile :: 6
	loci :: 6
	colt :: 6
	coit :: 6
	lictor :: 6
	lotic :: 6
 }
struct sockaddr ifa addr network address of this interface struct sockaddr ifa netmask  {
	     hetmans :: 9
           }
netmask of this interface union at most one of the following two is valid if the iff broadcast  {
	        broadcast :: -1000
                }
bit is set in ifa flags then ifa broadaddr  {
	chiropteran :: -1000
       }
is valid if the iff pointopoint  {
    }
bit is set then ifa dstaddr  {
    }
is valid it is never the case that both these bits are set at once struct sockaddr ifu broadaddr broadcast address of this interface struct sockaddr ifu dstaddr point to point destination  {
	                    destination :: -1000
                              }
address ifa ifu these very same macros are defined by net if h for struct ifaddr so if they are defined already the existing definitions will be fine  {
	                       fine :: -1000
                          }
ifndef ifa broadaddr define ifa broadaddr ifa ifu ifu broadaddr endif ifndef ifa dstaddr define ifa dstaddr ifa ifu ifu dstaddr endif void ifa data address specific data may be unused create a linked list of struct ifaddrs structures one for each network interface on the host machine if successful store the list in ifap  {
	                                                  igap :: 5
                                                     }
and return on errors return and set errno the storage returned in ifap is allocated dynamically and can only be properly  {
	            properly :: -1000
                   }
freed by passing it to freeifaddrs  {
    }
extern int getifaddrs struct ifaddrs ifap throw reclaim  {
	reclaim :: -1000
      }
the storage allocated by a previous getifaddrs call extern void freeifaddrs struct ifaddrs ifa throw end decls endif ifaddrs h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa iso c format conversion of integer types inttypes h ifndef inttypes h define inttypes h include features h get the type definitions include stdint h get a definition for wchar t but we must not define wchar t itself ifndef gwchar  {
                                                                                                                                                                                                 }
t defined ifdef cplusplus define gwchar t wchar t elif defined wchar type typedef wchar type gwchar t else define need wchar t include stddef h typedef wchar t gwchar t endif define gwchar t defined endif the iso c standard specifies that these macros must only be defined if explicitly requested if defined cplusplus defined stdc format macros if wordsize  {
	                                                   downsized :: 10
	                                                    wordiest :: 10
	                                                    woodsier :: 10
	                                                   worshiped :: 10
	                                                       words :: 10
	                                                    downsize :: 11
                                                           }
define pri prefix l define priptr  {
	preprint :: 7
	tripper :: 7
	tripery :: 7
	tripart :: 7
    }
prefix l else define pri prefix ll define priptr prefix endif macros for printing format specifiers  {
	     specifiers :: -1000
              }
decimal notation define prid  {
	prized :: 5
	prised :: 5
	primed :: 5
	prided :: 5
	priced :: 5
	dript :: 5
	drips :: 5
	prod :: 5
	prig :: 5
	prad :: 5
	paid :: 5
	irid :: 5
	grid :: 5
	drip :: 6
	arid :: 5
	pried :: 6
	pride :: 7
	pardi :: 5
  }
d define prid d define prid d define prid pri prefix d define pridleast  {
	     piddlers :: 11
	     plaiters :: 11
	   predikants :: 11
	  predynastic :: 11
	       paidle :: 11
	   predicants :: 11
	      paidles :: 12
	    drawliest :: 11
	     predials :: 12
	     triplets :: 11
	     dripless :: 11
	     tripedal :: 11
	      tripled :: 11
	      triples :: 11
	    prelatist :: 11
	     paddlers :: 11
	   prelatised :: 11
	    periblast :: 11
            }
d define pridleast d define pridleast d define pridleast pri prefix d define pridfast  {
            }
d define pridfast priptr prefix d define pridfast priptr prefix d define pridfast pri prefix d define prii  {
	            primi :: 6
                }
i define prii i define prii i define prii pri prefix i define priileast  {
	     hypoderm :: -1000
            }
i define priileast i define priileast i define priileast pri prefix i define priifast  {
	     pacifist :: 10
            }
i define priifast priptr prefix i define priifast priptr prefix i define priifast pri prefix i octal notation define prio o define prio o define prio o define prio pri prefix o define prioleast  {
	                      profligates :: 11
	                        portliest :: 11
	                         plaiters :: 11
	                          paroles :: 11
	                         pelorias :: 12
	                         poitrels :: 12
	                         triplets :: 11
	                         triolets :: 12
	                          triples :: 11
	                        prelatist :: 11
	                        periblast :: 11
                                }
o define prioleast o define prioleast o define prioleast pri prefix o define priofast  {
	     prosaist :: 10
	      profits :: 10
	      parotis :: 10
	     parodist :: 10
            }
o define priofast priptr prefix o define priofast priptr prefix o define priofast pri prefix o unsigned integers define priu  {
	        pulchritude :: -1000
                  }
u define priu u define priu u define priu pri prefix u define priuleast  {
	    peculiars :: 11
	     plaiters :: 11
	     triplets :: 11
	      triples :: 11
	    prelatist :: 11
	     primulas :: 11
	    periblast :: 11
            }
u define priuleast u define priuleast u define priuleast pri prefix u define priufast  {
            }
u define priufast priptr prefix u define priufast priptr prefix u define priufast pri prefix u lowercase hexadecimal notation define prix  {
	              praxis :: 5
	                prig :: 5
	                prex :: 5
                   }
x define prix x define prix x define prix pri prefix x define prixleast  {
	     plaiters :: 11
	     triplets :: 11
	      triplex :: 11
	      triples :: 11
	    prelatist :: 11
	    periblast :: 11
            }
x define prixleast x define prixleast x define prixleast pri prefix x define prixfast  {
            }
x define prixfast priptr prefix x define prixfast priptr prefix x define prixfast pri prefix x uppercase hexadecimal notation define prix x define prix x define prix x define prix pri prefix x define prixleast x define prixleast x define prixleast x define prixleast pri prefix x define prixfast x define prixfast priptr prefix x define prixfast priptr prefix x define prixfast pri prefix x macros for printing intmax  {
	                                                              pitman :: 7
	                                                              titman :: 7
                                                                   }
t and uintmax  {
 }
t define pridmax  {
	ameloblast :: -1000
 }
pri prefix d define priimax  {
   }
pri prefix i define priomax  {
   }
pri prefix o define priumax  {
   }
pri prefix u define prixmax  {
   }
pri prefix x define prixmax pri prefix x macros for printing intptr  {
	     intort :: 7
	      inept :: 7
	      inapt :: 7
	  interrupt :: 7
          }
t and uintptr  {
 }
t define pridptr  {
	tripper :: 9
	dripper :: 9
 }
priptr prefix d define priiptr  {
	trippier :: 9
   }
priptr prefix i define prioptr  {
	tripper :: 9
   }
priptr prefix o define priuptr  {
	tripper :: 9
	irrupt :: 10
	irrupts :: 9
   }
priptr prefix u define prixptr  {
	tripper :: 9
   }
priptr prefix x define prixptr priptr prefix x macros for scanning format specifiers signed decimal notation define scnd  {
	           syndic :: 5
	             sind :: 5
	             send :: 5
	             scud :: 5
	             scad :: 5
	             sand :: 5
	            scend :: 5
                }
hhd  {
 }
define scnd hd define scnd d define scnd pri prefix d define scndleast  {
	    scarlets :: 11
	    scantles :: 11
	     candles :: 11
	    sandlots :: 11
	    landless :: 11
	    candlers :: 11
	 sandblaster :: 11
	   sandblast :: 11
           }
hhd define scndleast hd define scndleast d define scndleast pri prefix d define scndfast  {
	     stedfast :: 10
	     handfast :: 10
	    handfasts :: 10
            }
hhd define scndfast priptr prefix d define scndfast priptr prefix d define scndfast pri prefix d signed decimal notation define scni  {
	              scrine :: 5
	               sonic :: 6
	               since :: 5
	               scion :: 5
	                 sin :: 5
                   }
hhi  {
	heigh :: 3
	haith :: 3
	high :: 3
	phi :: 3
	khi :: 3
	ghi :: 3
	chi :: 3
 }
define scni hi define scni i define scni pri prefix i define scnileast  {
	   scholiast :: 11
	   scantiest :: 11
	    scarlets :: 11
	    salients :: 11
	    salicets :: 12
	    scantles :: 11
	    scanties :: 11
	    scaliest :: 11
	    sanicles :: 12
	    staniels :: 11
	   snarliest :: 11
	   scenarist :: 11
	  schalstein :: 11
	    singlets :: 11
           }
hhi define scnileast hi define scnileast i define scnileast pri prefix i define scnifast  {
            }
hhi define scnifast priptr prefix i define scnifast priptr prefix i define scnifast pri prefix i unsigned decimal notation define scnu  {
	              scrunt :: 5
	              schuln :: 5
	               conus :: 5
                   }
hhu  {
	hie :: -1000
 }
define scnu hu define scnu u define scnu pri prefix u define scnuleast  {
	    annulets :: 11
	   simulcast :: 11
	    scarlets :: 11
	    scantles :: 11
	    scalenus :: 11
	 simulcasted :: 11
           }
hhu define scnuleast hu define scnuleast u define scnuleast pri prefix u define scnufast  {
            }
hhu define scnufast priptr prefix u define scnufast priptr prefix u define scnufast pri prefix u octal notation define scno  {
	              sonic :: 5
	              sonce :: 5
	              scorn :: 5
	              scone :: 5
	              scion :: 6
	               cons :: 5
	                son :: 5
                  }
hho  {
	hoosh :: 3
	hooch :: 3
	phoh :: 3
	hohs :: 3
	zho :: 3
	who :: 3
	tho :: 3
	rho :: 3
	pho :: 3
	oho :: 3
	mho :: 3
	hoh :: 4
	oh :: 3
 }
define scno ho define scno o define scno pri prefix o define scnoleast  {
	   scholiast :: 12
	    scarlets :: 11
	    scantles :: 11
	    coatless :: 11
           }
hho define scnoleast ho define scnoleast o define scnoleast pri prefix o define scnofast  {
            }
hho define scnofast priptr prefix o define scnofast priptr prefix o define scnofast pri prefix o hexadecimal notation define scnx  {
                  }
hhx  {
 }
define scnx hx  {
	hox :: 2
	hex :: 2
 }
define scnx x define scnx pri prefix x define scnxleast  {
	 scarlets :: 11
	 scantles :: 11
        }
hhx define scnxleast hx define scnxleast x define scnxleast pri prefix x define scnxfast  {
            }
hhx define scnxfast priptr prefix x define scnxfast priptr prefix x define scnxfast pri prefix x macros for scanning intmax t and uintmax t define scndmax  {
                        }
pri prefix d define scnimax  {
   }
pri prefix i define scnomax  {
   }
pri prefix o define scnumax  {
   }
pri prefix u define scnxmax  {
   }
pri prefix x macros for scaning  {
	seaning :: 11
	loanings :: 9
	scantling :: 9
	cantings :: 9
	saucing :: 9
	snawing :: 10
	snaring :: 10
	snaking :: 10
	cannings :: 10
	syncing :: 9
	scanting :: 10
	canning :: 9
	scanning :: 9
	sanding :: 9
	scalings :: 9
	spaning :: 11
	spacing :: 10
	saining :: 10
	craning :: 10
	dancings :: 9
	guanins :: 9
	sacring :: 9
	sacking :: 9
	cyanins :: 9
	scening :: 11
	staning :: 11
	scaring :: 11
	scaping :: 11
	scaling :: 11
	meanings :: 9
	leanings :: 9
    }
intptr t and uintptr t define scndptr  {
     }
priptr prefix d define scniptr  {
	script :: 11
	scripter :: 9
	scripted :: 9
	scripts :: 9
	scripting :: 9
	sprint :: 9
	scrip :: 9
   }
priptr prefix i define scnoptr  {
	synoptic :: 9
   }
priptr prefix o define scnuptr  {
	scrunt :: 10
   }
priptr prefix u define scnxptr  {
   }
priptr prefix x endif c format macros begin decls if wordsize we have to define the uintmax t type using ldiv  {
                   }
t typedef struct long int quot quotient  {
	quotient :: -1000
     }
long int rem remainder  {
	remainder :: -1000
  }
imaxdiv  {
	harridan :: -1000
 }
t else we have to define the uintmax t type using lldiv  {
          }
t typedef struct long long int quot quotient long long int rem remainder imaxdiv t endif compute  {
	         compute :: -1000
               }
absolute value of n extern intmax t imaxabs  {
      }
intmax t n throw attribute const return the imaxdiv t representation of the value of numer over denom  {
	          demount :: 6
	          demonry :: 6
	          demonic :: 6
	           genoms :: 6
	            genom :: 7
	            devon :: 6
	            denim :: 7
	            demos :: 6
	            demon :: 8
	            demob :: 6
	           denims :: 6
	           demons :: 7
	          venomed :: 6
	            venom :: 7
	             meno :: 7
	             mend :: 6
	             done :: 6
	             demo :: 7
	           venoms :: 6
	            monde :: 6
	              den :: 6
                }
extern imaxdiv t imaxdiv intmax t numer intmax t denom throw attribute const like strtol  {
	       settlor :: 7
	       trotyls :: 7
	        strout :: 7
	        stroll :: 7
	        sterol :: 7
	        stator :: 8
	         torts :: 7
	          stot :: 7
	          sort :: 7
             }
but convert to intmax t extern intmax t strtoimax  {
       }
const char restrict nptr  {
  }
char restrict endptr  {
	sapogenin :: -1000
 }
int base throw like strtoul  {
	strout :: 9
	surtout :: 9
   }
but convert to uintmax t extern uintmax t strtoumax  {
	 stratum :: 12
       }
const char restrict nptr char restrict endptr int base throw like wcstol  {
	    wittols :: 7
	     costal :: 7
	       wost :: 7
          }
but convert to intmax t extern intmax t wcstoimax  {
       }
const gwchar t restrict nptr gwchar t restrict endptr int base throw like wcstoul  {
            }
but convert to uintmax t extern uintmax t wcstoumax  {
       }
const gwchar t restrict nptr gwchar t restrict endptr int base throw ifdef use extern inlines if wordsize extern long int strtol internal const char restrict nptr char restrict endptr int base int group throw nonnull wur  {
	                              wurzel :: 3
	                              wursts :: 3
	                              wurley :: 3
	                               wurst :: 4
	                                waur :: 3
	                                 wus :: 3
	                                 wud :: 3
	                                 war :: 3
	                                 pur :: 3
	                                 nur :: 3
	                                 lur :: 3
	                                 cur :: 3
	                                 bur :: 3
                                   }
like strtol but convert to intmax t extern inline intmax t nth strtoimax const char restrict nptr char restrict endptr int base return strtol internal nptr endptr base extern unsigned long int strtoul internal const char restrict nptr char restrict endptr int base int group throw nonnull wur like strtoul but convert to uintmax t extern inline uintmax t nth strtoumax const char restrict nptr char restrict endptr int base return strtoul internal nptr endptr base extern long int wcstol internal const gwchar t restrict nptr gwchar t restrict endptr int base int group throw nonnull wur like wcstol but convert to intmax t extern inline intmax t nth wcstoimax const gwchar t restrict nptr gwchar t restrict endptr int base return wcstol internal nptr endptr base extern unsigned long int wcstoul internal const gwchar t restrict nptr gwchar t restrict endptr int base int group throw nonnull wur like wcstoul but convert to uintmax t extern inline uintmax t nth wcstoumax const gwchar t restrict nptr gwchar t restrict endptr int base return wcstoul internal nptr endptr base else wordsize extension extern long long int strtoll  {
	                                                                                                                                                                                 tortillas :: 9
                                                                                                                                                                                         }
internal const char restrict nptr char restrict endptr int base int group throw nonnull wur like strtol but convert to intmax t extern inline intmax t nth strtoimax const char restrict nptr char restrict endptr int base return strtoll internal nptr endptr base extension extern unsigned long long int strtoull  {
                                                }
internal const char restrict nptr char restrict endptr int base int group throw nonnull wur like strtoul but convert to uintmax t extern inline uintmax t nth strtoumax const char restrict nptr char restrict endptr int base return strtoull internal nptr endptr base extension extern long long int wcstoll  {
                                               }
internal const gwchar t restrict nptr gwchar t restrict endptr int base int group throw nonnull wur like wcstol but convert to intmax t extern inline intmax t nth wcstoimax const gwchar t restrict nptr gwchar t restrict endptr int base return wcstoll internal nptr endptr base extension extern unsigned long long int wcstoull  {
	                                        diffusiveness :: -1000
                                                    }
internal const gwchar t restrict nptr gwchar t restrict endptr int base int group throw nonnull wur like wcstoul but convert to uintmax t extern inline uintmax t nth wcstoumax const gwchar t restrict nptr gwchar t restrict endptr int base return wcstoull internal nptr endptr base endif wordsize endif use extern inlines end decls endif inttypes h jerror  {
	                                                    terror :: 9
	                                                   terrors :: 8
                                                         }
h copyright c thomas  {
	shoats :: 7
	shamos :: 7
	atoms :: 7
	stomach :: 8
	tharms :: 7
	stomas :: 8
	stomal :: 7
	thema :: 7
	stoma :: 8
	harmost :: 7
	haomas :: 8
	shoat :: 7
	stomachy :: 7
	stomachs :: 7
  }
g lane  {
	lane :: -1000
 }
modified by guido  {
	guiro :: 7
	guild :: 6
	guide :: 7
	guidons :: 8
	guiros :: 6
	guidon :: 9
	guides :: 6
	guider :: 6
 }
vollbeding  {
	vulgarism :: -1000
 }
this file is part of the independent jpeg  {
      }
group s software for conditions of distribution and use see the accompanying  {
	accompanying :: -1000
          }
readme  {
	reamends :: 7
	redamage :: 7
	leader :: 7
	meander :: 8
	herdmen :: 7
	breamed :: 7
	retimed :: 7
	deare :: 7
	defamer :: 8
	resumed :: 7
	defamers :: 7
	seadrome :: 7
	readiest :: 7
	racemed :: 8
	renamed :: 9
	renames :: 7
	degame :: 7
	defame :: 7
	relumed :: 7
	dearie :: 7
	remated :: 8
	deader :: 7
	remades :: 8
	reddleman :: 7
	creamed :: 7
	rename :: 8
	roadmen :: 8
	remate :: 7
	remake :: 7
	remade :: 9
	revamped :: 7
	rediae :: 7
	redate :: 7
	reaved :: 7
	reaped :: 7
	reamed :: 9
	reader :: 7
	headmen :: 8
	headier :: 7
	reedmen :: 7
	reedman :: 9
	meagre :: 7
	radome :: 7
	raceme :: 7
	reasted :: 7
	rearmed :: 9
	reamend :: 8
	readmit :: 7
	beadmen :: 8
	readied :: 7
	readies :: 8
	readier :: 7
	beadier :: 7
	readded :: 7
	reached :: 7
	header :: 7
	reed :: 7
	read :: 7
	dreamed :: 7
	dreamer :: 7
	leadmen :: 8
	leadier :: 7
	yealmed :: 7
	redemand :: 7
	merde :: 7
	meanders :: 7
 }
file this file defines the error and message codes for the jpeg library edit this file to add new codes or to translate the message strings to some other language a set of error reporting macros are defined too some applications using the jpeg library may wish  {
	                                          wish :: -1000
                                             }
to include this file to get the error codes and or the macros to define the enum list of message codes include this file without defining macro jmessage  {
	                   dressage :: 10
                          }
to create a message string table include it again with a suitable jmessage definition see jerror c for an example ifndef jmessage ifndef jerror h first time through define the enum list define jmake  {
                                }
enum list else repeated inclusions  {
	inclusions :: -1000
   }
of this file are no ops unless jmessage is defined define jmessage code string endif jerror h endif jmessage ifdef jmake enum list typedef enum define jmessage code string code endif jmake enum list jmessage jmsg  {
	                          ginormous :: -1000
                                  }
nomessage  {
 }
bogus  {
	bogus :: -1000
 }
message code d must be first entry for maintenance  {
	maintenance :: -1000
       }
convenience list is alphabetical by message code name if jpeg lib version jmessage jerr arith notimpl  {
	        optimal :: 9
              }
sorry  {
	sorry :: -1000
 }
arithmetic coding  {
	coding :: -1000
 }
is not implemented endif jmessage jerr bad align type align type is wrong please fix jmessage jerr bad alloc chunk  {
	              chunk :: -1000
                  }
max alloc chunk is wrong please fix jmessage jerr bad buffer mode bogus buffer control mode jmessage jerr bad component id invalid component id d in sos  {
	                       sos :: -1000
                         }
if jpeg lib version jmessage jerr bad crop  {
	   crop :: -1000
      }
spec invalid crop request endif jmessage jerr bad dct  {
	   dutch :: 3
	   ditch :: 3
	    duct :: 3
	    dict :: 3
	   octad :: 3
	     dot :: 3
	     dit :: 3
       }
coef  {
	unrestrainednesses :: -1000
 }
dct coefficient  {
	coefficient :: -1000
 }
out of range jmessage jerr bad dctsize  {
	outsized :: 9
     }
idct  {
	dicta :: 5
	dict :: 6
 }
output block size d not supported if jpeg lib version jmessage jerr bad drop sampling  {
	      sampling :: -1000
             }
component index d mismatching  {
	mismatching :: -1000
  }
sampling ratio  {
	ratio :: -1000
 }
d d d d c endif jmessage jerr bad huff  {
	     huff :: -1000
        }
table bogus huffman  {
 }
table definition jmessage jerr bad in colorspace bogus input colorspace jmessage jerr bad j colorspace bogus jpeg colorspace jmessage jerr bad length bogus marker length jmessage jerr bad lib version wrong jpeg library version library is d caller expects d jmessage jerr bad mcu  {
	                                       scum :: 4
	                                      scums :: 3
	                                       chum :: 3
	                                      mouch :: 3
	                                        mou :: 3
	                                        meu :: 3
	                                        ecu :: 3
	                                        cum :: 3
                                          }
size sampling factors too large for interleaved  {
	interleaved :: -1000
     }
scan jmessage jerr bad pool id invalid memory pool code d jmessage jerr bad precision unsupported jpeg data precision d jmessage jerr bad progression  {
	            progression :: -1000
                      }
invalid progressive  {
	progressive :: -1000
 }
parameters ss d se d ah d al d jmessage jerr bad prog script invalid progressive parameters at scan script entry d jmessage jerr bad sampling bogus sampling factors jmessage jerr bad scan script invalid scan script at entry d jmessage jerr bad state improper  {
	                                    improper :: -1000
                                           }
call to jpeg library in state d jmessage jerr bad struct size jpeg parameter struct mismatch library thinks  {
	           thinks :: -1000
                }
size is u caller expects u jmessage jerr bad virtual access bogus virtual array access jmessage jerr buffer size buffer passed to jpeg library is too small jmessage jerr cant suspend suspension  {
	                     suspension :: -1000
                              }
not allowed here jmessage jerr ccir  {
	crick :: 5
    }
notimpl ccir sampling not implemented yet jmessage jerr component count too many color components d max d jmessage jerr conversion notimpl unsupported color conversion request jmessage jerr dac  {
	                      laced :: 3
	                      faced :: 3
	                      ducat :: 3
	                      ducal :: 3
	                      dicta :: 3
	                      decal :: 3
	                      decaf :: 3
	                      daric :: 3
	                      darcy :: 3
	                      dance :: 3
	                      dacha :: 3
	                      daces :: 4
	                     dactyl :: 3
	                     dacoit :: 3
	                     dacker :: 3
	                       dace :: 5
	                       caid :: 3
	                       cads :: 3
	                       cade :: 3
	                      raced :: 3
	                      paced :: 3
	                      maced :: 3
	                        vac :: 3
	                        sac :: 3
	                        mac :: 3
	                        lac :: 3
	                        doc :: 3
	                        day :: 3
	                        das :: 3
	                        dap :: 3
	                        dan :: 3
	                        dam :: 3
	                        dal :: 3
	                        dak :: 3
	                        dah :: 3
	                        dag :: 3
	                        dae :: 3
	                        dab :: 3
	                        cad :: 4
	                         da :: 4
	                         ca :: 3
                          }
index bogus dac index d jmessage jerr dac value bogus dac value x x jmessage jerr dht  {
	             did :: -1000
               }
index bogus dht index d jmessage jerr dqt  {
	    eat :: -1000
      }
index bogus dqt index d jmessage jerr empty image  {
	   image :: -1000
       }
empty jpeg image dnl  {
	unlid :: 3
	unled :: 3
	dol :: 3
	del :: 3
	dal :: 3
  }
not supported jmessage jerr ems read read from ems failed jmessage jerr ems write write to ems failed jmessage jerr eoi  {
	               koine :: 3
	               eosin :: 3
	               boite :: 3
	               voile :: 3
	               voice :: 3
	               toise :: 3
	               toile :: 3
	                euoi :: 3
	               poise :: 3
	               noise :: 3
	               moire :: 3
	                 poi :: 3
	                 moi :: 3
	                 koi :: 3
	                 hoi :: 3
	                 eon :: 3
	                  io :: 3
                   }
expected didn t expect more than one scan jmessage jerr file read input file read error jmessage jerr file write output file write error out of disk space jmessage jerr fract  {
	                         fract :: -1000
                             }
sample  {
	sample :: -1000
 }
notimpl fractional  {
	fractional :: -1000
 }
sampling not implemented yet jmessage jerr huff clen  {
	 blench :: 5
	 plench :: 5
	  clone :: 6
	  cline :: 6
	  clean :: 6
	 flench :: 5
	 clones :: 5
	 cloner :: 5
	 cloned :: 5
	 clines :: 5
	 clench :: 5
	 cleans :: 5
	 elench :: 5
	   glen :: 5
	   clon :: 5
	   clew :: 5
	   clem :: 5
	   cleg :: 5
	   clef :: 5
	   clan :: 5
      }
overflow huffman code size table overflow jmessage jerr huff missing code missing huffman code table entry jmessage jerr image too big maximum supported image dimension  {
	               dimension :: -1000
                       }
is u pixels  {
	pixels :: -1000
 }
jmessage jerr input empty empty input file jmessage jerr input eof premature end of input file jmessage jerr mismatched  {
	        mismatched :: -1000
                 }
quant table cannot transcode  {
	transude :: 11
	transpose :: 11
	transcend :: 12
	transduce :: 13
	ancestored :: 11
	transposed :: 12
	wainscoted :: 11
	transected :: 11
	transduces :: 11
	transducer :: 11
	transduced :: 12
	draconites :: 11
	croustade :: 11
	tranced :: 11
	trances :: 11
	ostracode :: 11
  }
due to multiple use of quantization  {
	quantization :: -1000
    }
table d jmessage jerr missing data scan script does not transmit all data jmessage jerr mode change invalid color quantization mode change jmessage jerr notimpl not implemented yet jmessage jerr not compiled requested feature was omitted at compile time if jpeg lib version jmessage jerr no arith table arithmetic table x x was not defined endif jmessage jerr no backing store backing store not supported jmessage jerr no huff table huffman table x x was not defined jmessage jerr no image jpeg datastream  {
	                                                                        headstream :: 12
                                                                                 }
contains no image jmessage jerr no quant table quantization table x x was not defined jmessage jerr no soi  {
	               sny :: -1000
                 }
not a jpeg file starts with x x x x jmessage jerr out of memory insufficient  {
	   insufficient :: -1000
              }
memory case d jmessage jerr quant components cannot quantize  {
	quantize :: -1000
       }
more than d color components jmessage jerr quant few colors cannot quantize to fewer  {
	        fewer :: -1000
            }
than d colors jmessage jerr quant many colors cannot quantize to more than d colors jmessage jerr sof duplicate invalid jpeg file structure two sof markers  {
	                  markers :: -1000
                        }
jmessage jerr sof no sos invalid jpeg file structure missing sos marker jmessage jerr sof unsupported unsupported jpeg process sof type x x jmessage jerr soi duplicate invalid jpeg file structure two soi markers jmessage jerr sos no sof invalid jpeg file structure sos before sof jmessage jerr tfile  {
	                                           flite :: 7
	                                          trifle :: 6
	                                          flited :: 6
	                                          toiles :: 6
	                                          toiler :: 6
	                                          toiled :: 6
	                                          fillet :: 6
	                                           utile :: 6
	                                           toile :: 7
	                                           teils :: 6
	                                           stile :: 6
	                                            teil :: 7
	                                          tailer :: 6
	                                          tailed :: 6
                                               }
create failed to create temporary file s jmessage jerr tfile read read failed on temporary file jmessage jerr tfile seek seek failed on temporary file jmessage jerr tfile write write failed on temporary file out of disk space jmessage jerr too little data application transferred  {
	                                 transferred :: -1000
                                           }
too few scanlines  {
	synclines :: 13
	salicines :: 12
	scantiness :: 12
	solanines :: 12
	scallions :: 11
	chanciness :: 11
	stannites :: 11
	scannings :: 11
	scansion :: 11
	yeanlings :: 11
	weanlings :: 11
	scalpins :: 11
	scaldings :: 11
	scentings :: 11
	slangings :: 11
	slanginess :: 11
	scarpines :: 12
	snarlings :: 11
	annalises :: 11
	canalises :: 11
	chatlines :: 11
	mainlines :: 11
	crankiness :: 11
	snowlines :: 11
	smaltines :: 11
 }
jmessage jerr unknown marker unsupported marker type x x jmessage jerr virtual bug virtual array controller  {
	     controller :: -1000
              }
messed  {
	messed :: -1000
 }
up jmessage jerr width  {
	width :: -1000
  }
overflow image too wide for this implementation jmessage jerr xms  {
	      xis :: 3
	      ums :: 3
	      oms :: 3
	      ems :: 3
	       sm :: 3
        }
read read from xms failed jmessage jerr xms write write to xms failed jmessage jmsg copyright jcopyright  {
               }
jmessage jmsg version jversion  {
	revision :: 10
	oversoon :: 10
	overspin :: 11
	aversion :: 13
	eversion :: 13
	emersion :: 10
	overswing :: 10
	aversions :: 11
	eversions :: 11
  }
jmessage jtrc  {
	keas :: -1000
 }
bit tables caution  {
	caution :: -1000
 }
quantization tables are too coarse  {
	coarse :: -1000
   }
for baseline  {
	baseline :: -1000
 }
jpeg jmessage jtrc adobe  {
	adobe :: -1000
  }
adobe app marker version d flags x x x x transform  {
	 transform :: -1000
         }
d jmessage jtrc app unknown app marker not jfif  {
	apathetically :: -1000
       }
length u jmessage jtrc app unknown app marker not adobe length u jmessage jtrc dac define arithmetic table x x x x jmessage jtrc dht define huffman table x x jmessage jtrc dqt define quantization table d precision d jmessage jtrc dri  {
	                                   drives :: 3
	                                   driven :: 3
	                                   drivel :: 3
	                                   drippy :: 3
	                                   drinks :: 3
	                                   drills :: 3
	                                   drifty :: 3
	                                   drifts :: 3
	                                   driest :: 3
	                                   driegh :: 3
	                                    irids :: 3
	                                    grind :: 3
	                                    grids :: 3
	                                    gride :: 3
	                                    fried :: 3
	                                    droit :: 3
	                                    drive :: 4
	                                    dript :: 4
	                                    drips :: 4
	                                    drink :: 4
	                                    drily :: 4
	                                    drill :: 4
	                                    drift :: 4
	                                    drier :: 3
	                                    dried :: 3
	                                    dribs :: 4
	                                    drain :: 3
	                                    drail :: 3
	                                    cried :: 3
	                                    dairy :: 3
	                                    bride :: 3
	                                    yrivd :: 3
	                                    wried :: 3
	                                    tried :: 3
	                                    triad :: 3
	                                     raid :: 3
	                                     irid :: 4
	                                     grid :: 4
	                                     drip :: 5
	                                     drib :: 5
	                                     dirt :: 3
	                                     dirl :: 3
	                                     dirk :: 3
	                                     dire :: 3
	                                     dari :: 3
	                                     arid :: 4
	                                    pried :: 3
	                                    pride :: 3
	                                      rid :: 3
	                                      dui :: 3
	                                       dr :: 4
	                                       di :: 3
                                        }
define restart interval  {
	interval :: -1000
 }
u jmessage jtrc ems close freed ems handle u jmessage jtrc ems open obtained  {
	     obtained :: -1000
            }
ems handle u jmessage jtrc eoi end of image jmessage jtrc huffbits  {
	   huffiest :: 10
          }
d d d d d d d d jmessage jtrc jfif jfif app marker version d d density  {
	          density :: -1000
                }
dx  {
	eh :: -1000
 }
d d jmessage jtrc jfif badthumbnailsize  {
    }
warning thumbnail  {
	thumbnail :: -1000
 }
image size does not match data length u jmessage jtrc jfif extension jfif extension marker type x x length u jmessage jtrc jfif thumbnail with d x d thumbnail image jmessage jtrc misc marker miscellaneous marker x x length u jmessage jtrc parmless  {
	                                  normless :: 10
	                                  formless :: 10
	                                  gormless :: 10
	                                  pastless :: 10
	                                  tramless :: 11
	                                  passless :: 10
	                                  firmless :: 10
	                                harmlessly :: 10
	                                 parcloses :: 10
	                                   parsley :: 10
	                                   paroles :: 10
	                                   samples :: 10
	                                   sampler :: 10
	                                  painless :: 10
	                                  gaumless :: 10
	                                   palmers :: 10
	                                  partlets :: 10
	                                  wartless :: 10
	                                  pangless :: 10
	                                  parsleys :: 12
	                                  warmness :: 10
	                                  harmless :: 13
	                                  samplers :: 12
	                                  barkless :: 10
	                                 parulises :: 10
	                                  portless :: 10
	                                  wareless :: 10
	                                  careless :: 10
	                                  termless :: 10
	                                  rumpless :: 10
	                                  garbless :: 10
	                                  barbless :: 10
	                                  pathless :: 10
                                         }
marker unexpected marker x x jmessage jtrc quantvals  {
	  greed :: -1000
      }
u u u u u u u u jmessage jtrc quant ncolors  {
          }
quantizing  {
	quantizing :: -1000
 }
to d d d d colors jmessage jtrc quant ncolors quantizing to d colors jmessage jtrc quant selected selected d colors for quantization jmessage jtrc recovery action at marker x x recovery action d jmessage jtrc rst rst d jmessage jtrc smooth  {
	                                   smooth :: -1000
                                        }
notimpl smoothing  {
	smoothing :: -1000
 }
not supported with nonstandard  {
	nonstandard :: -1000
  }
sampling ratios  {
	ratios :: -1000
 }
jmessage jtrc sof start of frame x x width u height  {
	    height :: -1000
         }
u components d jmessage jtrc sof component component d dhx  {
	  fulfill :: -1000
        }
dv  {
	ef :: -1000
 }
q d jmessage jtrc soi start of image jmessage jtrc sos start of scan d components jmessage jtrc sos component component d dc d ac d jmessage jtrc sos params  {
	                       praams :: 10
	                    paramours :: 7
	                    paraments :: 8
	                    parameses :: 8
	                       sarape :: 7
	                    paradigms :: 7
	                      parasol :: 7
	                      paranym :: 7
	                      parangs :: 7
	                      paramos :: 10
	                      parages :: 7
	                      parados :: 7
	                      parades :: 7
	                      paracme :: 7
	                       parkas :: 8
	                       paramo :: 9
	                       damars :: 7
	                       stramp :: 7
	                       marahs :: 8
	                       maraes :: 8
	                       malars :: 7
	                       makars :: 7
	                      karaism :: 7
	                   paramounts :: 7
	                         para :: 8
	                         mara :: 7
	                        praam :: 8
	                        paras :: 9
	                   paramedics :: 7
	                     paranyms :: 8
	                     parament :: 7
	                     paramese :: 9
	                     paracmes :: 8
	                        maras :: 8
                            }
ss d se d ah d al d jmessage jtrc tfile close closed temporary file s jmessage jtrc tfile open opened temporary file s jmessage jtrc thumb jpeg jfif extension marker jpeg compressed  {
	                      compressed :: -1000
                               }
thumbnail image length u jmessage jtrc thumb palette  {
	palette :: -1000
      }
jfif extension marker palette thumbnail image length u jmessage jtrc thumb rgb jfif extension marker rgb thumbnail image length u jmessage jtrc unknown ids unrecognized component ids d d d assuming  {
	                      assuming :: -1000
                             }
ycbcr  {
 }
jmessage jtrc xms close freed xms handle u jmessage jtrc xms open obtained xms handle u jmessage jwrn  {
	          whiffle :: -1000
                }
adobe xform  {
 }
unknown adobe color transform code d if jpeg lib version jmessage jwrn arith bad code corrupt jpeg data bad arithmetic code endif jmessage jwrn bogus progression inconsistent  {
	              inconsistent :: -1000
                         }
progression sequence for component d coefficient d jmessage jwrn extraneous  {
	extraneous :: -1000
        }
data corrupt jpeg data u extraneous bytes before marker x x jmessage jwrn hit marker corrupt jpeg data premature end of data segment jmessage jwrn huff bad code corrupt jpeg data bad huffman code jmessage jwrn jfif major warning unknown jfif revision number d d jmessage jwrn jpeg eof premature end of jpeg file jmessage jwrn must resync  {
	                                                   resiny :: 8
	                                                     reny :: 7
	                                                    resin :: 7
                                                        }
corrupt jpeg data found marker x x instead of rst d jmessage jwrn not sequential invalid sos parameters for sequential jpeg jmessage jwrn too much data application transferred too many scanlines if jpeg lib version jmessage jerr bad crop spec invalid crop request if defined c arith coding supported defined d arith coding supported jmessage jerr no arith table arithmetic table x x was not defined jmessage jwrn arith bad code corrupt jpeg data bad arithmetic code endif endif ifdef jmake enum list jmsg lastmsgcode  {
                                                                                   }
j message code undef jmake enum list endif jmake enum list zap  {
	        zap :: -1000
          }
jmessage macro so that future re inclusions do nothing by default undef jmessage ifndef jerror h define jerror h macros to simplify using the error and trace  {
	                     trace :: -1000
                         }
message stuff the first parameter is either type of cinfo  {
	    confr :: 6
	  confirm :: 6
	  confits :: 6
	  confide :: 6
	   confix :: 7
	   confit :: 7
	   coffin :: 6
	    zinco :: 6
	   cineol :: 6
	     fino :: 6
	     coni :: 6
	     coif :: 6
	     cion :: 6
        }
pointer fatal errors print message and exit define errexit  {
       }
cinfo code cinfo err msg code code cinfo err error exit j common ptr cinfo define errexit cinfo code p cinfo err msg code code cinfo err msg parm i p cinfo err error exit j common ptr cinfo define errexit cinfo code p p cinfo err msg code code cinfo err msg parm i p cinfo err msg parm i p cinfo err error exit j common ptr cinfo define errexit cinfo code p p p cinfo err msg code code cinfo err msg parm i p cinfo err msg parm i p cinfo err msg parm i p cinfo err error exit j common ptr cinfo define errexit cinfo code p p p p cinfo err msg code code cinfo err msg parm i p cinfo err msg parm i p cinfo err msg parm i p cinfo err msg parm i p cinfo err error exit j common ptr cinfo define errexits  {
	                                                                                                                                                 exteriors :: 10
                                                                                                                                                         }
cinfo code str cinfo err msg code code strncpy  {
       }
cinfo err msg parm s str jmsg str parm max cinfo err error exit j common ptr cinfo define makestmt  {
                  }
stuff do stuff while nonfatal  {
	nonfatal :: -1000
   }
errors we can keep going  {
	going :: -1000
   }
but the data is probably corrupt define warnms  {
	 wrangs :: 7
	warmish :: 7
	warmest :: 7
	 warmen :: 7
	warmness :: 7
	warmings :: 7
	  warns :: 9
	  warms :: 8
	   wars :: 7
	   warn :: 8
	   warm :: 7
	  rawns :: 7
      }
cinfo code cinfo err msg code code cinfo err emit message j common ptr cinfo define warnms cinfo code p cinfo err msg code code cinfo err msg parm i p cinfo err emit message j common ptr cinfo define warnms cinfo code p p cinfo err msg code code cinfo err msg parm i p cinfo err msg parm i p cinfo err emit message j common ptr cinfo informational  {
	                                                         informational :: -1000
                                                                     }
debugging messages define tracems  {
	trackmen :: 9
	teamers :: 9
	traces :: 11
	traced :: 9
	crates :: 9
	mercats :: 9
	trace :: 10
	trances :: 9
	tramels :: 10
	tracers :: 10
  }
cinfo lvl  {
 }
code cinfo err msg code code cinfo err emit message j common ptr cinfo lvl define tracems cinfo lvl code p cinfo err msg code code cinfo err msg parm i p cinfo err emit message j common ptr cinfo lvl define tracems cinfo lvl code p p cinfo err msg code code cinfo err msg parm i p cinfo err msg parm i p cinfo err emit message j common ptr cinfo lvl define tracems cinfo lvl code p p p makestmt int mp cinfo err msg parm i mp p mp p mp p cinfo err msg code code cinfo err emit message j common ptr cinfo lvl define tracems cinfo lvl code p p p p makestmt int mp cinfo err msg parm i mp p mp p mp p mp p cinfo err msg code code cinfo err emit message j common ptr cinfo lvl define tracems cinfo lvl code p p p p p makestmt int mp cinfo err msg parm i mp p mp p mp p mp p mp p cinfo err msg code code cinfo err emit message j common ptr cinfo lvl define tracems cinfo lvl code p p p p p p p p makestmt int mp cinfo err msg parm i mp p mp p mp p mp p mp p mp p mp p mp p cinfo err msg code code cinfo err emit message j common ptr cinfo lvl define tracemss  {
	                                                                                                                                                                                                                                           tramless :: 11
	                                                                                                                                                                                                                                             traces :: 11
	                                                                                                                                                                                                                                              trace :: 10
                                                                                                                                                                                                                                                  }
cinfo lvl code str cinfo err msg code code strncpy cinfo err msg parm s str jmsg str parm max cinfo err emit message j common ptr cinfo lvl endif jerror h jmorecfg  {
                               }
h copyright c thomas g lane copyright c d r commander  {
	 commander :: -1000
         }
this file is part of the independent jpeg group s software for conditions of distribution and use see the accompanying readme file this file contains additional configuration options that customize the jpeg software for special applications or support machine dependent optimizations most users will not need to touch  {
	                                          touch :: -1000
                                              }
this file define bits in jsample  {
	tramples :: 9
	whamples :: 9
	examples :: 9
    }
as either for bit sample values the usual setting for bit sample values only and are legal data precisions  {
	        precisions :: -1000
                 }
for lossy  {
	lossy :: -1000
 }
jpeg according to the jpeg standard and the ijg  {
	    jigs :: 3
	     jig :: 4
       }
code does not support anything else we do not support run time selection of data precision sorry define bits in jsample use or maximum number of components color channels allowed in jpeg image to meet  {
	                              meet :: -1000
                                 }
the letter of the jpeg spec set this to however darn  {
	      darn :: -1000
         }
few applications need more than channels maybe for cmyk alpha mask we recommend as a reasonable compromise  {
	      compromise :: -1000
               }
use if you are really short on memory each allowed component costs  {
	      costs :: -1000
          }
a hundred  {
	hundred :: -1000
 }
or so bytes of storage whether actually used in an image or not define max components maximum number of image components basic data types you may need to change these if you have a machine with unusual data type sizes for example char not bits short not bits or long not bits we don t care  {
	                                                   care :: -1000
                                                      }
whether int is or bits but it had better be at least representation of a single sample pixel element value we frequently allocate large arrays of these so it s important to keep them small but if you have memory to burn  {
	                                     burn :: -1000
                                        }
and access to char or short arrays is very slow  {
	     slow :: -1000
        }
on your hardware you might want to change these if bits in jsample jsample should be the smallest  {
	      summarizers :: -1000
                }
type that will hold the values you can use a signed char by having getjsample  {
             }
mask it with xff ifdef have unsigned char typedef unsigned char jsample define getjsample value int value else not have unsigned char typedef char jsample ifdef char unsigned define getjsample value int value else define getjsample value int value xff endif char unsigned endif have unsigned char define maxjsample  {
                                               }
define centerjsample  {
 }
endif bits in jsample if bits in jsample jsample should be the smallest type that will hold the values on nearly  {
	              nearly :: -1000
                   }
all machines short will do nicely  {
	nicely :: -1000
    }
typedef short jsample define getjsample value int value define maxjsample define centerjsample endif bits in jsample representation of a dct frequency coefficient this should be a signed value of at least bits short is usually ok again we allocate large arrays of these but you can change to int if you have memory to burn and short is really slow typedef short jcoef  {
                                                             }
compressed datastreams  {
	headstreams :: 14
 }
are represented as arrays of joctet  {
	jockette :: 7
	jotter :: 7
	jotted :: 7
    }
these must be exactly bits wide at least once they are written to external storage note that when using the stdio data source destination managers  {
	                managers :: -1000
                       }
this is also the data type passed to fread  {
	  dreads :: 6
	   fried :: 6
	   frena :: 6
	   freed :: 6
	   freak :: 7
	   fraud :: 6
	   fared :: 7
	   farad :: 6
	   dream :: 6
	   dread :: 7
	  freaky :: 6
	  freaks :: 6
	  frayed :: 6
	  framed :: 6
	   bread :: 7
	   aread :: 7
	  areads :: 6
	  treads :: 6
	 freaked :: 6
	  oreads :: 6
	  afeard :: 6
	dreadful :: 6
	   tread :: 7
	    frae :: 6
	  bready :: 6
	  breads :: 6
	   oread :: 7
       }
fwrite  {
	fruited :: 7
	fruiter :: 7
	freit :: 8
	freity :: 7
	freits :: 7
	swifter :: 8
	swifters :: 7
	ferity :: 8
	strife :: 7
	refit :: 7
	awaiter :: 7
 }
ifdef have unsigned char typedef unsigned char joctet define getjoctet  {
        }
value value else not have unsigned char typedef char joctet ifdef char unsigned define getjoctet value value else define getjoctet value value xff endif char unsigned endif have unsigned char these typedefs are used for various table entries and so forth  {
	                                   forth :: -1000
                                       }
they must be at least as wide as specified but making them too big won t cost a huge amount of memory so we don t provide special extraction  {
	                  extraction :: -1000
                           }
code like we did for jsample in other words these typedefs live  {
	       live :: -1000
          }
at a different point on the speed  {
	 speed :: -1000
     }
space tradeoff  {
	tradeoff :: -1000
 }
curve uint must hold at least the values ifdef have unsigned char typedef unsigned char uint else not have unsigned char ifdef char unsigned typedef char uint else not char unsigned typedef short uint endif char unsigned endif have unsigned char uint must hold at least the values ifdef have unsigned short typedef unsigned short uint else not have unsigned short typedef unsigned int uint endif have unsigned short int must hold at least the values ifndef xmd  {
                                                                            }
h x xmd h correctly  {
	surquedry :: -1000
   }
defines int typedef short int endif int must hold at least signed bit values ifndef xmd h x xmd h correctly defines int typedef long int endif datatype used for image dimensions  {
	                     dimensions :: -1000
                              }
the jpeg standard only supports images  {
	images :: -1000
    }
up to k k due to bit fields in sof markers therefore unsigned int is sufficient  {
	     sufficient :: -1000
              }
on all machines however if you need to handle larger  {
	   larger :: -1000
        }
images and you don t mind  {
	 mind :: -1000
    }
deviating  {
	deviating :: -1000
 }
from the spec you can change this datatype typedef unsigned int jdimension  {
	 distension :: 12
	 dissension :: 12
          }
define jpeg max dimension l a tad  {
	   tad :: -1000
     }
under k to prevent overflows  {
	overflows :: -1000
   }
these macros are used in all function definitions and extern declarations you could modify them if you need to change function linkage  {
	              linkage :: -1000
                    }
conventions  {
	conventions :: -1000
 }
in particular you ll need to do that to make the library a windows dll another application is to make all functions global for use with debuggers  {
	                 debuggers :: -1000
                         }
or code profilers  {
	profilers :: -1000
 }
that require it a function called through method pointers define methoddef  {
	methodized :: 12
	methodised :: 12
         }
type static type a function used only in its module define local type static type a function referenced thru externs  {
	            externs :: -1000
                  }
define global type type a reference to a global function define extern type extern type this macro is used to declare a method that is a function pointer we want to supply prototype parameters if the compiler can cope  {
	                                  cope :: -1000
                                     }
note that the arglist parameter must be parenthesized  {
	parenthesized :: -1000
      }
again you can customize this if you need special linkage keywords  {
	  keywords :: -1000
         }
ifdef have prototypes define jmethod  {
   }
type methodname  {
	methadone :: 13
	methadones :: 12
 }
arglist type methodname arglist else define jmethod type methodname arglist type methodname endif here is the pseudo  {
	          pseudo :: -1000
               }
keyword for declaring  {
	declaring :: -1000
 }
pointers that must be far on x machines most of the specialized coding for x is handled by just saying  {
	             saying :: -1000
                  }
far where such a pointer is needed in a few places explicit coding is needed see uses of the need far pointers symbol ifdef need far pointers define far far else define far endif on a few systems type boolean and or its values false true may appear in standard header files or you may have conflicts with application specific header files that you want to include together with these files defining have boolean before including jpeglib  {
                                                                           }
h should make it work ifndef have boolean typedef int boolean endif ifndef false in case these macros already exist define false values of boolean endif ifndef true define true endif the remaining options affect code selection within the jpeg library but they don t need to be visible  {
	                                         visible :: -1000
                                               }
to most applications using the library to minimize application namespace pollution the symbols won t be defined unless jpeg internals or jpeg internal options has been defined ifdef jpeg internals define jpeg internal options endif ifdef jpeg internal options these defines indicate whether to include various optional functions undefining  {
	                                      hexachords :: -1000
                                               }
some of these symbols will produce a smaller  {
	smaller :: -1000
      }
but less capable  {
	capable :: -1000
 }
library note that you can leave certain source files out of the compilation linking process if you ve undef d the corresponding symbols you may have to do that if your compiler doesn t like null source files capability  {
	                            capability :: -1000
                                     }
options common to encoder  {
	encoder :: -1000
  }
and decoder  {
	decoder :: -1000
 }
define dct islow supported slow but accurate  {
	accurate :: -1000
     }
integer algorithm define dct ifast  {
	fiats :: 6
	feast :: 6
	fiesta :: 6
	afrits :: 6
	itas :: 7
   }
supported faster  {
	faster :: -1000
 }
less accurate integer method define dct float supported floating point accurate fast on fast hw encoder capability options define c multiscan  {
	             cultism :: 12
	          culminates :: 11
	            multicar :: 11
	            sultanic :: 11
	         multiagency :: 11
	          multichain :: 11
	           suctional :: 11
	         multiscreen :: 12
                   }
files supported multiple scan jpeg files define c progressive supported progressive jpeg requires multiscan define entropy  {
	        entropy :: -1000
              }
opt supported optimization of entropy coding parms note if you selected bit data precision it is dangerous  {
	       dangerous :: -1000
               }
to turn off entropy opt supported the standard huffman tables are only good for bit precision so jchuff  {
                }
c normally uses entropy optimization to compute usable  {
	 usable :: -1000
      }
tables for higher precision if you don t want to do optimization you ll have to supply different default huffman tables the exact same statements  {
	              statements :: -1000
                       }
apply for progressive jpeg the default tables don t work for progressive mode this may get fixed however define input smoothing supported input image smoothing option decoder capability options define d multiscan files supported multiple scan jpeg files define d progressive supported progressive jpeg requires multiscan define save markers supported jpeg save markers needed define block smoothing supported block smoothing progressive only define idct scaling  {
	                                                         scaling :: -1000
                                                               }
supported output rescaling  {
	rescaling :: -1000
 }
via idct undef upsample  {
	ensample :: 10
	upleaps :: 10
	resample :: 10
  }
scaling supported output rescaling at upsample stage  {
	  veal :: -1000
     }
define upsample merging supported fast path for sloppy  {
	 sloppy :: -1000
      }
upsampling  {
	derisivenesses :: -1000
 }
define quant pass supported pass color quantization define quant pass supported pass color quantization more capability options later no doubt  {
	        polemicizes :: -1000
                  }
ordering of rgb data in scanlines passed to or from the application if your application wants to deal with data in the order b g r just change these macros you can also deal with formats such as r g b x one extra byte per pixel by changing  {
	                                        changing :: -1000
                                               }
rgb pixelsize  {
	cyprus :: -1000
 }
note that changing the offsets will also change the order in which colormap  {
	       color :: 10
	    colorman :: 13
	    colormen :: 10
           }
data is organized  {
	organized :: -1000
 }
restrictions the sample applications cjpeg  {
   }
djpeg  {
 }
do not support modified rgb formats these macros only affect rgb ycbcr color conversion so they are not useful if you are using jpeg color spaces other than ycbcr or grayscale  {
	                    graywackes :: 11
                             }
the color quantizer  {
	quantizer :: -1000
 }
modules will not behave desirably  {
	desirably :: -1000
   }
if rgb pixelsize is not they don t understand about dummy color components so you can t use color quantization if you change that value define rgb red offset of red in an rgb scanline element define rgb green  {
	                                 green :: -1000
                                     }
offset of green define rgb blue  {
	 blue :: -1000
    }
offset of blue define rgb pixelsize jsamples  {
	tramples :: 10
	stampless :: 10
	esemplasy :: 10
	whamples :: 10
	examples :: 10
     }
per rgb scanline element define jpeg numcs  {
	cumins :: 6
	 numbs :: 7
     }
define ext rgb red define ext rgb green define ext rgb blue define ext rgb pixelsize define ext rgbx  {
	           arghans :: -1000
                 }
red define ext rgbx green define ext rgbx blue define ext rgbx pixelsize define ext bgr  {
	          burgs :: 3
	          burgh :: 3
	          bergs :: 3
	          barge :: 3
	           garb :: 3
	           burg :: 4
	           brog :: 3
	           brig :: 3
	           brag :: 3
	           berg :: 4
	            bur :: 3
	            brr :: 3
	            bor :: 3
	            bar :: 3
	             br :: 3
              }
red define ext bgr green define ext bgr blue define ext bgr pixelsize define ext bgrx  {
              }
red define ext bgrx green define ext bgrx blue define ext bgrx pixelsize define ext xbgr  {
              }
red define ext xbgr green define ext xbgr blue define ext xbgr pixelsize define ext xrgb  {
              }
red define ext xrgb green define ext xrgb blue define ext xrgb pixelsize static const int rgb red jpeg numcs rgb red ext rgb red ext rgbx red ext bgr red ext bgrx red ext xbgr red ext xrgb red ext rgbx red ext bgrx red ext xbgr red ext xrgb red static const int rgb green jpeg numcs rgb green ext rgb green ext rgbx green ext bgr green ext bgrx green ext xbgr green ext xrgb green ext rgbx green ext bgrx green ext xbgr green ext xrgb green static const int rgb blue jpeg numcs rgb blue ext rgb blue ext rgbx blue ext bgr blue ext bgrx blue ext xbgr blue ext xrgb blue ext rgbx blue ext bgrx blue ext xbgr blue ext xrgb blue static const int rgb pixelsize jpeg numcs rgb pixelsize ext rgb pixelsize ext rgbx pixelsize ext bgr pixelsize ext bgrx pixelsize ext xbgr pixelsize ext xrgb pixelsize ext rgbx pixelsize ext bgrx pixelsize ext xbgr pixelsize ext xrgb pixelsize definitions for speed related optimizations on some machines notably  {
	                                                                                                                                                                          notably :: -1000
                                                                                                                                                                                }
series int is bits but multiplying  {
	multiplying :: -1000
    }
two bit shorts  {
	shorts :: -1000
 }
is faster than multiplying two ints  {
	intuse :: 5
	intros :: 5
	inters :: 5
	inust :: 6
	intis :: 5
	inset :: 5
	antis :: 5
	 tins :: 5
	 snit :: 5
	 nits :: 6
	 into :: 5
	 inte :: 5
	 ants :: 5
	  ins :: 5
    }
define multiplier  {
	multiplier :: -1000
 }
as short on such a machine multiplier must be at least bits wide ifndef multiplier ifndef with simd  {
	             silt :: -1000
                }
define multiplier int type for fastest  {
	fastest :: -1000
    }
integer multiply else define multiplier short prefer bit with simd for parellelism  {
	parallelisms :: 16
	parallelism :: 18
          }
endif endif fast float should be either float or double whichever  {
	 whichever :: -1000
         }
is done faster by your compiler note that this type is only used in the floating point dct routines so it only matters  {
	               matters :: -1000
                     }
if you ve defined dct float supported typically float is faster in ansi c compilers while double is faster in pre ansi compilers because they insist  {
	                   insist :: -1000
                        }
on converting to double anyway  {
	anyway :: -1000
   }
the code below therefore chooses  {
	chooses :: -1000
   }
float if we have ansi style prototypes ifndef fast float ifdef have prototypes define fast float float else define fast float double endif endif endif jpeg internal options jpegint  {
	                     jeeping :: 9
                           }
h copyright c thomas g lane modified by guido vollbeding this file is part of the independent jpeg group s software for conditions of distribution and use see the accompanying readme file this file provides common declarations for the various jpeg modules these declarations are considered internal to the jpeg library most applications using the library shouldn t need to include this file declarations for both compression  {
	                                                       compression :: -1000
                                                                 }
decompression  {
	decompression :: -1000
 }
typedef enum operating modes for buffer controllers  {
	controllers :: -1000
     }
jbuf  {
 }
pass thru plain stripwise  {
	stairwise :: 14
	stripes :: 11
	spirewise :: 12
	stripiest :: 12
  }
operation remaining modes require a full image buffer to have been created jbuf save source run source subobject  {
                }
only save output jbuf crank  {
	crank :: -1000
   }
dest run dest subobject only using saved data jbuf save and pass run both subobjects  {
             }
save output j buf mode values of global state field jdapi  {
         }
c has some dependencies on ordering define cstate  {
	astuter :: 7
	rotates :: 7
	astatic :: 7
	 sclate :: 7
	catties :: 8
	 sceatt :: 7
	carates :: 7
	 astute :: 8
	 cytase :: 7
	nutates :: 7
	estated :: 8
	estates :: 7
	creates :: 7
	 cottae :: 7
	cerates :: 7
	 estate :: 9
	cytaster :: 7
	 cleats :: 7
	chattels :: 7
	chatters :: 7
	stactes :: 7
	  sceat :: 7
	scatter :: 7
	clatters :: 7
      }
start after create compress define cstate scanning start compress done write scanlines ok define cstate raw ok start compress done write raw data ok define cstate wrcoefs  {
                         }
jpeg write coefficients  {
	coefficients :: -1000
 }
done define dstate  {
	dogates :: 7
	astuter :: 7
	rotated :: 7
	rotates :: 7
	delates :: 7
	slatted :: 7
	sedate :: 7
	toasted :: 7
	astute :: 8
	nutated :: 7
	nutates :: 7
	estated :: 10
	estates :: 7
	debates :: 7
	derats :: 7
	dilates :: 7
	defats :: 7
	spatted :: 7
	swatted :: 7
	estate :: 9
	sudate :: 7
	started :: 7
	notated :: 7
	donates :: 7
	derates :: 7
	mutated :: 7
 }
start after create decompress define dstate inheader  {
	threaden :: 10
	inhere :: 10
	inhearse :: 11
	inholder :: 10
	interdeal :: 10
	inhered :: 11
     }
reading header markers no sos yet define dstate ready  {
	   ready :: -1000
       }
found sos ready for start decompress define dstate preload  {
	 paroled :: 9
	 presold :: 10
	 premold :: 10
	 predial :: 9
	poularde :: 9
       }
reading multiscan file in start decompress define dstate prescan  {
	  prance :: 9
	prescind :: 10
	pursuance :: 9
	pristane :: 9
	 preacts :: 9
	 prances :: 10
	   presa :: 9
       }
performing dummy pass for pass quant define dstate scanning start decompress done read scanlines ok define dstate raw ok start decompress done read raw data ok define dstate bufimage  {
	                    fumigate :: 10
                           }
expecting  {
	leafy :: -1000
 }
jpeg start output define dstate bufpost  {
    }
looking for sos eoi in jpeg finish output define dstate rdcoefs  {
	   recodes :: 9
         }
reading file in jpeg read coefficients define dstate stopping looking for eoi in jpeg finish decompress declarations for compression modules master  {
	              master :: -1000
                   }
control module struct jpeg comp master jmethod void prepare for pass j compress ptr cinfo jmethod void pass startup j compress ptr cinfo jmethod void finish pass j compress ptr cinfo state variables made visible to other modules boolean call pass startup true if pass startup must be called boolean is last pass true during last pass main buffer control downsampled  {
                                                           }
data buffer struct jpeg c main controller jmethod void start pass j compress ptr cinfo j buf mode pass mode jmethod void process data j compress ptr cinfo jsamparray  {
                           }
input buf jdimension in row  {
	 row :: -1000
   }
ctr jdimension in rows  {
	rows :: -1000
  }
avail compression preprocessing  {
	preprocessing :: -1000
 }
downsampling  {
 }
input buffer control struct jpeg c prep controller jmethod void start pass j compress ptr cinfo j buf mode pass mode jmethod void pre process data j compress ptr cinfo jsamparray input buf jdimension in row ctr jdimension in rows avail jsampimage  {
                                        }
output buf jdimension out row group ctr jdimension out row groups avail coefficient buffer control struct jpeg c coef controller jmethod void start pass j compress ptr cinfo j buf mode pass mode jmethod boolean compress data j compress ptr cinfo jsampimage input buf colorspace conversion struct jpeg color converter  {
	                                        converter :: -1000
                                                }
jmethod void start pass j compress ptr cinfo jmethod void color convert j compress ptr cinfo jsamparray input buf jsampimage output buf jdimension output row int num rows downsampling struct jpeg downsampler  {
                              }
jmethod void start pass j compress ptr cinfo jmethod void downsample j compress ptr cinfo jsampimage input buf jdimension in row index jsampimage output buf jdimension out row group index boolean need context rows true if need rows above below forward dct also controls coefficient quantization struct jpeg forward dct jmethod void start pass j compress ptr cinfo perhaps this should be an array jmethod void forward dct j compress ptr cinfo jpeg component info compptr  {
	                                                                    compter :: 9
                                                                          }
jsamparray sample data jblockrow  {
  }
coef blocks jdimension start row jdimension start col jdimension num blocks entropy encoding struct jpeg entropy encoder jmethod void start pass j compress ptr cinfo boolean gather  {
	                    gather :: -1000
                         }
statistics  {
	statistics :: -1000
 }
jmethod boolean encode mcu j compress ptr cinfo jblockrow mcu data jmethod void finish pass j compress ptr cinfo marker writing struct jpeg marker writer  {
	                  writer :: -1000
                       }
jmethod void write file header j compress ptr cinfo jmethod void write frame header j compress ptr cinfo jmethod void write scan header j compress ptr cinfo jmethod void write file trailer j compress ptr cinfo jmethod void write tables only j compress ptr cinfo these routines are exported to allow insertion  {
	                                          insertion :: -1000
                                                  }
of extra markers probably only com and appn  {
      }
markers should be written this way jmethod void write marker header j compress ptr cinfo int marker unsigned int datalen jmethod void write marker byte j compress ptr cinfo int val declarations for decompression modules master control module struct jpeg decomp master jmethod void prepare for output pass j decompress ptr cinfo jmethod void finish output pass j decompress ptr cinfo state variables made visible to other modules boolean is dummy pass true during st pass for pass quant input control module struct jpeg input controller jmethod int consume input j decompress ptr cinfo jmethod void reset input controller j decompress ptr cinfo jmethod void start input pass j decompress ptr cinfo jmethod void finish input pass j decompress ptr cinfo state variables made visible to other modules boolean has multiple scans  {
	                                                                                                                              scans :: -1000
                                                                                                                                  }
true if file has multiple scans boolean eoi reached true when eoi has been consumed main buffer control downsampled data buffer struct jpeg d main controller jmethod void start pass j decompress ptr cinfo j buf mode pass mode jmethod void process data j decompress ptr cinfo jsamparray output buf jdimension out row ctr jdimension out rows avail coefficient buffer control struct jpeg d coef controller jmethod void start input pass j decompress ptr cinfo jmethod int consume data j decompress ptr cinfo jmethod void start output pass j decompress ptr cinfo jmethod int decompress data j decompress ptr cinfo jsampimage output buf pointer to array of coefficient virtual arrays or null if none jvirt  {
                                                                                                                 }
barray  {
	yarrans :: 7
	garrya :: 7
	bajra :: 7
	barrat :: 9
	barratry :: 7
	barranco :: 7
	barrages :: 7
	barraged :: 7
	warray :: 9
	barnyard :: 7
	yarran :: 8
	barware :: 7
	barrack :: 8
	carbaryl :: 7
 }
ptr coef arrays decompression postprocessing  {
	overprocessing :: 18
	teleprocessing :: 18
	postdepression :: 18
   }
color quantization buffer control struct jpeg d post controller jmethod void start pass j decompress ptr cinfo j buf mode pass mode jmethod void post process data j decompress ptr cinfo jsampimage input buf jdimension in row group ctr jdimension in row groups avail jsamparray output buf jdimension out row ctr jdimension out rows avail marker reading parsing struct jpeg marker reader  {
	                                                       reader :: -1000
                                                            }
jmethod void reset marker reader j decompress ptr cinfo read markers until sos or eoi returns same codes as are defined for jpeg consume input jpeg suspended jpeg reached sos or jpeg reached eoi jmethod int read markers j decompress ptr cinfo read a restart marker exported for use by entropy decoder only jpeg marker parser method read restart marker state of marker reader nominally  {
	                                                        nymphean :: -1000
                                                               }
internal but applications supplying com or appn handlers might like to know the state boolean saw  {
	            saw :: -1000
              }
soi found soi boolean saw sof found sof int next restart num next restart number expected unsigned int discarded  {
	         discarded :: -1000
                 }
bytes of bytes skipped looking for a marker entropy decoding  {
	 decoding :: -1000
        }
struct jpeg entropy decoder jmethod void start pass j decompress ptr cinfo jmethod boolean decode mcu j decompress ptr cinfo jblockrow mcu data this is here to share code between baseline and progressive decoders  {
	                         decoders :: -1000
                                }
other modules probably should not use it boolean insufficient data set true after emitting  {
	     emitting :: -1000
            }
warning inverse dct also performs  {
	performs :: -1000
   }
dequantization  {
	derivatization :: 18
	dehumanizations :: 19
	neutralization :: 18
 }
typedef jmethod void inverse dct method ptr j decompress ptr cinfo jpeg component info compptr jcoefptr  {
              }
coef block jsamparray output buf jdimension output col struct jpeg inverse dct jmethod void start pass j decompress ptr cinfo it is useful to allow each component to have a separate idct method inverse dct method ptr inverse dct max components upsampling note that upsampler  {
	                                   resampled :: 11
	                                    resample :: 12
                                           }
must also call color converter struct jpeg upsampler jmethod void start pass j decompress ptr cinfo jmethod void upsample j decompress ptr cinfo jsampimage input buf jdimension in row group ctr jdimension in row groups avail jsamparray output buf jdimension out row ctr jdimension out rows avail boolean need context rows true if need rows above below colorspace conversion struct jpeg color deconverter  {
	                                                     reconvert :: 14
	                                                    reconveyed :: 14
	                                                   reconverted :: 19
	                                                   unconverted :: 14
                                                             }
jmethod void start pass j decompress ptr cinfo jmethod void color convert j decompress ptr cinfo jsampimage input buf jdimension input row jsamparray output buf int num rows color quantization or color precision reduction  {
	                        reduction :: -1000
                                }
struct jpeg color quantizer jmethod void start pass j decompress ptr cinfo boolean is pre scan jmethod void color quantize j decompress ptr cinfo jsamparray input buf jsamparray output buf int num rows jmethod void finish pass j decompress ptr cinfo jmethod void new color map j decompress ptr cinfo miscellaneous useful macros undef max define max a b a b a b undef min define min a b a b a b we assume that right shift corresponds to signed division by with rounding towards  {
	                                                                              towards :: -1000
                                                                                    }
minus infinity  {
	infinity :: -1000
 }
this is correct for typical arithmetic shift instructions that shift in copies of the sign bit but some c compilers implement with an unsigned shift for these machines you must define right shift is unsigned right shift provides a proper signed right shift of an int quantity it is only applied with constant shift counts shift temps  {
	                                                   temps :: -1000
                                                       }
must be included in the variables of any routine using right shift ifdef right shift is unsigned define shift temps int shift temp define right shift x shft  {
	                      hefts :: 5
	                      hafts :: 5
	                       soft :: 5
	                       sift :: 5
	                       shut :: 5
	                       shot :: 5
	                       shit :: 5
	                       shet :: 5
	                       shat :: 5
	                      shift :: 5
	                      shaft :: 5
                          }
shift temp x shift temp shft int shft shift temp shft else define shift temps define right shift x shft x shft endif short forms of external names for systems with brain  {
	                          brain :: -1000
                              }
damaged  {
	damaged :: -1000
 }
linkers  {
	slump :: -1000
 }
ifdef need short external names define jinit  {
	binits :: 6
	 binit :: 7
	pinite :: 6
	finite :: 6
     }
compress master jicompress  {
	decompress :: 14
	recompress :: 14
	decompressing :: 13
	decompression :: 12
 }
define jinit c master control jicmaster  {
	cremaster :: 11
    }
define jinit c main controller jicmainc  {
    }
define jinit c prep controller jicprepc  {
    }
define jinit c coef controller jiccoefc  {
    }
define jinit color converter jiccolor  {
	piccolo :: 11
	piccolos :: 10
	miscolor :: 10
	discolor :: 10
   }
define jinit downsampler jidownsampler  {
  }
define jinit forward dct jifdct  {
   }
define jinit huff encoder jihencoder  {
   }
define jinit phuff  {
	pouffs :: 6
	pouffe :: 6
	pluffy :: 6
	pluffs :: 6
	chuff :: 7
	chuffy :: 6
	chuffs :: 6
	pouff :: 7
	pluff :: 7
 }
encoder jiphencoder  {
 }
define jinit arith encoder jiaencoder  {
   }
define jinit marker writer jimwriter  {
	miswrite :: 11
   }
define jinit master decompress jidmaster  {
	misparted :: 11
	dismasted :: 11
   }
define jinit d main controller jidmainc  {
    }
define jinit d coef controller jidcoefc  {
    }
define jinit d post controller jidpostc  {
    }
define jinit input controller jiinctlr  {
   }
define jinit marker reader jimreader  {
	misleader :: 11
	misrender :: 11
	remainder :: 11
   }
define jinit huff decoder jihdecoder  {
	isocrymal :: -1000
   }
define jinit phuff decoder jiphdecoder  {
   }
define jinit arith decoder jiadecoder  {
   }
define jinit inverse dct jiidct  {
   }
define jinit upsampler jiupsampler  {
  }
define jinit color deconverter jidcolor  {
	miscolored :: 10
	discolored :: 10
	discolour :: 10
	discolors :: 11
	miscolor :: 10
	discolor :: 12
   }
define jinit pass quantizer ji quant define jinit pass quantizer ji quant define jinit merged upsampler jimupsampler  {
               }
define jinit memory mgr  {
	marg :: 4
	germ :: 3
	merge :: 3
	margs :: 3
	marge :: 3
	mor :: 3
	mir :: 3
	mar :: 3
  }
jimemmgr  {
 }
define jdiv  {
 }
round up jdivround  {
 }
define jround  {
	rotund :: 7
	grounds :: 8
	jocund :: 8
	ground :: 9
 }
up jround define jcopy sample rows jcopysamples  {
     }
define jcopy block row jcopyblocks  {
   }
define jzero  {
 }
far jzerofar  {
	arsenics :: -1000
 }
define jpeg zigzag  {
	zigzag :: -1000
 }
order jzigtable  {
	besieges :: -1000
 }
define jpeg natural  {
	natural :: -1000
 }
order jzagtable  {
	grantable :: 11
	stageable :: 11
 }
define jpeg aritab  {
	agitable :: 7
	atria :: 7
	arista :: 7
	tribal :: 7
	writable :: 7
	raitas :: 7
	taira :: 7
	brit :: 7
	aria :: 7
	riata :: 7
	raita :: 8
 }
jaritab  {
	jarina :: 9
 }
endif need short external names compression module initialization routines extern void jinit compress master jpp  {
	           jap :: 3
             }
j compress ptr cinfo extern void jinit c master control jpp j compress ptr cinfo boolean transcode only extern void jinit c main controller jpp j compress ptr cinfo boolean need full buffer extern void jinit c prep controller jpp j compress ptr cinfo boolean need full buffer extern void jinit c coef controller jpp j compress ptr cinfo boolean need full buffer extern void jinit color converter jpp j compress ptr cinfo extern void jinit downsampler jpp j compress ptr cinfo extern void jinit forward dct jpp j compress ptr cinfo extern void jinit huff encoder jpp j compress ptr cinfo extern void jinit phuff encoder jpp j compress ptr cinfo extern void jinit arith encoder jpp j compress ptr cinfo extern void jinit marker writer jpp j compress ptr cinfo decompression module initialization routines extern void jinit master decompress jpp j decompress ptr cinfo extern void jinit d main controller jpp j decompress ptr cinfo boolean need full buffer extern void jinit d coef controller jpp j decompress ptr cinfo boolean need full buffer extern void jinit d post controller jpp j decompress ptr cinfo boolean need full buffer extern void jinit input controller jpp j decompress ptr cinfo extern void jinit marker reader jpp j decompress ptr cinfo extern void jinit huff decoder jpp j decompress ptr cinfo extern void jinit phuff decoder jpp j decompress ptr cinfo extern void jinit arith decoder jpp j decompress ptr cinfo extern void jinit inverse dct jpp j decompress ptr cinfo extern void jinit upsampler jpp j decompress ptr cinfo extern void jinit color deconverter jpp j decompress ptr cinfo extern void jinit pass quantizer jpp j decompress ptr cinfo extern void jinit pass quantizer jpp j decompress ptr cinfo extern void jinit merged upsampler jpp j decompress ptr cinfo memory manager initialization extern void jinit memory mgr jpp j common ptr cinfo utility routines in jutils  {
	                                                                                                                                                                                                                                                                                                                      tulips :: 7
	                                                                                                                                                                                                                                                                                                                    justling :: 7
	                                                                                                                                                                                                                                                                                                                      justly :: 7
	                                                                                                                                                                                                                                                                                                                      justle :: 7
	                                                                                                                                                                                                                                                                                                                      jurist :: 7
	                                                                                                                                                                                                                                                                                                                     jubiles :: 7
	                                                                                                                                                                                                                                                                                                                     rutiles :: 7
	                                                                                                                                                                                                                                                                                                                      sutile :: 8
	                                                                                                                                                                                                                                                                                                                   jubilates :: 7
                                                                                                                                                                                                                                                                                                                           }
c extern long jdiv round up jpp long a long b extern long jround up jpp long a long b extern void jcopy sample rows jpp jsamparray input array int source row jsamparray output array int dest row int num rows jdimension num cols  {
	                                       cols :: -1000
                                          }
extern void jcopy block row jpp jblockrow input row jblockrow output row jdimension num blocks extern void jzero far jpp void far target size t bytestozero  {
                        }
constant tables in jutils c if this table is not actually needed in v a extern const int jpeg zigzag order natural coef order to zigzag order endif extern const int jpeg natural order zigzag coef order to natural order arithmetic coding probability  {
	                               probability :: -1000
                                         }
estimation  {
	estimation :: -1000
 }
tables in jaricom  {
 }
c extern const int jpeg aritab suppress undefined structure complaints  {
	complaints :: -1000
        }
if necessary ifdef incomplete types broken ifndef am memory manager only jmemmgr  {
          }
c defines these struct jvirt sarray  {
	yarrans :: 9
	satrapy :: 7
	sardar :: 8
	salary :: 7
	garrya :: 7
	carrats :: 7
	astray :: 7
	parrals :: 7
	narras :: 8
	marrams :: 7
	jarrahs :: 7
	hurrays :: 7
	garryas :: 8
	garrans :: 7
	sarrazin :: 7
	warray :: 9
	yarrs :: 7
	yarran :: 8
	tayras :: 7
	tarras :: 8
	sorra :: 7
	sirra :: 7
	serra :: 7
	sacra :: 7
	sabra :: 7
	yardarms :: 7
	murrays :: 7
    }
control long dummy struct jvirt barray control long dummy endif endif incomplete types broken jpeglib h copyright c thomas g lane modified by guido vollbeding copyright c d r commander this file is part of the independent jpeg group s software for conditions of distribution and use see the accompanying readme file this file defines the application interface for the jpeg library most applications using the library need only include this file and perhaps jerror h if they want to know the exact error codes ifndef jpeglib h define jpeglib h first we include the configuration files that record how this installation of the jpeg library is set up jconfig  {
                                                                                                            }
h can be generated automatically for many systems jmorecfg h contains manual configuration options that most people need not worry  {
	              worry :: -1000
                  }
about ifndef jconfig included in case jinclude  {
	conclude :: 10
     }
h already did include jconfig h widely used configuration options endif include jmorecfg h seldom  {
	        seldom :: -1000
             }
changed options ifdef cplusplus ifndef dont use extern c extern c endif endif various constants determining  {
	    determining :: -1000
              }
the sizes of things all of these are specified by the jpeg standard so don t change them if you want to be compatible define dctsize the basic dct block is x samples  {
	                         samples :: -1000
                               }
define dctsize dctsize squared  {
	squared :: -1000
  }
of elements in a block define num quant tbls  {
	    tils :: 5
	    tels :: 5
       }
quantization tables are numbered  {
	numbered :: -1000
  }
define num huff tbls huffman tables are numbered define num arith tbls arith coding tables are numbered define max comps  {
	              comps :: -1000
                  }
in scan jpeg limit on of components in one scan define max samp factor jpeg limit on sampling factors unfortunately  {
	      unfortunately :: -1000
                  }
some bozo  {
	bozo :: -1000
 }
at adobe saw no reason to be bound by the standard the postscript  {
	  postscript :: -1000
           }
dct filter can emit files with many more than blocks mcu if you happen  {
	       happen :: -1000
            }
to run across such a file you can up d max blocks in mcu to handle it we even let you do this from the jconfig h file however we strongly  {
	                      strongly :: -1000
                             }
discourage  {
	discourage :: -1000
 }
changing c max blocks in mcu just because adobe sometimes emits  {
	     emits :: -1000
         }
noncompliant  {
	noncompliant :: -1000
 }
files doesn t mean you should too define c max blocks in mcu compressor  {
	   compressor :: -1000
            }
s limit on blocks per mcu ifndef d max blocks in mcu define d max blocks in mcu decompressor  {
	        recomposes :: 16
	        recomposed :: 15
	        decomposes :: 17
	        decomposer :: 16
	        decompress :: 18
	        recompress :: 17
	       decomposers :: 17
	         decompose :: 15
	     decompressing :: 15
	     decompression :: 18
	    decompressions :: 15
                 }
s limit on blocks per mcu endif data structures for images arrays of samples and of dct coefficients on x machines the image arrays are too big for near pointers but the pointer arrays can fit in near memory typedef jsample far jsamprow  {
                                         }
ptr to one image row of pixel samples typedef jsamprow jsamparray ptr to some rows a d sample array typedef jsamparray jsampimage a d sample array top index is color typedef jcoef jblock dctsize one block of coefficients typedef jblock far jblockrow pointer to one row of coefficient blocks typedef jblockrow jblockarray  {
                                                  }
a d array of coefficient blocks typedef jblockarray jblockimage  {
       }
a d array of coefficient blocks typedef jcoef far jcoefptr useful in a couple of places types for jpeg compression parameters and working tables dct coefficient quantization tables typedef struct this array gives the coefficient quantizers  {
	                         quantizers :: -1000
                                  }
in natural array order not the zigzag order in which they are stored in a jpeg dqt marker caution ijg versions prior to v a kept this array in zigzag order uint quantval dctsize quantization step for each coefficient this field is used only during compression it s initialized false when the table is created and set true when it s been output to the file you could suppress output of a table by setting this to true see jpeg suppress tables for an example boolean sent table true when table has been output jquant  {
	                                                                                         jaunt :: 7
	                                                                                       jurants :: 7
	                                                                                        jurant :: 8
	                                                                                        equant :: 9
                                                                                             }
tbl huffman coding tables typedef struct these two fields directly represent the contents of a jpeg dht marker uint bits bits k of symbols with codes of length k bits bits is unused uint huffval  {
                                 }
the symbols in order of incr code length this field is used only during compression it s initialized false when the table is created and set true when it s been output to the file you could suppress output of a table by setting this to true see jpeg suppress tables for an example boolean sent table true when table has been output jhuff  {
	                                                          chuff :: 7
	                                                         chuffy :: 6
	                                                         chuffs :: 6
                                                              }
tbl basic info about one component color channel typedef struct these values are fixed over the whole image for compression they must be supplied by parameter setup for decompression they are read from the sof marker int component id identifier for this component int component index its index in sof or cinfo comp info int h samp factor horizontal  {
	                                                horizontal :: -1000
                                                         }
sampling factor int v samp factor vertical sampling factor int quant tbl no quantization table selector these values may vary  {
	               vary :: -1000
                  }
between scans for compression they must be supplied by parameter setup for decompression they are read from the sos marker the decompressor output side may not use these variables int dc tbl no dc entropy table selector int ac tbl no ac entropy table selector remaining fields should be treated as private by applications these values are computed  {
	                                                 computed :: -1000
                                                        }
during compression or decompression startup component s size in dct blocks any dummy blocks added to complete an mcu are not counted  {
	              counted :: -1000
                    }
therefore these values do not depend on whether a scan is interleaved or not jdimension width in blocks jdimension height in blocks size of a dct block in samples always dctsize for compression for decompression this is the size of the output from one dct block reflecting  {
	                                    reflecting :: -1000
                                             }
any scaling we choose to apply during the idct step values of are likely to be supported note that different components may receive different idct scalings  {
	                 scalings :: -1000
                        }
if jpeg lib version int dct h scaled  {
	 scaled :: -1000
      }
size int dct v scaled size else int dct scaled size endif the downsampled dimensions are the component s actual unpadded  {
	            sepadded :: 10
	            ungodded :: 10
	            unlidded :: 10
	            undraped :: 10
	            unbedded :: 10
	           unsaddled :: 10
	            unwedded :: 10
	            unpathed :: 10
	            unparted :: 10
	            unpaired :: 10
	            undamped :: 11
	            unpacked :: 10
                   }
number of samples at the main buffer preprocessing compression interface thus downsampled width ceil  {
	         ceil :: -1000
            }
image width hi hmax  {
	hoax :: 5
  }
and similarly  {
	similarly :: -1000
 }
for height for decompression idct scaling is included so downsampled width ceil image width hi hmax dct h scaled size dctsize jdimension downsampled width actual width in samples jdimension downsampled height actual height in samples this flag is used only for decompression in cases where some of the components will be ignored eg grayscale output from ycbcr image we can skip most computations  {
	                                                  computations :: -1000
                                                             }
for the unused components boolean component needed do we need the value of this component these values are computed before starting a scan of the component the decompressor output side may not use these variables int mcu width number of blocks per mcu horizontally  {
	                               horizontally :: -1000
                                          }
int mcu height number of blocks per mcu vertically  {
	vertically :: -1000
       }
int mcu blocks mcu width mcu height int mcu sample width mcu width in samples mcu width dct h scaled size int last col width of non dummy blocks across in last mcu int last row height of non dummy blocks down in last mcu saved quantization table for component null if none yet saved see jdinput  {
                                                       }
c comments about the need for this information this field is currently used only for decompression jquant tbl quant table private per component storage for dct or idct subsystem void dct table jpeg component info the script for encoding a multiple scan file is an array of these typedef struct int comps in scan number of components encoded in this scan int component index max comps in scan their sof comp info indexes  {
	                                                                 indexes :: -1000
                                                                       }
int ss se progressive jpeg spectral  {
	spectral :: -1000
    }
selection parms int ah al progressive jpeg successive approx parms jpeg scan info the decompressor can save appn and com markers in a list of these typedef struct jpeg marker struct far jpeg saved marker ptr struct jpeg marker struct jpeg saved marker ptr next next in list or null uint marker marker code jpeg com or jpeg app n unsigned int original  {
	                                                      original :: -1000
                                                             }
length bytes of data in the file unsigned int data length bytes of data saved at data joctet far data the data contained in the marker the marker length word is not counted in data length or original length known color spaces define jcs  {
	                                        jus :: 3
                                          }
extensions define jcs alpha extensions typedef enum jcs unknown error unspecified jcs grayscale monochrome  {
	   monochrome :: -1000
            }
jcs rgb red green blue as specified by the rgb red rgb green rgb blue and rgb pixelsize macros jcs ycbcr y cb cr also known as yuv  {
	                        yus :: 3
	                        yup :: 3
	                        yum :: 3
	                        yug :: 3
	                        luv :: 3
	                        guv :: 3
                          }
jcs cmyk c m y k jcs ycck  {
	  cocky :: 5
	   yuck :: 5
	   yock :: 5
	   yack :: 5
      }
y cb cr k jcs ext rgb red green blue jcs ext rgbx red green blue x jcs ext bgr blue green red jcs ext bgrx blue green red x jcs ext xbgr x blue green red jcs ext xrgb x red green blue when out color space it set to jcs ext rgbx jcs ext bgrx jcs ext xbgr or jcs ext xrgb during decompression the x byte is undefined and in order to ensure the best  {
	                                                                         best :: -1000
                                                                            }
performance  {
	performance :: -1000
 }
libjpeg  {
 }
turbo  {
	turbo :: -1000
 }
can set that byte to whatever value it wishes  {
	  wishes :: -1000
       }
use the following colorspace constants to ensure that the x byte is set to xff so that it can be interpreted as an opaque alpha channel jcs ext rgba  {
                           }
red green blue alpha jcs ext bgra  {
	 barge :: 5
	  garb :: 5
	  bura :: 5
	  brag :: 5
	  bora :: 5
	borage :: 5
	   bar :: 5
     }
blue green red alpha jcs ext abgr  {
     }
alpha blue green red jcs ext argb  {
	 grabs :: 5
	  garb :: 5
	  brag :: 5
     }
alpha red green blue j color space dct idct algorithm options typedef enum jdct  {
            }
islow slow but accurate integer algorithm jdct ifast faster less accurate integer method jdct float floating point accurate fast on fast hw j dct method ifndef jdct default may be overridden in jconfig h define jdct default jdct islow endif ifndef jdct fastest may be overridden in jconfig h define jdct fastest jdct ifast endif dithering  {
	                                              dithering :: -1000
                                                      }
options for decompression typedef enum jdither  {
	diether :: 9
	writhed :: 9
    }
none no dithering jdither ordered simple ordered dither jdither fs floyd  {
	     flory :: 6
	     flood :: 6
	      oldy :: 6
	     sloyd :: 7
	    sloyds :: 6
         }
steinberg  {
	stereoing :: 11
	steerling :: 11
	steering :: 11
	stringer :: 12
	stringed :: 11
	inselberg :: 11
	befingers :: 11
 }
error diffusion  {
	diffusion :: -1000
 }
dither j dither mode common fields between jpeg compression and decompression master structs define jpeg common fields struct jpeg error mgr err error handler module struct jpeg memory mgr mem memory manager module struct jpeg progress mgr progress progress monitor  {
	                                monitor :: -1000
                                      }
or null if none void client data available for use by application boolean is decompressor so common code can tell which is which int global state for checking call sequence validity routines that are to be used by both halves  {
	                                 halves :: -1000
                                      }
of the library are declared to receive a pointer to this structure there are no actual instances of jpeg common struct only of jpeg compress struct and jpeg decompress struct struct jpeg common struct jpeg common fields fields common to both master struct types additional fields follow in an actual jpeg compress struct or jpeg decompress struct all three  {
	                                                     three :: -1000
                                                         }
structs must agree  {
	agree :: -1000
 }
on these initial fields this would be a lot  {
	     lot :: -1000
       }
cleaner  {
	cleaner :: -1000
 }
in c typedef struct jpeg common struct j common ptr typedef struct jpeg compress struct j compress ptr typedef struct jpeg decompress struct j decompress ptr master record for a compression instance struct jpeg compress struct jpeg common fields fields shared with jpeg decompress struct destination for compressed data struct jpeg destination mgr dest description of source image these fields must be filled in by outer application before starting compression in color space must be correct before you can even call jpeg set defaults jdimension image width input image width jdimension image height input image height int input components of color components in input image j color space in color space colorspace of input image double input gamma  {
	                                                                                                                gamma :: -1000
                                                                                                                    }
image gamma of input image compression parameters these fields must be set before calling jpeg start compress we recommend calling jpeg set defaults to initialize everything to reasonable defaults then changing anything the application specifically wants to change that way you won t get burnt  {
	                                  racecourse :: -1000
                                           }
when new parameters are added also note that there are several helper  {
	     helper :: -1000
          }
routines to simplify changing parameters if jpeg lib version unsigned int scale num scale denom fraction by which to scale image jdimension jpeg width scaled jpeg image width jdimension jpeg height scaled jpeg image height dimensions of actual jpeg image that will be written to file derived from input dimensions by scaling factors above these fields are computed by jpeg start compress you can also use jpeg calc jpeg dimensions to determine these values in advance of calling jpeg start compress endif int data precision bits of precision in image data int num components of color components in jpeg image j color space jpeg color space colorspace of jpeg image jpeg component info comp info comp info i describes component that appears i th in sof jquant tbl quant tbl ptrs  {
	                                                                                                                              pubs :: -1000
                                                                                                                                 }
num quant tbls if jpeg lib version int q scale factor num quant tbls endif ptrs to coefficient quantization tables or null if not defined and corresponding scale factors percentage  {
	                   percentage :: -1000
                            }
initialized jhuff tbl dc huff tbl ptrs num huff tbls jhuff tbl ac huff tbl ptrs num huff tbls ptrs to huffman coding tables or null if not defined uint arith dc l num arith tbls l values for dc arith coding tables uint arith dc u num arith tbls u values for dc arith coding tables uint arith ac k num arith tbls kx values for ac arith coding tables int num scans of entries in scan info array const jpeg scan info scan info script for multi scan file or null the default value of scan info is null which causes a single scan sequential jpeg file to be emitted to create a multi scan file set num scans and scan info to point to an array of scan definitions boolean raw data in true caller supplies  {
	                                                                                                                                  supplies :: -1000
                                                                                                                                         }
downsampled data boolean arith code true arithmetic coding false huffman boolean optimize coding true optimize entropy encoding parms boolean ccir sampling true first samples are cosited  {
	                  hoisted :: 9
	                    cosie :: 9
	                    coset :: 9
	                  roisted :: 9
	                  cotised :: 12
	                  cotises :: 9
	                  stoited :: 9
	                  posited :: 11
	                  sopited :: 10
	                   cotise :: 10
	                  cestoid :: 10
	                   cosine :: 9
	                  foisted :: 9
	                   codist :: 9
	                  coedits :: 9
	                  noticed :: 9
	                  joisted :: 9
	                  podites :: 9
	                  coasted :: 10
                        }
if jpeg lib version boolean do fancy  {
	 fancy :: -1000
     }
downsampling true apply fancy downsampling endif int smoothing factor or for no input smoothing j dct method dct method dct algorithm selector the restart interval can be specified in absolute mcus  {
	                          scum :: 6
	                          mous :: 5
	                          meus :: 5
	                         scums :: 5
	                          ecus :: 5
                             }
by setting restart interval or in mcu rows by setting restart in rows in which case the correct restart interval will be figured  {
	               figured :: -1000
                     }
for each scan unsigned int restart interval mcus per restart or for no restart int restart in rows if mcu rows per restart interval parameters controlling  {
	              controlling :: -1000
                        }
emission  {
	emission :: -1000
 }
of special markers boolean write jfif header should a jfif marker be written uint jfif major version what to write for the jfif version number uint jfif minor version these three values are not used by the jpeg code merely  {
	                                 merely :: -1000
                                      }
copied into the jfif app marker density unit can be for unknown for dots  {
	         douc :: -1000
            }
inch  {
	inch :: -1000
 }
or for dots cm note that the pixel aspect  {
	  aspect :: -1000
       }
ratio is defined by x density y density even when density unit uint density unit jfif code for pixel size units  {
	               units :: -1000
                   }
uint x density horizontal pixel density uint y density vertical pixel density boolean write adobe marker should an adobe marker be written state variable index of next scanline to be written to jpeg write scanlines application may use this to control its processing loop  {
	                                       loop :: -1000
                                          }
e g while next scanline image height jdimension next scanline image height remaining fields are known throughout  {
	      throughout :: -1000
               }
compressor but generally should not be touched  {
	touched :: -1000
     }
by a surrounding  {
	surrounding :: -1000
 }
application these fields are computed during compression startup boolean progressive mode true if scan script uses progressive mode int max h samp factor largest h samp factor int max v samp factor largest v samp factor if jpeg lib version int min dct h scaled size smallest dct h scaled size of any component int min dct v scaled size smallest dct v scaled size of any component endif jdimension total imcu  {
                                                                      }
rows of imcu rows to be input to coef ctlr  {
	    clart :: 5
        }
the coefficient controller receives data in units of mcu rows as defined for fully interleaved scans whether the jpeg file is interleaved or not there are v samp factor dctsize sample rows of each component in an imcu interleaved mcu row these fields are valid during any one scan they describe the components and mcus actually appearing  {
	                                               appearing :: -1000
                                                       }
in the scan int comps in scan of jpeg components in this scan jpeg component info cur comp info max comps in scan cur comp info i describes component that appears i th in sos jdimension mcus per row of mcus across the image jdimension mcu rows in scan of mcu rows in the image int blocks in mcu of dct blocks per mcu int mcu membership  {
	                                                        membership :: -1000
                                                                 }
c max blocks in mcu mcu membership i is index in cur comp info of component owning  {
	          owning :: -1000
               }
i th block in an mcu int ss se ah al progressive jpeg parameters for scan if jpeg lib version int block size the basic dct block size const int natural order natural order position array int lim se min se dctsize endif links  {
	                                      links :: -1000
                                          }
to compression subobjects methods and private variables of modules struct jpeg comp master master struct jpeg c main controller main struct jpeg c prep controller prep struct jpeg c coef controller coef struct jpeg marker writer marker struct jpeg color converter cconvert  {
                                        }
struct jpeg downsampler downsample struct jpeg forward dct fdct  {
	    fact :: 5
       }
struct jpeg entropy encoder entropy jpeg scan info script space workspace  {
	 workspace :: -1000
         }
for jpeg simple progression int script space size master record for a decompression instance struct jpeg decompress struct jpeg common fields fields shared with jpeg compress struct source of compressed data struct jpeg source mgr src basic description of image filled in by jpeg read header application may inspect  {
	                                         inspect :: -1000
                                               }
these values to decide how to process image jdimension image width nominal image width from sof marker jdimension image height nominal image height int num components of color components in jpeg image j color space jpeg color space colorspace of jpeg image decompression processing parameters these fields must be set before calling jpeg start decompress note that jpeg read header initializes  {
	                                                 initializes :: -1000
                                                           }
them to default values j color space out color space colorspace for output unsigned int scale num scale denom fraction by which to scale image double output gamma image gamma wanted in output boolean buffered image true multiple output passes  {
	                                 passes :: -1000
                                      }
boolean raw data out true downsampled data wanted j dct method dct method idct algorithm selector boolean do fancy upsampling true apply fancy upsampling boolean do block smoothing true apply interblock  {
	                    interlocks :: 13
	                     interlock :: 14
	                     interclub :: 13
	                     interflow :: 12
                             }
smoothing boolean quantize colors true colormapped  {
    }
output wanted the following are ignored if not quantize colors j dither mode dither mode type of color dithering to use boolean two pass quantize true use two pass color quantization int desired number of colors max colors to use in created colormap these are significant only in buffered image mode boolean enable pass quant enable future use of pass quantizer boolean enable external quant enable future use of external colormap boolean enable pass quant enable future use of pass quantizer description of actual output image that will be returned to application these fields are computed by jpeg start decompress you can also use jpeg calc output dimensions to determine these values in advance of calling jpeg start decompress jdimension output width scaled image width jdimension output height scaled image height int out color components of color components in out color space int output components of color components returned output components is a colormap index when quantizing colors otherwise it equals  {
	                                                                                                                                                          equals :: -1000
                                                                                                                                                               }
out color components int rec outbuf height min recommended height of scanline buffer if the buffer passed to jpeg read scanlines is less than this many rows high space and time will be wasted  {
	                           wasted :: -1000
                                }
due to unnecessary  {
	unnecessary :: -1000
 }
data copying usually rec outbuf height will be or at most when quantizing colors the output colormap is described by these fields the application can supply a colormap by setting colormap non null before calling jpeg start decompress otherwise a colormap is created during jpeg start decompress or jpeg start output the map has out color components rows and actual number of colors columns  {
	                                                        columns :: -1000
                                                              }
int actual number of colors number of entries in use jsamparray colormap the color map as a d pixel array state variables these variables indicate the progress of decompression the application may examine these but must not modify them row index of next scanline to be read from jpeg read scanlines application may use this to control its processing loop e g while output scanline output height jdimension output scanline output height current input scan number and number of imcu rows completed in scan these indicate the progress of the decompressor input side int input scan number number of sos markers seen so far jdimension input imcu row number of imcu rows completed the output scan number is the notional  {
	                                                                                                               notional :: -1000
                                                                                                                      }
scan being displayed by the output side the decompressor will not allow output scan row number to get ahead  {
	             ahead :: -1000
                 }
of input scan row but it can fall arbitrarily  {
	arbitrarily :: -1000
       }
far behind  {
	churchy :: -1000
 }
int output scan number nominal scan number being displayed jdimension output imcu row number of imcu rows read current progression status coef bits c i indicates the precision with which component c s dct coefficient i in zigzag order is known it is when no data has yet been received otherwise it is the point transform shift value for the most recent  {
	                                                       recent :: -1000
                                                            }
scan of the coefficient thus at completion  {
	completion :: -1000
     }
of the progression this pointer is null when reading a non progressive file int coef bits dctsize or current al value for each coef internal jpeg parameters the application usually need not look at these fields note that the decompressor output side may not use any parameters that can change between scans quantization and huffman tables are carried  {
	                                                  carried :: -1000
                                                        }
forward across input datastreams when processing abbreviated  {
	retained :: -1000
     }
jpeg datastreams jquant tbl quant tbl ptrs num quant tbls ptrs to coefficient quantization tables or null if not defined jhuff tbl dc huff tbl ptrs num huff tbls jhuff tbl ac huff tbl ptrs num huff tbls ptrs to huffman coding tables or null if not defined these parameters are never carried across datastreams since they are given in sof sos markers or defined to be reset by soi int data precision bits of precision in image data jpeg component info comp info comp info i describes component that appears i th in sof if jpeg lib version boolean is baseline true if baseline sof encountered endif boolean progressive mode true if sofn  {
	                                                                                                            foins :: 5
	                                                                                                            fohns :: 5
	                                                                                                             sown :: 5
	                                                                                                             sorn :: 5
	                                                                                                             soft :: 5
	                                                                                                             sofa :: 5
	                                                                                                             fons :: 5
	                                                                                                           soften :: 5
	                                                                                                              son :: 5
                                                                                                                }
specifies progressive mode boolean arith code true arithmetic coding false huffman uint arith dc l num arith tbls l values for dc arith coding tables uint arith dc u num arith tbls u values for dc arith coding tables uint arith ac k num arith tbls kx values for ac arith coding tables unsigned int restart interval mcus per restart interval or for no restart these fields record data obtained from optional markers recognized by the jpeg library boolean saw jfif marker true iff a jfif app marker was found data copied from jfif marker only valid if saw jfif marker is true uint jfif major version jfif version number uint jfif minor version uint density unit jfif code for pixel size units uint x density horizontal pixel density uint y density vertical pixel density boolean saw adobe marker true iff an adobe app marker was found uint adobe transform color transform code from adobe marker boolean ccir sampling true first samples are cosited aside  {
	                                                                                                                                                               aside :: -1000
                                                                                                                                                                   }
from the specific data retained  {
	retained :: -1000
   }
from appn markers known to the library the uninterpreted  {
	uninterrupted :: 19
	reinterpreted :: 20
	reinterpret :: 16
	uninterested :: 16
	uninterruptedly :: 17
       }
contents of any or all appn and com markers can be saved in a list for examination  {
	     examination :: -1000
               }
by the application jpeg saved marker ptr marker list head of list of saved markers remaining fields are known throughout decompressor but generally should not be touched by a surrounding application these fields are computed during decompression startup int max h samp factor largest h samp factor int max v samp factor largest v samp factor if jpeg lib version int min dct h scaled size smallest dct h scaled size of any component int min dct v scaled size smallest dct v scaled size of any component else int min dct scaled size smallest dct scaled size of any component endif jdimension total imcu rows of imcu rows in image the coefficient controller s input and output progress is measured  {
	                                                                                                                measured :: -1000
                                                                                                                       }
in units of imcu interleaved mcu rows these are the same as mcu rows in fully interleaved jpeg scans but are used whether the scan is interleaved or not we define an imcu row as v samp factor dct block rows of each component therefore the idct output contains v samp factor dct v scaled size sample rows of a component per imcu row jsample sample range limit table for fast range limiting  {
	                                                                limiting :: -1000
                                                                       }
these fields are valid during any one scan they describe the components and mcus actually appearing in the scan note that the decompressor output side must not use these fields int comps in scan of jpeg components in this scan jpeg component info cur comp info max comps in scan cur comp info i describes component that appears i th in sos jdimension mcus per row of mcus across the image jdimension mcu rows in scan of mcu rows in the image int blocks in mcu of dct blocks per mcu int mcu membership d max blocks in mcu mcu membership i is index in cur comp info of component owning i th block in an mcu int ss se ah al progressive jpeg parameters for scan if jpeg lib version these fields are derived from se of first sos marker int block size the basic dct block size const int natural order natural order position array for entropy decode int lim se min se dctsize for entropy decode endif this field is shared between entropy decoder and marker parser it is either zero or the code of a jpeg marker that has been read from the data source but has not yet been processed int unread marker links to decompression subobjects methods private variables of modules struct jpeg decomp master master struct jpeg d main controller main struct jpeg d coef controller coef struct jpeg d post controller post struct jpeg input controller inputctl  {
                                                                                                                                                                                                                                                   }
struct jpeg marker reader marker struct jpeg entropy decoder entropy struct jpeg inverse dct idct struct jpeg upsampler upsample struct jpeg color deconverter cconvert struct jpeg color quantizer cquantize  {
	                      equant :: 11
                           }
object declarations for jpeg modules that may be supplied or called directly by the surrounding application as with all objects in the jpeg library these structs only define the publicly  {
	                     publicly :: -1000
                            }
visible methods and state variables of a module additional private fields may exist after the public ones error handler object struct jpeg error mgr error exit handler does not return to caller jmethod void error exit j common ptr cinfo conditionally  {
	                           conditionally :: -1000
                                       }
emit a trace or warning message jmethod void emit message j common ptr cinfo int msg level routine that actually outputs  {
	             outputs :: -1000
                   }
a trace or error message jmethod void output message j common ptr cinfo format a message string for the most recent jpeg error or message jmethod void format message j common ptr cinfo char buffer define jmsg length max recommended size of format message buffer reset error state variables at start of a new image jmethod void reset error mgr j common ptr cinfo the message id code and any parameters are saved here a message can have one string parameter or up to int parameters int msg code define jmsg str parm max union int i char s jmsg str parm max msg parm standard state variables for error facility int trace level max msg level that will be displayed for recoverable corrupt data errors we emit a warning message but keep going unless emit message chooses to abort emit message should count warnings in num warnings the surrounding application can check for bad data by seeing  {
	                                                                                                                                                       seeing :: -1000
                                                                                                                                                            }
if num warnings is nonzero at the end of processing long num warnings number of corrupt data warnings these fields point to the table s of error message strings an application can change the table pointer to switch to a different message list typically to change the language in which errors are reported some applications may wish to add additional error codes that will be handled by the jpeg library error mechanism the second table pointer is used for this purpose first table includes all errors generated by jpeg library itself error code is reserved for a no such error string message const char const jpeg message table library errors int last jpeg message table contains strings last jpeg message second table can be added by application see cjpeg djpeg for example it contains strings numbered first addon  {
	                                                                                                                                    acton :: -1000
                                                                                                                                        }
message last addon message const char const addon message table non library errors int first addon message code for first string in addon table int last addon message code for last string in addon table progress monitor object struct jpeg progress mgr jmethod void progress monitor j common ptr cinfo long pass counter work units completed in this pass long pass limit total number of work units in this pass int completed passes passes completed so far int total passes total number of passes expected data destination object for compression struct jpeg destination mgr joctet next output byte next byte to write in buffer size t free in buffer of byte spaces remaining in buffer jmethod void init destination j compress ptr cinfo jmethod boolean empty output buffer j compress ptr cinfo jmethod void term destination j compress ptr cinfo data source object for decompression struct jpeg source mgr const joctet next input byte next byte to read from buffer size t bytes in buffer of bytes remaining in buffer jmethod void init source j decompress ptr cinfo jmethod boolean fill input buffer j decompress ptr cinfo jmethod void skip input data j decompress ptr cinfo long num bytes jmethod boolean resync to restart j decompress ptr cinfo int desired jmethod void term source j decompress ptr cinfo memory manager object allocates  {
	                                                                                                                                                                                                                    allocates :: -1000
                                                                                                                                                                                                                            }
small objects a few k total large objects tens of k and really big objects virtual arrays with backing store if needed the memory manager does not allow individual objects to be freed rather each created object is assigned  {
	                              assigned :: -1000
                                     }
to a pool and whole pools  {
	pools :: -1000
    }
can be freed at once this is faster and more convenient than remembering  {
	 remembering :: -1000
           }
exactly what to free especially where malloc free are not too speedy  {
	     speedy :: -1000
          }
nb alloc routines never return null they exit to error exit if not successful define jpool  {
	          spool :: 7
	         spools :: 6
              }
permanent  {
	permanent :: -1000
 }
lasts until master record is destroyed define jpool image lasts until done with image datastream define jpool numpools  {
	          surance :: -1000
                }
typedef struct jvirt sarray control jvirt sarray ptr typedef struct jvirt barray control jvirt barray ptr struct jpeg memory mgr method pointers jmethod void alloc small j common ptr cinfo int pool id size t sizeofobject  {
                                  }
jmethod void far alloc large j common ptr cinfo int pool id size t sizeofobject jmethod jsamparray alloc sarray j common ptr cinfo int pool id jdimension samplesperrow  {
                          }
jdimension numrows  {
 }
jmethod jblockarray alloc barray j common ptr cinfo int pool id jdimension blocksperrow  {
           }
jdimension numrows jmethod jvirt sarray ptr request virt sarray j common ptr cinfo int pool id boolean pre zero jdimension samplesperrow jdimension numrows jdimension maxaccess  {
                       }
jmethod jvirt barray ptr request virt barray j common ptr cinfo int pool id boolean pre zero jdimension blocksperrow jdimension numrows jdimension maxaccess jmethod void realize  {
	                  realize :: -1000
                        }
virt arrays j common ptr cinfo jmethod jsamparray access virt sarray j common ptr cinfo jvirt sarray ptr ptr jdimension start row jdimension num rows boolean writable jmethod jblockarray access virt barray j common ptr cinfo jvirt barray ptr ptr jdimension start row jdimension num rows boolean writable jmethod void free pool j common ptr cinfo int pool id jmethod void self destruct j common ptr cinfo limit on memory allocation for this jpeg object note that this is merely advisory  {
	                                                                        advisory :: -1000
                                                                               }
not a guaranteed maximum it only affects  {
	affects :: -1000
     }
the space used for virtual array buffers may be changed by outer application after creating the jpeg object long max memory to use maximum allocation request accepted by alloc large long max alloc chunk routine signature for application supplied marker processing methods need not pass marker code since it is stored in cinfo unread marker typedef jmethod boolean jpeg marker parser method j decompress ptr cinfo declarations for routines called by application the jpp macro hides  {
	                                                                      hides :: -1000
                                                                          }
prototype parameters from compilers that can t cope note jpp requires double parentheses  {
	 parentheses :: -1000
           }
ifdef have prototypes define jpp arglist arglist else define jpp arglist endif short forms of external names for systems with brain damaged linkers we shorten  {
	                 shorten :: -1000
                       }
external names to be unique in the first six letters which is good enough for all known systems if your compiler itself needs names to be unique in less than characters you are out of luck  {
	                               luck :: -1000
                                  }
get a better compiler ifdef need short external names define jpeg std error jstderror  {
            }
define jpeg createcompress  {
 }
jcreacompress  {
 }
define jpeg createdecompress  {
 }
jcreadecompress  {
	unfruitfulnesses :: -1000
 }
define jpeg destroy compress jdestcompress  {
   }
define jpeg destroy decompress jdestdecompress  {
   }
define jpeg stdio dest jstddest  {
   }
define jpeg stdio src jstdsrc  {
   }
if jpeg lib version define jpeg mem dest jmemdest  {
       }
define jpeg mem src jmemsrc  {
   }
endif define jpeg set defaults jsetdefaults  {
    }
define jpeg set colorspace jsetcolorspace  {
   }
define jpeg default colorspace jdefcolorspace  {
   }
define jpeg set quality jsetquality  {
   }
define jpeg set linear  {
	linear :: -1000
  }
quality jsetlquality  {
 }
if jpeg lib version define jpeg default qtables  {
	 stable :: 11
	stabled :: 10
	stables :: 11
	stabler :: 10
	stablers :: 9
	stablest :: 9
      }
jdefqtables  {
 }
endif define jpeg add quant table jaddquanttable  {
     }
define jpeg quality scaling jqualityscaling  {
   }
define jpeg simple progression jsimprogress  {
   }
define jpeg suppress tables jsuppresstables  {
	eyries :: -1000
   }
define jpeg alloc quant table jalcqtable  {
    }
define jpeg alloc huff table jalchtable  {
	chelatable :: 13
    }
define jpeg start compress jstrtcompress  {
   }
define jpeg write scanlines jwrtscanlines  {
   }
define jpeg finish compress jfincompress  {
   }
if jpeg lib version define jpeg calc jpeg dimensions jcjpegdimensions  {
        }
endif define jpeg write raw data jwrtrawdata  {
     }
define jpeg write marker jwrtmarker  {
   }
define jpeg write m header jwrtmheader  {
	pavis :: -1000
    }
define jpeg write m byte jwrtmbyte  {
    }
define jpeg write tables jwrttables  {
	trustable :: 12
	turntables :: 13
	worktables :: 13
	twistable :: 13
   }
define jpeg read header jreadheader  {
   }
define jpeg start decompress jstrtdecompress  {
   }
define jpeg read scanlines jreadscanlines  {
   }
define jpeg finish decompress jfindecompress  {
   }
define jpeg read raw data jreadrawdata  {
	 naoi :: -1000
    }
define jpeg has multiple scans jhasmultscn  {
	vasoconstrictor :: -1000
    }
define jpeg start output jstrtoutput  {
   }
define jpeg finish output jfinoutput  {
   }
define jpeg input complete jincomplete  {
   }
define jpeg new colormap jnewcmap  {
   }
define jpeg consume input jconsumeinput  {
   }
if jpeg lib version define jpeg core output dimensions jcoredimensions  {
        }
endif define jpeg calc output dimensions jcalcdimensions  {
     }
define jpeg save markers jsavemarkers  {
	produces :: -1000
   }
define jpeg set marker processor jsetmarker  {
    }
define jpeg read coefficients jreadcoefs  {
   }
define jpeg write coefficients jwrtcoefs  {
   }
define jpeg copy critical parameters jcopycrit  {
    }
define jpeg abort compress jabrtcompress  {
   }
define jpeg abort decompress jabrtdecompress  {
   }
define jpeg abort jabort  {
	labor :: 7
	jabot :: 9
	tabor :: 9
	jato :: 7
	tabour :: 7
	tabors :: 8
	tabored :: 7
	taboret :: 7
	taborin :: 7
	jabots :: 8
  }
define jpeg destroy jdestroy  {
  }
define jpeg resync to restart jresyncrestart  {
    }
endif need short external names default error management setup extern struct jpeg error mgr jpeg std error jpp struct jpeg error mgr err initialization of jpeg compression objects jpeg create compress and jpeg create decompress are the exported names that applications should call these expand to calls on jpeg createcompress and jpeg createdecompress with additional information passed for version mismatch checking nb you must set up the error manager before calling jpeg create xxx define jpeg create compress cinfo jpeg createcompress cinfo jpeg lib version size t sizeof struct jpeg compress struct define jpeg create decompress cinfo jpeg createdecompress cinfo jpeg lib version size t sizeof struct jpeg decompress struct extern void jpeg createcompress jpp j compress ptr cinfo int version size t structsize  {
	                                                                                                                 strictures :: 12
	                                                                                                                securitizes :: 12
	                                                                                                                scrutinizes :: 13
                                                                                                                          }
extern void jpeg createdecompress jpp j decompress ptr cinfo int version size t structsize destruction  {
	   destruction :: -1000
             }
of jpeg compression objects extern void jpeg destroy compress jpp j compress ptr cinfo extern void jpeg destroy decompress jpp j decompress ptr cinfo standard data source and destination managers stdio streams caller is responsible  {
	                       responsible :: -1000
                                 }
for opening the file before and closing after extern void jpeg stdio dest jpp j compress ptr cinfo file outfile  {
	            sulfite :: 9
	           outlived :: 9
	           outlives :: 9
	           outliver :: 9
	           outlined :: 9
	           outlines :: 9
	           outliner :: 9
	         outfielder :: 9
	           outflies :: 11
	           outfired :: 10
	           outfires :: 10
	           outfield :: 11
	             outlie :: 10
	            outwile :: 11
	            outlive :: 10
	            outline :: 10
	            outlies :: 9
	            outlier :: 9
	            outflew :: 9
	            outfire :: 11
	            outfelt :: 9
	            outfeel :: 9
	          outfields :: 10
	          outrelief :: 9
	           outwiles :: 10
                  }
extern void jpeg stdio src jpp j decompress ptr cinfo file infile  {
	     inline :: 7
	     inlier :: 7
	      intil :: 7
	      infix :: 7
	     infill :: 8
	     infelt :: 7
	  infielder :: 7
	      elfin :: 7
	 infiltered :: 7
	 infiltrate :: 7
	    enfiled :: 8
	    unfiled :: 8
	   infilter :: 9
	   infilled :: 8
	   infields :: 8
	   infidels :: 9
	  infilters :: 8
	    infixed :: 8
	    infixes :: 8
	    infills :: 7
	    infield :: 9
          }
if jpeg lib version data source and destination managers memory buffers extern void jpeg mem dest jpp j compress ptr cinfo unsigned char outbuffer  {
	              outburned :: 11
	              outnumber :: 11
                      }
unsigned long outsize extern void jpeg mem src jpp j decompress ptr cinfo unsigned char inbuffer  {
	   insufferably :: 11
	   insufferable :: 10
	     unbuffered :: 10
	         rebuff :: 10
	      rebuffing :: 11
              }
unsigned long insize  {
	ionize :: 8
	ionise :: 7
	indites :: 7
	indices :: 7
	inside :: 9
	incites :: 7
	incised :: 7
	incises :: 7
	indies :: 7
	incise :: 8
	ionized :: 7
	ionizes :: 9
	ionizer :: 7
	citizens :: 7
	unsized :: 8
	invites :: 7
	iodizes :: 7
	insinew :: 7
	insider :: 8
	ionizers :: 8
	infixes :: 7
 }
endif default parameter setup for compression extern void jpeg set defaults jpp j compress ptr cinfo compression parameter setup aids  {
	               aids :: -1000
                  }
extern void jpeg set colorspace jpp j compress ptr cinfo j color space colorspace extern void jpeg default colorspace jpp j compress ptr cinfo extern void jpeg set quality jpp j compress ptr cinfo int quality boolean force baseline extern void jpeg set linear quality jpp j compress ptr cinfo int scale factor boolean force baseline if jpeg lib version extern void jpeg default qtables jpp j compress ptr cinfo boolean force baseline endif extern void jpeg add quant table jpp j compress ptr cinfo int which tbl const unsigned int basic table int scale factor boolean force baseline extern int jpeg quality scaling jpp int quality extern void jpeg simple progression jpp j compress ptr cinfo extern void jpeg suppress tables jpp j compress ptr cinfo boolean suppress extern jquant tbl jpeg alloc quant table jpp j common ptr cinfo extern jhuff tbl jpeg alloc huff table jpp j common ptr cinfo main entry points for compression extern void jpeg start compress jpp j compress ptr cinfo boolean write all tables extern jdimension jpeg write scanlines jpp j compress ptr cinfo jsamparray scanlines jdimension num lines extern void jpeg finish compress jpp j compress ptr cinfo if jpeg lib version precalculate  {
	                                                                                                                                                                                            precalculuses :: 15
	                                                                                                                                                                                               precalculi :: 15
	                                                                                                                                                                                             miscalculate :: 15
                                                                                                                                                                                                        }
jpeg dimensions for current compression parameters extern void jpeg calc jpeg dimensions jpp j compress ptr cinfo endif replaces jpeg write scanlines when writing raw downsampled data extern jdimension jpeg write raw data jpp j compress ptr cinfo jsampimage data jdimension num lines write a special marker see libjpeg txt concerning  {
	                                        concerning :: -1000
                                                 }
safe usage extern void jpeg write marker jpp j compress ptr cinfo int marker const joctet dataptr  {
               }
unsigned int datalen same but piecemeal  {
	piecemeal :: -1000
    }
extern void jpeg write m header jpp j compress ptr cinfo int marker unsigned int datalen extern void jpeg write m byte jpp j compress ptr cinfo int val alternate  {
	                    alternate :: -1000
                            }
compression function just write an abbreviated table file extern void jpeg write tables jpp j compress ptr cinfo decompression startup read start of jpeg datastream to see what s there extern int jpeg read header jpp j decompress ptr cinfo boolean require image return value is one of define jpeg suspended suspended due to lack of input data define jpeg header ok found valid image datastream define jpeg header tables only found valid table specs  {
	                                                                     specs :: -1000
                                                                         }
only datastream if you pass require image true normal case you need not check for a tables only return code an abbreviated file will cause an error exit jpeg suspended is only possible if you use a data source module that can give a suspension return the stdio source module doesn t main entry points for decompression extern boolean jpeg start decompress jpp j decompress ptr cinfo extern jdimension jpeg read scanlines jpp j decompress ptr cinfo jsamparray scanlines jdimension max lines extern boolean jpeg finish decompress jpp j decompress ptr cinfo replaces jpeg read scanlines when reading raw downsampled data extern jdimension jpeg read raw data jpp j decompress ptr cinfo jsampimage data jdimension max lines additional entry points for buffered image mode extern boolean jpeg has multiple scans jpp j decompress ptr cinfo extern boolean jpeg start output jpp j decompress ptr cinfo int scan number extern boolean jpeg finish output jpp j decompress ptr cinfo extern boolean jpeg input complete jpp j decompress ptr cinfo extern void jpeg new colormap jpp j decompress ptr cinfo extern int jpeg consume input jpp j decompress ptr cinfo return value is one of define jpeg suspended suspended due to lack of input data define jpeg reached sos reached start of new scan define jpeg reached eoi reached end of image define jpeg row completed completed one imcu row define jpeg scan completed completed last imcu row of a scan precalculate output dimensions for current decompression parameters if jpeg lib version extern void jpeg core output dimensions jpp j decompress ptr cinfo endif extern void jpeg calc output dimensions jpp j decompress ptr cinfo control saving  {
	                                                                                                                                                                                                                                                                            saving :: -1000
                                                                                                                                                                                                                                                                                 }
of com and appn markers into marker list extern void jpeg save markers jpp j decompress ptr cinfo int marker code unsigned int length limit install a special processing method for com or appn markers extern void jpeg set marker processor jpp j decompress ptr cinfo int marker code jpeg marker parser method routine read or write raw dct coefficients useful for lossless  {
	                                                      passless :: 10
	                                                      massless :: 10
	                                                      loamless :: 10
	                                                      lordless :: 10
	                                                      lensless :: 10
	                                                      loveless :: 10
	                                                      soulless :: 11
	                                                      soilless :: 11
	                                                      loftless :: 10
                                                             }
transcoding  {
	transonic :: 14
	wainscoting :: 14
	ancestoring :: 14
	transgenic :: 14
	transecting :: 14
	transducing :: 17
	transposing :: 15
	transsonic :: 14
 }
extern jvirt barray ptr jpeg read coefficients jpp j decompress ptr cinfo extern void jpeg write coefficients jpp j compress ptr cinfo jvirt barray ptr coef arrays extern void jpeg copy critical parameters jpp j decompress ptr srcinfo  {
	                               orcins :: 10
	                                orcin :: 9
                                    }
j compress ptr dstinfo  {
	dotings :: 9
  }
if you choose to abort compression or decompression before completing  {
	completing :: -1000
        }
jpeg finish de compress then you need to clean up to release memory temporary files etc you can just call jpeg destroy de compress if you re done with the jpeg object but if you want to clean it up and reuse  {
	                                    reuse :: -1000
                                        }
it call this extern void jpeg abort compress jpp j compress ptr cinfo extern void jpeg abort decompress jpp j decompress ptr cinfo generic versions of jpeg abort and jpeg destroy that work on either flavor of jpeg object these may be more convenient in some places extern void jpeg abort jpp j common ptr cinfo extern void jpeg destroy jpp j common ptr cinfo default restart marker resync procedure for use by data source modules extern boolean jpeg resync to restart jpp j decompress ptr cinfo int desired these marker codes are exported since applications and data source modules are likely to want to use them define jpeg rst xd rst marker code define jpeg eoi xd eoi marker code define jpeg app xe app marker code define jpeg com xfe com marker code if we have a brain damaged compiler that emits warnings or worse  {
	                                                                                                                                             worse :: -1000
                                                                                                                                                 }
errors for structure definitions that are never filled in keep it quiet by supplying dummy definitions for the various substructures  {
	      substructures :: -1000
                  }
ifdef incomplete types broken ifndef jpeg internals will be defined in jpegint h struct jvirt sarray control long dummy struct jvirt barray control long dummy struct jpeg comp master long dummy struct jpeg c main controller long dummy struct jpeg c prep controller long dummy struct jpeg c coef controller long dummy struct jpeg marker writer long dummy struct jpeg color converter long dummy struct jpeg downsampler long dummy struct jpeg forward dct long dummy struct jpeg entropy encoder long dummy struct jpeg decomp master long dummy struct jpeg d main controller long dummy struct jpeg d coef controller long dummy struct jpeg d post controller long dummy struct jpeg input controller long dummy struct jpeg marker reader long dummy struct jpeg entropy decoder long dummy struct jpeg inverse dct long dummy struct jpeg upsampler long dummy struct jpeg color deconverter long dummy struct jpeg color quantizer long dummy endif jpeg internals endif incomplete types broken the jpeg library modules define jpeg internals before including this file the internal structure declarations are read only when that is true applications using the library should not include jpegint h but may wish to include jerror h ifdef jpeg internals include jpegint h fetch private declarations include jerror h fetch error codes too endif ifdef cplusplus ifndef dont use extern c endif endif endif jpeglib h mode c c basic offset indent tabs mode nil copyright by the massachusetts institute of technology all rights reserved export of this software from the united  {
	                                                                                                                                                                                                                                                  united :: -1000
                                                                                                                                                                                                                                                       }
states  {
	states :: -1000
 }
of america  {
	avarice :: 9
 }
may require a specific license from the united states government  {
	government :: -1000
        }
it is the responsibility of any person or organization  {
	organization :: -1000
       }
contemplating  {
	contemplating :: -1000
 }
export to obtain such a license before exporting  {
	exporting :: -1000
      }
within that constraint  {
	constraint :: -1000
 }
permission to use copy modify and distribute this software and its documentation for any purpose and without fee is hereby granted provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting  {
	                                 supporting :: -1000
                                          }
documentation and that the name of m i t not be used in advertising or publicity  {
	      publicity :: -1000
              }
pertaining  {
	pertaining :: -1000
 }
to distribution of the software without specific written prior permission furthermore  {
	furthermore :: -1000
         }
if you modify this software you must label your software as modified software and not distribute it in such a fashion that it might be confused  {
	                 confused :: -1000
                        }
with the original m i t software m i t makes no representations  {
	representations :: -1000
           }
about the suitability  {
	suitability :: -1000
 }
of this software for any purpose it is provided as is without express or implied warranty copyright c by the fundsxpress  {
                   }
inc all rights reserved export of this software from the united states of america may require a specific license from the united states government it is the responsibility of any person or organization contemplating export to obtain such a license before exporting within that constraint permission to use copy modify and distribute this software and its documentation for any purpose and without fee is hereby granted provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation and that the name of fundsxpress not be used in advertising or publicity pertaining to distribution of the software without specific written prior permission fundsxpress makes no representations about the suitability of this software for any purpose it is provided as is without express or implied warranty this software is provided as is and without any express or implied warranties including without limitation the implied warranties of merchantibility  {
	                                                                                                                                              merchantability :: 26
	                                                                                                                                            merchantabilities :: 20
                                                                                                                                                            }
and fitness for a particular purpose copyright sun microsystems  {
       }
inc all rights reserved use is subject to license terms kdc  {
	      duck :: 3
	      dock :: 3
	      dick :: 3
	      deck :: 3
         }
database interface definitions this api is not considered as stable as the main krb  {
	          lar :: -1000
            }
api we may make arbitrary incompatible changes between feature releases e g from to we will make some effort  {
	            effort :: -1000
                 }
to avoid making incompatible changes for bugfix  {
	 buffi :: 7
	subfix :: 8
	buffing :: 7
     }
releases but will make them if necessary ifndef krb kdb  {
	      kob :: 3
	      kab :: 3
        }
define krb kdb include krb h this version will be incremented when incompatible changes are made to the kdb api and will be kept in sync with the libkdb  {
	                     kibbled :: 7
	                      libbed :: 7
                           }
major version define krb kdb api version salt types define krb kdb salttype  {
	    calotype :: 10
	   calotypes :: 11
	   allotypes :: 10
	   saltpeter :: 10
           }
normal define krb kdb salttype v define krb kdb salttype norealm  {
	  normalcy :: 9
	 normalize :: 10
	 normalise :: 10
	normalizes :: 9
	normalized :: 9
	normalises :: 9
	normalised :: 9
	normalcies :: 9
	    loreal :: 9
	   tonearm :: 9
	   normals :: 10
	    normal :: 11
	    boreal :: 9
         }
define krb kdb salttype onlyrealm  {
   }
define krb kdb salttype special define krb kdb salttype afs  {
	    afros :: 3
	     fast :: 3
	     fash :: 3
	     aufs :: 3
	     arfs :: 3
	      ifs :: 3
	      fas :: 4
	      efs :: 3
	      aws :: 3
	      ats :: 3
	      ass :: 3
	      ars :: 3
	      als :: 3
	      ais :: 3
	      ahs :: 3
	      aft :: 3
	      ads :: 3
	      abs :: 3
	       as :: 3
        }
define krb kdb salttype certhash  {
	berthas :: 10
	chetahs :: 10
	heptarchs :: 10
   }
attributes define krb kdb disallow  {
	disallow :: -1000
   }
postdated  {
	postdated :: -1000
 }
x define krb kdb disallow forwardable  {
    }
x define krb kdb disallow tgt  {
	  tut :: 3
	  tot :: 3
	  tit :: 3
	  tet :: 3
	  tat :: 3
    }
based x define krb kdb disallow renewable  {
	renewable :: -1000
     }
x define krb kdb disallow proxiable  {
	previable :: 12
	proximate :: 11
	printable :: 11
	droppable :: 11
	proximal :: 12
	proximately :: 11
	probeable :: 12
	expirable :: 11
    }
x define krb kdb disallow dup skey x define krb kdb disallow all tix  {
	        toxin :: 3
	        toxic :: 3
	        taxis :: 3
	         taxi :: 4
	         mixt :: 4
	        sixty :: 3
	        sixth :: 3
	        sixte :: 3
	         fixt :: 4
	          tux :: 3
	          tis :: 3
	          tip :: 3
	          tin :: 3
	          til :: 3
	          tig :: 3
	          tie :: 3
	          tid :: 3
	          tic :: 3
	          tax :: 3
	          six :: 3
	          pix :: 3
	          nix :: 3
	          mix :: 3
	           xi :: 3
	           ti :: 4
            }
x define krb kdb requires pre auth x define krb kdb requires hw auth x define krb kdb requires pwchange  {
	           verkramp :: -1000
                  }
x define krb kdb disallow svr x define krb kdb pwchange service x define krb kdb support desmd  {
	            dosed :: 6
	           desmid :: 8
	          desmoid :: 7
	          desmids :: 6
                }
x define krb kdb new princ x define krb kdb ok as delegate  {
	    delegate :: -1000
           }
x define krb kdb ok to auth as delegate x s u self ok define krb kdb no auth data required x creation flags define krb kdb create btree  {
	                      better :: 6
	                      berret :: 6
	                      bereft :: 6
	                      berate :: 6
	                      belter :: 6
	                      befret :: 6
	                      beater :: 6
	                       boree :: 7
	                       berme :: 6
	                       beret :: 7
	                      streel :: 6
	                      streek :: 6
	                       three :: 6
	                        bere :: 6
	                      brevet :: 6
	                      boreen :: 6
                           }
x define krb kdb create hash x private flag used to indicate principal is local tgs  {
	           tygs :: 3
	           tugs :: 3
	           togs :: 3
	           tigs :: 3
	           tegs :: 3
	           tags :: 3
	           gist :: 3
	           gest :: 3
	           gast :: 3
	          ngstr :: 3
	            ugs :: 3
	            tis :: 3
	            tes :: 3
	            tas :: 3
	             ts :: 3
              }
define krb kdb ticket  {
	ticket :: -1000
  }
granting  {
	granting :: -1000
 }
service x private flag used to indicate xrealm  {
	  areal :: 7
	  ureal :: 7
      }
relationship  {
	relationship :: -1000
 }
is non transitive  {
	transitive :: -1000
 }
define krb kdb xrealm non transitive x entry get flags name canonicalization  {
	technicalizations :: 21
	technicalization :: 22
          }
requested define krb kdb flag canonicalize  {
	canonical :: 17
	canonicals :: 16
	canonicate :: 15
    }
x include authorization data generated by backend  {
	banked :: 10
	backet :: 9
	backer :: 9
	backed :: 11
	backside :: 9
	backbend :: 9
     }
define krb kdb flag include pac x is as req client referrals  {
	  referrals :: -1000
          }
only define krb kdb flag client referrals only x map cross realm  {
	      realm :: -1000
          }
principals define krb kdb flag map principals x protocol transition  {
	transition :: -1000
        }
define krb kdb flag protocol transition x constrained  {
	constrained :: -1000
      }
delegation  {
	delegation :: -1000
 }
define krb kdb flag constrained delegation x user to user define krb kdb flag user to user x cross realm define krb kdb flag cross realm x allow in realm aliases define krb kdb flag alias ok x define krb kdb flags s u krb kdb flag protocol transition krb kdb flag constrained delegation if defined win note these structures cannot be modified without changing the database version number in libkdb a but should be expandable  {
	                                                                 expandable :: -1000
                                                                          }
by adding new tl data types typedef struct krb tl data struct krb tl data tl data next not saved krb int tl data type krb ui tl data length krb octet  {
	                          octet :: -1000
                              }
tl data contents krb tl data string attributes currently stored inside tl data map c string keys to values they can be set via kadmin  {
	                  diamin :: 7
	                 mankind :: 8
	                  daimon :: 7
	                  daimen :: 7
	                  aidmen :: 7
	                  aidman :: 7
	                  kamsin :: 8
	                 damming :: 7
	                  mawkin :: 7
	                 madling :: 7
	                  malkin :: 7
	                    kaim :: 7
	                    kadi :: 7
	                 kamsins :: 7
                       }
and consumed by kdc plugins  {
	pulsing :: 10
	pulings :: 9
	pausing :: 9
	paulins :: 10
	slusing :: 9
	slueing :: 9
	pausingly :: 9
	pluming :: 10
	plussing :: 9
	plugs :: 9
	purlings :: 9
	purlins :: 9
   }
typedef struct krb string attr st char key char value krb string attr if this ever changes up the version number and make the arrays be as big as necessary currently the first type is the enctype  {
	                             neotype :: 9
	                             ecotype :: 10
	                            ecotypes :: 9
	                             encrypt :: 9
	                           encrypted :: 10
                                   }
and the second is the salt type typedef struct krb key data krb int key data ver version krb int key data kvno  {
	                  kino :: 5
	                  keno :: 5
	                   kon :: 5
                     }
key version krb int key data type array of types krb ui key data length array of lengths krb octet key data contents array of pointers krb key data define krb kdb v key data array of array elements typedef struct krb keysalt  {
                                         }
krb int type krb data data length data krb keysalt a principal database entry extensions to this structure currently use the tl data list the e data and e length fields are not used by any calling code except kdb util dump and load which marshal  {
	                                      marshal :: -1000
                                            }
and unmarshal  {
 }
the array in the dump record kdb modules may use these fields internally as long as they set e length appropriately non zero if the data should be marshalled  {
	                  marshalled :: -1000
                           }
across dump and load zero if not and handle null e data values in caller constructed principal entries typedef struct krb db entry new krb magic magic not saved krb ui len krb ui mask members currently changed set krb flags attributes krb deltat  {
	                                      delta :: 9
	                                      dealt :: 7
	                                     desalt :: 7
	                                     dental :: 7
	                                     deltas :: 8
	                                    saltate :: 7
	                                    dictate :: 7
	                                   lactated :: 7
	                                    peltate :: 7
	                                    peltast :: 7
	                                   detrital :: 7
	                                   saltated :: 8
                                          }
max life  {
	life :: -1000
 }
krb deltat max renewable life krb timestamp expiration  {
	expiration :: -1000
      }
when the client expires  {
	expires :: -1000
  }
krb timestamp pw expiration when its passwd expires krb timestamp last success last successful passwd krb timestamp last failed last failed passwd attempt  {
	               attempt :: -1000
                     }
krb kvno fail auth count of failed passwd attempt krb int n tl data krb int n key data krb ui e length length of extra data krb octet e data extra data to be saved krb principal princ length data krb tl data tl data linked list krb key data key data array krb db entry typedef struct osa policy ent t int version char name krb ui pw min life krb ui pw max life krb ui pw min length krb ui pw min classes krb ui pw history num krb ui policy refcnt  {
	                                                                                         refect :: 7
	                                                                                         recent :: 7
	                                                                                         recant :: 8
	                                                                                        recants :: 7
	                                                                                           reft :: 7
                                                                                              }
only valid if version krb ui pw max fail pwdmaxfailure  {
        }
krb ui pw failcnt  {
	fatling :: 9
	catlin :: 9
  }
interval pwdfailurecountinterval  {
 }
krb ui pw lockout  {
	lockout :: -1000
  }
duration  {
	duration :: -1000
 }
pwdlockoutduration  {
 }
osa policy ent rec osa policy ent t typedef void osa adb  {
	      adobo :: 3
	      adobe :: 3
	       dabs :: 3
	       abed :: 3
	        dab :: 4
	        bad :: 3
	        alb :: 3
	        ads :: 3
	        ado :: 3
	        adi :: 3
	         ad :: 4
	         ab :: 3
          }
iter policy func void osa policy ent t typedef struct krb key salt tuple  {
	      pullets :: 6
	        duple :: 7
	        butle :: 6
	      duplets :: 7
	      tupelos :: 6
	       tupelo :: 7
	       tulles :: 6
	      outleap :: 6
	        tupek :: 6
	        tulle :: 7
	         tule :: 6
	       pullet :: 7
	       duplex :: 6
	       duplet :: 8
	          tup :: 6
            }
krb enctype ks enctype krb int ks salttype krb key salt tuple define krb kdb magic number xdbdbdbdb  {
                }
define krb kdb v base length define krb tl last pwd change x define krb tl mod princ x define krb tl kadm data x define krb tl kadm e data x define krb tl rb challenge  {
	                           challenge :: -1000
                                   }
x ifdef securid  {
	decuria :: 10
	scoured :: 9
	sciurid :: 10
	scaured :: 9
	decursion :: 9
	scurried :: 9
	securitan :: 9
	decurions :: 10
	security :: 10
	decurion :: 9
	securing :: 10
	decuries :: 10
	decurias :: 11
	secured :: 10
 }
define krb tl securid state x endif securid define krb tl user certificate  {
	 certificate :: -1000
           }
x define krb tl mkvno  {
   }
x define krb tl actkvno  {
   }
x define krb tl mkey  {
   }
aux x a string attributes may not always be represented in tl data kadmin clients  {
	       clients :: -1000
             }
must use the get strings and set string rpcs  {
	    rocs :: 5
       }
define krb tl string attrs  {
	yttrias :: 6
	attars :: 6
	astrut :: 6
	artist :: 6
	ottars :: 6
	attraps :: 6
	attorns :: 6
	attires :: 6
	tetras :: 6
	starts :: 6
	trats :: 6
	start :: 7
	tarts :: 6
	arts :: 6
   }
x b define krb tl pac logon  {
	lagoon :: 6
	 colon :: 6
	oolongs :: 6
	oulong :: 6
	logions :: 6
	oolong :: 7
	cogons :: 6
	oogonial :: 6
	locoing :: 6
	looing :: 7
	logion :: 7
	 solon :: 6
	  nolo :: 6
	  loon :: 6
	  logo :: 8
	oblong :: 6
	 logos :: 7
	 logoi :: 7
	 logan :: 6
     }
info x ndr encoded validation  {
	validation :: -1000
   }
info define krb tl server referral x asn encoded serverreferralinfo  {
        }
define krb tl svr referral data x asn encoded pa svr referral data define krb tl constrained delegation acl x each entry is a permitted spn  {
	                    sunup :: 3
	                     spun :: 4
	                     spin :: 4
	                     span :: 4
	                     snip :: 3
	                     snap :: 3
	                    spunk :: 3
	                    spoon :: 3
	                    spiny :: 3
	                    spink :: 3
	                    spine :: 3
	                    spina :: 3
	                    spent :: 3
	                    spend :: 3
	                    spean :: 3
	                    spawn :: 3
	                    spank :: 3
	                    spang :: 3
	                    spane :: 3
	                    spain :: 3
	                     puns :: 3
	                     pons :: 3
	                     pins :: 3
	                     pens :: 3
	                      spa :: 3
	                      son :: 3
	                      sin :: 3
	                      sen :: 3
	                      san :: 3
                        }
define krb tl lm key x lm owf  {
	    owt :: 3
	    ows :: 3
	    own :: 3
	    owl :: 3
	    owe :: 3
	    orf :: 3
	    off :: 3
	    oaf :: 3
	     ow :: 4
	     of :: 3
      }
define krb tl x subject issuer name x i issuerdn  {
	    issue :: 10
	 insureds :: 11
	   issuer :: 12
	   issued :: 11
        }
s subjectdn  {
	subjections :: 11
	subjecting :: 14
	subjection :: 13
	subjectify :: 11
	subtend :: 11
	subject :: 14
	subjected :: 13
	subjacent :: 12
	subjects :: 12
 }
define krb tl last admin unlock x timestamp of admin unlock define krb tl db args x fff version number for krb tl actkvno data define krb tl actkvno ver version number for krb tl mkey aux data define krb tl mkey aux ver typedef struct krb actkvno node struct krb actkvno node next krb kvno act kvno krb timestamp act time krb actkvno node typedef struct krb mkey aux node struct krb mkey aux node next krb kvno mkey kvno kvno of mkey protecting  {
	                                                                          protecting :: -1000
                                                                                   }
the latest  {
	latest :: -1000
 }
mkey krb key data latest mkey most recent mkey krb mkey aux node typedef struct krb keylist  {
	         stylise :: 9
	          skylit :: 9
               }
node krb keyblock  {
 }
keyblock krb kvno kvno struct krb keylist node next krb keylist node determines the number of failed kdc requests before disallow all tix is set on the principal define krb max fail count xxx depends on knowledge  {
	                           knowledge :: -1000
                                   }
of krb parse name formats define krb kdb m name k m kerberos  {
	    berberis :: 10
	   herborise :: 10
	    berserks :: 11
           }
master prompts  {
	prompts :: -1000
 }
used by default when reading the kdc password from the keyboard  {
	  keyboard :: -1000
         }
define krb kdc mkey enter  {
	enter :: -1000
   }
kdc database master key define krb kdc mkey re enter kdc database master key to verify extern char krb mkey pwd prompt extern char krb mkey pwd prompt these macros specify the encoding of data within the database data encoding is little endian ifdef krb int h include k platform h define krb kdb decode int cp i krb int i load le cp define krb kdb decode int cp i krb int i load le cp define krb kdb encode int i cp store le i cp define krb kdb encode int i cp store le i cp endif krb int h define krb kdb open rw define krb kdb open ro ifndef krb kdb srv  {
	                                                                                                               arvos :: 3
	                                                                                                               urvas :: 3
	                                                                                                               syver :: 3
	                                                                                                                revs :: 3
	                                                                                                               siver :: 3
	                                                                                                               sever :: 3
	                                                                                                               savor :: 3
	                                                                                                               saver :: 3
	                                                                                                                 sov :: 3
                                                                                                                   }
type kdc define krb kdb srv type kdc x endif ifndef krb kdb srv type admin define krb kdb srv type admin x endif ifndef krb kdb srv type passwd define krb kdb srv type passwd x endif ifndef krb kdb srv type other define krb kdb srv type other x endif define krb kdb opt set db name define krb kdb opt set lock mode define krb db lockmode  {
	                                                            locomoted :: 10
                                                                    }
shared x define krb db lockmode exclusive x define krb db lockmode dontblock  {
	   bootblack :: 11
	   roadblock :: 11
           }
x define krb db lockmode permanent x libkdb spec krb error code krb db setup lib handle krb context kcontext  {
                  }
krb error code krb db open krb context kcontext char db args int mode krb error code krb db init krb context kcontext krb error code krb db create krb context kcontext char db args krb error code krb db inited  {
	                                 inedita :: 7
	                                  untied :: 7
	                                 indited :: 7
	                                 indites :: 7
	                                  intoed :: 7
	                                  united :: 9
	                                 incited :: 7
	                                   indie :: 8
	                                  indite :: 8
	                                  indies :: 7
	                                  twined :: 7
	                                  dinted :: 7
	                                unitedly :: 7
	                                  trined :: 7
	                                  minted :: 7
	                                 invited :: 7
	                                  tinted :: 7
	                                  tineid :: 7
	                                  hinted :: 7
	                                  ointed :: 7
	                                intrepid :: 7
	                                   unite :: 7
	                                  vinted :: 7
                                       }
krb context kcontext krb error code kdb db create krb context kcontext char db args krb error code krb db fini krb context kcontext const char krb db errcode string krb context kcontext long err code krb error code krb db destroy krb context kcontext char db args krb error code krb db promote krb context kcontext char db args krb error code krb db get age krb context kcontext char db name time t t krb error code krb db lock krb context kcontext int lock mode krb error code krb db unlock krb context kcontext krb error code krb db get principal krb context kcontext krb const principal search for unsigned int flags krb db entry entry void krb db free principal krb context kcontext krb db entry entry krb error code krb db put principal krb context kcontext krb db entry entry krb error code krb db delete principal krb context kcontext krb principal search for krb error code krb db iterate  {
	                                                                                                                                                             iterate :: -1000
                                                                                                                                                                   }
krb context kcontext char match entry int func krb pointer krb db entry krb pointer func arg krb error code krb db store master key krb context kcontext char keyfile  {
	                       brigue :: -1000
                            }
krb principal mname  {
	anime :: 6
	mnemes :: 6
	madmen :: 7
	enamel :: 6
	mneme :: 7
 }
krb kvno kvno krb keyblock key char master pwd krb error code krb db store master key list krb context kcontext char keyfile krb principal mname krb keylist node keylist char master pwd krb error code krb db fetch mkey krb context context krb principal mname krb enctype etype  {
	                                           etape :: 7
	                                          etapes :: 6
                                               }
krb boolean fromkeyboard  {
 }
krb boolean twice  {
	twice :: -1000
 }
char db args krb kvno kvno krb data salt krb keyblock key krb error code krb db fetch mkey list krb context context krb principal mname const krb keyblock mkey krb kvno mkvno krb keylist node mkeys  {
                                   }
list free a master keylist void krb db free mkey list krb context context krb keylist node mkey list krb error code krb dbe  {
	                  diebs :: 3
	                   dieb :: 4
	                   debt :: 3
	                   debs :: 3
	                   bred :: 3
	                   bled :: 3
	                   abed :: 4
	                    obe :: 3
	                    dye :: 3
	                    due :: 3
	                    doe :: 3
	                    die :: 3
	                    dee :: 3
	                    dae :: 3
	                    bed :: 3
	                     de :: 3
                      }
find enctype krb context kcontext krb db entry dbentp  {
	   drent :: 7
       }
krb int ktype  {
 }
krb int stype  {
	stypses :: 6
	stupefy :: 7
	stepney :: 6
	styler :: 6
	styled :: 6
	stuped :: 6
	stoper :: 6
	stoped :: 6
	stipel :: 6
	stiped :: 6
	steepy :: 6
	style :: 7
	styed :: 6
	stupe :: 7
	stope :: 7
	stipe :: 7
	stye :: 7
	stey :: 6
	step :: 7
	slype :: 7
 }
krb int kvno krb key data kdatap  {
     }
krb error code krb dbe search enctype krb context kcontext krb db entry dbentp krb int start krb int ktype krb int stype krb int kvno krb key data kdatap krb error code krb db setup mkey name krb context context const char keyname  {
                                          }
const char realm char fullname  {
   }
krb principal principal decrypts the key given in a key data if a mkey is specified that master key is used if a mkey is null then all master keys are tried  {
	                          tried :: -1000
                              }
krb error code krb dbe decrypt key data krb context context const krb keyblock mkey const krb key data key data krb keyblock dbkey  {
	                  dykey :: 7
	                  dykes :: 6
	                  dikey :: 7
	                  byked :: 7
	                   dyke :: 7
	                   byke :: 6
                      }
krb keysalt keysalt krb error code krb dbe encrypt key data krb context context const krb keyblock mkey const krb keyblock dbkey const krb keysalt keysalt int keyver  {
	                      kerve :: 9
	                     kurvey :: 7
	                     kerves :: 8
	                     kerved :: 8
	                     kersey :: 7
	                    servery :: 7
	                    beavery :: 7
	                    knavery :: 7
                          }
krb key data key data krb error code krb dbe fetch act key list krb context context krb principal princ krb actkvno node act key list krb error code krb dbe find act mkey krb context context krb keylist node mkey list krb actkvno node act mkey list krb kvno act kvno krb keyblock act mkey krb error code krb dbe find mkey krb context context krb keylist node mkey list krb db entry entry krb keyblock mkey set mkvno to mkvno in entry tl data or if not present krb error code krb dbe lookup  {
	                                                                                         lookup :: -1000
                                                                                              }
mkvno krb context context krb db entry entry krb kvno mkvno set mkvno to mkvno in entry tl data or minimum value from mkey list krb error code krb dbe get mkvno krb context context krb db entry entry krb keylist node mkey list krb kvno mkvno krb error code krb dbe lookup mod princ data krb context context krb db entry entry krb timestamp mod time krb principal mod princ krb error code krb dbe lookup mkey aux krb context context krb db entry entry krb mkey aux node mkey aux data list krb error code krb dbe update mkvno krb context context krb db entry entry krb kvno mkvno krb error code krb dbe lookup actkvno krb context context krb db entry entry krb actkvno node actkvno list krb error code krb dbe update mkey aux krb context context krb db entry entry krb mkey aux node mkey aux data list krb error code krb dbe update actkvno krb context context krb db entry entry const krb actkvno node actkvno list krb error code krb dbe update last pwd change krb context context krb db entry entry krb timestamp stamp krb error code krb dbe update last admin unlock krb context context krb db entry entry krb timestamp stamp krb error code krb dbe lookup tl data krb context context krb db entry entry krb tl data ret tl data krb error code krb dbe create key data krb context context krb db entry entry krb error code krb dbe update mod princ data krb context context krb db entry entry krb timestamp mod date krb const principal mod princ void krb db alloc krb context kcontext void ptr size t size void krb db free krb context kcontext void ptr krb error code krb dbe lookup last pwd change krb context context krb db entry entry krb timestamp stamp krb error code krb dbe lookup last admin unlock krb context context krb db entry entry krb timestamp stamp retrieve the set of string attributes in entry in no particular order free strings out with krb dbe free strings when done krb error code krb dbe get strings krb context context krb db entry entry krb string attr strings out int count out retrieve a single string attribute from entry or null if there is no attribute for key free value out with krb dbe free string when done krb error code krb dbe get string krb context context krb db entry entry const char key char value out change or add a string attribute in entry or delete it if value is null krb error code krb dbe set string krb context context krb db entry entry const char key const char value krb error code krb dbe delete tl data krb context context krb db entry entry krb int tl data type krb error code krb dbe update tl data krb context context krb db entry entry krb tl data new tl data krb error code krb dbe cpw  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   dag :: -1000
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }
krb context kcontext krb keyblock master key krb key salt tuple ks tuple int ks tuple count char passwd int new kvno krb boolean keepold  {
	                  kelped :: 9
                       }
krb db entry db entry krb error code krb dbe ark  {
	       ark :: -1000
         }
krb context context krb keyblock master key krb key salt tuple ks tuple int ks tuple count krb db entry db entry krb error code krb dbe crk  {
	                      crook :: 3
	                      cronk :: 3
	                      croak :: 3
	                      creek :: 3
	                      creak :: 3
	                      crank :: 3
	                      crake :: 3
	                       cork :: 3
	                       cark :: 3
	                        irk :: 3
	                        erk :: 3
	                        cru :: 3
	                        cro :: 3
	                        ark :: 3
	                         kr :: 3
	                         cr :: 4
                          }
krb context context krb keyblock master key krb key salt tuple ks tuple int ks tuple count krb boolean keepold krb db entry db entry krb error code krb dbe apw  {
	                           bag :: -1000
                             }
krb context context krb keyblock master key krb key salt tuple ks tuple int ks tuple count char passwd krb db entry db entry int krb db get key data kvno krb context context int count krb key data data krb error code krb db sign authdata  {
	                                      automata :: 10
                                             }
krb context kcontext unsigned int flags krb const principal client princ krb db entry client krb db entry server krb db entry krbtgt  {
                     }
krb keyblock client key krb keyblock server key krb keyblock krbtgt key krb keyblock session key krb timestamp authtime  {
	          mutative :: 11
	        autotimers :: 11
	        autotheism :: 10
	          matutine :: 10
	         autotimer :: 12
                 }
krb authdata tgt auth data krb authdata signed auth data krb error code krb db check transited  {
	       transited :: -1000
               }
realms  {
	realms :: -1000
 }
krb context kcontext const krb data tr contents const krb data client realm const krb data server realm krb error code krb db check policy as krb context kcontext krb kdc req request krb db entry client krb db entry server krb timestamp kdc time const char status krb pa data e data krb error code krb db check policy tgs krb context kcontext krb kdc req request krb db entry server krb ticket ticket const char status krb pa data e data void krb db audit as req krb context kcontext krb kdc req request krb db entry client krb db entry server krb timestamp authtime krb error code error code void krb db refresh  {
	                                                                                                            refresh :: -1000
                                                                                                                  }
config krb context kcontext krb error code krb db check allowed to delegate krb context kcontext krb const principal client const krb db entry server krb const principal proxy  {
	                       proxy :: -1000
                           }
default functions should not be directly called default functions prototype krb error code krb dbe def search enctype krb context kcontext krb db entry dbentp krb int start krb int ktype krb int stype krb int kvno krb key data kdatap krb error code krb def store mkey list krb context context char keyfile krb principal mname krb keylist node keylist char master pwd krb error code krb db def fetch mkey krb context context krb principal mname krb keyblock key krb kvno kvno char db args krb error code krb def fetch mkey list krb context context krb principal mprinc  {
                                                                                                   }
const krb keyblock mkey krb kvno mkvno krb keylist node mkeys list krb error code krb dbe def cpw krb context context krb keyblock master key krb key salt tuple ks tuple int ks tuple count char passwd int new kvno krb boolean keepold krb db entry db entry krb error code krb dbe def decrypt key data krb context context const krb keyblock mkey const krb key data key data krb keyblock dbkey krb keysalt keysalt krb error code krb dbe def encrypt key data krb context context const krb keyblock mkey const krb keyblock dbkey const krb keysalt keysalt int keyver krb key data key data krb error code krb db create policy krb context kcontext osa policy ent t policy krb error code krb db get policy krb context kcontext char name osa policy ent t policy krb error code krb db put policy krb context kcontext osa policy ent t policy krb error code krb db iter policy krb context kcontext char match entry osa adb iter policy func func void data krb error code krb db delete policy krb context kcontext char policy void krb db free policy krb context kcontext osa policy ent t policy krb error code krb db set context krb context void db context krb error code krb db get context krb context void db context void krb dbe free key data contents krb context krb key data void krb dbe free key list krb context krb keylist node void krb dbe free actkvno list krb context krb actkvno node void krb dbe free mkey aux list krb context krb mkey aux node void krb dbe free tl data krb context krb tl data void krb dbe free strings krb context krb string attr int count void krb dbe free string krb context char define krb kdb def flags define kdb max db name define kdb realm section realms define kdb module pointer database module define kdb module def section dbdefaults  {
                                                                                                                                                                                                                                                                                                                                        }
define kdb module section dbmodules  {
	bemuddles :: 11
   }
define kdb lib pointer db library define kdb database conf file default secure profile path define kdb database env prof kdc profile env define krb kdb open rw define krb kdb open ro define krb kdb opt set db name define krb kdb opt set lock mode this number indicates the date of the last incompatible change to the dal  {
	                                                        dal :: -1000
                                                          }
the maj ver field of the module s vtable structure must match this version define krb kdb dal major version a krb context can hold one database object modules should use krb db set context and krb db get context to store state associated with the database object some module functions are mandatory  {
	                                           mandatory :: -1000
                                                   }
for kdc operation others are optional or apply only to administrative  {
	administrative :: -1000
         }
operations if a function is optional a module can leave the function pointer as null alternatively  {
	  alternatively :: -1000
              }
modules can return krb plugin op notsupp  {
     }
when asked  {
	asked :: -1000
 }
to perform an inapplicable  {
	inapplicable :: -1000
  }
action some module functions have default implementations  {
	implementations :: -1000
     }
which will call back into the vtable interface leave these functions as null to use the default implementations the documentation in these comments describes the dal as it is currently implemented and used not as it should be so if anything seems  {
	                                    seems :: -1000
                                        }
off that probably means the current state of things is off typedef struct kdb vftabl  {
	       vatable :: 8
	       votable :: 8
	        vatful :: 7
             }
short int maj ver short int min ver mandatory invoked after the module library is loaded when the first db using the module is opened across all contexts krb error code init library void mandatory invoked before the module library is unloaded  {
	                                 unloaded :: -1000
                                        }
after the last db using the module is closed across all contexts krb error code fini library void mandatory initialize a database object profile settings should be read from conf section inside kdb module section db args communicates command line arguments for module specific flags mode will be one of krb kdb open rw ro or d with one of krb kdb srv type kdc admin passwd other krb error code init module krb context kcontext char conf section char db args int mode mandatory finalize the database object contained in a context free any state contained in the db context pointer and null it out krb error code fini module krb context kcontext optional initialize a database object while creating the underlying  {
	                                                                                                                underlying :: -1000
                                                                                                                         }
database conf section and db args have the same meaning as in init module this function may return an error if the database already exists used by kdb util create if db args contains the value temporary the module should create an exclusively locked side copy of the database suitable for loading in a propagation  {
	                                           propagation :: -1000
                                                     }
from master to slave  {
	slave :: -1000
  }
this side copy will later be promoted  {
	promoted :: -1000
     }
with promote db allowing  {
	allowing :: -1000
  }
complete updates  {
	updates :: -1000
 }
of the db with no loss in read availability  {
	availability :: -1000
       }
if the module cannot comply  {
	comply :: -1000
   }
with this architecture it should return an error krb error code create krb context kcontext char conf section char db args optional destroy a database conf section and db args have the same meaning as in init module used by kdb util destroy in current usage the database is destroyed while open so the module should handle that krb error code destroy krb context kcontext char conf section char db args deprecated no longer used as of krb can be removed in the next dal revision modules should leave as null krb error code get age krb context kcontext char db name time t age optional lock the database with semantics  {
	                                                                                                     semantics :: -1000
                                                                                                             }
depending on the mode argument krb db lockmode shared lock may coexist  {
	    coexist :: -1000
          }
with other shared locks krb db lockmode exclusive lock may not coexist with other locks krb db lockmode permanent exclusive lock surviving  {
	            surviving :: -1000
                    }
process exit krb db lockmode dontblock is unused and unimplemented  {
	unimplemented :: -1000
        }
used by the kadmin lock command incremental  {
	incremental :: -1000
     }
propagation and kdb util dump incremental propagation support requires shared locks to operate  {
	     operate :: -1000
           }
kdb util dump will continue unlocked  {
	unlocked :: -1000
    }
if the module returns krb plugin op notsupp krb error code lock krb context kcontext int mode optional release a lock created with db lock krb error code unlock krb context kcontext mandatory set entry to an allocated entry for the principal search for if the principal is not found return krb kdb noentry  {
	                                               tonner :: 9
                                                    }
the meaning of flags are as follows krb kdb flag canonicalize set by the kdc when looking up entries for an as or tgs request with canonicalization requested determines whether the module should return out of realm referrals krb kdb flag include pac set by the kdc during an as request when the client requested pac information during padata  {
	                                                   patamar :: 7
	                                                   patacas :: 7
	                                                    zapata :: 8
	                                                   paratha :: 7
	                                                   panadas :: 7
	                                                  palatals :: 7
	                                                    pataca :: 8
	                                                    panada :: 8
	                                                   palatal :: 8
                                                         }
and during most tgs requests indicates that the module should include pac information when its sign authdata method is invoked krb kdb flag client referrals only set by the kdc when looking up the client entry in an as request affects how the module should return out of realm referrals krb kdb flag map principals set by the kdc when looking up the client entry during tgs requests except for s u tgs requests and requests where the server entry has the krb kdb no auth data required attribute indicates that the module should map foreign  {
	                                                                                        foreign :: -1000
                                                                                              }
principals to local principals if it supports doing so krb kdb flag protocol transition set by the kdc when looking up the client entry during an s u self tgs request this affects the pac information which should be included when authorization data is generated see the microsoft s u specification for details krb kdb flag constrained delegation set by the kdc when looking up the client entry during an s u proxy tgs request also affects pac generation krb kdb flag cross realm set by the kdc when looking up a client entry during a tgs request if the client principal is not part of the realm being served  {
	                                                                                                       served :: -1000
                                                                                                            }
krb kdb flag alias ok set by the kdc for server principal lookups  {
	     lookups :: -1000
           }
and for as request client principal lookups with canonicalization requested also set by the admin interface determines whether the module should return in realm aliases a module can return in realm aliases if krb kdb flag alias ok is set to return an in realm alias fill in a different value for entries princ than the one requested a module can return out of realm referrals if krb kdb flag canonicalize is set for as request clients krb kdb flag client referrals only is also set the module should do so by simply filling  {
	                                                                                      filling :: -1000
                                                                                            }
in an out of realm name in entries princ and setting all other fields to null otherwise the module should return the entry for the cross realm tgs of the referred to realm for tgs referals  {
	                           severals :: 10
	                            several :: 10
	                          referrals :: 10
	                             refers :: 11
	                           relearns :: 10
	                           generals :: 10
	                           reframes :: 10
	                              refer :: 10
	                            federal :: 10
	                           federals :: 12
	                           ruderals :: 10
                                  }
the module can also include tl data of type krb tl server referral containing asn encoded windows referral data as documented in draft  {
	                 draft :: -1000
                     }
ietf krb wg  {
	wog :: 2
	wig :: 2
	wag :: 2
 }
kerberos referrals appendix  {
	appendix :: -1000
 }
a this will be returned to the client as encrypted padata krb error code get principal krb context kcontext krb const principal search for unsigned int flags krb db entry entry mandatory free a database entry the entry may have been constructed by the caller using the db alloc function to allocate associated memory thus a plugin must allocate each field of a principal entry separately  {
	                                                       separately :: -1000
                                                                }
void free principal krb context kcontext krb db entry entry optional create or modify a principal entry db args communicates command line arguments for module specific flags the mask field of an entry indicates the changed fields mask values are defined in kadmin s admin h header if kadm principal is set in the mask the entry is new otherwise it already exists all fields of an entry are expected to contain correct values regardless of whether they are specified in the mask so it is acceptable  {
	                                                                            acceptable :: -1000
                                                                                     }
for a module to ignore the mask and update the entire entry krb error code put principal krb context kcontext krb db entry entry char db args optional delete the entry for the principal search for if the principal did not exist return krb kdb noentry krb error code delete principal krb context kcontext krb const principal search for optional for each principal entry in the database invoke func with the argments  {
	                                                               reagents :: 10
	                                                                sarment :: 11
	                                                              arguments :: 10
	                                                                margent :: 10
	                                                               regrants :: 10
	                                                               raiments :: 11
	                                                                garment :: 11
	                                                               augments :: 13
	                                                               segments :: 10
	                                                                augment :: 11
	                                                               migrants :: 10
	                                                                 ragmen :: 10
	                                                               ailments :: 10
	                                                               garments :: 13
	                                                               varments :: 11
	                                                               sarmenta :: 10
	                                                               sarments :: 11
	                                                               figments :: 10
	                                                               pigments :: 10
	                                                                argents :: 10
	                                                               margents :: 12
	                                                              augmentor :: 11
	                                                              segmental :: 10
	                                                             augmentors :: 12
	                                                               aliments :: 10
	                                                             augmenters :: 11
	                                                                segment :: 10
	                                                             segmentary :: 11
	                                                              argentums :: 10
                                                                      }
func arg and the entry data if match entry is specified the module may narrow the iteration to principal names matching that regular expression a module may alternatively ignore match entry krb error code iterate krb context kcontext char match entry int func krb pointer krb db entry krb pointer func arg optional create a password policy entry return an error if the policy already exists krb error code create policy krb context kcontext osa policy ent t policy optional set policy to the policy entry of the specified name if the entry does not exist return krb kdb noentry krb error code get policy krb context kcontext char name osa policy ent t policy optional modify an existing password policy entry to match the values in policy return an error if the policy does not already exist krb error code put policy krb context kcontext osa policy ent t policy optional for each password policy entry in the database invoke func with the argments data and the entry data if match entry is specified the module may narrow the iteration to policy names matching that regular expression a module may alternatively ignore match entry krb error code iter policy krb context kcontext char match entry osa adb iter policy func func void data optional delete the password policy entry with the name policy return an error if the entry does not exist krb error code delete policy krb context kcontext char policy optional free a policy entry returned by db get policy void free policy krb context kcontext osa policy ent t val mandatory has the semantics of realloc ptr size callers use this to allocate memory for new or changed principal entries so the module should expect to potentially  {
	                                                                                                                                                                                                                                                                                       potentially :: -1000
                                                                                                                                                                                                                                                                                                 }
see this memory in db free principal void alloc krb context kcontext void ptr size t size mandatory has the semantics of free ptr callers use this to free fields from a principal entry such as key data before changing it in place and in some cases to free data they allocated with db alloc void free krb context kcontext void ptr optional with default retrieve a master keyblock from the stash  {
	                                                                  stash :: -1000
                                                                      }
file db args filling in key and kvno mname is the name of the master principal for the realm the default implementation reads  {
	                 reads :: -1000
                     }
the master keyblock from a keytab  {
    }
or old format stash file krb error code fetch master key krb context kcontext krb principal mname krb keyblock key krb kvno kvno char db args optional with default given a keyblock for some version of the database s master key fetch the decrypted master key values from the database and store the list into mkeys list the caller will free mkeys list using a libkdb function which uses the standard free function so the module must not use a custom allocator  {
	                                                                        allocator :: -1000
                                                                                }
the caller may not know the version number of the master key it has in which case it will pass ignore vno  {
	                 vino :: 3
	                   on :: 3
                    }
the default implementation ignores  {
	ignores :: -1000
  }
kvno and tries the key against the current master key data and all krb tl mkey aux values which contain copies of the master keys encrypted with old master keys krb error code fetch master key list krb context kcontext krb principal mname const krb keyblock key krb kvno kvno krb keylist node mkeys list optional with default save a list of master keyblocks  {
                                                              }
obtained from fetch master key list into the stash file db arg the caller will set master pwd to null so the module should just ignore it mname is the name of the master principal for the realm the default implementation saves  {
	                                    saves :: -1000
                                        }
the list of master keys in a keytab format file krb error code store master key list krb context kcontext char db arg krb principal mname krb keylist node keylist char master pwd optional with default starting at position start scan the key data of a database entry for a key matching the enctype ktype the salt type stype and the version kvno store the resulting key into kdatap and set start to the position after the key found if ktype is negative match any enctype if stype is negative match any salt type if kvno is zero or negative find the most recent key version satisfying  {
	                                                                                                satisfying :: -1000
                                                                                                         }
the other constraints  {
	constraints :: -1000
 }
krb error code dbe search enctype krb context kcontext krb db entry dbentp krb int start krb int ktype krb int stype krb int kvno krb key data kdatap optional with default change the key data for db entry to include keys derived from the password passwd in each of the specified key salt types at version new kvno discard the old key data if keepold is not set the default implementation uses the keyblock master key to encrypt each new key via the function encrypt key data krb error code change pwd krb context context krb keyblock master key krb key salt tuple ks tuple int ks tuple count char passwd int new kvno krb boolean keepold krb db entry db entry optional promote a temporary database to be the live one context must be initialized with an exclusively locked database created with the temporary db arg on success the database object contained in context will be finalized  {
	                                                                                                                                                     finalized :: -1000
                                                                                                                                                             }
this method is used by kdb util load to replace the live database with minimal loss of read availability krb error code promote db krb context context char conf section char db args optional with default decrypt the key in key data with master keyblock mkey placing the result into dbkey copy the salt from key data if any into keysalt either dbkey or keysalt may be left unmodified on successful return if key data does not contain key or salt information the default implementation expects the encrypted key in krb c encrypt format to be stored in key data contents with length given by key data length if key data ver is it expects the salt to be stored unencrypted  {
                                                                                                                       }
in key data contents with length given by key data length krb error code decrypt key data krb context kcontext const krb keyblock mkey const krb key data key data krb keyblock dbkey krb keysalt keysalt optional with default encrypt dbkey with master keyblock mkey placing the result into key data along with keysalt the default implementation stores the encrypted key in krb c encrypt format in key data contents and the length in key data length if keysalt is specified it sets key data ver to and stores the salt in key data contents and its length in key data length if keysalt is not specified key data ver is set to krb error code encrypt key data krb context kcontext const krb keyblock mkey const krb keyblock dbkey const krb keysalt keysalt int keyver krb key data key data optional generate signed authorization data such as a windows pac for the ticket to be returned to the client place the signed authorization data if any in signed auth data this function will be invoked for an as request if the client included padata requesting  {
	                                                                                                                                                                               requesting :: -1000
                                                                                                                                                                                        }
a pac this function will be invoked for a tgs request if there is authorization data in the tgt if the client is from another realm or if the tgs request is an s u self or s u proxy request this function will not be invoked during tgs requests if the server principal has the no auth data required attribute set input parameters are flags the flags used to look up the client principal client princ for s u proxy tgs requests the client principal requested by the service for regular tgs requests the possibly canonicalized  {
	                                                                                   technicalized :: 16
	                                                                                       canonical :: 17
	                                                                                      canonicals :: 16
                                                                                               }
client principal client the db entry of the client for s u self this will be the db entry for the client principal requested by the service server the db entry of the service principal krbtgt for tgs requests the db entry of the possibly foreign ticket granting service of the tgt for as requests the db entry of the service principal client key the reply  {
	                                                            reply :: -1000
                                                                }
key for the kdc request before any fast armor is applied for as requests this may be the client s long term key or a key chosen by a preauth  {
	                       precut :: 9
	                       preact :: 9
	                     preaudit :: 9
	                      unearth :: 9
                            }
mechanism for tgs requests this may be the subkey  {
	 punkeys :: 7
	 turkeys :: 7
	   busky :: 7
	  busket :: 7
	  busker :: 7
	  busked :: 7
	  burkes :: 7
       }
found in the ap req or the session key of the tgt server key the server key used to encrypt the returned ticket krbtgt key for tgs requests the key of the possibly foreign ticket granting service of the tgt for as requests the service principal s key session key the session key of the ticket being granted to the requestor  {
	                                                   requestor :: -1000
                                                           }
authtime the timestamp of the original client authentication time for as requests this is the current time for tgs requests this is the authtime of the subject ticket tgt or s u proxy evidence  {
	                         evidence :: -1000
                                }
ticket tgt auth data for tgs requests the authorization data present in the subject ticket for as requests null krb error code sign authdata krb context kcontext unsigned int flags krb const principal client princ krb db entry client krb db entry server krb db entry krbtgt krb keyblock client key krb keyblock server key krb keyblock krbtgt key krb keyblock session key krb timestamp authtime krb authdata tgt auth data krb authdata signed auth data optional perform a policy check on a cross realm ticket s transited field and return an error other than krb plugin op notsupp if the check fails krb error code check transited realms krb context kcontext const krb data tr contents const krb data client realm const krb data server realm optional perform a policy check on an as request in addition to the standard policy checks return if the as request is allowed if the as request is not allowed place a short string literal into status if desired place data into e data any data placed here will be freed by the caller using the standard free function return an appropriate error such as kdc err policy krb error code check policy as krb context kcontext krb kdc req request krb db entry client krb db entry server krb timestamp kdc time const char status krb pa data e data optional perform a policy check on a tgs request in addition to the standard policy checks return if the tgs request is allowed if the tgs request is not allowed place a short string literal into status if desired place data into e data any data placed here will be freed by the caller using the standard free function return an appropriate error such as kdc err policy the input parameter ticket contains the tgt used in the tgs request krb error code check policy tgs krb context kcontext krb kdc req request krb db entry server krb ticket ticket const char status krb pa data e data optional this method informs  {
	                                                                                                                                                                                                                                                                                                                                            informs :: -1000
                                                                                                                                                                                                                                                                                                                                                  }
the module of a successful or unsuccessful  {
	unsuccessful :: -1000
     }
as request void audit as req krb context kcontext krb kdc req request krb db entry client krb db entry server krb timestamp authtime krb error code error code note there is currently no method for auditing tgs requests optional this method informs the module of a request to reload  {
	                                           reload :: -1000
                                                }
configuration or other state that is the kdc received a sighup  {
	   sighful :: 7
	    pignus :: 7
	    pights :: 7
	      sugh :: 7
	      sigh :: 8
	     sight :: 7
	     pughs :: 7
         }
void refresh config krb context kcontext optional perform a policy check on server being allowed to obtain tickets  {
	          tickets :: -1000
                }
from client to proxy note that proxy is the target of the delegation not the delegating  {
	     delegating :: -1000
              }
service the term proxy is from the viewpoint  {
	viewpoint :: -1000
      }
of the delegating service asking  {
	asking :: -1000
   }
another service to perform some of its work in the authentication context of the client this terminology  {
	     terminology :: -1000
               }
comes  {
	comes :: -1000
 }
from the microsoft s u protocol documentation return if policy allows it or an appropriate error such as krb kdc err policy if not if this method is not implemented all s u proxy delegation requests will be rejected  {
	                              rejected :: -1000
                                     }
krb error code check allowed to delegate krb context context krb const principal client const krb db entry server krb const principal proxy kdb vftabl endif defined win endif krb kdb mode c c basic offset indent tabs mode nil the mit kerberos header file krb h used to live here as of the release we re installing  {
	                                               installing :: -1000
                                                        }
multiple kerberos headers so they re all moving  {
	 moving :: -1000
      }
to a krb subdirectory  {
	subdirectors :: 20
	subdirector :: 22
  }
this file is present just to keep old software still compiling please update your code to use the new path for the header include krb krb h access to locale dependent parameters copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef langinfo  {
	                                                                                                                                                                landing :: 10
	                                                                                                                                                                 ganoin :: 10
	                                                                                                                                                                loaning :: 10
	                                                                                                                                                                loafing :: 10
	                                                                                                                                                                 longan :: 10
                                                                                                                                                                      }
h define langinfo h get the type definition include nl types h include bits locale h define the lc category names begin decls construct an nl item  {
	                      item :: -1000
                         }
value for nl langinfo from a locale category lc and an item index within the category some code may depend on the item values within a category increasing  {
	                 increasing :: -1000
                          }
monotonically  {
	monotonically :: -1000
 }
with the indices define nl item category index category index extract the category and item index from a constructed nl item value define nl item category item int item define nl item index item int item xffff enumeration of locale items  {
	                                   items :: -1000
                                       }
that can be queried  {
	queried :: -1000
  }
with nl langinfo enum lc time category date and time formatting  {
	formatting :: -1000
         }
abbreviated days of the week  {
	week :: -1000
   }
abday  {
	bayad :: 6
 }
nl item lc time sun define abday abday abday define abday abday abday define abday abday abday define abday abday abday define abday abday abday define abday abday abday define abday abday long named days of the week day sunday  {
	                                sundaes :: 7
	                                bendays :: 7
	                                runways :: 7
	                                 sunray :: 9
	                                 sundry :: 9
	                                 sundra :: 8
	                                 sundae :: 9
	                                 suldan :: 8
	                                 sudary :: 7
	                                 bunyas :: 7
	                                   sand :: 7
	                                  sandy :: 8
	                                 soudan :: 7
	                                sunward :: 7
	                                sunrays :: 7
	                                sundial :: 7
	                                sundari :: 8
                                      }
define day day day monday  {
	honda :: 7
	mordantly :: 7
	donary :: 7
	fonda :: 7
	mordancy :: 8
	mornay :: 8
	monody :: 7
	monads :: 7
	mordant :: 7
	zonda :: 7
	mondial :: 7
	mondain :: 7
	yond :: 7
	mona :: 7
	mand :: 7
	mandatory :: 7
	dynamo :: 7
	monde :: 7
	monad :: 8
   }
define day day day tuesday  {
	outstayed :: 9
   }
define day day day wednesday  {
   }
define day day day thursday  {
   }
define day day day friday  {
	stuping :: -1000
   }
define day day day saturday  {
	satyra :: 10
	daturas :: 11
	salutary :: 10
   }
define day day abbreviated month names abmon  {
	ambones :: 6
	bemoan :: 6
	 ammon :: 7
	 abmho :: 6
	ammons :: 6
	almond :: 6
	abdomen :: 6
	  ambo :: 6
     }
jan  {
	junta :: 3
	kanji :: 3
	jaunt :: 3
	janty :: 4
	janes :: 4
	banjo :: 3
	jean :: 3
	jann :: 4
	jane :: 5
	jansky :: 3
	janker :: 3
	jangly :: 3
	jangle :: 3
	wan :: 3
	van :: 3
	tan :: 3
	san :: 3
	ran :: 3
	pan :: 3
	nan :: 3
	man :: 3
	jin :: 3
	jay :: 3
	jaw :: 3
	jar :: 3
	jap :: 3
	jam :: 3
	jag :: 3
	jab :: 3
	han :: 3
	gan :: 3
	fan :: 3
	dan :: 3
	can :: 3
	ban :: 3
	na :: 3
 }
define abmon abmon abmon define abmon abmon abmon define abmon abmon abmon define abmon abmon abmon define abmon abmon abmon define abmon abmon abmon define abmon abmon abmon define abmon abmon abmon define abmon abmon abmon define abmon abmon abmon define abmon abmon abmon define abmon abmon long month names mon january  {
	                                            manuary :: 11
	                                             jaguar :: 9
                                                  }
define mon mon mon define mon mon mon define mon mon mon define mon mon mon define mon mon mon define mon mon mon define mon mon mon define mon mon mon define mon mon mon define mon mon mon define mon mon mon define mon mon am str ante  {
	                                             ante :: -1000
                                                }
meridiem  {
 }
string define am str am str pm str post meridiem string define pm str pm str d t fmt date and time format for strftime  {
	               foretimes :: 10
	               termtimes :: 10
                       }
define d t fmt d t fmt d fmt date format for strftime define d fmt d fmt t fmt time format for strftime define t fmt t fmt t fmt ampm  {
	                            amp :: 5
                              }
hour time format for strftime define t fmt ampm t fmt ampm era alternate era define era era era year year in alternate era format ifdef use gnu define era year era year endif era d fmt date in alternate era format define era d fmt era d fmt alt digits  {
	                                            digits :: -1000
                                                 }
alternate symbols for digits define alt digits alt digits era d t fmt date and time in alternate era format define era d t fmt era d t fmt era t fmt time in alternate era format define era t fmt era t fmt nl time era num entries number entries in the era arrays nl time era entries structure with era entries in usable form nl wabday  {
	                                                        dissemblers :: -1000
                                                                  }
sun nl wabday nl wabday nl wabday nl wabday nl wabday nl wabday long named days of the week nl wday  {
	          ultrashort :: -1000
                   }
sunday nl wday monday nl wday tuesday nl wday wednesday nl wday thursday nl wday friday nl wday saturday abbreviated month names nl wabmon  {
	                 bowman :: 8
                      }
jan nl wabmon nl wabmon nl wabmon nl wabmon nl wabmon nl wabmon nl wabmon nl wabmon nl wabmon nl wabmon nl wabmon long month names nl wmon  {
	                       woon :: 5
	                       mown :: 5
                          }
january nl wmon nl wmon nl wmon nl wmon nl wmon nl wmon nl wmon nl wmon nl wmon nl wmon nl wmon nl wam  {
	                  wampus :: 3
	                  wampee :: 3
	                  wambly :: 3
	                  wamble :: 3
	                   woman :: 3
	                   wasms :: 3
	                   warms :: 3
	                   wames :: 4
	                   wamed :: 4
	                    wham :: 3
	                    wasm :: 4
	                    warm :: 4
	                    wame :: 5
	                    maws :: 3
	                    mawr :: 3
	                    mawn :: 3
	                    mawk :: 3
	                     yam :: 3
	                     wem :: 3
	                     way :: 3
	                     wax :: 3
	                     wat :: 3
	                     was :: 3
	                     war :: 3
	                     wap :: 3
	                     wan :: 3
	                     wag :: 3
	                     wae :: 3
	                     wad :: 3
	                     wab :: 3
	                     tam :: 3
	                     sam :: 3
	                     ram :: 3
	                     pam :: 3
	                     nam :: 3
	                     maw :: 4
	                     mam :: 3
	                     lam :: 3
	                     kam :: 3
	                     jam :: 3
	                     ham :: 3
	                     gam :: 3
	                     dam :: 3
	                     bam :: 3
	                      ma :: 3
                       }
str ante meridiem string nl wpm  {
	wimpy :: 3
	wimps :: 3
	 wimp :: 4
	  wem :: 3
    }
str post meridiem string nl wd t fmt date and time format for strftime nl wd fmt date format for strftime nl wt fmt time format for strftime nl wt fmt ampm hour time format for strftime nl wera  {
	                                 dewar :: 5
	                                 wreak :: 5
	                                 wears :: 5
	                                 wares :: 5
	                                 wared :: 5
	                                  weta :: 5
	                                  wert :: 5
	                                  weka :: 5
	                                  wear :: 6
	                                  ware :: 6
	                                  vera :: 5
	                                  sera :: 5
	                                 sewar :: 5
	                                 rewax :: 5
	                                 rewan :: 5
	                                 resaw :: 5
	                                   war :: 5
                                     }
year year in alternate era format nl wera d fmt date in alternate era format nl walt  {
	          wattle :: 5
	          wastel :: 5
	          walnut :: 5
	         waltzed :: 5
	         waltzes :: 5
	         waltzer :: 5
	           waltz :: 7
	            wilt :: 5
	            welt :: 5
	            watt :: 5
	            wast :: 5
	            wart :: 5
	            want :: 5
	            waly :: 5
	            walk :: 5
	            wali :: 5
	            wale :: 5
	            wald :: 5
	            wait :: 5
	            waft :: 5
	            salt :: 5
	            malt :: 5
	            halt :: 5
	            dalt :: 5
	             wat :: 5
               }
digits alternate symbols for digits nl wera d t fmt date and time in alternate era format nl wera t fmt time in alternate era format nl time week ndays  {
	                        drays :: 6
	                        adays :: 7
                            }
nl time week stday  {
	strayed :: 7
	todays :: 7
	steady :: 7
	stayed :: 6
	today :: 6
	stray :: 7
	strad :: 6
	stead :: 6
	stagy :: 6
	stay :: 6
	satay :: 6
	sadly :: 6
  }
nl time week stweek  {
	etwee :: 7
	streeks :: 7
	atweels :: 7
	etwees :: 8
	streek :: 9
	stewed :: 7
	steek :: 7
  }
nl time first weekday  {
	weekday :: -1000
  }
nl time first workday  {
	workday :: -1000
  }
nl time cal direction nl time timezone  {
	semitone :: 10
	monetize :: 10
	zonetime :: 10
     }
date fmt strftime format for date define date fmt date fmt nl w date fmt nl time codeset nl num lc time number of indices in lc time category lc collate  {
	                       collate :: -1000
                             }
category text sorting this information is accessed  {
	accessed :: -1000
     }
by the strcoll  {
	stroll :: 9
 }
and strxfrm  {
 }
functions these nl langinfo names are used only internally nl collate nrules  {
	     prunes :: 8
	     inures :: 7
	     uncles :: 7
	     rubles :: 7
	     cruels :: 7
	   neurosal :: 7
	    runless :: 7
	    runlets :: 7
	     enures :: 7
	     loures :: 7
	     nursle :: 7
	     nurses :: 7
	     gruels :: 7
	     nurled :: 7
	      nurse :: 7
	      nurls :: 7
	      noule :: 7
	     urines :: 7
	      neurs :: 7
          }
nl item lc collate nl collate rulesets  {
	cureless :: 10
	ruthless :: 10
	rustless :: 10
	riteless :: 10
	rustles :: 10
	ruleless :: 11
	solerets :: 11
	tuneless :: 10
	tubeless :: 10
     }
nl collate tablemb  {
	table :: 9
 }
nl collate weightmb  {
	weighty :: 11
	weights :: 11
	weight :: 12
	weigh :: 10
 }
nl collate extramb  {
	extra :: 10
	extrema :: 9
	extras :: 9
 }
nl collate indirectmb  {
	indirectly :: 14
	indirect :: 16
	indicter :: 12
 }
nl collate gap  {
	gap :: -1000
 }
nl collate gap nl collate gap nl collate tablewc  {
	   cable :: 9
	   table :: 10
	  tables :: 9
	  tabled :: 9
	  cablet :: 10
       }
nl collate weightwc  {
	weighty :: 10
	weights :: 10
	weight :: 11
 }
nl collate extrawc  {
	extra :: 10
	extract :: 9
	extras :: 9
 }
nl collate indirectwc  {
	indirectly :: 13
	indirect :: 15
	indicter :: 12
	endocritic :: 12
 }
nl collate symb hash sizemb  {
	sizeably :: 7
	bizes :: 8
	mizens :: 7
	size :: 8
	sizer :: 7
	sized :: 7
	bize :: 7
   }
nl collate symb tablemb nl collate symb extramb nl collate collseqmb  {
         }
nl collate collseqwc  {
 }
nl collate codeset nl num lc collate lc ctype category character classification this information is accessed by the functions in ctype h these nl langinfo names are used only internally nl ctype class nl item lc ctype nl ctype toupper nl ctype gap nl ctype tolower nl ctype gap nl ctype class nl ctype gap nl ctype gap nl ctype gap nl ctype gap nl ctype class names nl ctype map names nl ctype width nl ctype mb cur max nl ctype codeset name codeset nl ctype codeset name define codeset codeset nl ctype toupper nl ctype tolower nl ctype class offset nl ctype map offset nl ctype indigits  {
	                                                                                                    incipits :: 10
	                                                                                                   indigotin :: 10
	                                                                                                    inditing :: 10
	                                                                                                    indicias :: 10
	                                                                                                  indigotins :: 11
	                                                                                                    iodising :: 10
                                                                                                           }
mb len nl ctype indigits mb nl ctype indigits mb nl ctype indigits mb nl ctype indigits mb nl ctype indigits mb nl ctype indigits mb nl ctype indigits mb nl ctype indigits mb nl ctype indigits mb nl ctype indigits mb nl ctype indigits wc len nl ctype indigits wc nl ctype indigits wc nl ctype indigits wc nl ctype indigits wc nl ctype indigits wc nl ctype indigits wc nl ctype indigits wc nl ctype indigits wc nl ctype indigits wc nl ctype indigits wc nl ctype outdigit  {
	                                                                               inaugurate :: -1000
                                                                                        }
mb nl ctype outdigit mb nl ctype outdigit mb nl ctype outdigit mb nl ctype outdigit mb nl ctype outdigit mb nl ctype outdigit mb nl ctype outdigit mb nl ctype outdigit mb nl ctype outdigit mb nl ctype outdigit wc nl ctype outdigit wc nl ctype outdigit wc nl ctype outdigit wc nl ctype outdigit wc nl ctype outdigit wc nl ctype outdigit wc nl ctype outdigit wc nl ctype outdigit wc nl ctype outdigit wc nl ctype translit tab size nl ctype translit from idx nl ctype translit from tbl nl ctype translit to idx nl ctype translit to tbl nl ctype translit default missing len nl ctype translit default missing nl ctype translit ignore len nl ctype translit ignore nl ctype map to nonascii  {
	                                                                                                                      nonacids :: 10
	                                                                                                                     nonacidic :: 10
	                                                                                                                   nonartistic :: 10
	                                                                                                                         nonas :: 10
                                                                                                                             }
nl ctype nonascii case nl ctype extra map nl ctype extra map nl ctype extra map nl ctype extra map nl ctype extra map nl ctype extra map nl ctype extra map nl ctype extra map nl ctype extra map nl ctype extra map nl ctype extra map nl ctype extra map nl ctype extra map nl ctype extra map nl num lc ctype lc monetary  {
	                                                         monetary :: -1000
                                                                }
category formatting of monetary quantities these items each correspond to a member of struct lconv  {
	          clon :: 6
             }
defined in locale h int curr symbol nl item lc monetary ifdef use gnu define int curr symbol int curr symbol endif currency  {
	              currency :: -1000
                     }
symbol ifdef use gnu define currency symbol currency symbol endif mon decimal point ifdef use gnu define mon decimal point mon decimal point endif mon thousands  {
	                thousands :: -1000
                        }
sep ifdef use gnu define mon thousands sep mon thousands sep endif mon grouping ifdef use gnu define mon grouping mon grouping endif positive sign ifdef use gnu define positive sign positive sign endif negative sign ifdef use gnu define negative sign negative sign endif int frac digits ifdef use gnu define int frac digits int frac digits endif frac digits ifdef use gnu define frac digits frac digits endif p cs precedes  {
	                                                                precedes :: -1000
                                                                       }
ifdef use gnu define p cs precedes p cs precedes endif p sep by space ifdef use gnu define p sep by space p sep by space endif n cs precedes ifdef use gnu define n cs precedes n cs precedes endif n sep by space ifdef use gnu define n sep by space n sep by space endif p sign posn  {
	                                                       pounds :: 5
	                                                       postin :: 5
	                                                       posnet :: 6
	                                                       posing :: 5
	                                                       points :: 5
	                                                       poinds :: 5
	                                                         posy :: 5
	                                                         post :: 5
	                                                         posh :: 5
	                                                         pose :: 5
	                                                         porn :: 5
	                                                         pons :: 6
	                                                        porns :: 6
	                                                        poons :: 5
	                                                        pongs :: 5
	                                                        pones :: 5
	                                                        ponds :: 5
	                                                        pions :: 5
	                                                        peons :: 5
	                                                          pos :: 6
	                                                          nos :: 5
                                                            }
ifdef use gnu define p sign posn p sign posn endif n sign posn ifdef use gnu define n sign posn n sign posn endif nl monetary crncystr  {
                          }
define crncystr nl monetary crncystr int p cs precedes ifdef use gnu define int p cs precedes int p cs precedes endif int p sep by space ifdef use gnu define int p sep by space int p sep by space endif int n cs precedes ifdef use gnu define int n cs precedes int n cs precedes endif int n sep by space ifdef use gnu define int n sep by space int n sep by space endif int p sign posn ifdef use gnu define int p sign posn int p sign posn endif int n sign posn ifdef use gnu define int n sign posn int n sign posn endif nl monetary duo  {
	                                                                                                                duo :: -1000
                                                                                                                  }
int curr symbol nl monetary duo currency symbol nl monetary duo int frac digits nl monetary duo frac digits nl monetary duo p cs precedes nl monetary duo p sep by space nl monetary duo n cs precedes nl monetary duo n sep by space nl monetary duo int p cs precedes nl monetary duo int p sep by space nl monetary duo int n cs precedes nl monetary duo int n sep by space nl monetary duo p sign posn nl monetary duo n sign posn nl monetary duo int p sign posn nl monetary duo int n sign posn nl monetary uno valid from nl monetary uno valid to nl monetary duo valid from nl monetary duo valid to nl monetary conversion rate  {
	                                                                                                                        rate :: -1000
                                                                                                                           }
nl monetary decimal point wc nl monetary thousands sep wc nl monetary codeset nl num lc monetary lc numeric category formatting of numbers these also correspond to members of struct lconv see locale h decimal point nl item lc numeric ifdef use gnu define decimal point decimal point endif radixchar  {
	                                        radicular :: 11
                                                }
decimal point define radixchar radixchar thousands sep ifdef use gnu define thousands sep thousands sep endif thousep  {
	          trouse :: 9
	         shouted :: 9
	         shouter :: 9
	         troupes :: 9
	         thorpes :: 9
	          chouse :: 9
	           thous :: 10
               }
thousands sep define thousep thousep grouping ifdef use gnu define grouping grouping endif nl numeric decimal point wc nl numeric thousands sep wc nl numeric codeset nl num lc numeric yesexpr  {
                             }
nl item lc messages regex matching yes input define yesexpr yesexpr noexpr  {
	     plexor :: 7
          }
regex matching no input define noexpr noexpr yesstr  {
	shyster :: 7
	 tusser :: 7
	 tosser :: 7
	 resits :: 7
	russety :: 7
	 reasty :: 7
	pessary :: 7
	 yeasts :: 7
	  yeast :: 7
	xysters :: 7
	  rests :: 7
	oysters :: 7
      }
output string for yes if defined use gnu defined use xopen defined use xopen k define yesstr yesstr endif nostr output string for no if defined use gnu defined use xopen defined use xopen k define nostr nostr endif nl messages codeset nl num lc messages nl paper  {
	                                          paper :: -1000
                                              }
height nl item lc paper nl paper width nl paper codeset nl num lc paper nl name name fmt nl item lc name nl name name gen nl name name mr nl name name mrs  {
	                              mors :: 3
	                              mirs :: 3
	                              mars :: 3
	                             muser :: 3
	                             miser :: 3
	                             maser :: 3
	                               urs :: 3
	                               ors :: 3
	                               mus :: 3
	                               mos :: 3
	                               mis :: 3
	                               mes :: 3
	                               mas :: 3
	                               ers :: 3
	                               ars :: 3
	                                ms :: 3
                                 }
nl name name miss nl name name ms nl name codeset nl num lc name nl address postal  {
	           postal :: -1000
                }
fmt nl item lc address nl address country  {
	country :: -1000
      }
name nl address country post nl address country ab nl address country ab nl address country car nl address country num nl address country isbn  {
	                    nibs :: 5
	                    isba :: 5
                       }
nl address lang name nl address lang ab nl address lang term nl address lang lib nl address codeset nl num lc address nl telephone  {
	               telephone :: -1000
                       }
tel int fmt nl item lc telephone nl telephone tel dom fmt nl telephone int select nl telephone int prefix nl telephone codeset nl num lc telephone nl measurement measurement nl item lc measurement nl measurement codeset nl num lc measurement nl identification title  {
	                                      title :: -1000
                                          }
nl item lc identification nl identification source nl identification address nl identification contact nl identification email  {
	         impale :: 6
	          elain :: 6
              }
nl identification tel nl identification fax  {
	  fax :: -1000
    }
nl identification language nl identification territory  {
	territory :: -1000
    }
nl identification audience  {
	audience :: -1000
 }
nl identification application nl identification abbreviation nl identification revision nl identification date nl identification category nl identification codeset nl num lc identification this marks the highest value used nl num this macro produces  {
	                        produces :: -1000
                               }
an item you can pass to nl langinfo or nl langinfo l to get the name of the locale in use for category define nl locale name category nl item category nl item index ifdef use gnu define nl locale name category nl locale name category endif return the current locale s value for item if item is invalid an empty string is returned the string returned will not change until setlocale  {
	                                                             decollates :: 11
                                                                      }
is called it is usually in read only memory and cannot be modified extern char nl langinfo nl item item throw ifdef use xopen k this interface is for the extended locale model see locale h for more information get locale datatype definition include xlocale h just like nl langinfo but get the information from the locale object l extern char nl langinfo l nl item item locale t l endif end decls endif langinfo h this header file is used in bsd to define struct lastlog  {
	                                                                                lastly :: 9
                                                                                     }
which we define in bits utmp  {
	tumps :: 5
	 tump :: 6
    }
h include utmp h openldap  {
   }
this work is part of openldap software http www openldap org copyright the openldap foundation all rights reserved redistribution and use in source and binary forms with or without modification are permitted only as authorized  {
	                        authorized :: -1000
                                 }
by the openldap public license a copy of this license is available in file license in the top level directory of the distribution or alternatively at http www openldap org license html  {
	                         hamlet :: 5
                              }
portions copyright c regents of the university of michigan  {
	 miching :: 12
	machining :: 11
	michings :: 11
       }
all rights reserved redistribution and use in source and binary forms are permitted provided that this notice is preserved  {
	         preserved :: -1000
                 }
and that due credit  {
	credit :: -1000
  }
is given to the university of michigan at ann arbor  {
	    arbor :: -1000
        }
the name of the university may not be used to endorse or promote products derived from this software without specific prior written permission this software is provided as is without express or implied warranty ifndef lber  {
	                               lier :: 5
	                               leer :: 5
	                               laer :: 5
                                  }
h define lber h include lber types h include string h ldap  {
	     leaped :: 5
	       leap :: 5
          }
begin decl ber tag t represents the identifier octets  {
	  octets :: -1000
       }
at the beginning of ber elements openldap treats  {
	 treats :: -1000
      }
them as mere big endian unsigned integers actually the ber identifier octets look like this bits of st octet class universal  {
	           universal :: -1000
                   }
application context specific private data type primitive  {
	primitive :: -1000
     }
constructed tag number for asn tag numbers x f tag number above is x f and the next ber octets contain the actual asn tag number big endian base bit in all but the last octet minimum number of octets ber classes and mask in st identifier octet define lber class universal ber tag t x u define lber class application ber tag t x u define lber class context ber tag t x u define lber class private ber tag t xc u define lber class mask ber tag t xc u ber encoding type and mask in st identifier octet define lber primitive ber tag t x u define lber constructed ber tag t x u define lber encoding mask ber tag t x u define lber big tag mask ber tag t x fu define lber more tag mask ber tag t x u lber error and lber default are values that can never appear as valid ber tags so it is safe to use them to report errors valid tags have tag ber tag t xff xff define lber error ber tag t define lber default ber tag t general ber types we know about define lber boolean ber tag t x ul define lber integer ber tag t x ul define lber bitstring  {
	                                                                                                                                                                                                               timberings :: 11
	                                                                                                                                                                                                                brittling :: 12
	                                                                                                                                                                                                                 bittings :: 11
	                                                                                                                                                                                                                firstling :: 11
	                                                                                                                                                                                                                maistring :: 11
	                                                                                                                                                                                                                bristling :: 13
	                                                                                                                                                                                                               titterings :: 12
	                                                                                                                                                                                                               brattlings :: 11
	                                                                                                                                                                                                               betterings :: 12
	                                                                                                                                                                                                                besitting :: 11
	                                                                                                                                                                                                                bowstring :: 12
	                                                                                                                                                                                                                jittering :: 11
	                                                                                                                                                                                                                littering :: 11
	                                                                                                                                                                                                                pittering :: 11
	                                                                                                                                                                                                                tittering :: 11
	                                                                                                                                                                                                                wittering :: 11
	                                                                                                                                                                                                                battering :: 11
	                                                                                                                                                                                                                bettering :: 11
	                                                                                                                                                                                                                buttering :: 11
	                                                                                                                                                                                                                bittering :: 14
                                                                                                                                                                                                                        }
ber tag t x ul define lber octetstring  {
      }
ber tag t x ul define lber null ber tag t x ul define lber enumerated ber tag t x aul  {
	                 bel :: -1000
                   }
define lber sequence ber tag t x ul constructed define lber set ber tag t x ul constructed lber berelement  {
	           terebene :: 13
	         regalement :: 12
	         enlevement :: 12
	         rabblement :: 12
	          terebenes :: 12
	         revilement :: 12
                  }
options define lber use der x get set options for berelement define lber opt ber options x define lber opt ber debug x define lber opt ber remaining bytes x define lber opt ber total bytes x define lber opt ber bytes to write x define lber opt ber memctx  {
                                                }
x define lber opt debug level lber opt ber debug define lber opt remaining bytes lber opt ber remaining bytes define lber opt total bytes lber opt ber total bytes define lber opt bytes to write lber opt ber bytes to write define lber opt log print fn x define lber opt memory fns  {
	                                                 fons :: 3
	                                                 fins :: 3
	                                                 fens :: 3
	                                                 fans :: 3
	                                                  uns :: 3
	                                                  ons :: 3
	                                                  ins :: 3
	                                                  fas :: 3
	                                                  ens :: 3
                                                    }
x define lber opt error fn x define lber opt log print file x get set memory debug options define lber opt memory inuse  {
	                 unused :: 6
	                 unties :: 6
	                 inures :: 8
	                 inured :: 6
	                 intuse :: 6
	                 insure :: 6
	                 unites :: 6
	                 unisex :: 7
	                 undies :: 6
	                  inust :: 7
	                  inure :: 7
	                  indue :: 6
	                 infuse :: 6
	                 indues :: 7
	                 incuse :: 6
	                  anise :: 6
	                inulase :: 6
	                inquest :: 6
	                   unis :: 6
                      }
x for memory debugging define lber opt log proc x for external logging function typedef int ber errno fn ldap p void typedef void ber log print fn ldap p ldap const char buf typedef void ber memalloc  {
                                    }
fn ldap p ber len t size void ctx typedef void ber memcalloc  {
           }
fn ldap p ber len t n ber len t size void ctx typedef void ber memrealloc fn ldap p void p ber len t size void ctx typedef void ber memfree fn ldap p void p void ctx typedef struct lber memory fns ber memalloc fn bmf  {
	                                           bumf :: 3
	                                            emf :: 3
                                              }
malloc ber memcalloc fn bmf calloc ber memrealloc fn bmf realloc ber memfree fn bmf free bermemoryfunctions  {
               }
lber sockbuf  {
 }
io options define lber sb opt get fd define lber sb opt set fd define lber sb opt has io define lber sb opt set nonblock  {
	                nonblacks :: 11
	                 sunblock :: 10
	                 nonblack :: 12
                        }
define lber sb opt get ssl  {
	sylis :: 3
	sulks :: 3
	 sols :: 4
	 sels :: 4
	 sals :: 4
	solus :: 3
	solos :: 3
	soles :: 3
	solas :: 3
	silts :: 3
	silks :: 3
	siles :: 3
	silds :: 3
	selfs :: 3
	salts :: 3
	salse :: 3
	salsa :: 3
	salps :: 3
	sales :: 3
    }
define lber sb opt data ready define lber sb opt set readahead  {
          }
define lber sb opt drain  {
	drain :: -1000
   }
define lber sb opt needs read define lber sb opt needs write define lber sb opt get max incoming  {
	          incoming :: -1000
                 }
define lber sb opt set max incoming only meaningful ifdef ldap pf local sendmsg define lber sb opt unget  {
	             unget :: -1000
                 }
buf largest option used by the library define lber sb opt opt max lber io operations stacking  {
	        stacking :: -1000
               }
levels define lber sbiod  {
	bipods :: 6
	obis :: 6
	obied :: 6
  }
level provider  {
	provider :: -1000
 }
define lber sbiod level transport  {
	transport :: -1000
   }
define lber sbiod level application get set options for sockbuf define lber opt sockbuf desc x define lber opt sockbuf options x define lber opt sockbuf debug x on off values lber v char ber pvt  {
	                                put :: 3
	                                pst :: 3
	                                pot :: 3
	                                pit :: 3
	                                pht :: 3
	                                pet :: 3
	                                pat :: 3
                                  }
opt on define lber opt on void ber pvt opt on define lber opt off void define lber opt success define lber opt error typedef struct berelement berelement typedef struct sockbuf sockbuf typedef struct sockbuf io sockbuf io structure for lber io operarion  {
	                                 troparion :: 12
	                                 operation :: 14
	                                operagoing :: 11
	                                 proration :: 11
	                                orpharions :: 12
	                                  operator :: 11
	                                 orpharion :: 13
	                               operational :: 11
	                                operations :: 13
	                               probationer :: 11
	                                 pretorian :: 11
                                         }
descriptor typedef struct sockbuf io desc int sbiod level sockbuf sbiod sb sockbuf io sbiod io void sbiod pvt struct sockbuf io desc sbiod next sockbuf io desc structure for lber io operation functions struct sockbuf io int sbi setup sockbuf io desc sbiod void arg int sbi remove sockbuf io desc sbiod int sbi ctrl sockbuf io desc sbiod int opt void arg ber slen  {
	                                                           blends :: 5
	                                                            glens :: 6
	                                                            elans :: 5
	                                                             sten :: 5
	                                                             sley :: 5
	                                                             slew :: 5
	                                                             sled :: 5
	                                                             seen :: 5
	                                                            slane :: 6
	                                                             glen :: 5
	                                                            liens :: 5
                                                                }
t sbi read sockbuf io desc sbiod void buf ber len t len ber slen t sbi write sockbuf io desc sbiod void buf ber len t len int sbi close sockbuf io desc sbiod helper macros for lber io functions define lber sbiod read next sbiod buf len sbiod sbiod next sbiod io sbi read sbiod sbiod next buf len define lber sbiod write next sbiod buf len sbiod sbiod next sbiod io sbi write sbiod sbiod next buf len define lber sbiod ctrl next sbiod opt arg sbiod sbiod next sbiod sbiod next sbiod io sbi ctrl sbiod sbiod next opt arg structure for returning a sequence of octet strings length typedef struct berval  {
	                                                                                                             lekvar :: 7
	                                                                                                             serval :: 9
	                                                                                                             larvae :: 7
	                                                                                                            herbals :: 7
	                                                                                                             nerval :: 9
	                                                                                                           verbally :: 7
	                                                                                                             bedral :: 8
	                                                                                                              brave :: 7
	                                                                                                            bravely :: 8
	                                                                                                            verbals :: 9
	                                                                                                            servals :: 8
	                                                                                                            bedrals :: 7
	                                                                                                           servable :: 7
	                                                                                                             herbal :: 8
	                                                                                                             marvel :: 7
	                                                                                                             versal :: 8
	                                                                                                             vernal :: 8
	                                                                                                             vermal :: 8
	                                                                                                             verbal :: 10
	                                                                                                             carvel :: 7
	                                                                                                          verbality :: 7
	                                                                                                          verbalist :: 7
	                                                                                                          verbalism :: 7
	                                                                                                             boreal :: 8
	                                                                                                             varvel :: 7
                                                                                                                  }
ber len t bv  {
	  b :: 2
  }
len char bv val bervalue  {
	servable :: 11
   }
typedef bervalue bervarray  {
 }
to distinguish from a single bv this should be moved  {
	    moved :: -1000
        }
to lber int h in bprint  {
	burin :: 7
	sprinted :: 7
	sprint :: 9
	sprints :: 8
    }
c lber f void ber error print ldap p ldap const char data lber f void ber bprint ldap p ldap const char data ber len t len lber f void ber dump ldap p berelement ber int inout  {
	                                 knout :: 7
	                                inputs :: 6
	                                 inust :: 6
	                                 input :: 7
	                                 ingot :: 6
	                                 incut :: 7
	                                knouts :: 6
	                              snoutish :: 6
	                              snoutier :: 6
	                                 snout :: 7
	                                  into :: 6
	                                snouty :: 6
	                                snouts :: 6
                                     }
in decode c typedef int berdecodecallback  {
    }
ldap p berelement ber void data int mode lber f ber tag t ber get tag ldap p berelement ber lber f ber tag t ber skip tag ldap p berelement ber ber len t len lber f ber tag t ber peek  {
	                                      peek :: -1000
                                         }
tag ldap p berelement ber ber len t len lber f ber tag t ber skip element ldap p berelement ber struct berval bv lber f ber tag t ber peek element ldap p ldap const berelement ber struct berval bv lber f ber tag t ber get int ldap p berelement ber ber int t num lber f ber tag t ber get enum ldap p berelement ber ber int t num lber f ber tag t ber get stringb  {
	                                                                          siring :: 9
	                                                                         borings :: 9
	                                                                          sering :: 9
	                                                                       strongbox :: 9
	                                                                         tirings :: 9
	                                                                         stringy :: 11
	                                                                         strings :: 10
	                                                                         tyrings :: 9
	                                                                        stringer :: 9
	                                                                        stringed :: 10
	                                                                       springbok :: 9
	                                                                          stying :: 9
	                                                                          strung :: 9
	                                                                          strong :: 9
	                                                                          string :: 12
	                                                                           strig :: 9
	                                                                          spring :: 9
	                                                                          soring :: 9
                                                                               }
ldap p berelement ber char buf ber len t len define lber bv alloc x allocate copy result otherwise in place define lber bv noterm  {
	                anteroom :: 7
	                intercom :: 7
	                motormen :: 7
	                   doter :: 7
	                  monera :: 7
	                  modern :: 7
	                  toners :: 7
	                   voter :: 7
	                   toter :: 7
	                   toner :: 8
	                    rote :: 7
	                    note :: 8
	                    nome :: 7
	                    mote :: 7
	                 tonearm :: 7
	                  nother :: 7
	                  noters :: 9
	                   notes :: 7
	                   noter :: 10
	                   noted :: 7
	                   noser :: 7
	                   niter :: 7
	                   moner :: 8
                       }
x omit nul terminator if parsing in place define lber bv string x fail if berval contains embedded lber bv string currently accepts  {
	              forgeman :: -1000
                     }
a terminating in the berval because active directory sends  {
	   sends :: -1000
       }
that in at least the diagonsticmessage  {
    }
field lber f ber tag t ber get stringbv  {
	 stringy :: 11
	 strings :: 10
	stringed :: 10
	  string :: 12
       }
ldap p berelement ber struct berval bv int options lber f ber tag t ber get stringa  {
	          siring :: 9
	      stringhalt :: 9
	          sering :: 9
	          sating :: 10
	         syringa :: 11
	         tirings :: 9
	        myringas :: 9
	        syringas :: 9
	         sarangi :: 9
	         airings :: 9
	         parings :: 9
	         stringy :: 11
	         strings :: 10
	         strigae :: 9
	         strange :: 10
	        stingray :: 9
	        springal :: 10
	         tyrings :: 9
	         darings :: 9
	         seringa :: 11
	          rating :: 9
	          rasing :: 9
	        stringer :: 9
	        stringed :: 10
	       springald :: 9
	          stying :: 9
	          strung :: 9
	          strong :: 9
	          string :: 12
	          striga :: 10
	          strain :: 9
	         staring :: 9
	         stainer :: 9
	          taring :: 10
	           strig :: 9
	           stria :: 9
	           stain :: 9
	          spring :: 9
	           sarin :: 9
	          soring :: 9
	         earings :: 9
	        straying :: 9
	        strawing :: 9
	         ratings :: 10
	        strangle :: 9
	        strafing :: 9
	        seringas :: 9
               }
ldap p berelement ber char buf lber f ber tag t ber get stringal  {
	    strangled :: 10
	   springalds :: 10
	    strangely :: 11
	   stringhalt :: 11
	   springtail :: 10
	       sating :: 10
	      syringa :: 11
	      stringy :: 11
	      strings :: 10
	      strange :: 10
	     springal :: 13
	     strongyl :: 10
	     starling :: 10
	      seringa :: 11
	     stringed :: 10
	    springlet :: 10
	    springald :: 12
	    springals :: 11
	    stringily :: 11
	    syringeal :: 10
	       string :: 12
	       striga :: 10
	    strayling :: 10
	    staringly :: 10
	       taring :: 10
	      ratings :: 10
	     strangle :: 11
            }
ldap p berelement ber struct berval bv lber f ber tag t ber get bitstringa  {
	     striating :: 12
	     brittling :: 12
	     straiting :: 12
	     maistring :: 13
	     bristling :: 13
	     brattling :: 12
	     situating :: 12
	    titterings :: 12
	    brattlings :: 13
	    betterings :: 12
	     nitrating :: 12
	     titrating :: 12
	     bowstring :: 12
	     battering :: 13
	     bittering :: 14
             }
ldap p berelement ber char buf ber len t len lber f ber tag t ber get null ldap p berelement ber lber f ber tag t ber get boolean ldap p berelement ber ber int t boolval  {
                                    }
lber f ber tag t ber first element ldap p berelement ber ber len t len char last lber f ber tag t ber next element ldap p berelement ber ber len t len ldap const char last lber f ber tag t ber scanf  {
	                                      scanty :: 6
	                                      francs :: 6
	                                    scarfpin :: 6
	                                    scarfing :: 6
	                                        scan :: 8
	                                       scena :: 6
	                                       scarf :: 7
	                                       scant :: 7
	                                       scans :: 6
	                                       scaff :: 7
                                           }
ldap p berelement ber ldap const char fmt lber f int ber decode oid ldap p struct berval in struct berval out in encode c lber f int ber encode oid ldap p struct berval in struct berval out typedef int berencodecallback  {
                                        }
ldap p berelement ber void data lber f int ber put enum ldap p berelement ber ber int t num ber tag t tag lber f int ber put int ldap p berelement ber ber int t num ber tag t tag lber f int ber put ostring  {
	                                        sporing :: 9
	                                       rootings :: 9
	                                       riotings :: 9
	                                        smoring :: 9
	                                        souring :: 9
	                                       astringe :: 10
	                                        orating :: 9
	                                        storing :: 11
	                                        sorting :: 10
	                                        shoring :: 9
	                                        scoring :: 9
	                                        outsing :: 10
	                                        outring :: 11
	                                        ousting :: 9
	                                        touring :: 9
	                                       tourings :: 10
	                                      astringed :: 9
	                                        staring :: 9
	                                       outwings :: 9
	                                      outreigns :: 9
	                                       sortings :: 9
	                                        snoring :: 9
	                                       outsings :: 9
	                                       outrings :: 12
                                              }
ldap p berelement ber ldap const char str ber len t len ber tag t tag lber f int ber put berval ldap p berelement ber struct berval bv ber tag t tag lber f int ber put string ldap p berelement ber ldap const char str ber tag t tag lber f int ber put bitstring ldap p berelement ber ldap const char str ber len t bitlen  {
	                                                              giblet :: 7
	                                                              bitten :: 8
	                                                              billet :: 8
	                                                              berlin :: 7
	                                                               butle :: 7
	                                                               blite :: 7
	                                                               birle :: 7
	                                                           butlering :: 7
	                                                             belting :: 7
	                                                            bulletin :: 7
	                                                              riblet :: 7
	                                                             butling :: 7
	                                                             bitless :: 8
	                                                             biplane :: 7
	                                                             billets :: 7
	                                                               title :: 7
	                                                                bite :: 7
	                                                             violent :: 7
	                                                              litten :: 7
	                                                              listen :: 7
	                                                              libken :: 7
                                                                   }
ber tag t tag lber f int ber put null ldap p berelement ber ber tag t tag lber f int ber put boolean ldap p berelement ber ber int t boolval ber tag t tag lber f int ber start seq ldap p berelement ber ber tag t tag lber f int ber start set ldap p berelement ber ber tag t tag lber f int ber put seq ldap p berelement ber lber f int ber put set ldap p berelement ber lber f int ber printf ldap p berelement ber ldap const char fmt in io c lber f ber slen t ber skip data ldap p berelement ber ber len t len lber f ber slen t ber read ldap p berelement ber char buf ber len t len lber f ber slen t ber write ldap p berelement ber ldap const char buf ber len t len int zero nonzero is unsupported from openldap lber f void ber free ldap p berelement ber int freebuf  {
	                                                                                                                                                                methystic :: -1000
                                                                                                                                                                        }
lber f void ber free buf ldap p berelement ber lber f int ber flush ldap p sockbuf sb berelement ber int freeit  {
	               eremite :: 7
	                 freit :: 7
	                 freet :: 9
	                 frees :: 7
	                 freed :: 7
	                 fiere :: 7
	                freety :: 8
	                freets :: 8
	                freest :: 9
	                tremie :: 7
	               freesia :: 7
	               freeing :: 8
	              fieriest :: 7
	               fertile :: 7
	               ferrite :: 8
	                faerie :: 7
	             frenetics :: 7
	              ferrites :: 7
	                  tree :: 7
	               treeing :: 7
	                  free :: 8
	               arenite :: 7
	            fremituses :: 7
                     }
define lber flush free never x traditional  {
	traditional :: -1000
     }
behavior define lber flush free on success x traditional behavior define lber flush free on error x define lber flush free always lber flush free on success lber flush free on error lber f int ber flush ldap p sockbuf sb berelement ber int freeit deprecated lber f berelement ber alloc ldap p void deprecated lber f berelement der alloc ldap p void deprecated lber f berelement ber alloc t ldap p int beroptions  {
	                                                               coemptions :: 12
	                                                                preoption :: 13
	                                                               pertusions :: 12
	                                                               perditions :: 13
	                                                               recaptions :: 13
	                                                                obreption :: 15
	                                                               ectropions :: 12
	                                                               entropions :: 12
	                                                               premotions :: 13
	                                                               reptations :: 12
	                                                               receptions :: 12
	                                                               abruptions :: 13
	                                                               preoptions :: 15
	                                                                detorsion :: 12
	                                                                retorsion :: 12
	                                                               prenotions :: 13
	                                                               detorsions :: 12
	                                                               retorsions :: 12
	                                                               retortions :: 13
	                                                               apportions :: 12
	                                                               detortions :: 13
	                                                               extortions :: 12
	                                                               operations :: 13
	                                                               probations :: 13
	                                                                pertusion :: 12
	                                                               bolections :: 12
	                                                               aerobionts :: 12
	                                                             probationers :: 12
                                                                        }
lber f berelement ber dup ldap p berelement ber lber f ber tag t ber get next ldap p sockbuf sb ber len t len berelement ber lber f void ber init ldap p berelement ber struct berval bv int options lber f void ber init w nullc  {
	                                        cullion :: 6
	                                        culling :: 6
	                                         nulled :: 6
	                                         nullas :: 6
	                                         nullah :: 6
	                                           null :: 8
	                                          nulls :: 7
	                                          nulla :: 7
                                              }
ldap p deprecated berelement ber int options lber f void ber reset ldap p berelement ber int was writing lber f berelement ber init ldap p struct berval bv lber f int ber flatten  {
	                          flatten :: -1000
                                }
ldap p berelement ber struct berval bvptr  {
     }
lber f int ber flatten ldap p berelement ber struct berval bv int alloc lber f int ber remaining ldap p berelement ber lber ber accessor functions lber f int ber get option ldap p void item int option void outvalue  {
	                                outvalue :: -1000
                                       }
lber f int ber set option ldap p void item int option ldap const void invalue  {
	      devaluing :: 9
	      revaluing :: 9
	       unvalued :: 10
	        unalive :: 9
	        infulae :: 9
	       involute :: 9
              }
lber sockbuf c lber f sockbuf ber sockbuf alloc ldap p void lber f void ber sockbuf free ldap p sockbuf sb lber f int ber sockbuf add io ldap p sockbuf sb sockbuf io sbio int layer void arg lber f int ber sockbuf remove io ldap p sockbuf sb sockbuf io sbio int layer lber f int ber sockbuf ctrl ldap p sockbuf sb int opt void arg lber v sockbuf io ber sockbuf io tcp lber v sockbuf io ber sockbuf io readahead lber v sockbuf io ber sockbuf io fd lber v sockbuf io ber sockbuf io debug lber v sockbuf io ber sockbuf io udp  {
	                                                                                                        upped :: 3
	                                                                                                        umped :: 3
	                                                                                                         updo :: 3
	                                                                                                         dups :: 3
	                                                                                                         dupe :: 3
	                                                                                                          ump :: 3
	                                                                                                          uds :: 3
	                                                                                                          udo :: 3
	                                                                                                          pud :: 3
	                                                                                                          dup :: 4
	                                                                                                           up :: 3
                                                                                                            }
lber memory c lber f void ber memalloc ldap p ber len t s lber f void ber memrealloc ldap p void p ber len t s lber f void ber memcalloc ldap p ber len t n ber len t s lber f void ber memfree ldap p void p lber f void ber memvfree  {
                                                      }
ldap p void vector lber f void ber bvfree  {
	  befret :: 7
	  before :: 7
       }
ldap p struct berval bv lber f void ber bvecfree  {
	 overfree :: 10
        }
ldap p struct berval bv lber f int ber bvecadd  {
	restrictions :: -1000
        }
ldap p struct berval bvec struct berval bv lber f struct berval ber dupbv  {
	          dup :: 6
            }
ldap p struct berval dst struct berval src lber f struct berval ber bvdup  {
            }
ldap p struct berval src lber f struct berval ber mem bv ldap p ldap const char ber len t len int duplicate struct berval bv lber f struct berval ber str bv ldap p ldap const char ber len t len int duplicate struct berval bv define ber bvstr  {
	                                        coalition :: -1000
                                                }
a ber str bv a null define ber bvstrdup  {
       }
a ber str bv a null lber f char ber strdup ldap p ldap const char lber f ber len t ber strnlen  {
	              projects :: -1000
                     }
ldap p ldap const char s ber len t len lber f char ber strndup  {
	       standup :: 11
             }
ldap p ldap const char s ber len t l lber f struct berval ber bvreplace  {
	      fireplace :: 12
	     fireplaces :: 11
	     fireplaced :: 11
	     overplaced :: 12
              }
ldap p struct berval dst ldap const struct berval src lber f void ber bvarray  {
             }
free ldap p bervarray p lber f int ber bvarray add ldap p bervarray p bervalue bv define ber bvcmp  {
                  }
v v v bv len v bv len v bv len v bv len memcmp  {
             }
v bv val v bv val v bv len error c lber f int ber errno addr ldap p void define ber errno ber errno addr define lber error none define lber error param x define lber error memory x ldap end decl endif lber h include lber types h generated from lber types hin by configure openldap this work is part of openldap software http www openldap org copyright the openldap foundation all rights reserved redistribution and use in source and binary forms with or without modification are permitted only as authorized by the openldap public license a copy of this license is available in file license in the top level directory of the distribution or alternatively at http www openldap org license html lber types ifndef lber types h define lber types h include ldap cdefs h ldap begin decl lber boolean enum integers bits or larger define lber int t int lber tags bits or larger define lber tag t long lber socket descriptor define lber socket t int lber lengths bits or larger define lber len t long booleans  {
	                                                                                                                                                                               boolean :: 14
	                                                                                                                                                                              balloons :: 10
	                                                                                                                                                                              borneols :: 10
                                                                                                                                                                                     }
enumerations and integers typedef lber int t ber int t signed and unsigned versions typedef signed lber int t ber sint  {
	            outwings :: -1000
                   }
t typedef unsigned lber int t ber uint t tags typedef unsigned lber tag t ber tag t socket descriptors typedef lber socket t ber socket t lengths typedef unsigned lber len t ber len t signed lengths typedef signed lber len t ber slen t ldap end decl endif lber types h little cms copyright c marti maria permission is hereby granted free of charge to any person obtaining a copy of this software and associated documentation files the software to deal in the software without restriction including without limitation the rights to use copy modify merge publish distribute sublicense and or sell copies of the software and to permit persons to whom the software is furnished to do so subject to the following conditions the above copyright notice and this permission notice shall be included in all copies or substantial portions of the software the software is provided as is without warranty of any kind express or implied including but not limited to the warranties of merchantability fitness for a particular purpose and noninfringement  {
                                                                                                                                                                              }
in no event shall the authors  {
	authors :: -1000
    }
or copyright holders  {
	holders :: -1000
 }
be liable for any claim damages or other liability whether in an action of contract tort or otherwise arising from out of or in connection with the software or the use or other dealings in the software version ifndef cms h configuration toggles  {
	                                   toggles :: -1000
                                         }
optimization mode note that use assembler is fastest by far but it is limited to pentium  {
	        punties :: 9
	        pinetum :: 11
              }
use float are the generic floating point routines use c should work on virtually  {
	    virtually :: -1000
            }
any machine define use float define use c define use assembler define this if you are using this package as a dll windows only define lcms  {
	                     lams :: 5
                        }
dll define lcms dll build uncomment  {
	retreaters :: -1000
    }
if you are trying  {
	trying :: -1000
  }
the engine in a non windows environment like linux sgi vax freebsd beos etc define non windows uncomment this one if you are using big endian machines only meaningful when non windows is used define use big endian uncomment this one if your compiler machine does support the long long type this will speedup  {
	                                              speedup :: -1000
                                                    }
fixed point math use c only define use int some machines does not have a reliable swab  {
	            swab :: -1000
               }
function usually leave commented  {
	commented :: -1000
  }
unless the testbed  {
	bested :: 9
	bestead :: 9
	settled :: 9
	tested :: 10
	testae :: 9
	teste :: 9
 }
diagnoses  {
	diagnoses :: -1000
 }
the contrary  {
	contrary :: -1000
 }
define use custom swab uncomment this if your compiler supports inline define use inline uncomment this if your compiler doesn t work with fast floor function define use default floor conversion uncomment this line on multithreading  {
                                  }
environments  {
	environments :: -1000
 }
define use pthreads  {
	potheads :: 11
	pitheads :: 11
	preheats :: 10
 }
uncomment this line if you want lcms to use the black point tag in profile if commented lcms will compute the black point by its own it is safer to leve it commented out define honor  {
	                              honor :: -1000
                                  }
black point tag end of configuration toggles define lcms version microsoft visualc  {
	   visually :: 9
	     visual :: 12
	     vistal :: 9
	     vidual :: 9
	    visuals :: 10
          }
deal with microsoft s attempt at deprecating  {
	deprecating :: -1000
     }
c standard runtime functions ifdef msc ver undef non windows if msc ver ifndef crt secure no deprecate define crt secure no deprecate endif endif endif borland  {
	                  norlands :: 10
	                   bollard :: 10
	                   bogland :: 11
	                   troland :: 9
	                  bollards :: 9
	                  boglands :: 10
	                  parlando :: 9
	                   norland :: 11
                         }
c ifdef borlandc  {
	norlands :: 10
	bollard :: 10
	cotland :: 10
	bogland :: 11
	corban :: 10
	boglands :: 10
	norland :: 11
 }
undef non windows endif include stdio h include stdlib h include math h include assert h include stdarg h include time h metroworks  {
	            mitreworts :: 12
	            sternworks :: 12
	             metalwork :: 12
	            waterworks :: 12
	            interworks :: 12
	            metalworks :: 14
                     }
codewarrior  {
 }
ifdef mwerks  {
	wrecks :: 7
	wreaks :: 7
	smerk :: 8
	smerks :: 8
 }
define unlink  {
	unlink :: -1000
 }
remove if win define use custom swab undef non windows else define non windows endif endif here comes the non windows settings ifdef non windows non windows environments also avoid indentation  {
	                   indentation :: -1000
                             }
on includes ifdef use pthreads include pthread h typedef pthread rwlock  {
	  relocked :: 7
	   relocks :: 8
	    relock :: 9
         }
t lcms rwlock t define lcms create lock x pthread rwlock init x null define lcms free lock x pthread rwlock destroy x define lcms read lock x pthread rwlock rdlock  {
	                      relocked :: 9
	                       relocks :: 8
	                        relock :: 9
	                        redock :: 8
	                       redocks :: 7
                             }
x define lcms write lock x pthread rwlock wrlock  {
	 relocks :: 7
	  relock :: 8
       }
x define lcms unlock x pthread rwlock unlock x endif undef lcms dll ifdef use assembler undef use assembler define use c endif ifdef host big endian define use big endian endif if defined sgi defined sgi defined powerpc defined sparc defined ppc defined s defined s x define use big endian endif if target cpu ppc define use big endian endif if macintosh  {
	                                                      macintosh :: -1000
                                                              }
ifndef little endian define use big endian endif endif ifdef big endian define use big endian endif ifdef words bigendian define use big endian endif if defined openbsd defined netbsd defined freebsd include sys types h define use int define lcmsslonglong  {
                                       }
int t define lcmsulonglong  {
  }
u int t endif ifdef use int ifndef lcmsulonglong define lcmsulonglong unsigned long long define lcmsslonglong long long endif endif if defined integrity  {
	             integrity :: -1000
                     }
include memory h endif include string h if defined gnuc defined freebsd include unistd h endif ifndef lcms win types already defined typedef unsigned char byte lpbyte  {
                         }
typedef unsigned short word lpword  {
	irrupted :: -1000
   }
typedef unsigned long dword  {
	sworded :: 6
	swords :: 6
	sword :: 7
  }
lpdword  {
 }
typedef char lpstr  {
	lustre :: 6
	lustra :: 6
 }
typedef void lpvoid  {
	lipoids :: 7
	lipoid :: 8
 }
define zeromemory  {
 }
p l memset  {
	semsem :: 7
	mementos :: 8
	messmate :: 7
	mimester :: 7
	mismet :: 7
	temses :: 7
	temsed :: 8
	emmets :: 7
	temse :: 9
	temes :: 7
	mems :: 7
	memento :: 7
	members :: 7
	meristem :: 7
 }
p l define copymemory  {
	samosas :: -1000
  }
d s l memcpy d s l define far ifndef stricmp  {
	    script :: 9
	    scrimp :: 9
	    strick :: 9
	    strich :: 9
	     strip :: 9
         }
define stricmp strcasecmp  {
 }
endif ifndef false define false endif ifndef true define true endif define loword  {
	      dolors :: 7
	       dolor :: 8
	       loord :: 7
           }
l word l define hiword  {
   }
l word dword l ifndef max path define max path endif define cdecl endif the specification for inline is section of the c standard iso iec define lcms inline static inline else win stuff ifndef win lean  {
	                                lean :: -1000
                                   }
and mean define win lean and mean endif include windows h ifdef win ifdef use assembler undef use assembler define use c endif endif ifdef use int ifndef lcmsulonglong define lcmsulonglong unsigned int define lcmsslonglong int endif endif this works for both vc borlandc define lcms inline inline ifdef use pthreads typedef critical section lcms rwlock t define lcms create lock x initializecriticalsection  {
                                                             }
x define lcms free lock x deletecriticalsection  {
     }
x define lcms read lock x entercriticalsection  {
     }
x define lcms write lock x entercriticalsection x define lcms unlock x leavecriticalsection  {
           }
x endif endif ifndef use pthreads typedef int lcms rwlock t define lcms create lock x define lcms free lock x define lcms read lock x define lcms write lock x define lcms unlock x endif base types typedef int lcmsbool  {
                                       }
typedef void lcmshandle  {
 }
include icc h icc header file some tag type additions  {
	additions :: -1000
        }
define lcmssignature  {
 }
icsignature x c d l define icsigluvkdata  {
     }
iccolorspacesignature x c bl luvk  {
	luvs :: 5
	lusk :: 5
	lunk :: 5
	luck :: 5
	 luv :: 6
   }
define icsighexachromedata  {
 }
iccolorspacesignature x d l mch  {
	mach :: 3
	schmo :: 3
	 och :: 3
	 ich :: 3
   }
define icsigheptachromedata  {
 }
iccolorspacesignature x d l mch define icsigoctachromedata  {
     }
iccolorspacesignature x d l mch define icsigmch  {
     }
data iccolorspacesignature x d l mch define icsigmch data iccolorspacesignature x d l mch define icsigmch data iccolorspacesignature x d l mch define icsigmch data iccolorspacesignature x d l mch define icsigmch data iccolorspacesignature x d l mch define icsigmchadata  {
                                      }
iccolorspacesignature x d l mcha  {
	nonjuring :: -1000
   }
define icsigmchbdata  {
 }
iccolorspacesignature x d l mchb  {
   }
define icsigmchcdata  {
 }
iccolorspacesignature x d l mchc  {
   }
define icsigmchddata  {
 }
iccolorspacesignature x d l mchd  {
   }
define icsigmchedata  {
 }
iccolorspacesignature x d l mche  {
	schema :: 5
	schelm :: 5
	oche :: 5
	eche :: 5
	ache :: 5
   }
define icsigmchfdata  {
	mendicancies :: -1000
 }
iccolorspacesignature x d l mchf  {
   }
define icsigchromaticitytag  {
 }
ictagsignature x dl as per addendum  {
	addendum :: -1000
    }
to spec icc define icsigchromaticadaptationtag  {
   }
ictagsignature x l chad  {
	chad :: -1000
  }
define icsigcoloranttabletag  {
 }
ictagsignature x c l clrt  {
	clart :: 5
	curtly :: 5
	curt :: 5
	cort :: 5
	clot :: 5
	cert :: 5
	cart :: 5
	cartel :: 5
   }
define icsigcoloranttableouttag  {
 }
ictagsignature x c f l clot  {
	 clot :: -1000
    }
define icsigparametriccurvetype  {
 }
ictagtypesignature x l parametric  {
	parametric :: -1000
  }
icc define icsigmultilocalizedunicodetype  {
 }
ictagtypesignature x d c l define icsigs fixed arraytype ictagtypesignature x l define icsigchromaticitytype  {
            }
ictagtypesignature x dl define icsiglutatobtype  {
	utricular :: -1000
   }
ictagtypesignature x d l mab  {
	mabe :: 5
	lamb :: 3
	jamb :: 3
	iamb :: 3
	gamb :: 3
	barm :: 3
	balm :: 3
	ambo :: 3
	maybe :: 3
	mabes :: 4
	 wab :: 3
	 tab :: 3
	 sab :: 3
	 nab :: 3
	 mob :: 3
	 mib :: 3
	 may :: 3
	 max :: 3
	 maw :: 3
	 mat :: 3
	 mas :: 3
	 mar :: 3
	 map :: 3
	 man :: 3
	 mal :: 3
	 mak :: 3
	 mag :: 3
	 mae :: 3
	 mad :: 3
	 mac :: 3
	 lab :: 3
	 kab :: 3
	 jab :: 3
	 gab :: 3
	 fab :: 3
	 dab :: 3
	 cab :: 3
	 bam :: 4
	  ma :: 4
	  ba :: 3
   }
define icsiglutbtoatype  {
 }
ictagtypesignature x d l mba  {
	vulgate :: -1000
   }
define icsigcoloranttabletype  {
 }
ictagtypesignature x c l clrt typedef struct icuint number gridpoints  {
	profitings :: 12
        }
number of grid points in each dimension icuint number prec precision of data elements in bytes icuint number pad icuint number pad icuint number pad icuint number data icany data follows see spec for size icclutstruct  {
	                         abductores :: -1000
                                  }
iclutatob  {
 }
typedef struct icuint number inputchan number of input channels icuint number outputchan number of output channels icuint number pad icuint number pad icuint number offsetb  {
	                 offsets :: 10
	                 offbeat :: 9
	                offbeats :: 10
	                  offset :: 12
                       }
offset to first b curve icuint number offsetmat  {
	 offset :: 11
      }
offset to matrix  {
	matrix :: -1000
 }
icuint number offsetm offset to first m curve icuint number offsetc  {
	   offsets :: 10
	   offcuts :: 9
	    offset :: 12
         }
offset to clut icuint number offseta  {
	offstage :: 10
	offtakes :: 9
	offsets :: 10
	offbeat :: 9
	offbeats :: 10
	offset :: 12
    }
offset to first a curve icuint number data icany data follows see spec for size iclutatob iclutbtoa  {
               }
typedef struct icuint number inputchan number of input channels icuint number outputchan number of output channels icuint number pad icuint number pad icuint number offsetb offset to first b curve icuint number offsetmat offset to matrix icuint number offsetm offset to first m curve icuint number offsetc offset to clut icuint number offseta offset to first a curve icuint number data icany data follows see spec for size iclutbtoa ifdef cplusplus extern c endif calling convention ifdef non windows define lcmsexport  {
	                                                                    untowardness :: -1000
                                                                               }
define lcmsapi  {
	limpas :: 9
 }
else ifdef lcms dll ifdef borlandc define lcmsexport stdcall  {
       }
export define lcmsapi else vc define lcmsexport stdcall ifdef lcms dll build define lcmsapi declspec dllexport else define lcmsapi declspec dllimport endif endif else define lcmsexport cdecl define lcmsapi endif endif ifdef use assembler ifdef borlandc define asm  {
	                                aswim :: 3
	                                ammos :: 3
	                                almes :: 3
	                                acmes :: 3
	                                 yams :: 3
	                                 tams :: 3
	                                 soma :: 3
	                                 sima :: 3
	                                 samp :: 3
	                                 same :: 3
	                                 rams :: 3
	                                 pams :: 3
	                                 nams :: 3
	                                 mams :: 3
	                                 lams :: 3
	                                 jams :: 3
	                                 hams :: 3
	                                 gams :: 3
	                                 dams :: 3
	                                 cams :: 3
	                                 amps :: 3
	                                 alms :: 4
	                                 aims :: 4
	                                  sam :: 4
	                                  mas :: 3
	                                  ism :: 3
	                                  ask :: 3
	                                  ash :: 3
	                                  arm :: 3
	                                  aim :: 3
	                                   ms :: 3
	                                   as :: 4
	                                   am :: 3
                                    }
asm define ret v return v else vc define asm asm define ret v return endif endif ifdef msc ver ifndef stricmp define stricmp stricmp endif ifndef unlink define unlink unlink endif ifndef swab define swab swab endif ifndef itoa  {
	                                  iotas :: 5
	                                  stoai :: 6
	                                   stoa :: 5
	                                   iota :: 6
	                                    ita :: 5
                                      }
define itoa itoa endif ifndef fileno define fileno fileno endif ifndef strupr  {
	    striper :: 7
	    stirrup :: 7
	     stupor :: 7
	      stoup :: 7
	    irrupts :: 7
          }
define strupr strupr endif ifndef hypot  {
	hypos :: 7
	typhon :: 6
	hypoid :: 6
	hypoed :: 6
	hypotaxis :: 6
	hypotaxes :: 6
	typos :: 6
	 typo :: 7
	 hypo :: 8
	hypothec :: 6
	hypocist :: 6
	  hyp :: 6
    }
define hypot hypot endif ifndef snprintf  {
	enprints :: 12
	enprint :: 11
    }
define snprintf snprintf endif ifndef vsnprintf  {
    }
define vsnprintf vsnprintf endif endif ifndef m pi define m pi endif ifndef loge  {
	         loge :: -1000
            }
define loge endif little cms api typedef lcmshandle cmshprofile  {
       }
opaque typedefs to hide internals typedef lcmshandle cmshtransform  {
      }
define maxchannels  {
	mischannels :: 16
	mischannel :: 16
 }
maximum number of channels format of pixel is defined by one dword using bit fields as follows d ttttt  {
                 }
u y f p x s eee  {
	   due :: -1000
     }
cccc  {
 }
bbb  {
	bar :: -1000
 }
d use dither bits only t pixeltype  {
     }
f flavor minisblack  {
	minilabs :: 12
	minicabs :: 12
 }
chocolate  {
	chocolate :: -1000
 }
miniswhite  {
	miniskirted :: 12
 }
vanilla  {
	vanilla :: -1000
 }
p planar  {
	planar :: -1000
 }
chunky  {
	chunky :: -1000
 }
planar x swap bps  {
	bops :: 3
	baps :: 3
	bus :: 3
	bos :: 3
	bis :: 3
	bas :: 3
  }
endianess  {
	snideness :: 12
	nakedness :: 11
	inaneness :: 11
	alienness :: 11
	readiness :: 11
	headiness :: 11
	sandiness :: 11
	handiness :: 11
	naiveness :: 11
	neediness :: 11
 }
s do swap ie bgr kymc  {
    }
e extra samples c channels samples per pixel b bytes per sample y swap first changes abgr to bgra and kcmy  {
                   }
to cmyk define dither sh s s define colorspace sh s s define swapfirst  {
	    swampiest :: 11
            }
sh s s define flavor sh s s define planar sh p p define endian sh e e define doswap  {
	             dowlas :: 7
	              dowps :: 7
	            dognaps :: 7
                  }
sh e e define extra sh e e define channels sh c c define bytes sh b b pixel types define pt any don t check colorspace are reserved define pt gray define pt rgb define pt cmy define pt cmyk define pt ycbcr define pt yuv lu v define pt xyz define pt lab define pt yuvk  {
	                                                   tathed :: -1000
                                                        }
lu v k define pt hsv define pt hls define pt yxy define pt hifi  {
	          hili :: 5
             }
define pt hifi define pt hifi define pt hifi define pt hifi define pt hifi define pt hifi define pt hifi define pt hifi define pt hifi define nocolorspacecheck  {
                           }
x x xffff some not all representations ifndef type rgb type rgb is a very common identifier so don t include ours  {
	                 ours :: -1000
                    }
if user has it already defined define type gray colorspace sh pt gray channels sh bytes sh define type gray rev colorspace sh pt gray channels sh bytes sh flavor sh define type gray colorspace sh pt gray channels sh bytes sh define type gray rev colorspace sh pt gray channels sh bytes sh flavor sh define type gray se colorspace sh pt gray channels sh bytes sh endian sh define type graya  {
	                                                                   grays :: 6
	                                                                   grana :: 7
	                                                                   grama :: 7
	                                                                   graal :: 6
	                                                                graymail :: 6
	                                                                grayback :: 6
	                                                                drayages :: 6
	                                                                  gramas :: 6
	                                                                 graylag :: 6
	                                                                    gray :: 7
	                                                                 granary :: 6
	                                                                 gramary :: 6
	                                                                 drayage :: 7
                                                                       }
colorspace sh pt gray extra sh channels sh bytes sh define type graya colorspace sh pt gray extra sh channels sh bytes sh define type graya se colorspace sh pt gray extra sh channels sh bytes sh endian sh define type graya planar colorspace sh pt gray extra sh channels sh bytes sh planar sh define type graya planar colorspace sh pt gray extra sh channels sh bytes sh planar sh define type rgb colorspace sh pt rgb channels sh bytes sh define type rgb planar colorspace sh pt rgb channels sh bytes sh planar sh define type bgr colorspace sh pt rgb channels sh bytes sh doswap sh define type bgr planar colorspace sh pt rgb channels sh bytes sh doswap sh planar sh define type rgb colorspace sh pt rgb channels sh bytes sh define type rgb planar colorspace sh pt rgb channels sh bytes sh planar sh define type rgb se colorspace sh pt rgb channels sh bytes sh endian sh define type bgr colorspace sh pt rgb channels sh bytes sh doswap sh define type bgr planar colorspace sh pt rgb channels sh bytes sh doswap sh planar sh define type bgr se colorspace sh pt rgb channels sh bytes sh doswap sh endian sh define type rgba colorspace sh pt rgb extra sh channels sh bytes sh define type rgba planar colorspace sh pt rgb extra sh channels sh bytes sh planar sh define type rgba colorspace sh pt rgb extra sh channels sh bytes sh define type rgba planar colorspace sh pt rgb extra sh channels sh bytes sh planar sh define type rgba se colorspace sh pt rgb extra sh channels sh bytes sh endian sh define type argb colorspace sh pt rgb extra sh channels sh bytes sh swapfirst sh define type argb colorspace sh pt rgb extra sh channels sh bytes sh swapfirst sh define type abgr colorspace sh pt rgb extra sh channels sh bytes sh doswap sh define type abgr colorspace sh pt rgb extra sh channels sh bytes sh doswap sh define type abgr planar colorspace sh pt rgb extra sh channels sh bytes sh doswap sh planar sh define type abgr se colorspace sh pt rgb extra sh channels sh bytes sh doswap sh endian sh define type bgra colorspace sh pt rgb extra sh channels sh bytes sh doswap sh swapfirst sh define type bgra colorspace sh pt rgb extra sh channels sh bytes sh doswap sh swapfirst sh define type bgra se colorspace sh pt rgb extra sh channels sh bytes sh endian sh swapfirst sh define type cmy colorspace sh pt cmy channels sh bytes sh define type cmy planar colorspace sh pt cmy channels sh bytes sh planar sh define type cmy colorspace sh pt cmy channels sh bytes sh define type cmy planar colorspace sh pt cmy channels sh bytes sh planar sh define type cmy se colorspace sh pt cmy channels sh bytes sh endian sh define type cmyk colorspace sh pt cmyk channels sh bytes sh define type cmyka  {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           }
colorspace sh pt cmyk extra sh channels sh bytes sh define type cmyk rev colorspace sh pt cmyk channels sh bytes sh flavor sh define type yuvk type cmyk rev define type cmyk planar colorspace sh pt cmyk channels sh bytes sh planar sh define type cmyk colorspace sh pt cmyk channels sh bytes sh define type cmyk rev colorspace sh pt cmyk channels sh bytes sh flavor sh define type yuvk type cmyk rev define type cmyk planar colorspace sh pt cmyk channels sh bytes sh planar sh define type cmyk se colorspace sh pt cmyk channels sh bytes sh endian sh define type kymc colorspace sh pt cmyk channels sh bytes sh doswap sh define type kymc colorspace sh pt cmyk channels sh bytes sh doswap sh define type kymc se colorspace sh pt cmyk channels sh bytes sh doswap sh endian sh define type kcmy colorspace sh pt cmyk channels sh bytes sh swapfirst sh define type kcmy rev colorspace sh pt cmyk channels sh bytes sh flavor sh swapfirst sh define type kcmy colorspace sh pt cmyk channels sh bytes sh swapfirst sh define type kcmy rev colorspace sh pt cmyk channels sh bytes sh flavor sh swapfirst sh define type kcmy se colorspace sh pt cmyk channels sh bytes sh endian sh swapfirst sh hifi separations  {
	                                                                                                                                                                                                                 separations :: -1000
                                                                                                                                                                                                                           }
thanks  {
	thanks :: -1000
 }
to steven  {
	steven :: -1000
 }
greaves  {
	greaves :: -1000
 }
for providing  {
	providing :: -1000
 }
the code the colorspace is not checked define type cmyk channels sh bytes sh define type cmyk channels sh bytes sh define type cmyk se channels sh bytes sh endian sh define type kymc channels sh bytes sh doswap sh define type kymc channels sh bytes sh doswap sh define type kymc se channels sh bytes sh doswap sh endian sh define type cmykcm  {
                                                              }
channels sh bytes sh define type cmykcm planar channels sh bytes sh planar sh define type cmykcm channels sh bytes sh define type cmykcm planar channels sh bytes sh planar sh define type cmykcm se channels sh bytes sh endian sh separations with more than channels aren t very standarized  {
	                                      scandalized :: 16
	                                         standard :: 15
	                                      standardize :: 18
	                                      standardise :: 15
	                                     standardizes :: 16
	                                     standardized :: 16
	                                     standardises :: 14
                                                }
except most start with cmyk and add other colors so i just used then total number of channels after cmyk i e cmyk define type cmyk channels sh bytes sh define type cmyk channels sh bytes sh define type cmyk se channels sh bytes sh endian sh define type kymc channels sh bytes sh doswap sh define type kymc channels sh bytes sh doswap sh define type kymc se channels sh bytes sh doswap sh endian sh define type cmyk channels sh bytes sh define type cmyk channels sh bytes sh define type cmyk se channels sh bytes sh endian sh define type kymc channels sh bytes sh doswap sh define type kymc channels sh bytes sh doswap sh define type kymc se channels sh bytes sh doswap sh endian sh define type cmyk channels sh bytes sh define type cmyk channels sh bytes sh define type cmyk se channels sh bytes sh endian sh define type kymc channels sh bytes sh doswap sh define type kymc channels sh bytes sh doswap sh define type kymc se channels sh bytes sh doswap sh endian sh define type cmyk channels sh bytes sh define type cmyk channels sh bytes sh define type cmyk se channels sh bytes sh endian sh define type kymc channels sh bytes sh doswap sh define type kymc channels sh bytes sh doswap sh define type kymc se channels sh bytes sh doswap sh endian sh define type cmyk channels sh bytes sh define type cmyk channels sh bytes sh define type cmyk se channels sh bytes sh endian sh define type kymc channels sh bytes sh doswap sh define type kymc channels sh bytes sh doswap sh define type kymc se channels sh bytes sh doswap sh endian sh define type cmyk channels sh bytes sh define type cmyk channels sh bytes sh define type cmyk se channels sh bytes sh endian sh define type kymc channels sh bytes sh doswap sh define type kymc channels sh bytes sh doswap sh define type kymc se channels sh bytes sh doswap sh endian sh colorimetric  {
	                                                                                                                                                                                                                                                                                                                                               colorimetric :: -1000
                                                                                                                                                                                                                                                                                                                                                          }
define type xyz colorspace sh pt xyz channels sh bytes sh define type lab colorspace sh pt lab channels sh bytes sh define type alab  {
	               dipodidae :: -1000
                       }
colorspace sh pt lab channels sh bytes sh extra sh doswap sh define type lab colorspace sh pt lab channels sh bytes sh define type yxy colorspace sh pt yxy channels sh bytes sh ycbcr define type ycbcr colorspace sh pt ycbcr channels sh bytes sh define type ycbcr planar colorspace sh pt ycbcr channels sh bytes sh planar sh define type ycbcr colorspace sh pt ycbcr channels sh bytes sh define type ycbcr planar colorspace sh pt ycbcr channels sh bytes sh planar sh define type ycbcr se colorspace sh pt ycbcr channels sh bytes sh endian sh yuv define type yuv colorspace sh pt yuv channels sh bytes sh define type yuv planar colorspace sh pt yuv channels sh bytes sh planar sh define type yuv colorspace sh pt yuv channels sh bytes sh define type yuv planar colorspace sh pt yuv channels sh bytes sh planar sh define type yuv se colorspace sh pt yuv channels sh bytes sh endian sh hls define type hls colorspace sh pt hls channels sh bytes sh define type hls planar colorspace sh pt hls channels sh bytes sh planar sh define type hls colorspace sh pt hls channels sh bytes sh define type hls planar colorspace sh pt hls channels sh bytes sh planar sh define type hls se colorspace sh pt hls channels sh bytes sh endian sh hsv define type hsv colorspace sh pt hsv channels sh bytes sh define type hsv planar colorspace sh pt hsv channels sh bytes sh planar sh define type hsv colorspace sh pt hsv channels sh bytes sh define type hsv planar colorspace sh pt hsv channels sh bytes sh planar sh define type hsv se colorspace sh pt hsv channels sh bytes sh endian sh named color index only bits allowed don t check colorspace define type named color index channels sh bytes sh double values painful  {
	                                                                                                                                                                                                                                                                                                                    painful :: -1000
                                                                                                                                                                                                                                                                                                                          }
slow but sometimes helpful  {
	helpful :: -1000
  }
note that bytes field is set to zero define type xyz dbl colorspace sh pt xyz channels sh bytes sh define type lab dbl colorspace sh pt lab channels sh bytes sh define type gray dbl colorspace sh pt gray channels sh bytes sh define type rgb dbl colorspace sh pt rgb channels sh bytes sh define type cmyk dbl colorspace sh pt cmyk channels sh bytes sh endif gamma table parameters typedef struct unsigned int crc has my  {
	                                                                            my :: -1000
                                                                             }
table been touched keep initial parameters for further serialization  {
	serialization :: -1000
       }
int type double params lcmsgammaparams  {
   }
far lplcmsgammaparams  {
 }
gamma tables typedef struct lcmsgammaparams seed parameters used for table creation table based representation follows int nentries  {
	       orneriest :: 10
	        internes :: 11
	        gantries :: 10
	        pantries :: 10
	        peltries :: 10
	        vestries :: 10
	        penuries :: 10
	        gentries :: 13
	        sentries :: 13
	        dentines :: 10
	        rentiers :: 10
	        niteries :: 10
	        neurines :: 10
	        innerves :: 10
	        vintries :: 10
	        nervines :: 10
	       gentrices :: 10
	        denaries :: 10
	        senaries :: 10
	        nineties :: 11
               }
word gammatable  {
	lemmata :: 12
	magmata :: 12
 }
gammatable typedef gammatable far lpgammatable  {
   }
sampled  {
	sampled :: -1000
 }
curves d typedef struct int nitems double values sampledcurve  {
       }
typedef sampledcurve far lpsampledcurve  {
  }
vectors typedef struct float vector double n vec typedef vec far lpvec  {
          }
typedef struct matrix vec v mat typedef mat far lpmat  {
	    splat :: 6
	     lamp :: 6
        }
colorspace values typedef struct double x double y double z cmsciexyz  {
         }
typedef cmsciexyz far lpcmsciexyz  {
	saburra :: -1000
  }
typedef struct double x double y double y cmsciexyy  {
       }
typedef cmsciexyy far lpcmsciexyy  {
  }
typedef struct double l double a double b cmscielab  {
       }
typedef cmscielab far lpcmscielab  {
  }
typedef struct double l double c double h cmscielch  {
       }
typedef cmscielch far lpcmscielch  {
  }
typedef struct double j double c double h cmsjch  {
       }
typedef cmsjch far lpcmsjch  {
  }
primaries  {
	primaries :: -1000
 }
typedef struct cmsciexyz red cmsciexyz green cmsciexyz blue cmsciexyztriple  {
       }
typedef cmsciexyztriple far lpcmsciexyztriple  {
  }
typedef struct cmsciexyy red cmsciexyy green cmsciexyy blue cmsciexyytriple  {
       }
typedef cmsciexyytriple far lpcmsciexyytriple  {
  }
following icc spec define d x define d y define d z define perceptual  {
	   perceptual :: -1000
            }
black x define perceptual black y define perceptual black z does return pointers to constant structs lcmsapi lpcmsciexyz lcmsexport cmsd  {
                  }
xyz void lcmsapi lpcmsciexyy lcmsexport cmsd xyy  {
	 xylyl :: 3
     }
void input output lcmsapi cmshprofile lcmsexport cmsopenprofilefromfile  {
     }
const char iccprofile  {
 }
const char saccess  {
	saccoses :: 11
	abscess :: 9
	success :: 11
	sacless :: 10
	saucisse :: 9
	successor :: 9
 }
lcmsapi cmshprofile lcmsexport cmsopenprofilefrommem  {
  }
lpvoid memptr  {
	tempura :: 7
	kempt :: 7
	mumpers :: 7
	mumper :: 8
	temper :: 7
	tempt :: 7
	temp :: 7
	tamper :: 7
 }
dword dwsize  {
	assized :: 7
	resized :: 7
	unsized :: 7
	dorizes :: 7
 }
lcmsapi lcmsbool lcmsexport cmscloseprofile  {
	bedeguar :: -1000
  }
cmshprofile hprofile  {
 }
predefined  {
	predefined :: -1000
 }
run time profiles  {
	profiles :: -1000
 }
lcmsapi cmshprofile lcmsexport cmscreatergbprofile  {
  }
lpcmsciexyy whitepoint  {
 }
lpcmsciexyytriple primaries lpgammatable transferfunction  {
  }
lcmsapi cmshprofile lcmsexport cmscreategrayprofile  {
  }
lpcmsciexyy whitepoint lpgammatable transferfunction lcmsapi cmshprofile lcmsexport cmscreatelinearizationdevicelink  {
      }
iccolorspacesignature colorspace lpgammatable transferfunctions  {
  }
lcmsapi cmshprofile lcmsexport cmscreateinklimitingdevicelink  {
  }
iccolorspacesignature colorspace double limit lcmsapi cmshprofile lcmsexport cmscreatelabprofile  {
      }
lpcmsciexyy whitepoint lcmsapi cmshprofile lcmsexport cmscreatelab profile lpcmsciexyy whitepoint lcmsapi cmshprofile lcmsexport cmscreatexyzprofile  {
           }
void lcmsapi cmshprofile lcmsexport cmscreate srgbprofile  {
    }
void lcmsapi cmshprofile lcmsexport cmscreatebchswabstractprofile  {
   }
int nlutpoints  {
	bluepoint :: 12
	bluepoints :: 14
	autopoints :: 12
 }
double bright  {
	neutralizer :: -1000
 }
double contrast double hue  {
	hue :: -1000
  }
double saturation  {
	saturation :: -1000
 }
int tempsrc  {
	tempers :: 9
	tampers :: 9
	temps :: 10
	tempuras :: 9
 }
int tempdest  {
	tempted :: 12
	tempter :: 10
	templet :: 10
	temples :: 10
	deepmost :: 10
	timidest :: 10
	tempested :: 10
	tempters :: 11
	templets :: 11
	hempiest :: 10
	tempests :: 10
	adeptest :: 10
 }
lcmsapi cmshprofile lcmsexport cmscreatenullprofile  {
  }
void colorimetric space conversions  {
	conversions :: -1000
  }
lcmsapi void lcmsexport cmsxyz  {
  }
xyy lpcmsciexyy dest const cmsciexyz source lcmsapi void lcmsexport cmsxyy  {
        }
xyz lpcmsciexyz dest const cmsciexyy source lcmsapi void lcmsexport cmsxyz lab lpcmsciexyz whitepoint lpcmscielab lab const cmsciexyz xyz lcmsapi void lcmsexport cmslab  {
	              cymbals :: 7
                    }
xyz lpcmsciexyz whitepoint lpcmsciexyz xyz const cmscielab lab lcmsapi void lcmsexport cmslab lch lpcmscielch lch const cmscielab lab lcmsapi void lcmsexport cmslch  {
                    }
lab lpcmscielab lab const cmscielch lch cielab  {
	 chela :: 7
	 ceiba :: 7
	 cable :: 7
	kickable :: 7
	citeable :: 8
	cembali :: 7
	coinable :: 7
	citable :: 7
     }
handling lcmsapi double lcmsexport cmsdeltae  {
   }
lpcmscielab lab lpcmscielab lab lcmsapi double lcmsexport cmscie deltae  {
	dealates :: 7
	 delayer :: 7
	 delated :: 8
	 delates :: 9
	 medalet :: 7
	  gelate :: 7
	 deflate :: 8
	   delta :: 9
	  belted :: 7
	  belate :: 7
	  dilate :: 7
	 teazled :: 7
	 dealate :: 8
	 teagled :: 7
	 valeted :: 7
	  pelted :: 7
	  derate :: 7
	  dentel :: 7
	  dental :: 7
	  deltas :: 8
	  delete :: 7
	  delead :: 7
	  delate :: 10
	  defeat :: 7
	  debate :: 7
	 belated :: 8
	 related :: 8
	  welted :: 7
	  dartle :: 7
	delicate :: 7
	delibate :: 7
	  relate :: 7
	  felted :: 7
	bedtable :: 7
	 petaled :: 7
	  melted :: 7
	 redealt :: 7
	 metaled :: 7
	 legated :: 7
	 velated :: 8
	   telae :: 7
	  elated :: 7
	    deet :: 7
	    dalt :: 7
	 meltage :: 7
	  velate :: 7
	deflates :: 7
	deflater :: 7
	 gelated :: 8
       }
lpcmscielab lab lpcmscielab lab lcmsapi double lcmsexport cmsbfddeltae  {
	costliness :: -1000
      }
lpcmscielab lab lpcmscielab lab lcmsapi double lcmsexport cmscmcdeltae  {
      }
lpcmscielab lab lpcmscielab lab lcmsapi double lcmsexport cmscie deltae lpcmscielab lab lpcmscielab lab double kl double kc double kh  {
	       buttonballs :: -1000
                 }
lcmsapi void lcmsexport cmsclamplab  {
  }
lpcmscielab lab double amax  {
	amas :: 5
	amah :: 5
	ama :: 6
  }
double amin  {
	amin :: -1000
 }
double bmax  {
 }
double bmin  {
	brin :: 5
	bein :: 5
	amin :: 5
 }
lcmsapi lcmsbool lcmsexport cmswhitepointfromtemp  {
  }
int tempk  {
	kempt :: 8
	kemps :: 6
	tempos :: 6
	tempt :: 6
	temps :: 7
	tempo :: 7
	tempi :: 7
	temp :: 8
	kemp :: 7
 }
lpcmsciexyy whitepoint lcmsapi lcmsbool lcmsexport cmsadapttoilluminant  {
    }
lpcmsciexyz result lpcmsciexyz sourcewhitept  {
  }
lpcmsciexyz illuminant lpcmsciexyz value lcmsapi lcmsbool lcmsexport cmsbuildrgb  {
      }
xyztransfermatrix  {
 }
lpmat r lpcmsciexyy whitepoint lpcmsciexyytriple primaries viewing conditions define avg  {
	     viga :: 3
	     vega :: 3
	     vagi :: 3
	      avo :: 3
	      ave :: 3
	       ag :: 3
        }
surround define avg surround define dim surround define dark  {
	    dark :: -1000
       }
surround define cutsheet  {
 }
surround define d calculate define d calculate discount  {
	discount :: -1000
      }
typedef struct cmsciexyz whitepoint double yb  {
	  yob :: 2
	  aby :: 2
	   by :: 2
    }
double la int surround double d value cmsviewingconditions  {
      }
typedef cmsviewingconditions far lpcmsviewingconditions  {
  }
ciecam  {
	circa :: 7
	caeca :: 7
	icecap :: 7
	caecum :: 8
	mecca :: 7
 }
s lcmsapi lcmshandle lcmsexport cmsciecam  {
   }
sinit  {
	pinites :: 7
	piniest :: 6
	intis :: 6
	binits :: 8
	seniti :: 7
	finis :: 6
	sanity :: 6
	binit :: 7
	winiest :: 6
	pinite :: 6
	tiniest :: 6
	finite :: 6
	ignites :: 6
	visit :: 6
	nisi :: 6
	liniest :: 6
	pinitols :: 6
	finites :: 7
	viniest :: 6
	minis :: 6
	siting :: 7
 }
lpcmsviewingconditions pvc  {
	pus :: -1000
 }
lcmsapi void lcmsexport cmsciecam sdone  {
	drones :: 7
	sponged :: 6
	spondee :: 6
	donnes :: 6
	drone :: 6
	stonked :: 6
	stonied :: 6
	anodes :: 6
	adonise :: 6
	sconced :: 6
	droners :: 6
	stoney :: 6
	stoner :: 6
	stoned :: 8
	stone :: 7
	stond :: 6
	snod :: 6
	spode :: 6
	sonde :: 7
	snore :: 6
	snoke :: 6
	shone :: 7
	scone :: 7
	sorned :: 7
	sooner :: 6
	sonder :: 6
	sodden :: 6
	snowed :: 7
	snored :: 7
	snoked :: 7
	noosed :: 6
   }
lcmshandle hmodel  {
	dhole :: 7
	holder :: 7
	holden :: 7
 }
lcmsapi void lcmsexport cmsciecam sforward  {
	forewards :: 11
	foreward :: 10
	swordcraft :: 10
   }
lcmshandle hmodel lpcmsciexyz pin lpcmsjch pout  {
	 pout :: -1000
    }
lcmsapi void lcmsexport cmsciecam sreverse  {
	traverses :: 10
	renversed :: 10
	renverses :: 11
	preserve :: 11
	renverse :: 11
	subverse :: 10
	serveries :: 12
	servers :: 11
	preserves :: 12
	preserved :: 10
	perverse :: 11
	traverse :: 10
   }
lcmshandle hmodel lpcmsjch pin lpcmsciexyz pout ciecam lcmsapi lcmshandle lcmsexport cmsciecam init lpcmsviewingconditions pvc lcmsapi void lcmsexport cmsciecam done lcmshandle hmodel lcmsapi void lcmsexport cmsciecam forward lcmshandle hmodel lpcmsciexyz pin lpcmsjch pout lcmsapi void lcmsexport cmsciecam reverse lcmshandle hmodel lpcmsjch pin lpcmsciexyz pout gamma lcmsapi lpgammatable lcmsexport cmsbuildgamma  {
                                              }
int nentries double gamma lcmsapi lpgammatable lcmsexport cmsbuildparametricgamma  {
      }
int nentries int type double params lcmsapi lpgammatable lcmsexport cmsallocgamma  {
        }
int nentries lcmsapi void lcmsexport cmsfreegamma  {
    }
lpgammatable gamma lcmsapi void lcmsexport cmsfreegammatriple  {
    }
lpgammatable gamma lcmsapi lpgammatable lcmsexport cmsdupgamma  {
    }
lpgammatable src lcmsapi lpgammatable lcmsexport cmsreversegamma  {
    }
int nresultsamples  {
 }
lpgammatable ingamma  {
	mewed :: -1000
 }
lcmsapi lpgammatable lcmsexport cmsjoingamma  {
  }
lpgammatable ingamma lpgammatable outgamma  {
  }
lcmsapi lpgammatable lcmsexport cmsjoingammaex  {
  }
lpgammatable ingamma lpgammatable outgamma int npoints  {
	anoints :: 10
    }
lcmsapi lcmsbool lcmsexport cmssmoothgamma  {
  }
lpgammatable tab double lambda  {
	lambda :: -1000
  }
lcmsapi double lcmsexport cmsestimategamma  {
  }
lpgammatable t lcmsapi double lcmsexport cmsestimategammaex  {
    }
lpword table int nentries double thereshold  {
    }
lcmsapi lpgammatable lcmsexport cmsreadiccgamma  {
  }
cmshprofile hprofile ictagsignature sig lcmsapi lpgammatable lcmsexport cmsreadiccgammareversed  {
      }
cmshprofile hprofile ictagsignature sig access to profile data lcmsapi lcmsbool lcmsexport cmstakemediawhitepoint  {
          }
lpcmsciexyz dest cmshprofile hprofile lcmsapi lcmsbool lcmsexport cmstakemediablackpoint  {
      }
lpcmsciexyz dest cmshprofile hprofile lcmsapi lcmsbool lcmsexport cmstakeiluminant  {
      }
lpcmsciexyz dest cmshprofile hprofile lcmsapi lcmsbool lcmsexport cmstakecolorants  {
      }
lpcmsciexyztriple dest cmshprofile hprofile lcmsapi dword lcmsexport cmstakeheaderflags  {
      }
cmshprofile hprofile lcmsapi dword lcmsexport cmstakeheaderattributes  {
    }
cmshprofile hprofile lcmsapi void lcmsexport cmssetlanguage  {
    }
const char languagecode  {
	languaged :: 16
	language :: 15
 }
const char countrycode  {
	countryside :: 14
	countrywide :: 14
 }
lcmsapi const char lcmsexport cmstakeproductname  {
   }
cmshprofile hprofile lcmsapi const char lcmsexport cmstakeproductdesc  {
     }
cmshprofile hprofile lcmsapi const char lcmsexport cmstakeproductinfo  {
     }
cmshprofile hprofile lcmsapi const char lcmsexport cmstakemanufacturer  {
     }
cmshprofile hprofile lcmsapi const char lcmsexport cmstakemodel  {
     }
cmshprofile hprofile lcmsapi const char lcmsexport cmstakecopyright  {
     }
cmshprofile hprofile lcmsapi const byte lcmsexport cmstakeprofileid  {
     }
cmshprofile hprofile lcmsapi lcmsbool lcmsexport cmstakecreationdatetime  {
	revocations :: -1000
    }
struct tm dest cmshprofile hprofile lcmsapi lcmsbool lcmsexport cmstakecalibrationdatetime  {
       }
struct tm dest cmshprofile hprofile lcmsapi lcmsbool lcmsexport cmsistag  {
       }
cmshprofile hprofile ictagsignature sig lcmsapi int lcmsexport cmstakerenderingintent  {
      }
cmshprofile hprofile lcmsapi lcmsbool lcmsexport cmstakechartargetdata  {
    }
cmshprofile hprofile char data size t len lcmsapi int lcmsexport cmsreadicctextex  {
         }
cmshprofile hprofile ictagsignature sig char text size t size lcmsapi int lcmsexport cmsreadicctext cmshprofile hprofile ictagsignature sig char text define lcms desc max typedef struct icsignature devicemfg icsignature devicemodel icuint number attributes ictechnologysignature technology char manufacturer lcms desc max char model lcms desc max cmspseqdesc  {
                                           }
far lpcmspseqdesc  {
 }
typedef struct int n cmspseqdesc seq cmsseq  {
	 cesse :: 7
	  cess :: 7
     }
far lpcmsseq  {
 }
lcmsapi lpcmsseq lcmsexport cmsreadprofilesequencedescription  {
  }
cmshprofile hprofile lcmsapi void lcmsexport cmsfreeprofilesequencedescription  {
    }
lpcmsseq pseq translate form to our notation to icc lcmsapi iccolorspacesignature lcmsexport cmsicccolorspace  {
           }
int ournotation  {
	protonation :: 15
	protonations :: 14
	connotations :: 14
	connotation :: 15
 }
lcmsapi int lcmsexport cmslcmscolorspace  {
  }
iccolorspacesignature profilespace  {
 }
lcmsapi int lcmsexport cmschannelsof  {
	mischannels :: 18
  }
iccolorspacesignature colorspace lcmsapi lcmsbool lcmsexport cmsismatrixshaper  {
    }
cmshprofile hprofile how profiles may be used define lcms used as input define lcms used as output define lcms used as proof lcmsapi lcmsbool lcmsexport cmsisintentsupported  {
                        }
cmshprofile hprofile int intent int useddirection  {
    }
lcmsapi iccolorspacesignature lcmsexport cmsgetpcs  {
	cosmetics :: 11
  }
cmshprofile hprofile lcmsapi iccolorspacesignature lcmsexport cmsgetcolorspace  {
    }
cmshprofile hprofile lcmsapi icprofileclasssignature lcmsexport cmsgetdeviceclass  {
    }
cmshprofile hprofile lcmsapi dword lcmsexport cmsgetprofileiccversion  {
    }
cmshprofile hprofile lcmsapi void lcmsexport cmssetprofileiccversion  {
    }
cmshprofile hprofile dword version lcmsapi icint number lcmsexport cmsgettagcount  {
       }
cmshprofile hprofile lcmsapi ictagsignature lcmsexport cmsgettagsignature  {
    }
cmshprofile hprofile icint number n lcmsapi void lcmsexport cmssetdeviceclass  {
       }
cmshprofile hprofile icprofileclasssignature sig lcmsapi void lcmsexport cmssetcolorspace  {
      }
cmshprofile hprofile iccolorspacesignature sig lcmsapi void lcmsexport cmssetpcs  {
      }
cmshprofile hprofile iccolorspacesignature pcs lcmsapi void lcmsexport cmssetrenderingintent  {
	 trover :: -1000
      }
cmshprofile hprofile int renderingintent lcmsapi void lcmsexport cmssetheaderflags  {
      }
cmshprofile hprofile dword flags lcmsapi void lcmsexport cmssetheaderattributes  {
      }
cmshprofile hprofile dword flags lcmsapi void lcmsexport cmssetprofileid  {
      }
cmshprofile hprofile lpbyte profileid  {
	profilist :: 11
	profiling :: 11
	profile :: 13
	profited :: 11
	profiled :: 14
	profiles :: 12
	profiler :: 11
	prefiled :: 11
	reptiloid :: 11
	prolicide :: 11
  }
intents define intent perceptual define intent relative colorimetric define intent saturation define intent absolute colorimetric flags define cmsflags  {
	          boonies :: -1000
                }
matrixinput  {
 }
x define cmsflags matrixoutput  {
  }
x define cmsflags matrixonly  {
	matrocliny :: 13
	matronly :: 12
	matriliny :: 12
	matrimony :: 13
	patrimony :: 13
	matrix :: 12
  }
cmsflags matrixinput cmsflags matrixoutput define cmsflags nowhiteonwhitefixup  {
     }
x don t hot  {
	hot :: -1000
  }
fix scum  {
	scum :: -1000
 }
dot define cmsflags noprelinearization  {
	dateline :: -1000
  }
x don t create prelinearization  {
	denuclearization :: 20
	demineralization :: 20
	recentralization :: 20
   }
tables on precalculated  {
	miscalculated :: 17
 }
transforms  {
	transforms :: -1000
 }
internal use define cmsflags guessdeviceclass  {
   }
x guess device class for transform devicelink  {
	delivering :: 12
     }
define cmsflags notcache  {
	potlache :: 10
	coenact :: 10
	conchate :: 10
 }
x inhibit pixel cache define cmsflags notprecalc  {
	overfell :: -1000
     }
x define cmsflags nulltransform  {
  }
x don t transform anyway define cmsflags highresprecalc  {
      }
x use more memory to give better accurancy  {
	accuracy :: 14
	recusancy :: 11
	occupancy :: 12
      }
define cmsflags lowresprecalc  {
 }
x use less memory to minimize resouces  {
	rehouses :: 12
	refocussed :: 10
	cercuses :: 10
	recluses :: 11
	revoices :: 10
	recloses :: 10
	rejoices :: 10
	scrouges :: 10
	rescues :: 11
	resources :: 11
	recourses :: 10
	censures :: 10
	respaces :: 10
	resolves :: 10
	rehouse :: 10
	carouses :: 10
	recoupe :: 10
	repousse :: 10
	refocuses :: 10
	rescuers :: 10
	rescores :: 10
	obscures :: 10
     }
define cmsflags whiteblackcompensation  {
 }
x define cmsflags blackpointcompensation  {
  }
cmsflags whiteblackcompensation proofing  {
	proofing :: -1000
 }
flags define cmsflags gamutcheck  {
  }
x out of gamut alarm  {
	alarm :: -1000
   }
define cmsflags softproofing  {
	mothproofing :: 17
	rustproofing :: 17
 }
x do softproofing black preservation  {
	preservation :: -1000
   }
define cmsflags preserveblack  {
	preserve :: 16
	preservable :: 20
 }
x crd special define cmsflags nodefaultresourcedef  {
    }
x gridpoints define cmsflags gridpoints n n xff transforms lcmsapi cmshtransform lcmsexport cmscreatetransform  {
           }
cmshprofile input dword inputformat  {
  }
cmshprofile output dword outputformat  {
  }
int intent dword dwflags  {
  }
lcmsapi cmshtransform lcmsexport cmscreateproofingtransform  {
  }
cmshprofile input dword inputformat cmshprofile output dword outputformat cmshprofile proofing int intent int proofingintent  {
            }
dword dwflags lcmsapi cmshtransform lcmsexport cmscreatemultiprofiletransform  {
    }
cmshprofile hprofiles  {
 }
int nprofiles  {
	fluorines :: 11
	nerolis :: 11
 }
dword inputformat dword outputformat int intent dword dwflags lcmsapi void lcmsexport cmsdeletetransform  {
          }
cmshtransform htransform  {
	stratiform :: 12
 }
lcmsapi void lcmsexport cmsdotransform  {
  }
cmshtransform transform lpvoid inputbuffer  {
	cribwork :: -1000
  }
lpvoid outputbuffer  {
 }
unsigned int size lcmsapi void lcmsexport cmschangebuffersformat  {
     }
cmshtransform htransform dword inputformat dword dwoutputformat  {
    }
lcmsapi void lcmsexport cmssetalarmcodes  {
  }
int r int g int b lcmsapi void lcmsexport cmsgetalarmcodes  {
        }
int r int g int b adaptation  {
	adaptation :: -1000
     }
state for absolute colorimetric intent lcmsapi double lcmsexport cmssetadaptationstate  {
       }
double d primary preservation strategy  {
	strategy :: -1000
   }
define lcms preserve pure k define lcms preserve k plane  {
	    plane :: -1000
        }
lcmsapi int lcmsexport cmssetcmykpreservationstrategy  {
  }
int n named color support typedef struct char name max path word pcs word devicecolorant  {
             }
maxchannels cmsnamedcolor  {
 }
far lpcmsnamedcolor  {
 }
typedef struct int ncolors int allocated int colorantcount  {
      }
char prefix char suffix cmsnamedcolor list cmsnamedcolorlist  {
     }
far lpcmsnamedcolorlist  {
 }
named color support lcmsapi int lcmsexport cmsnamedcolorcount  {
     }
cmshtransform xform lcmsapi lcmsbool lcmsexport cmsnamedcolorinfo  {
    }
cmshtransform xform int ncolor char name char prefix char suffix lcmsapi int lcmsexport cmsnamedcolorindex  {
            }
cmshtransform xform const char name colorant tables lcmsapi lpcmsnamedcolorlist lcmsexport cmsreadcoloranttable  {
         }
cmshprofile hprofile ictagsignature sig profile creation lcmsapi lcmsbool lcmsexport cmsaddtag  {
        }
cmshprofile hprofile ictagsignature sig const void data converts  {
	converts :: -1000
      }
a transform to a devicelink profile lcmsapi cmshprofile lcmsexport cmstransform  {
        }
devicelink cmshtransform htransform dword dwflags set the save as bit flag lcmsapi void lcmsexport cmssetlutdepth  {
             }
cmshprofile hprofile int depth save profile lcmsapi lcmsbool lcmsexport cmssaveprofile  {
        }
cmshprofile hprofile const char filename lcmsapi lcmsbool lcmsexport cmssaveprofiletomem  {
       }
cmshprofile hprofile void memptr size t bytesneeded  {
     }
postscript colorrenderingdictionary  {
 }
and colorspacearray  {
 }
lcmsapi dword lcmsexport cmsgetpostscriptcsa  {
  }
cmshprofile hprofile int intent lpvoid buffer dword dwbufferlen  {
	unbuffered :: 14
      }
lcmsapi dword lcmsexport cmsgetpostscriptcrd  {
  }
cmshprofile hprofile int intent lpvoid buffer dword dwbufferlen lcmsapi dword lcmsexport cmsgetpostscriptcrdex  {
          }
cmshprofile hprofile int intent dword dwflags lpvoid buffer dword dwbufferlen error handling define lcms error abort define lcms error show define lcms error ignore lcmsapi int lcmsexport cmserroraction  {
                          }
int naction  {
	cantions :: 11
	caution :: 10
	cautions :: 9
	caption :: 10
	captions :: 9
	cantion :: 12
	contain :: 9
	auction :: 10
	paction :: 11
	actinon :: 9
	factions :: 10
	tactions :: 10
	unctions :: 9
	unction :: 10
	enation :: 9
	taction :: 11
	auctions :: 9
 }
define lcms errc warning x define lcms errc recoverable x define lcms errc aborted x typedef int cmserrorhandlerfunction  {
                }
int errorcode  {
 }
const char errortext  {
	uncaps :: -1000
 }
lcmsapi void lcmsexport cmsseterrorhandler  {
  }
cmserrorhandlerfunction fn lut manipulation  {
	manipulation :: -1000
  }
typedef struct lcms lut struc lut far lplut  {
	  uplit :: 6
      }
opaque pointer lcmsapi lplut lcmsexport cmsalloclut  {
    }
void lcmsapi lplut lcmsexport cmsalloclineartable  {
   }
lplut newlut  {
	netful :: 7
	englut :: 7
	nutlet :: 7
	newt :: 7
	newly :: 7
 }
lpgammatable tables int ntable  {
	unable :: 8
	neatly :: 7
	stableman :: 7
	stablemen :: 7
	neoblast :: 7
	stable :: 9
	enable :: 8
	stabled :: 8
	stables :: 8
	stabler :: 8
	blanket :: 7
	enabled :: 7
	enables :: 7
	enabler :: 7
	branle :: 7
	netball :: 7
	stablers :: 7
  }
lcmsapi lplut lcmsexport cmsalloc dgrid  {
	druid :: 6
	deride :: 6
   }
lplut lut int clutpoints int inputchan int outputchan lcmsapi lplut lcmsexport cmssetmatrixlut  {
          }
lplut lut lpmat m lcmsapi lplut lcmsexport cmssetmatrixlut lplut lut lpmat m lpvec off dword dwflags lcmsapi void lcmsexport cmsfreelut  {
                  }
lplut lut lcmsapi void lcmsexport cmsevallut  {
    }
lplut lut word in word out lcmsapi double lcmsexport cmsevallutreverse  {
        }
lplut lut word target word result lpword hint lcmsapi lplut lcmsexport cmsreadicclut  {
          }
cmshprofile hprofile ictagsignature sig lcmsapi lplut lcmsexport cmsduplut  {
      }
lplut orig lut sampling typedef int cmssampler  {
     }
register word in register word out register lpvoid cargo  {
	   cargo :: -1000
       }
define sampler  {
	sampler :: -1000
 }
hastl  {
	laths :: 6
	hasteful :: 6
	hosta :: 6
	hasty :: 7
	haste :: 7
	hasta :: 6
	harts :: 6
	hants :: 6
	halts :: 8
	hafts :: 6
	haets :: 6
	lastly :: 6
	hustle :: 6
	hostly :: 6
	fastly :: 6
	hastily :: 7
	harslet :: 6
	tash :: 6
	salt :: 6
	hasten :: 6
	hasted :: 6
	haslet :: 7
	last :: 7
	lash :: 6
	hantle :: 6
	hats :: 6
	hast :: 8
	halt :: 7
	castle :: 6
	hantles :: 7
	halters :: 6
	vastly :: 6
	haltless :: 6
	has :: 6
 }
lut hastl define sampler hastl lut hastl define sampler inspect x lcmsapi int lcmsexport cmssample dgrid lplut lut cmssampler sampler lpvoid cargo dword dwflags formatters  {
	              formatters :: -1000
                       }
typedef unsigned char cmsformatter  {
  }
register void cmmcargo  {
 }
register word tounroll  {
	tourbillons :: 10
	tourbillion :: 10
	tourbillon :: 11
 }
register lpbyte buffer lcmsapi void lcmsexport cmssetuserformatters  {
     }
cmshtransform htransform dword dwinput  {
  }
cmsformatter input dword dwoutput cmsformatter output lcmsapi void lcmsexport cmsgetuserformatters  {
        }
cmshtransform htransform lpdword inputformat cmsformatter input lpdword outputformat cmsformatter output it cgats  {
	      goats :: 6
	      gnats :: 6
	      ghats :: 6
	      geats :: 6
	      crags :: 6
	      coats :: 7
	      chats :: 7
	      casts :: 6
	      cants :: 6
	       scat :: 6
	      scats :: 6
	       cast :: 6
          }
x handling lcmsapi lcmshandle lcmsexport cmsit  {
	 cist :: 6
	casita :: 6
	musit :: 6
    }
alloc void lcmsapi void lcmsexport cmsit free lcmshandle it tables lcmsapi int lcmsexport cmsit tablecount  {
	      tabletop :: 12
             }
lcmshandle it lcmsapi int lcmsexport cmsit settable  {
	sealable :: 10
	tastable :: 11
	bittacles :: 10
	bedtables :: 11
	settle :: 10
	fittable :: 10
	tentacles :: 10
	meltable :: 10
	testable :: 14
	nestable :: 12
	seizable :: 10
	rentable :: 10
	sellable :: 10
	suitable :: 10
	statable :: 12
	bedtable :: 10
	servable :: 10
	sendable :: 10
	heatable :: 10
	beatable :: 10
	sortable :: 10
	wettable :: 13
	nettable :: 13
	lettable :: 13
	gettable :: 13
	cuttable :: 10
     }
lcmshandle it int ntable persistence  {
	persistence :: -1000
   }
lcmsapi lcmshandle lcmsexport cmsit loadfromfile  {
   }
const char cfilename  {
 }
lcmsapi lcmshandle lcmsexport cmsit loadfrommem  {
   }
void ptr size t len lcmsapi lcmsbool lcmsexport cmsit savetofile  {
        }
lcmshandle it const char cfilename lcmsapi lcmsbool lcmsexport cmsit savetomem  {
        }
lcmshandle hit void memptr size t bytesneeded properties  {
	properties :: -1000
      }
lcmsapi const char lcmsexport cmsit getsheettype  {
    }
lcmshandle hit lcmsapi lcmsbool lcmsexport cmsit setsheettype  {
     }
lcmshandle hit const char type lcmsapi lcmsbool lcmsexport cmsit setcomment lcmshandle hit const char ccomment  {
             }
lcmsapi lcmsbool lcmsexport cmsit setpropertystr  {
   }
lcmshandle hit const char cprop  {
	croppy :: 6
   }
const char str lcmsapi lcmsbool lcmsexport cmsit setpropertydbl  {
	variegated :: -1000
      }
lcmshandle hit const char cprop double val lcmsapi lcmsbool lcmsexport cmsit setpropertyhex  {
          }
lcmshandle hit const char cprop int val lcmsapi lcmsbool lcmsexport cmsit setpropertymulti  {
          }
lcmshandle hit const char cprop const char csubprop  {
	pyrolusites :: -1000
      }
const char val lcmsapi lcmsbool lcmsexport cmsit setpropertyuncooked  {
      }
lcmshandle hit const char key const char buffer lcmsapi const char lcmsexport cmsit getproperty  {
            }
lcmshandle hit const char cprop lcmsapi double lcmsexport cmsit getpropertydbl  {
        }
lcmshandle hit const char cprop lcmsapi const char lcmsexport cmsit getpropertymulti  {
	 amatorian :: -1000
         }
lcmshandle hit const char cprop const char csubprop lcmsapi int lcmsexport cmsit enumproperties  {
           }
lcmshandle hit const char propertynames  {
	propertyless :: 16
   }
lcmsapi int lcmsexport cmsit enumpropertymulti  {
   }
lcmshandle hit const char cprop const char subpropertynames  {
      }
datasets  {
	beatitudes :: -1000
 }
lcmsapi const char lcmsexport cmsit getdatarowcol  {
    }
lcmshandle it int row int col lcmsapi double lcmsexport cmsit getdatarowcoldbl  {
         }
lcmshandle it int row int col lcmsapi lcmsbool lcmsexport cmsit setdatarowcol  {
         }
lcmshandle hit int row int col const char val lcmsapi lcmsbool lcmsexport cmsit setdatarowcoldbl  {
            }
lcmshandle hit int row int col double val lcmsapi const char lcmsexport cmsit getdata lcmshandle it const char cpatch  {
	       reemissions :: -1000
                 }
const char csample  {
	fendy :: -1000
 }
lcmsapi double lcmsexport cmsit getdatadbl  {
   }
lcmshandle it const char cpatch const char csample lcmsapi lcmsbool lcmsexport cmsit setdata lcmshandle it const char cpatch const char csample const char val lcmsapi lcmsbool lcmsexport cmsit setdatadbl  {
                           }
lcmshandle hit const char cpatch const char csample double val lcmsapi int lcmsexport cmsit getdataformat  {
             }
lcmshandle hit const char csample lcmsapi lcmsbool lcmsexport cmsit setdataformat  {
        }
lcmshandle it int n const char sample lcmsapi int lcmsexport cmsit enumdataformat  {
          }
lcmshandle it char samplenames  {
  }
lcmsapi const char lcmsexport cmsit getpatchname  {
	  ego :: -1000
    }
lcmshandle hit int npatch  {
	planchet :: 7
	planch :: 7
	snatchy :: 7
	nautch :: 8
	stanch :: 7
	snatch :: 8
  }
char buffer lcmsapi int lcmsexport cmsit getpatchbyname  {
     }
lcmshandle hit const char csample the label extension lcmsapi int lcmsexport cmsit settablebylabel  {
	     epicure :: -1000
           }
lcmshandle hit const char cset  {
	crest :: 5
	coste :: 5
	chest :: 5
	cesti :: 5
	cesta :: 5
	certs :: 5
	cents :: 5
	celts :: 5
	caste :: 5
	cheths :: 5
	sect :: 5
   }
const char cfield  {
	flied :: 7
	clied :: 8
	chiel :: 7
	coiled :: 7
	coifed :: 7
	chields :: 8
	afield :: 9
	chield :: 9
	ceiled :: 7
	cliffed :: 7
 }
const char expectedtype  {
 }
lcmsapi lcmsbool lcmsexport cmsit setindexcolumn  {
   }
lcmshandle hit const char csample formatter for double lcmsapi void lcmsexport cmsit definedblformat  {
           }
lcmshandle it const char formatter end of little cms api from here functions are private you can use them only if using static libraries and at your own risk  {
	                        risk :: -1000
                           }
of be stripped  {
	stripped :: -1000
 }
or changed at futures  {
	futures :: -1000
  }
releases ifndef lcms apionly  {
	apiol :: 9
  }
compatibility with anterior  {
	anterior :: -1000
 }
versions not needed anymore morge  {
	murgeon :: 7
	horme :: 6
	porges :: 6
	porged :: 6
	gorse :: 6
	forme :: 6
	forge :: 7
	forgeman :: 6
	forget :: 6
	forges :: 6
	forged :: 6
	morses :: 6
	morsel :: 6
	mornes :: 6
	morned :: 6
	morgue :: 8
	morgen :: 9
	morgay :: 6
	morgan :: 6
	moreen :: 6
	monger :: 8
	mogged :: 6
	morgues :: 7
	morgens :: 8
	merges :: 6
	merged :: 6
	mongrel :: 6
	mongery :: 7
	mongers :: 7
	marges :: 6
	more :: 7
	gore :: 6
	rouge :: 6
	gormed :: 7
	gorget :: 6
	gorged :: 6
	porge :: 7
	morse :: 7
	morne :: 7
	mores :: 6
	morel :: 6
	morae :: 7
	moire :: 6
	merge :: 7
	marge :: 7
	 mor :: 6
   }
lcmsapi void lcmsexport cmslabencoded  {
  }
float lpcmscielab lab const word wlab  {
	blaws :: 5
	blawn :: 5
	 slab :: 5
	 flab :: 5
	 blaw :: 6
	 blab :: 5
    }
lcmsapi void lcmsexport cmslabencoded float lpcmscielab lab const word wlab lcmsapi void lcmsexport cmsfloat  {
            }
labencoded  {
	expatriations :: -1000
 }
word wlab const cmscielab lab lcmsapi void lcmsexport cmsfloat labencoded word wlab const cmscielab lab lcmsapi void lcmsexport cmsxyzencoded  {
                 }
float lpcmsciexyz fxyz  {
 }
const word xyz lcmsapi void lcmsexport cmsfloat xyzencoded  {
      }
word xyz const cmsciexyz fxyz profiling  {
	profiling :: -1000
    }
extensions would be removed from api in future revisions  {
	revisions :: -1000
       }
lcmsapi lcmsbool lcmsexport cmsaddtexttag  {
  }
cmshprofile hprofile ictagsignature sig const char text lcmsapi lcmsbool lcmsexport cmsaddxyztag  {
         }
cmshprofile hprofile ictagsignature sig const cmsciexyz xyz lcmsapi lcmsbool lcmsexport cmsaddluttag  {
         }
cmshprofile hprofile ictagsignature sig const void lut lcmsapi lcmsbool lcmsexport cmsaddgammatag  {
         }
cmshprofile hprofile ictagsignature sig lpgammatable transferfunction lcmsapi lcmsbool lcmsexport cmsaddchromaticitytag  {
        }
cmshprofile hprofile ictagsignature sig lpcmsciexyytriple chrm  {
	chirm :: 5
	charm :: 5
	chromo :: 5
	chrome :: 5
	chroma :: 5
	chrism :: 5
	chimer :: 5
	chimar :: 5
	 corm :: 5
	 chum :: 5
	 cham :: 5
    }
lcmsapi lcmsbool lcmsexport cmsaddsequencedescriptiontag  {
  }
cmshprofile hprofile ictagsignature sig lpcmsseq pseq lcmsapi lcmsbool lcmsexport cmsaddnamedcolortag  {
        }
cmshprofile hprofile ictagsignature sig lpcmsnamedcolorlist nc lcmsapi lcmsbool lcmsexport cmsadddatetimetag  {
        }
cmshprofile hprofile ictagsignature sig struct tm datetime lcmsapi lcmsbool lcmsexport cmsaddcoloranttabletag  {
         }
cmshprofile hprofile ictagsignature sig lpcmsnamedcolorlist nc lcmsapi lcmsbool lcmsexport cmsaddchromaticadaptationtag  {
        }
cmshprofile hprofile ictagsignature sig const cmsciexyz mat inline functions fast floor conversion logic thanks to sree  {
	           tatu :: -1000
              }
kotay  {
	korat :: 6
	tokays :: 7
	tokay :: 8
	today :: 6
 }
and stuart  {
	attars :: 7
	stuprate :: 8
	astrut :: 7
	astart :: 7
	stratum :: 8
	stratus :: 7
	truant :: 7
	ottars :: 7
	truants :: 8
	squatty :: 7
	stuprated :: 7
	squatter :: 8
	striatum :: 7
	strunt :: 7
	strout :: 7
	strati :: 7
	strath :: 7
	strait :: 8
	stature :: 7
	startup :: 7
	surat :: 7
	sturt :: 8
	strut :: 7
	start :: 7
	squattier :: 7
	straucht :: 7
 }
nixon  {
	nitons :: 6
	pinon :: 6
	niton :: 7
	ninon :: 6
 }
note than this only works in the range because mantissa is interpreted as fixed point the union is to avoid pointer aliasing  {
	             aliasing :: -1000
                    }
overoptimization  {
 }
lcms inline int cmsquickfloor  {
	communicatees :: -1000
  }
double val ifdef use default floor conversion return int floor val else const double lcms double fixmagic  {
               }
uses limited precision to floor union double val int halves temp temp val val lcms double fixmagic ifdef use big endian return temp halves else return temp halves endif endif clamp  {
	                 monochromator :: -1000
                             }
with saturation lcms inline word cmsclampword  {
    }
int in if in return if in xffff return xffffu  {
        }
including marker return word in ifndef lcms user alloc low level alloc hook lcms inline void cmsmalloc  {
	       mundified :: -1000
               }
size t size if size size t return null never allow over mb if size return null prevent signed size t exploits  {
	             exploits :: -1000
                    }
return void malloc size lcms inline void cmscalloc  {
      }
size t nmemb  {
 }
size t size size t alloc nmemb size if size return cmsmalloc if alloc size nmemb return null return cmsmalloc alloc lcms inline void cmsfree void ptr if ptr free ptr endif end of inline functions signal error from inside lcms code void cdecl cmssignalerror  {
                                           }
int errorcode const char errortext alignment handling needed in readlut  {
	 readouts :: 10
	 readjust :: 9
	 radulate :: 9
	resaluted :: 9
	  rundlet :: 9
	  readout :: 11
        }
and readlut typedef struct ics fixed number a icuint number b cmstestalign  {
          }
define sizeof uint aligned sizeof cmstestalign sizeof ics fixed number typedef struct ics fixed number a icuint number b cmstestalign define sizeof uint aligned sizeof cmstestalign sizeof ics fixed number fixed point typedef icint number fixed fixed whith  {
	                               writhe :: 6
	                                haith :: 6
	                               whisht :: 8
	                             whithers :: 7
	                            whithered :: 6
	                             whishted :: 6
	                                width :: 6
	                                whity :: 6
	                                whits :: 6
	                                white :: 6
	                                whish :: 7
	                                which :: 7
	                                thigh :: 6
	                                swith :: 6
	                              whitish :: 6
	                              whither :: 8
	                              whishts :: 7
	                                 whit :: 7
                                    }
sign define int to fixed x x define double to fixed x fixed x define fixed to int x x define fixed rest to int x x xffffu define fixed to double x double x define round fixed to int x x x fixed cdecl fixedmul  {
	                                        fixed :: 10
	                                      fixedly :: 10
                                            }
fixed a fixed b fixed cdecl fixedsquare  {
     }
fixed a ifdef use inline lcms inline fixed tofixeddomain  {
       }
int a return a a x fff xffff lcms inline int fromfixeddomain  {
          }
fixed a return a a x fff else fixed cdecl tofixeddomain int a a int cdecl fromfixeddomain fixed a a endif fixed cdecl fixedlerp  {
	               diplexer :: 11
                      }
fixed a fixed l fixed h word cdecl fixedscale  {
       }
word a fixed s vector matrix operations i m using the notation frequently found in literature  {
	     literature :: -1000
              }
mostly  {
	mostly :: -1000
 }
graphic gems  {
	gems :: -1000
 }
samples not to be same routines vector members define vx  {
	      vox :: 2
	      vex :: 2
	        v :: 2
        }
define vy  {
	v :: 2
 }
define vz  {
	sisses :: -1000
 }
typedef struct fixed bits vector fixed n wvec  {
      }
far lpwvec  {
 }
typedef struct matrix fixed wvec v wmat  {
	  what :: 5
     }
far lpwmat  {
 }
void cdecl vec init lpvec r double x double y double z double version void cdecl vec initf lpwvec r double x double y double z fix version void cdecl vec tofix lpwvec r lpvec v void cdecl vec fromfix lpvec r lpwvec v void cdecl vec scalefix  {
	                                          scale :: 10
	                                        scaleni :: 11
                                              }
lpword r lpwvec scale void cdecl vec swap lpvec a lpvec b void cdecl vec divk  {
	           divs :: 5
	           dive :: 5
	           disk :: 5
	           dirk :: 5
	           dink :: 5
	           dick :: 5
	            div :: 6
              }
lpvec r lpvec v double d void cdecl vec perk  {
	     perk :: -1000
        }
lpvec r lpvec v double d void cdecl vec minus lpvec r lpvec a lpvec b void cdecl vec percomp  {
	            precoup :: 9
	         precompute :: 9
                  }
lpvec r lpvec a lpvec b lcmsbool cdecl vec equal lpwvec a lpwvec b double tolerance  {
	      tolerance :: -1000
              }
lcmsbool cdecl vec equalf  {
	monogerm :: -1000
  }
lpvec a lpvec b double tolerance void cdecl vec scaleandcut  {
        }
lpwvec r lpvec v double d void cdecl vec cross lpvec r lpvec u lpvec v void cdecl vec saturate  {
	           saturate :: -1000
                  }
lpvec v double cdecl vec distance  {
	distance :: -1000
    }
lpvec a lpvec b double cdecl vec length lpvec a void cdecl mat identity  {
	     identity :: -1000
            }
lpmat a void cdecl mat per lpmat r lpmat a lpmat b void cdecl mat perk lpmat r lpmat v double d int cdecl mat inverse lpmat a lpmat b lcmsbool cdecl mat solve  {
	                            solve :: -1000
                                }
lpvec x lpmat a lpvec b double cdecl mat det lpmat m void cdecl mat eval lpvec r lpmat a lpvec v void cdecl mat tofix lpwmat r lpmat v void cdecl mat fromfix lpmat r lpwmat v void cdecl mat evalw  {
	                                    avale :: 6
	                                     weal :: 6
	                                     veal :: 6
                                        }
lpwvec r lpwmat a lpwvec v lcmsbool cdecl mat isidentity  {
        }
lpwmat a double tolerance void cdecl mat scaleandcut lpwmat r lpmat v double d is a table linear int cdecl cmsislinear  {
                   }
word table int nentries i hold this structures describing domain details mainly for optimization purposes struct lcms l params struc typedef void cms dlerp  {
	                slurped :: 6
	                   pled :: 6
                      }
word input word output word luttable  {
	fittable :: 10
	rustable :: 10
	gustable :: 10
	huntable :: 10
	tiltable :: 11
	suitable :: 10
	listable :: 10
	wettable :: 10
	nettable :: 10
	lettable :: 13
	gettable :: 10
	cuttable :: 13
	quotable :: 10
	liftable :: 10
    }
struct lcms l params struc p typedef struct lcms l opt struc used on bit interpolations  {
	 interpolations :: -1000
              }
unsigned int x y z word rx ry  {
	     si :: -1000
      }
rz  {
	wineshop :: -1000
 }
l params far lpl params typedef struct lcms l params struc used on bits interpolations int nsamples  {
	        tramples :: 10
	        maniples :: 10
	        spangles :: 10
	       stampless :: 10
	       esemplasy :: 10
	        whamples :: 10
	        examples :: 10
               }
valid on all kinds  {
	kinds :: -1000
  }
of tables int ninputs  {
	pignuts :: 9
	ninjutsu :: 9
  }
only in d interpolation int noutputs  {
    }
only in d interpolation word domain int opta opta int opta opta optimization for d lut int opta opta int opta opta cms dlerp interp d the interpolation routine lpl params p points to some tables for bit speedup l params lpl params void cdecl cmscalcl  {
                                            }
params int nsamples lpl params p void cdecl cmscalcclut  {
       }
params int nsamples int inputchan int outputchan lpl params p void cdecl cmscalcclut paramsex  {
	       praams :: 10
	    paraments :: 10
	    parameses :: 10
	      paramos :: 10
	      paracme :: 10
	       maraes :: 10
	     paramese :: 11
	     paracmes :: 11
            }
int nsamples int inputchan int outputchan lcmsbool lusetetrahedral  {
      }
lpl params p word cdecl cmslinearinterplut  {
    }
word value word luttable lpl params p fixed cdecl cmslinearinterpfixed  {
	 reasoner :: -1000
        }
word value word luttable lpl params p word cdecl cmsreverselinearinterplut  {
        }
word value word luttable lpl params p void cdecl cmstrilinearinterp  {
        }
word input word output word luttable lpl params p void cdecl cmstetrahedralinterp  {
          }
word input word output word luttable lpl params p void cdecl cmstetrahedralinterp word input word output word luttable lpl params p lut handling define lut hasmatrix  {
	                submatrix :: 11
                        }
x do op flags define lut hastl x define lut hastl x define lut has dgrid x new in rev of icc spec define lut hasmatrix x matrix offset for lutatob  {
                             }
define lut hasmatrix x matrix offset for lutbtoa  {
	outbleats :: 9
	outbleat :: 10
      }
define lut hastl x curves for lutatob define lut hastl x curves for lutbtoa v emulation  {
	      emulation :: -1000
              }
define lut v output emulate  {
	emulate :: -1000
   }
v x is a v output lut emulating  {
	emulating :: -1000
      }
v define lut v input emulate v x is a v input lut emulating v define lut v output emulate v x is a v output lut emulating v define lut v input emulate v x is a v input lut emulating v struct lcms lut struc dword wflags  {
	                                    postmistress :: -1000
                                               }
wmat matrix fixed matrix unsigned int inputchan unsigned int outputchan unsigned int inputentries  {
           }
unsigned int outputentries  {
 }
unsigned int clutpoints lpword l maxchannels first linearization  {
	linearization :: -1000
      }
lpword l maxchannels last linearization lpword t d clut unsigned int tsize  {
	     ditzes :: 6
	     ritzes :: 6
	     tizzes :: 7
	      zeist :: 6
	      toise :: 6
	      seize :: 6
          }
clut size in bytes parameters optimizations l params in params l params out params l params clut params int intent accomplished  {
	        accomplished :: -1000
                   }
intent new for rev of spec reserved wmat mat wvec ofs lpword l maxchannels l params l params unsigned int l entries wmat mat wvec ofs lpword l maxchannels l params l params unsigned int l entries gray axes  {
	                                  axes :: -1000
                                     }
fixup  {
	fixure :: 6
	mixups :: 6
	mixup :: 7
 }
only on v bit lab lut lcmsbool fixgrayaxes  {
	allocated :: -1000
      }
parameters used for curve creation lcmsgammaparams lcurvesseed  {
     }
maxchannels lut far lplut lcmsbool cdecl cmssmoothendpoints  {
	interbehavior :: -1000
     }
lpword table int nentries crc of gamma tables unsigned int cmscrc  {
         }
ofgammatable  {
 }
lpgammatable table sampled curves lpsampledcurve cdecl cmsallocsampledcurve  {
	ongoingnesses :: -1000
     }
int nitems void cdecl cmsfreesampledcurve  {
   }
lpsampledcurve p lpsampledcurve cdecl cmsdupsampledcurve  {
   }
lpsampledcurve p lpsampledcurve cdecl cmsconvertgammatosampledcurve  {
   }
lpgammatable gamma int npoints lpgammatable cdecl cmsconvertsampledcurvetogamma  {
     }
lpsampledcurve sampled double max void cdecl cmsendpointsofsampledcurve  {
     }
lpsampledcurve p double min double max void cdecl cmsclampsampledcurve  {
       }
lpsampledcurve p double min double max lcmsbool cdecl cmssmoothsampledcurve  {
       }
lpsampledcurve tab double smoothinglambda  {
  }
void cdecl cmsrescalesampledcurve  {
 }
lpsampledcurve p double min double max int npoints lpsampledcurve cdecl cmsjoinsampledcurves  {
	 exorcised :: -1000
         }
lpsampledcurve x lpsampledcurve y int nresultingpoints  {
    }
shaper  {
	shaper :: -1000
 }
matrix handling define matshaper  {
	marshaled :: 11
  }
hasmatrix x do ops flags define matshaper hasshaper  {
      }
x define matshaper input x behaviour define matshaper output x define matshaper hasinpshaper  {
           }
x define matshaper allsmelted  {
  }
matshaper input matshaper output typedef struct dword dwflags wmat matrix l params p primary curve lpword l l params p secondary curve used as input in smelted  {
	                   smelted :: -1000
                         }
ones lpword l matshaper far lpmatshaper  {
    }
lpmatshaper cdecl cmsallocmatshaper  {
 }
lpmat matrix lpgammatable shaper dword behaviour lpmatshaper cdecl cmsallocmatshaper lpmat matrix lpgammatable in lpgammatable out dword behaviour void cdecl cmsfreematshaper  {
                  }
lpmatshaper matshaper void cdecl cmsevalmatshaper  {
   }
lpmatshaper matshaper word in word out lcmsbool cdecl cmsreadiccmatrixrgb  {
       }
xyz lpmat r cmshprofile hprofile lpmatshaper cdecl cmsbuildinputmatrixshaper  {
      }
cmshprofile inputprofile  {
 }
lpmatshaper cdecl cmsbuildoutputmatrixshaper  {
 }
cmshprofile outputprofile  {
	riels :: -1000
 }
white point primary chromas  {
	eigentones :: -1000
  }
handling lcmsbool cdecl cmsadaptationmatrix  {
  }
lpmat r lpmat conematrix  {
	moderatrix :: 13
	cinerator :: 12
	cameration :: 12
	racemation :: 12
	manometric :: 13
	coinmate :: 13
	coinmates :: 12
	dominatrix :: 12
	dominatrixes :: 12
  }
lpcmsciexyz fromill  {
 }
lpcmsciexyz toill  {
	twilly :: 6
	twills :: 6
	tuille :: 6
	trills :: 6
	trillo :: 8
	maillot :: 6
	thills :: 6
	trilloes :: 6
	twill :: 7
	troll :: 6
	triol :: 6
	trill :: 7
	tolyl :: 6
	toils :: 6
	toile :: 6
	thiol :: 6
	thill :: 7
	still :: 6
	toll :: 6
	toil :: 7
	toilless :: 7
	taille :: 6
	toilful :: 7
 }
lcmsbool cdecl cmsadaptmatrixtod  {
 }
lpmat r lpcmsciexyy sourcewhitept lcmsbool cdecl cmsadaptmatrixfromd  {
     }
lpmat r lpcmsciexyy destwhitept  {
	brimstony :: -1000
  }
lcmsbool cdecl cmsreadchromaticadaptationmatrix  {
 }
lpmat r cmshprofile hprofile inter pcs conversion routines they assume d as white point void cdecl cmsxyz labencoded word xyz word lab void cdecl cmslab xyzencoded word lab word xyz retrieve text representation of wp void cdecl cmsidentifywhitepoint  {
                                    }
char buffer lpcmsciexyz whitept  {
	whiteout :: 9
	white :: 9
	whittle :: 9
	whitter :: 9
	whitest :: 11
	whippet :: 9
  }
quantize to word in a maxsamples  {
	muclucs :: -1000
    }
domain word cdecl cmsquantizeval  {
  }
double i int maxsamples lpcmsnamedcolorlist cdecl cmsallocnamedcolorlist  {
     }
int n int cdecl cmsreadiccnamedcolorlist  {
   }
cmshtransform xform cmshprofile hprofile ictagsignature sig void cdecl cmsfreenamedcolorlist  {
       }
lpcmsnamedcolorlist list lcmsbool cdecl cmsappendnamedcolor  {
   }
cmshtransform xform const char name word pcs word colorant maxchannels i o define max table tag this is the internal struct holding profile details typedef struct lcms iccprofile struct void stream associated stream if null tags are supposed  {
	                             supposed :: -1000
                                    }
to be in memory rather than in a file only most important items found in icc profile icprofileclasssignature deviceclass iccolorspacesignature colorspace iccolorspacesignature pcs icrenderingintent renderingintent icuint number flags icuint number attributes cmsciexyz illuminant additions for v profiles icuint number version mat chromaticadaptation  {
                                        }
cmsciexyz mediawhitepoint  {
 }
cmsciexyz mediablackpoint  {
 }
byte profileid dictionary  {
	dictionary :: -1000
 }
icint number tagcount  {
 }
ictagsignature tagnames  {
	wantages :: 10
	vantages :: 10
	magnates :: 14
	tannages :: 12
	tankages :: 11
	magentas :: 11
	pageants :: 10
	emanates :: 10
	mandates :: 10
	magnate :: 12
	tannage :: 10
	nametags :: 10
	thanages :: 11
 }
max table tag size t tagsizes  {
	capsizes :: 10
	agatizes :: 10
	teasings :: 10
    }
max table tag size t tagoffsets  {
    }
max table tag lpvoid tagptrs  {
   }
max table tag char physicalfile  {
   }
max path lcmsbool iswrite  {
	unwrites :: 9
	rewrites :: 9
	cowrites :: 9
  }
lcmsbool saveas  {
	shevas :: 7
	selvas :: 7
	caveats :: 7
	savates :: 8
	savages :: 8
	savers :: 8
	savagest :: 7
	vanessa :: 8
	kavass :: 7
	saves :: 8
	salvages :: 7
 }
bits struct tm created i o handlers size t read void buffer size t size size t count struct lcms iccprofile struct icc lcmsbool seek struct lcms iccprofile struct icc size t offset lcmsbool close struct lcms iccprofile struct icc size t tell struct lcms iccprofile struct icc writting  {
	                                        trotting :: 10
	                                      twittingly :: 10
	                                      writhingly :: 10
	                                        whetting :: 10
	                                        twitting :: 12
	                                        twisting :: 11
	                                       twittings :: 11
	                                        twirling :: 10
	                                        aretting :: 10
	                                        fretting :: 10
	                                        wresting :: 10
	                                        waisting :: 10
	                                        knitting :: 10
	                                        twilting :: 11
	                                        shitting :: 10
	                                        whisting :: 10
	                                       trithings :: 10
	                                       writhings :: 11
	                                        quitting :: 10
	                                        gritting :: 13
	                                        fritting :: 13
	                                        trithing :: 11
	                                        writhing :: 12
	                                       twistings :: 10
	                                         written :: 10
	                                         writing :: 10
	                                        flitting :: 10
	                                        slitting :: 10
	                                        printing :: 10
	                                        wringing :: 10
	                                        dratting :: 10
	                                        drifting :: 10
	                                        grifting :: 10
	                                        spitting :: 10
	                                        emitting :: 10
	                                        smitting :: 10
	                                        omitting :: 10
	                                        wricking :: 10
	                                      grittiness :: 10
                                               }
lcmsbool write struct lcms iccprofile struct icc size t size lpvoid ptr size t usedspace  {
	    headspaces :: 11
	     headspace :: 11
             }
lcmsiccprofile  {
 }
far lplcmsiccprofile  {
 }
create an empty template  {
	template :: -1000
  }
for virtual profiles cmshprofile cdecl cmscreateprofileplaceholder  {
    }
void search into tag dictionary icint number cdecl cmssearchtag  {
       }
lplcmsiccprofile profile ictagsignature sig lcmsbool lsignalerror  {
    }
search for a particular tag replace if found or add new one else lpvoid cmsinittag  {
             }
lplcmsiccprofile icc ictagsignature sig size t size const void init lplcmsiccprofile cdecl cmscreateprofilefromfileplaceholder  {
           }
const char filename lplcmsiccprofile cdecl cmscreateprofilefrommemplaceholder  {
    }
lpvoid memptr dword dwsize void cmssetsavetodisk  {
    }
lplcmsiccprofile icc const char filename void cmssetsavetomemory  {
     }
lplcmsiccprofile icc lpvoid memptr size t dwsize these macros unpack  {
	   unpack :: -1000
        }
format specifiers into integers define t dither s s define t colorspace s s define t swapfirst s s define t flavor s s define t planar p p define t endian e e define t doswap e e define t extra e e define t channels c c define t bytes b b internal xform struct struct cmstransform struct full xform typedef void cmscolorcallbackfn  {
                                                               }
struct cmstransform struct transform lpvoid inputbuffer lpvoid outputbuffer unsigned int size intermediate pass from word to word typedef void cmsadjfn  {
	             zanies :: -1000
                  }
word in word out lpwmat m lpwvec b typedef void cmstransfn  {
         }
struct cmstransform struct transform word in word out typedef void cmscnvrt  {
         }
word in word out typedef lpbyte cmsfixfn  {
     }
register struct cmstransform struct info register word tounroll register lpbyte buffer transformation  {
	transformation :: -1000
          }
typedef struct cmstransform struct keep formats for further reference dword inputformat outputformat dword stridein  {
	    seriating :: 10
	    sortieing :: 10
	     strigine :: 10
	     strident :: 10
	     stridden :: 10
	     striding :: 11
	       stride :: 11
	    stridling :: 12
	    stridency :: 10
            }
strideout  {
	strikeouts :: 13
	stoited :: 11
	stoiter :: 11
	strouted :: 11
	strident :: 12
	stride :: 11
	stridulate :: 12
	strikeout :: 15
	stradiot :: 11
 }
planar support int intent proofintent  {
   }
int dogamutcheck  {
 }
cmshprofile inputprofile cmshprofile outputprofile cmshprofile previewprofile  {
    }
iccolorspacesignature entrycolorspace  {
 }
iccolorspacesignature exitcolorspace  {
 }
dword dworiginalflags  {
 }
flags as specified by user wmat m m matrix holding inter pcs operation wvec of of offset terms cmscolorcallbackfn xform steps in xform cmsfixfn frominput  {
                       }
cmstransfn fromdevice  {
 }
cmsadjfn stage cmsadjfn stage cmstransfn todevice  {
	videlicet :: 10
	coderive :: 11
	covetise :: 10
	coderives :: 10
    }
cmsfixfn tooutput  {
 }
luts  {
	lutzes :: 5
	tuts :: 5
	puts :: 5
	nuts :: 5
	luvs :: 5
	lutz :: 5
	lust :: 6
	lurs :: 5
	lugs :: 5
	lues :: 5
	luds :: 5
	lots :: 5
	lits :: 5
	lets :: 5
	lats :: 5
	cuts :: 5
	lusty :: 5
	lusts :: 5
	lunts :: 5
	lotus :: 5
 }
lplut device pcs lplut pcs device lplut gamut gamut check lplut preview preview proof lplut devicelink precalculated grid device link profile lplut gamutcheck precalculated device gamut check matrix shapers  {
	                     shapers :: -1000
                           }
lpmatshaper inmatshaper  {
 }
lpmatshaper outmatshaper  {
 }
lpmatshaper smeltmatshaper  {
 }
phase  {
	phase :: -1000
 }
of lab xyz abs rel int phase phase phase named color table lpcmsnamedcolorlist namedcolorlist  {
            }
flag for transform involving  {
	outgassed :: -1000
  }
v profiles lcmsbool linputv  {
  }
lab loutputv  {
 }
lab pixel cache word cachein  {
	antitrusters :: -1000
   }
maxchannels word cacheout  {
	cachepot :: 12
	catechu :: 10
	cache :: 10
	cachets :: 10
	cachepots :: 11
	cachou :: 10
	cachet :: 11
 }
maxchannels double adaptationstate  {
 }
figure for v incomplete state of adaptation lcms rwlock t rwlock cmstransform far lpcmstransform  {
            }
packing  {
	packing :: -1000
 }
unpacking  {
	unpacking :: -1000
 }
cmsfixfn cdecl cmsidentifyinputformat  {
 }
lpcmstransform xform dword dwinput cmsfixfn cdecl cmsidentifyoutputformat  {
     }
lpcmstransform xform dword dwoutput conversion define xyzrel  {
     }
define labrel  {
	largely :: 7
	ballers :: 7
	liberal :: 7
	laurel :: 9
	ladler :: 7
	labret :: 8
	labile :: 7
	labels :: 7
	blare :: 7
	barrel :: 8
	barbel :: 7
	baller :: 8
	labrets :: 7
	labeler :: 8
	labeller :: 7
	gabeller :: 7
	labelers :: 7
	fabler :: 7
	sabre :: 7
	barrels :: 7
	barbell :: 7
	umbrella :: 7
	laurels :: 8
	rubella :: 7
 }
int cdecl cmschoosecnvrt  {
 }
int absolute int phase lpcmsciexyz blackpointin  {
    }
lpcmsciexyz whitepointin  {
 }
lpcmsciexyz illuminantin  {
	illuminants :: 15
	illuminist :: 15
	illuminati :: 17
	illuminant :: 16
	illuminations :: 17
	illuminative :: 15
	illuminating :: 17
	illumination :: 18
 }
lpmat chromaticadaptationmatrixin  {
 }
int phase lpcmsciexyz blackpointout  {
  }
lpcmsciexyz whitepointout  {
 }
lpcmsciexyz illuminantout  {
	illuminants :: 17
	illuminato :: 16
	illuminant :: 18
	illumination :: 16
 }
lpmat chromaticadaptationmatrixout  {
 }
int dobpc  {
	dob :: 6
 }
double adaptationstate cmsadjfn fn lpwmat wm lpwvec wof  {
	  wolfs :: 3
	  woful :: 4
	   woof :: 3
	   wolf :: 4
	   sowf :: 3
	   howf :: 3
	   fowl :: 3
	   dowf :: 3
	    wot :: 3
	    wos :: 3
	    wop :: 3
	    won :: 3
	    wok :: 3
	    wog :: 3
	    woe :: 3
	    oof :: 3
	     wo :: 4
      }
clamping  {
	clamping :: -1000
 }
gamut handling lcmsbool cdecl cmsendpointsbyspace  {
   }
iccolorspacesignature space word white word black int noutputs word cdecl cmswhitebyspace  {
         }
iccolorspacesignature space word cdecl clamp l fixed in word cdecl clamp ab fixed in detection  {
	     detection :: -1000
             }
of black point define lcms bpflags  {
	beflag :: 9
	beflags :: 11
    }
d adapted x int cdecl cmsdetectblackpoint  {
    }
lpcmsciexyz blackpoint cmshprofile hprofile int intent dword dwflags choose reasonable resolution int cdecl cmsreasonablegridpointsbycolorspace  {
            }
iccolorspacesignature colorspace dword dwflags precalculate device link lplut cdecl cmsprecalculatedevicelink  {
        }
cmshtransform h dword dwflags precalculate black preserving  {
	preserving :: -1000
     }
device link lplut cmsprecalculateblackpreservingdevicelink  {
  }
cmshtransform hcmyk  {
 }
cmyk dword dwflags precalculate gamut check lplut cdecl cmsprecalculategamutcheck  {
       }
cmshtransform h hot fixes  {
	fixes :: -1000
  }
bad profiles lcmsbool cdecl cmsfixwhitemisalignment  {
   }
lpcmstransform p marks lut as bit on input lplut cdecl cmsblesslut  {
         }
lplut lut compute gamut boundary lplut cdecl cmscomputegamutlut  {
	filiate :: -1000
      }
cmshprofile hprofile int intent compute softproof lplut cdecl cmscomputesoftprooflut  {
       }
cmshprofile hprofile int nintent  {
  }
find a suitable prelinearization tables matching the given transform void cdecl cmscomputeprelinearizationtablesfromxform  {
          }
cmshtransform h int ntransforms  {
  }
lplut grid build a tone curve for k k if possible only works on cmyk lpgammatable cmsbuildktonecurve  {
               }
cmshtransform hcmyk cmyk int npoints validates  {
	validates :: -1000
    }
a lut lcmsbool cdecl cmsvalidatelut  {
   }
lplut newlut these are two vital  {
	vital :: -1000
    }
macros from converting between and bit representation define rgb to rgb word word rgb rgb define rgb to rgb byte rgb xff endif lcms apionly define cms h ifdef cplusplus endif endif openldap this work is part of openldap software http www openldap org copyright the openldap foundation all rights reserved redistribution and use in source and binary forms with or without modification are permitted only as authorized by the openldap public license a copy of this license is available in file license in the top level directory of the distribution or alternatively at http www openldap org license html ldap c defines ifndef ldap cdefs h define ldap cdefs h if defined cplusplus defined c plusplus  {
                                                                                                                   }
define ldap begin decl extern c define ldap end decl else define ldap begin decl begin declarations define ldap end decl end declarations endif if defined ldap no prototypes defined ldap needs prototypes defined stdc defined cplusplus defined c plusplus ansi c or c define ldap p protos  {
	                                       protoxid :: 7
	                                       protonic :: 7
	                                         proton :: 9
	                                         prosos :: 9
	                                         proofs :: 8
	                                         pronto :: 7
	                                         promos :: 9
	                                       proteose :: 8
	                                         droops :: 7
	                                         pottos :: 8
	                                         potoos :: 7
	                                         portas :: 7
	                                         pornos :: 7
	                                         poorts :: 8
	                                      protostar :: 7
	                                      protoxids :: 8
	                                       dropouts :: 7
	                                       prootics :: 7
	                                       promotes :: 8
	                                        crotons :: 7
	                                        provost :: 10
	                                        proviso :: 7
	                                        protore :: 7
	                                        protons :: 10
	                                        prosoma :: 7
	                                        prosody :: 7
	                                        propose :: 7
	                                        pronota :: 7
	                                      provostry :: 7
	                                        promote :: 7
	                                        prologs :: 7
	                                         photos :: 9
	                                         troops :: 9
	                                         tripos :: 7
	                                      proteoses :: 7
	                                       postoral :: 7
	                                         orthos :: 7
	                                        photons :: 7
	                                        photogs :: 7
	                                         pastor :: 7
	                                        poorest :: 7
	                                      prosodist :: 7
	                                     protostele :: 7
	                                     protoxides :: 7
	                                          troop :: 7
	                                      propositi :: 7
	                                           proo :: 7
	                                       portoise :: 7
	                                     protonemas :: 7
	                                          proto :: 10
	                                          prost :: 7
	                                          proso :: 9
	                                          proos :: 8
	                                          promo :: 7
	                                          ports :: 7
	                                          poots :: 7
	                                          photo :: 7
	                                       provosts :: 8
                                              }
protos define ldap concat x y x y define ldap concat x y ldap concat x y define ldap string x x stringify without expanding  {
	               expanding :: -1000
                       }
x define ldap xstring  {
	astringe :: 10
	storing :: 9
	astringed :: 9
	staring :: 9
	outrings :: 9
  }
x ldap string x expand x then stringify ifndef ldap const define ldap const const endif else no prototypes traditional c define ldap p protos define ldap concat x y x y define ldap string x x ifndef ldap const define ldap const no const endif endif no prototypes if gnuc gnuc minor define ldap gccattr  {
                                                      }
attrs attribute attrs else define ldap gccattr attrs endif support for windows dlls  {
	        ills :: 5
	        ells :: 5
	        dols :: 5
	        dels :: 5
	        dals :: 5
	        alls :: 5
           }
when external source code includes header files for dynamic libraries the external source code is importing  {
	      importing :: -1000
              }
dll symbols into its resulting object code on windows symbols imported from dlls must be explicitly indicated in header files with the declspec dllimport directive this is not totally necessary for functions because the compiler gcc or msvc  {
                                    }
will generate stubs when this directive is absent  {
	 accent :: -1000
      }
however this is required for imported variables the ldap libraries i e liblber  {
	     libeler :: 9
	    bellbird :: 9
	     dibbler :: 9
	     nibbler :: 9
           }
and libldap  {
 }
can be built as static or shared based on configuration just about all other source code in openldap use these libraries if the ldap libraries are configured  {
	                configured :: -1000
                         }
as shared configure defines the ldap libs  {
	  libs :: -1000
     }
dynamic macro when other source files include ldap library headers the ldap library symbols will automatically be marked as imported when the actual ldap libraries are being built the symbols will not be marked as imported because the lber library or ldap library macros will be respectively defined any project outside of openldap with source code wanting  {
	                                                 wanting :: -1000
                                                       }
to use ldap dynamic libraries should explicitly define ldap libs dynamic this will ensure that external source code appropriately marks symbols that will be imported the slapd  {
	                   slapped :: 6
	                     flaps :: 6
	                    pleads :: 6
	                    plaids :: 7
	                    salpid :: 6
	                     claps :: 6
	                   klipdas :: 6
	                   elapsed :: 6
	                   elapids :: 6
	                   stapled :: 6
	                      slap :: 8
	                      salp :: 6
	                     spald :: 8
	                     spaed :: 6
	                     slaps :: 6
	                     slade :: 6
	                     scald :: 6
	                    spauld :: 6
	                    spalds :: 6
	                     plaps :: 6
                         }
executable itself can be used as a dynamic library for example if a backend module is compiled as shared it will import symbols from slapd when this happens  {
	                    happens :: -1000
                          }
the slapd symbols must be marked as imported in header files that the backend module includes remember that slapd links with various static libraries if the ldap libraries were configured as static their object code is also part of the monolithic  {
	                              monolithic :: -1000
                                       }
slapd executable thus when a backend module imports  {
	imports :: -1000
      }
symbols from slapd it imports symbols from all of the static libraries in slapd as well thus the slap import macro when defined will appropriately mark symbols as imported this macro should be used by shared backend modules as well as any other external source code that imports symbols from the slapd executable as if it were a dll note that we don t actually have to worry about using the declspec dllexport directive anywhere  {
	                                                                  anywhere :: -1000
                                                                         }
this is because both msvc and mingw provide alternate more effective methods for exporting symbols out of binaries  {
	         binaries :: -1000
                }
i e the use of a def file note about backends  {
	  faciends :: 10
	 backsides :: 10
	    sacked :: 10
	    basked :: 10
	   backers :: 10
	   backets :: 10
	    banked :: 10
	  bookends :: 10
	    backed :: 11
	  bankside :: 10
	  bartends :: 10
	 backbends :: 10
	  backside :: 11
	  backings :: 10
         }
backends can be configured as static or dynamic when a backend is configured as dynamic slapd will load the backend explicitly and populate  {
	              populate :: -1000
                     }
function pointer structures by calling the backend s well known initialization function because of this procedure slapd never implicitly imports symbols from dynamic backends this makes it unnecessary to tag various backend functions with the declspec dllimport directive this is because neither slapd nor any other external binary should ever be implicitly loading a backend dynamic module backends are supposed to be self contained however it appears that back meta does implicitly import symbols from back ldap this means that the declspec dllimport directive should be marked on back ldap functions in its header files if and only if we re compiling for windows and back ldap has been configured as dynamic and back meta is the client of back ldap when client is slapd there is no effect since slapd does not implicitly import symbols todo  {
	                                                                                                                                  toxoid :: 5
	                                                                                                                                  toroid :: 5
	                                                                                                                                   tondo :: 5
	                                                                                                                                    toyo :: 5
	                                                                                                                                    toro :: 5
	                                                                                                                                    toko :: 5
	                                                                                                                                    toho :: 5
	                                                                                                                                    toco :: 5
	                                                                                                                                    dodo :: 5
	                                                                                                                                     too :: 5
	                                                                                                                                     tod :: 5
                                                                                                                                       }
currently back meta nor back ldap is supported for mingw thus there s no need to worry about this right now this is something that may or may not have to be addressed in the future lber library if defined win defined ldap libs dynamic defined lber library defined ldap libs dynamic defined slapd import define lber f type extern declspec dllimport type define lber v type extern declspec dllimport type else define lber f type extern type define lber v type extern type endif ldap library if defined win defined ldap libs dynamic defined ldap library defined ldap libs dynamic defined slapd import define ldap f type extern declspec dllimport type define ldap v type extern declspec dllimport type else define ldap f type extern type define ldap v type extern type endif avl  {
	                                                                                                                                  vola :: 3
	                                                                                                                                  vela :: 3
	                                                                                                                                  vali :: 3
	                                                                                                                                  vale :: 3
	                                                                                                                                  oval :: 3
	                                                                                                                                  aval :: 3
	                                                                                                                                   lav :: 3
	                                                                                                                                   awl :: 3
	                                                                                                                                   avo :: 3
	                                                                                                                                   ave :: 3
	                                                                                                                                   all :: 3
	                                                                                                                                   ail :: 3
	                                                                                                                                    al :: 3
                                                                                                                                     }
library if defined win defined slapd import define ldap avl f type extern declspec dllimport type define ldap avl v type extern declspec dllimport type else define ldap avl f type extern type define ldap avl v type extern type endif ldif  {
                                        }
library if defined win defined slapd import define ldap ldif f type extern declspec dllimport type define ldap ldif v type extern declspec dllimport type else define ldap ldif f type extern type define ldap ldif v type extern type endif lunicode  {
	                                 nucleoid :: 10
	                                 undocile :: 10
	                                  lingcod :: 10
                                        }
library if defined win defined slapd import define ldap lunicode f type extern declspec dllimport type define ldap lunicode v type extern declspec dllimport type else define ldap lunicode f type extern type define ldap lunicode v type extern type endif lutil  {
	                                   rutile :: 6
	                                   tuille :: 6
	                                   sutile :: 6
	                                    until :: 6
                                        }
library if defined win defined slapd import define ldap lutil f type extern declspec dllimport type define ldap lutil v type extern declspec dllimport type else define ldap lutil f type extern type define ldap lutil v type extern type endif rewrite  {
	                                  rewrite :: -1000
                                        }
library if defined win defined slapd import define ldap rewrite f type extern declspec dllimport type define ldap rewrite v type extern declspec dllimport type else define ldap rewrite f type extern type define ldap rewrite v type extern type endif slapd as a dynamic library exporting symbols if defined win defined slapd import define ldap slapd f type extern declspec dllimport type define ldap slapd v type extern declspec dllimport type else define ldap slapd f type extern type define ldap slapd v type extern type endif slapd as a dynamic library exporting symbols if defined win defined slapd import define ldap slapi  {
	                                                                                                platies :: 6
	                                                                                                planish :: 6
	                                                                                                  flaps :: 6
	                                                                                                 plaits :: 6
	                                                                                                 plains :: 6
	                                                                                                 plaids :: 6
	                                                                                                 salpid :: 7
	                                                                                                  claps :: 6
	                                                                                                sappily :: 6
	                                                                                                salpinx :: 6
	                                                                                                salpian :: 6
	                                                                                                spaniel :: 6
	                                                                                                 kalpis :: 6
	                                                                                                elapids :: 7
	                                                                                                   slip :: 7
	                                                                                                   slap :: 8
	                                                                                                 elapid :: 6
	                                                                                                   salp :: 6
	                                                                                                  spial :: 6
	                                                                                                  spail :: 7
	                                                                                                  spahi :: 6
	                                                                                                  slipt :: 6
	                                                                                                  slipe :: 6
	                                                                                                  slaps :: 6
	                                                                                                  slain :: 6
	                                                                                                  scapi :: 7
	                                                                                                  sampi :: 6
	                                                                                                soapily :: 7
	                                                                                                slipway :: 6
	                                                                                                  plaps :: 6
                                                                                                      }
f type extern declspec dllimport type define ldap slapi v type extern declspec dllimport type else define ldap slapi f type extern type define ldap slapi v type extern type endif slapd as a dynamic library exporting symbols if defined win defined slapd import define slapi f type extern declspec dllimport type define slapi v type extern declspec dllimport type else define slapi f type extern type define slapi v type extern type endif c library mingw links with the dynamic c run time library by default so the explicit definition of cstatic  {
	                                                                                     astatic :: 11
	                                                                                     clastic :: 9
	                                                                                     ascitic :: 9
	                                                                                     ascetic :: 9
	                                                                                     sciatic :: 9
	                                                                                     ectatic :: 10
                                                                                           }
will keep dllimport from being defined if desired msvc defines the dll macro when the compiler is invoked with md or mdd  {
	        scrimshanders :: -1000
                    }
which means the resulting object code will be linked with the dynamic c run time library technically  {
	     technically :: -1000
               }
it shouldn t be necessary to redefine  {
	redefine :: -1000
     }
any functions that the headers for the c library should already contain nevertheless  {
	nevertheless :: -1000
           }
this is here as a safe guard todo determine if these macros ever get expanded for windows if not the declspec expansion can probably be removed if defined mingw defined cstatic defined msc ver defined dll define ldap libc f type extern declspec dllimport type define ldap libc v type extern declspec dllimport type else define ldap libc f type extern type define ldap libc v type extern type endif endif ldap cdefs h include ldap features h generated from ldap features hin by configure openldap this work is part of openldap software http www openldap org copyright the openldap foundation all rights reserved redistribution and use in source and binary forms with or without modification are permitted only as authorized by the openldap public license a copy of this license is available in file license in the top level directory of the distribution or alternatively at http www openldap org license html ldap features ifndef ldap features h define ldap features h openldap api version macros define ldap vendor version define ldap vendor version major define ldap vendor version minor define ldap vendor version patch work in progress openldap reentrancy  {
	                                                                                                                                                                                    trenchancy :: 12
	                                                                                                                                                                                     reentrant :: 14
	                                                                                                                                                                                    reentrance :: 15
	                                                                                                                                                                                       reentry :: 12
	                                                                                                                                                                                   reentrances :: 14
	                                                                                                                                                                                    penetrancy :: 15
	                                                                                                                                                                                    itinerancy :: 12
                                                                                                                                                                                             }
thread safeness  {
	safeness :: -1000
 }
should be dynamically checked using ldap get option the lldap  {
        }
implementation is not thread safe the lldap r implementation is ldap api feature thread safe basic thread safety  {
	           safety :: -1000
                }
but also be ldap api feature session thread safe ldap api feature operation thread safe the preprocessor flag ldap api feature x openldap thread safe can be used to determine if lldap r is available at compile time you must define ldap thread safe if and only if you link with lldap r if you fail to define ldap thread safe when linking with lldap r or define ldap thread safe when linking with lldap provided header definations  {
	                                                                  definitions :: 18
	                                                                  decimations :: 16
	                                                                  defamations :: 16
	                                                                  geminations :: 16
	                                                                  denegations :: 14
	                                                                  indications :: 14
	                                                                  denudations :: 14
	                                                                  denotations :: 15
	                                                                   deliration :: 14
	                                                                  medications :: 15
	                                                                  alienations :: 14
	                                                                  divinations :: 16
	                                                                  dominations :: 16
	                                                                   decimation :: 14
	                                                                  detonations :: 16
	                                                                   derivation :: 14
	                                                                  meditations :: 15
	                                                                  iodinations :: 15
	                                                                 definitional :: 16
	                                                                  herniations :: 14
	                                                                   definition :: 16
	                                                                  depilations :: 16
	                                                                   defunction :: 14
	                                                                   depilation :: 14
	                                                                  indexations :: 15
	                                                                  infixations :: 15
	                                                                   detonation :: 14
	                                                                   defamation :: 14
	                                                                  derivations :: 16
	                                                                   deligation :: 14
	                                                                   semination :: 16
	                                                                   denization :: 16
	                                                                   gemination :: 14
	                                                                   divination :: 14
	                                                                   domination :: 14
	                                                                  dedications :: 15
	                                                                  defecations :: 15
                                                                            }
and declarations may be incorrect is lldap r available or not define ldap api feature x openldap thread safe ldap v referrals undef ldap api feature x openldap v referrals endif ldap features openldap this work is part of openldap software http www openldap org copyright the openldap foundation all rights reserved redistribution and use in source and binary forms with or without modification are permitted only as authorized by the openldap public license a copy of this license is available in file license in the top level directory of the distribution or alternatively at http www openldap org license html portions copyright c regents of the university of michigan all rights reserved redistribution and use in source and binary forms are permitted provided that this notice is preserved and that due credit is given to the university of michigan at ann arbor the name of the university may not be used to endorse or promote products derived from this software without specific prior written permission this software is provided as is without express or implied warranty ifndef ldap h define ldap h pull in lber include lber h include version and api feature defines include ldap features h ldap begin decl define ldap version define ldap version define ldap version define ldap version min ldap version define ldap version ldap version define ldap version max ldap version we use n here because it is above for rfc above rev of ietf ldapext  {
                                                                                                                                                                                                                                                 }
draft now quite dated  {
	dated :: -1000
  }
yet below allocations for new rfcs  {
	 rocs :: 5
    }
just in case there is someday  {
	someday :: -1000
    }
an rfc produced define ldap api version define ldap vendor name openldap openldap api features define ldap api feature x openldap ldap vendor version if defined ldap api feature x openldap reentrant defined ldap thread safe defined ldap api feature x openldap thread safe lldap may or may not be thread safe lldap r if available is always thread safe define ldap api feature thread safe define ldap api feature session thread safe define ldap api feature operation thread safe endif if defined ldap thread safe defined ldap api feature x openldap thread safe define ldap api feature session safe define ldap api operation session safe endif define ldap port ldap default ldap port define ldaps  {
	                                                                                                              leaps :: 7
	                                                                                                              leads :: 6
	                                                                                                              lamps :: 6
	                                                                                                              flaps :: 6
	                                                                                                              draps :: 6
	                                                                                                              claps :: 6
	                                                                                                            elapsed :: 6
	                                                                                                              udals :: 6
	                                                                                                               slap :: 6
	                                                                                                              spald :: 6
	                                                                                                              slaps :: 6
	                                                                                                              plaps :: 6
	                                                                                                              odals :: 6
	                                                                                                              loads :: 6
                                                                                                                  }
port ldaps default ldap over tls port define ldap root dse  {
	     dyers :: 3
	     duets :: 3
	     duels :: 3
	     dreys :: 3
	     drest :: 3
	     dreks :: 3
	     dregs :: 3
	     doest :: 3
	     doers :: 3
	     doeks :: 3
	     diets :: 3
	     diebs :: 3
	     deets :: 3
	     deers :: 3
	     deems :: 3
	      used :: 4
	      sted :: 3
	      sped :: 3
	      sned :: 3
	      sled :: 3
	      shed :: 3
	      seed :: 3
	      odes :: 3
	      ides :: 3
	      dyes :: 4
	      dues :: 4
	      dose :: 3
	      does :: 4
	      deys :: 3
	      dews :: 3
	      devs :: 3
	      deus :: 3
	      desk :: 3
	      dens :: 3
	      dels :: 3
	      dees :: 4
	      debs :: 3
	     pseud :: 3
	       use :: 3
	       sed :: 3
	       ose :: 3
	       dye :: 3
	       due :: 3
	       dso :: 3
	       doe :: 3
	       die :: 3
	       dee :: 3
	       dae :: 3
	        es :: 3
	        de :: 3
         }
define ldap no attrs define ldap all user attributes define ldap all operational attributes rfc rfc maxint  {
	         matinee :: 7
	         matings :: 7
	         taxings :: 7
	         taximen :: 8
	         taximan :: 7
	          matins :: 8
	          mating :: 8
	          manitu :: 7
	          manito :: 7
	          taxing :: 8
	            taxi :: 7
	          taming :: 7
	            maxi :: 8
	            mani :: 7
	           maxis :: 7
	           mavin :: 7
	           matin :: 9
               }
integer define ldap maxint ldap options x x fff reserved for api options x x fff reserved for api extended options x x fff reserved for private and experimental options define ldap opt api info x define ldap opt desc x historic define ldap opt deref x define ldap opt sizelimit  {
	                                          similize :: 11
                                                 }
x define ldap opt timelimit  {
	slighting :: -1000
   }
x x x not defined define ldap opt referrals x define ldap opt restart x x a x not defined define ldap opt protocol version x define ldap opt server controls x define ldap opt client controls x x not defined define ldap opt api feature info x x x f not defined define ldap opt host name x define ldap opt result code x define ldap opt error number ldap opt result code define ldap opt diagnostic message x define ldap opt error string ldap opt diagnostic message define ldap opt matched dn x x x fff not defined x used by microsoft for ldap opt auto reconnect  {
	                                                                                                   reconnect :: -1000
                                                                                                           }
define ldap opt sspi  {
	taper :: -1000
  }
flags x x used by microsoft for ldap opt ssl info x used by microsoft for ldap opt ref deref conn per msg define ldap opt sign x define ldap opt encrypt x define ldap opt sasl  {
	                              saults :: 5
	                              sables :: 5
	                                sash :: 5
	                                sals :: 6
	                               sisal :: 5
	                                lass :: 5
	                               sials :: 5
	                               seals :: 5
	                               sauls :: 6
	                               salts :: 5
	                               salse :: 5
	                               salps :: 5
	                               sales :: 5
	                               sails :: 6
	                                 las :: 5
                                   }
method x x used by microsoft for ldap opt arec  {
	     bats :: -1000
        }
exclusive define ldap opt security context x x a used by microsoft for ldap opt rootdse  {
	       rootages :: 9
	       doorstep :: 9
	        rootled :: 9
	        rootles :: 9
	        roosted :: 10
	       doomster :: 9
	         rooted :: 10
	         roosed :: 9
	         rodeos :: 9
	          roots :: 9
	         sooted :: 9
              }
cache x b x fff not defined api extensions define ldap opt api extension base x api extensions private and experimental options openldap specific options define ldap opt debug level x debug level define ldap opt timeout x default timeout define ldap opt refhoplimit  {
                                          }
x ref hop limit define ldap opt network timeout x socket level timeout define ldap opt uri x define ldap opt referral urls  {
	                  urns :: 5
	                  lurs :: 5
	                   urs :: 5
                     }
x referral urls define ldap opt sockbuf x sockbuf define ldap opt defbase  {
	     defeats :: 9
	    deflates :: 9
           }
x searchbase  {
	searchable :: 14
	scareheads :: 13
	searches :: 13
	gearcases :: 12
	searchers :: 12
	scarabees :: 13
 }
define ldap opt connect async x create connections  {
	connections :: -1000
      }
asynchronously  {
	asynchronously :: -1000
 }
define ldap opt connect cb x connection callbacks define ldap opt session refcnt x session reference count openldap tls options define ldap opt x tls x define ldap opt x tls ctx x openssl  {
	                            opens :: 9
                                }
ctx define ldap opt x tls cacertfile  {
	lacertine :: 12
     }
x define ldap opt x tls cacertdir  {
     }
x define ldap opt x tls certfile  {
	certified :: 10
	certifies :: 10
	fernticle :: 10
	fertile :: 10
     }
x define ldap opt x tls keyfile x define ldap opt x tls require cert x define ldap opt x tls protocol min x define ldap opt x tls cipher suite x define ldap opt x tls random file x define ldap opt x tls ssl ctx x a openssl ssl define ldap opt x tls crlcheck  {
	                                                precheck :: 10
                                                       }
x b define ldap opt x tls connect cb x c define ldap opt x tls connect arg x d define ldap opt x tls dhfile  {
	                 defilers :: 7
	                  defiled :: 7
	                  defiles :: 8
	                  defiler :: 8
	                   defile :: 9
	                  refiled :: 7
	                  enfiled :: 7
	                  unfiled :: 7
	                     defi :: 7
                        }
x e define ldap opt x tls newctx  {
	   newt :: 7
      }
x f define ldap opt x tls crlfile  {
      }
x gnutls  {
	gluts :: 8
	gaults :: 7
	grunts :: 7
	glutens :: 8
	glut :: 7
	snugly :: 7
	gluten :: 7
	gluons :: 7
 }
only define ldap opt x tls package x define ldap opt x tls never define ldap opt x tls hard define ldap opt x tls demand define ldap opt x tls allow define ldap opt x tls try define ldap opt x tls crl none define ldap opt x tls crl peer  {
	                                               peer :: -1000
                                                  }
define ldap opt x tls crl all for ldap opt x tls protocol min define ldap opt x tls protocol maj min maj min define ldap opt x tls protocol ssl define ldap opt x tls protocol ssl define ldap opt x tls protocol tls define ldap opt x tls protocol tls define ldap opt x tls protocol tls openldap sasl options define ldap opt x sasl mech x define ldap opt x sasl realm x define ldap opt x sasl authcid  {
	                                                                          outchid :: 9
                                                                                }
x define ldap opt x sasl authzid  {
     }
x define ldap opt x sasl ssf  {
	 softs :: 3
	 sofas :: 3
	 sifts :: 3
	 safes :: 3
     }
x read only define ldap opt x sasl ssf external x write only define ldap opt x sasl secprops  {
                 }
x write only define ldap opt x sasl ssf min x define ldap opt x sasl ssf max x define ldap opt x sasl maxbufsize  {
                       }
x define ldap opt x sasl mechlist  {
	medalist :: 10
	metalist :: 10
	micklest :: 11
     }
x a read only define ldap opt x sasl nocanon  {
	 nonagons :: 9
	  nonagon :: 10
        }
x b define ldap opt x sasl username  {
	overname :: 10
	undreamed :: 10
      }
x c read only define ldap opt x sasl gss creds  {
	     dauds :: -1000
         }
x d openldap gssapi options define ldap opt x gssapi do not free context x define ldap opt x gssapi allow remote  {
	               remote :: -1000
                    }
principal x openldap per connection tcp keepalive  {
	keepable :: 11
     }
settings linux only ignored where unsupported define ldap opt x keepalive idle x define ldap opt x keepalive probes  {
	            probes :: -1000
                 }
x define ldap opt x keepalive interval x private api extensions reserved for application use define ldap opt private extension base x private api inclusive  {
	               inclusive :: -1000
                       }
ldap get option and ldap set option return values as later versions may return other values indicating failure current applications should only compare returned value against ldap opt success define ldap opt success define ldap opt error option on off values define ldap opt on void ber pvt opt on define ldap opt off void typedef struct ldapapiinfo  {
                                                        }
int ldapai  {
	lampad :: 7
 }
info version version of ldapapiinfo define ldap api info version int ldapai api version revision of api supported int ldapai protocol version highest ldap version supported char ldapai extensions names of api extensions char ldapai vendor name name of supplier  {
	                               supplier :: -1000
                                      }
int ldapai vendor version supplier specific version ldapapiinfo typedef struct ldap apifeature  {
	 misfeature :: 13
	 disfeature :: 13
          }
info int ldapaif  {
 }
info version version of ldapapifeatureinfo  {
   }
define ldap feature info version apifeature info struct version char ldapaif name ldap api feature less prefix int ldapaif version value of ldap api feature ldapapifeatureinfo ldap control structure typedef struct ldapcontrol  {
                              }
char ldctl  {
 }
oid numericoid  {
	numerics :: 12
	lumbricoid :: 14
	numeric :: 13
 }
of control struct berval ldctl value encoded value of control char ldctl iscritical  {
	    picritic :: 12
	  uncritical :: 14
           }
criticality  {
	criticality :: -1000
 }
ldapcontrol ldap controls standard track  {
	track :: -1000
   }
controls define ldap control managedsait  {
   }
rfc define ldap control proxy authz rfc define ldap control subentries  {
	subentries :: -1000
         }
rfc define ldap control valuesreturnfilter  {
   }
rfc define ldap control assert rfc define ldap control pre read rfc define ldap control post read rfc define ldap control sortrequest  {
	           soubrettes :: 14
                    }
rfc define ldap control sortresponse  {
   }
rfc non standard track controls define ldap control pagedresults  {
       }
rfc ldap content synchronization operation rfc define ldap sync oid define ldap control sync ldap sync oid define ldap control sync state ldap sync oid define ldap control sync done ldap sync oid define ldap sync info ldap sync oid define ldap sync none x define ldap sync refresh only x define ldap sync reserved x define ldap sync refresh and persist x define ldap sync refresh presents  {
	                                                           presents :: -1000
                                                                  }
define ldap sync refresh deletes  {
	deletes :: -1000
   }
define ldap tag sync new cookie  {
	cookie :: -1000
    }
ber tag t x u define ldap tag sync refresh delete ber tag t xa u define ldap tag sync refresh present ber tag t xa u define ldap tag sync id set ber tag t xa u define ldap tag sync cookie ber tag t x u define ldap tag refreshdeletes  {
	                                         nephridium :: -1000
                                                  }
ber tag t x u define ldap tag refreshdone  {
	refreshens :: 14
	refreshen :: 16
	refreshed :: 16
	refreshment :: 15
	refreshened :: 14
       }
ber tag t x u define ldap tag reload hint ber tag t x u define ldap sync present define ldap sync add define ldap sync modify define ldap sync delete define ldap sync new cookie password policy controls work in progress its released disabled by default define ldap control passwordpolicyrequest  {
                                                 }
define ldap control passwordpolicyresponse  {
  }
various works in progress define ldap control noop define ldap control no subordinates  {
	subordinates :: -1000
           }
define ldap control relax define ldap control managedit  {
	agnamed :: 11
	managed :: 14
	manages :: 11
	manager :: 11
	 manage :: 12
      }
ldap control relax define ldap control slurp  {
	 slurp :: -1000
     }
define ldap control valsort  {
	salvor :: 10
	valours :: 9
	salvors :: 9
	valors :: 9
  }
define ldap control dontusecopy  {
  }
define ldap control x deref define ldap control x whatfailed  {
        }
ldap chaining behavior control work in progress draft sermersheim  {
       }
ldap chaining see also ldap no referrals found ldap cannot chain define ldap control x chaining behavior define ldap chaining preferred define ldap chaining required define ldap referrals preferred define ldap referrals required ms active directory controls for compatibility define ldap control x incremental values define ldap control x domain scope define ldap control x permissive  {
	                                             permissive :: -1000
                                                      }
modify define ldap control x search options define ldap search flag domain scope do not generate referrals define ldap search flag phantom  {
	              phantom :: -1000
                    }
root search all subordinate ncs  {
	scan :: 3
	 nos :: 3
	 nis :: 3
	 nas :: 3
	  ns :: 3
   }
define ldap control x tree delete ms active directory controls not implemented in slapd define ldap control x extended dn draft wahl  {
	                whale :: 5
	                 waul :: 5
	                 wall :: 5
	                 wail :: 5
	                 dahl :: 5
	                  lah :: 5
                    }
ldap session define ldap control x session tracking  {
	tracking :: -1000
      }
define ldap control x session tracking radius  {
	radius :: -1000
     }
acct  {
	cacti :: 5
	acetic :: 5
	accost :: 5
	accite :: 5
	accept :: 5
	accent :: 5
 }
session id ldap control x session tracking define ldap control x session tracking radius acct multi session id ldap control x session tracking define ldap control x session tracking username ldap control x session tracking various expired works ldap duplicated  {
	                             duplicated :: -1000
                                      }
entry control extension not implemented in slapd define ldap control dupent  {
	    unpent :: 8
	     dupes :: 7
	     duper :: 7
	   duplets :: 7
	    dipnet :: 7
	    detenu :: 7
	     tuned :: 7
	    nudest :: 7
	      dupe :: 8
	      dune :: 7
	    punted :: 7
	    duplet :: 8
	    pudent :: 10
	    upwent :: 7
	    upsent :: 7
         }
request define ldap control dupent response define ldap control dupent entry define ldap control dupent ldap control dupent request ldap persistent  {
	          persistent :: -1000
                   }
search control not implemented in slapd define ldap control persist request define ldap control persist entry change notice define ldap control persist entry change add x define ldap control persist entry change delete x define ldap control persist entry change modify x define ldap control persist entry change rename x ldap vlv  {
	                                         porphyries :: -1000
                                                  }
define ldap control vlvrequest  {
  }
define ldap control vlvresponse  {
  }
ldap unsolicited  {
	unsolicited :: -1000
 }
notifications  {
	notifications :: -1000
 }
define ldap notice of disconnection  {
	disconnection :: -1000
   }
rfc define ldap notice disconnect ldap notice of disconnection ldap extended operations define ldap exop  {
	         expos :: 5
	         epoxy :: 5
	        exopod :: 5
	          expo :: 6
	          exon :: 5
             }
start tls rfc define ldap exop modify passwd rfc define ldap tag exop modify passwd id ber tag t x u define ldap tag exop modify passwd old ber tag t x u define ldap tag exop modify passwd new ber tag t x u define ldap tag exop modify passwd gen ber tag t x u define ldap exop cancel rfc define ldap exop x cancel ldap exop cancel define ldap exop refresh rfc define ldap tag exop refresh req dn ber tag t x u define ldap tag exop refresh req ttl  {
	                                                                                        tolts :: 3
	                                                                                        tilts :: 3
	                                                                                        tilth :: 3
	                                                                                         tolt :: 4
	                                                                                         tilt :: 4
	                                                                                         telt :: 4
                                                                                            }
ber tag t x u define ldap tag exop refresh res ttl ber tag t x u define ldap exop who am i rfc define ldap exop x who am i ldap exop who am i various works in progress define ldap exop turn rfc define ldap exop x turn ldap exop turn ldap distributed procedures  {
	                                          unquestioning :: -1000
                                                      }
draft sermersheim ldap distproc  {
	disport :: 11
	dioptrics :: 10
	dipterous :: 10
	dipteros :: 11
  }
a work in progress define ldap x distproc base define ldap exop x chainedrequest  {
            }
ldap x distproc base define ldap feature x canchainops  {
       }
ldap x distproc base define ldap control x returncontref  {
       }
ldap x distproc base define ldap urlext  {
	urtexts :: 8
	urtext :: 9
     }
x localrefoid  {
 }
ldap x distproc base define ldap urlext x reftypeoid  {
       }
ldap x distproc base define ldap urlext x searchedsubtreeoid  {
       }
ldap x distproc base define ldap urlext x failednameoid  {
       }
ldap x distproc base define ldap urlext x localref x localreference  {
         }
define ldap urlext x reftype x referencetype  {
     }
define ldap urlext x searchedsubtree x searchedsubtree define ldap urlext x failedname x failedname ifdef ldap devel define ldap x txn  {
	                 tun :: 3
	                 ton :: 3
	                 tin :: 3
	                 ten :: 3
	                 tan :: 3
                   }
tmp define ldap exop x txn start ldap x txn define ldap control x txn spec ldap x txn define ldap exop x txn end ldap x txn define ldap exop x txn aborted notice ldap x txn endif ldap features define ldap feature all op attrs rfc define ldap feature objectclass  {
                                                  }
attrs objectclass new number to be assigned define ldap feature absolute filters define ldap feature language tag options define ldap feature language range options define ldap feature modify increment ldap experimental works in progress features define ldap feature subordinate scope children define ldap feature children scope ldap feature subordinate scope specific ldap instantiations  {
	                                      instantiations :: -1000
                                                   }
of ber types we know about overview  {
	overview :: -1000
     }
of lber tag construction  {
	construction :: -1000
  }
bits class universal application context specific private data type primitive constructed tag number general stuff define ldap tag message ber tag t x u constructed define ldap tag msgid ber tag t x u integer define ldap tag ldapdn  {
                                     }
ber tag t x u octet string define ldap tag ldapcred  {
         }
ber tag t x u octet string define ldap tag controls ber tag t xa u context specific constructed define ldap tag referral ber tag t xa u context specific constructed define ldap tag newsuperior  {
                                 }
ber tag t x u context specific primitive define ldap tag exop req oid ber tag t x u context specific primitive define ldap tag exop req value ber tag t x u context specific primitive define ldap tag exop res oid ber tag t x au context specific primitive define ldap tag exop res value ber tag t x bu context specific primitive define ldap tag im res oid ber tag t x u context specific primitive define ldap tag im res value ber tag t x u context specific primitive define ldap tag sasl res creds ber tag t x u context specific primitive ldap request messages define ldap req bind ber tag t x u application constructed define ldap req unbind  {
	                                                                                                                     unbind :: -1000
                                                                                                                          }
ber tag t x u application primitive define ldap req search ber tag t x u application constructed define ldap req modify ber tag t x u application constructed define ldap req add ber tag t x u application constructed define ldap req delete ber tag t x au application primitive define ldap req moddn  {
	                                               goddamn :: 6
	                                                 noddy :: 6
	                                                 monde :: 6
                                                     }
ber tag t x cu application constructed define ldap req modrdn  {
	    modern :: 7
         }
ldap req moddn define ldap req rename ldap req moddn define ldap req compare ber tag t x eu application constructed define ldap req abandon  {
	                 abandon :: -1000
                       }
ber tag t x u application primitive define ldap req extended ber tag t x u application constructed ldap response messages define ldap res bind ber tag t x u application constructed define ldap res search entry ber tag t x u application constructed define ldap res search reference ber tag t x u v application constructed define ldap res search result ber tag t x u application constructed define ldap res modify ber tag t x u application constructed define ldap res add ber tag t x u application constructed define ldap res delete ber tag t x bu application constructed define ldap res moddn ber tag t x du application constructed define ldap res modrdn ldap res moddn application constructed define ldap res rename ldap res moddn application constructed define ldap res compare ber tag t x fu application constructed define ldap res extended ber tag t x u v application constructed define ldap res intermediate ber tag t x u v application constructed define ldap res any define ldap res unsolicited sasl methods define ldap sasl simple char define ldap sasl null authentication methods available define ldap auth none ber tag t x u no authentication define ldap auth simple ber tag t x u context specific primitive define ldap auth sasl ber tag t xa u context specific constructed define ldap auth krbv  {
                                                                                                                                                                                                                                 }
ber tag t xffu  {
  }
means do both of the following define ldap auth krbv ber tag t x u context specific primitive define ldap auth krbv ber tag t x u context specific primitive used by the windows api but not used on the wire  {
	                                    wire :: -1000
                                       }
define ldap auth negotiate  {
	negotiate :: -1000
  }
ber tag t x ffu  {
	 ewe :: -1000
   }
filter types define ldap filter and ber tag t xa u context specific constructed define ldap filter or ber tag t xa u context specific constructed define ldap filter not ber tag t xa u context specific constructed define ldap filter equality ber tag t xa u context specific constructed define ldap filter substrings  {
	                                           bowstrings :: 13
	                                           subscripts :: 13
	                                           sunrisings :: 12
	                                           russetings :: 14
	                                           subsisting :: 12
	                                           outsprings :: 13
	                                           surmisings :: 12
                                                    }
ber tag t xa u context specific constructed define ldap filter ge ber tag t xa u context specific constructed define ldap filter le ber tag t xa u context specific constructed define ldap filter present ber tag t x u context specific primitive define ldap filter approx ber tag t xa u context specific constructed define ldap filter ext ber tag t xa u context specific constructed extended filter component types define ldap filter ext oid ber tag t x u context specific define ldap filter ext type ber tag t x u context specific define ldap filter ext value ber tag t x u context specific define ldap filter ext dnattrs  {
	                                                                                                          drants :: 9
                                                                                                               }
ber tag t x u context specific substring filter component types define ldap substring initial ber tag t x u context specific define ldap substring any ber tag t x u context specific define ldap substring final ber tag t x u context specific search scopes  {
	                                       scopes :: -1000
                                            }
define ldap scope base ber int t x define ldap scope baseobject  {
	  royalizes :: -1000
          }
ldap scope base define ldap scope onelevel  {
     }
ber int t x define ldap scope one ldap scope onelevel define ldap scope subtree ber int t x define ldap scope sub ldap scope subtree define ldap scope subordinate ber int t x openldap extension define ldap scope children ldap scope subordinate define ldap scope default ber int t openldap extension substring filter component types define ldap substring initial ber tag t x u context specific define ldap substring any ber tag t x u context specific define ldap substring final ber tag t x u context specific ldap result codes define ldap success x define ldap range n x y x n n y define ldap operations error x define ldap protocol error x define ldap timelimit exceeded  {
	                                                                                                               exceeded :: -1000
                                                                                                                      }
x define ldap sizelimit exceeded x define ldap compare false x define ldap compare true x define ldap auth method not supported x define ldap strong auth not supported ldap auth method not supported define ldap strong auth required x define ldap stronger  {
	                                  stronger :: -1000
                                         }
auth required ldap strong auth required define ldap partial results x ldapv  {
	 clottering :: -1000
          }
not ldapv define ldap referral x a ldapv define ldap adminlimit  {
         }
exceeded x b ldapv define ldap unavailable critical extension x c ldapv define ldap confidentiality  {
	confidentiality :: -1000
             }
required x d ldapv define ldap sasl bind in progress x e ldapv define ldap attr error n ldap range n x x define ldap no such attribute x define ldap undefined type x define ldap inappropriate  {
	                       inappropriate :: -1000
                                   }
matching x define ldap constraint violation x define ldap type or value exists x define ldap invalid syntax x define ldap name error n ldap range n x x define ldap no such object x define ldap alias problem x define ldap invalid dn syntax x define ldap is leaf  {
	                                             leaf :: -1000
                                                }
x not ldapv define ldap alias deref problem x define ldap security error n ldap range n x f x define ldap x proxy authz failure x f ldapv proxy authorization define ldap inappropriate auth x define ldap invalid credentials  {
	                            credentials :: -1000
                                      }
x define ldap insufficient access x define ldap service error n ldap range n x x define ldap busy  {
	             sabir :: -1000
                 }
x define ldap unavailable x define ldap unwilling  {
	unwilling :: -1000
      }
to perform x define ldap loop detect x define ldap update error n ldap range n x x define ldap naming violation x define ldap object class violation x define ldap not allowed on nonleaf  {
	                          nonleafy :: 13
	                           nonself :: 10
	                           nonlife :: 9
                                 }
x define ldap not allowed on rdn  {
	  rind :: 4
	  rand :: 4
	 runed :: 3
	 rondo :: 3
	 ronde :: 3
	 rindy :: 3
	 rinds :: 3
	 ranid :: 3
	 randy :: 3
	 rands :: 3
	   rin :: 3
	   ren :: 3
	   ran :: 3
	    rd :: 4
     }
x define ldap already exists x define ldap no object class mods  {
	unequivocal :: -1000
          }
x define ldap results too large x cldap  {
	clasped :: 6
	clapped :: 6
	clamped :: 6
	  clasp :: 6
	   clap :: 6
	   clad :: 6
      }
define ldap affects multiple dsas  {
	dsos :: 5
   }
x define ldap vlv error x c define ldap other x lcup  {
	       scup :: 5
	       loup :: 5
	      sculp :: 5
          }
operation codes not implemented define ldap cup  {
	   dep :: -1000
     }
resources exhausted x define ldap cup security violation x define ldap cup invalid data x define ldap cup unsupported scheme x define ldap cup reload required x cancel operation codes define ldap cancelled  {
	                       cancelled :: -1000
                               }
x define ldap no such operation x define ldap too late x define ldap cannot cancel x assertion control define ldap assertion failed x a proxied  {
	                  proxies :: 11
	                  provide :: 9
	                  proteid :: 9
	                  peroxid :: 9
                        }
authorization denied  {
	denied :: -1000
 }
define ldap proxied authorization denied x b experimental result codes define ldap e error n ldap range n x x fff ldap sync define ldap sync refresh required x private use result codes define ldap x error n ldap range n x xffff define ldap x sync refresh required x defunct  {
	                                           defunct :: -1000
                                                 }
define ldap x assertion failed x f defunct for the ldap no op control define ldap x no operation x e for the chaining behavior control consecutive  {
	               consecutive :: -1000
                         }
result codes requested see draft sermersheim ldap chaining ifdef ldap control x chaining behavior define ldap x no referrals found x define ldap x cannot chain x endif for distributed procedures see draft sermersheim ldap distproc ifdef ldap x distproc base define ldap x invalidreference  {
                                           }
x endif ifdef ldap x txn define ldap x txn specify okay x define ldap x txn id invalid x endif api error codes based on draft ietf ldap c api xx but with new negative code values define ldap api error n n define ldap api result n n define ldap server down define ldap local error define ldap encoding error define ldap decoding error define ldap timeout define ldap auth unknown define ldap filter error define ldap user cancelled define ldap param error define ldap no memory define ldap connect error define ldap not supported define ldap control not found define ldap no results returned define ldap more results to return obsolete define ldap client loop define ldap referral limit exceeded define ldap x connecting  {
	                                                                                                                    connecting :: -1000
                                                                                                                             }
this structure represents both ldap messages and ldap responses  {
	responses :: -1000
       }
these are really the same except in the case of search responses where a response has multiple messages typedef struct ldapmsg  {
                   }
ldapmessage  {
 }
for modifications typedef struct ldapmod  {
   }
int mod op define ldap mod op x define ldap mod add x define ldap mod delete x define ldap mod replace x define ldap mod increment x openldap extension define ldap mod bvalues  {
	                           avulse :: 9
	                          avulses :: 9
	                          blagues :: 10
                                }
x important do not use code x or above it is used internally by the backends see ldap servers  {
	           servers :: -1000
                 }
slapd slap h char mod type union mod vals u char modv  {
	       modi :: 5
	       mode :: 5
	      moved :: 5
	        mod :: 6
          }
strvals  {
	tarsals :: 9
	servals :: 11
 }
struct berval modv bvals  {
	haciendas :: -1000
  }
mod vals define mod values mod vals modv strvals define mod bvalues mod vals modv bvals ldapmod structure representing an ldap session which can encompass  {
	               encompass :: -1000
                       }
connections to multiple servers in the face  {
	  face :: -1000
     }
of referrals typedef struct ldap ldap define ldap deref never x define ldap deref searching x define ldap deref finding  {
	            finding :: -1000
                  }
x define ldap deref always x define ldap no limit how many messages to retrieve results for define ldap msg one x define ldap msg all x define ldap msg received x types for ldap url handling typedef struct ldap url desc struct ldap url desc lud  {
	                                           med :: -1000
                                             }
next char lud scheme char lud host int lud port char lud dn char lud attrs int lud scope char lud filter char lud exts int lud crit exts ldapurldesc  {
                            }
define ldap url success x success define ldap url err mem x can t allocate memory space define ldap url err param x parameter is bad define ldap url err badscheme  {
	                     blaspheme :: 11
	                    blasphemed :: 12
                             }
x url doesn t begin with ldap si define ldap url err badenclosure  {
           }
x url is missing trailing define ldap url err badurl  {
	   bedral :: 7
	   barful :: 7
	     balu :: 7
        }
x url is bad define ldap url err badhost  {
	   basho :: 9
	  bathos :: 11
	badmouth :: 9
	badmouths :: 10
       }
x host port is bad define ldap url err badattrs  {
	 rabattes :: 11
	 rabatted :: 10
        }
x bad or missing attributes define ldap url err badscope  {
	  marsala :: -1000
        }
x scope string is invalid or missing define ldap url err badfilter  {
          }
x bad or missing filter define ldap url err badexts  {
        }
x a bad or missing extensions ldap sync rfc api typedef struct ldap sync t ldap sync t typedef enum these are private the client should never see them ldap sync capi  {
	                          capiz :: 7
	                          campi :: 5
	                          aspic :: 5
	                         copita :: 5
	                           caps :: 5
	                           capo :: 5
	                           caph :: 5
	                           cape :: 5
	                         capsid :: 5
	                         capris :: 5
	                         caplin :: 5
	                         capita :: 5
	                         capias :: 5
	                          panic :: 5
	                         caliph :: 5
	                            cap :: 6
                              }
none ldap sync capi phase flag x u ldap sync capi idset  {
	      islet :: 6
	      inset :: 7
	      idles :: 6
	     bidets :: 6
	      edits :: 6
	      deist :: 6
	    ideates :: 6
	     idlest :: 7
	      tides :: 6
	      stied :: 6
	       tise :: 6
	      sited :: 6
	       ides :: 6
	        ids :: 6
	     edicts :: 6
          }
flag x u ldap sync capi done flag x u these are passed to ls search entry ldap sync capi present ldap sync present ldap sync capi add ldap sync add ldap sync capi modify ldap sync modify ldap sync capi delete ldap sync delete these are passed to ls intermediate ldap sync capi presents ldap sync capi phase flag ldap sync capi present ldap sync capi deletes ldap sync capi phase flag ldap sync capi delete ldap sync capi presents idset ldap sync capi presents ldap sync capi idset flag ldap sync capi deletes idset ldap sync capi deletes ldap sync capi idset flag ldap sync capi done ldap sync capi done flag ldap sync capi presents ldap sync refresh t called when an entry is returned by ldap result if phase is ldap sync capi add or ldap sync capi modify the entry has been either added or modified and thus the complete view of the entry should be in the ldapmessage if phase is ldap sync capi present or ldap sync capi delete only the dn should be in the ldapmessage typedef int ldap sync search entry f ldap p ldap sync t ls ldapmessage msg struct berval entryuuid  {
	                                                                                                                                                                                                   aswoon :: -1000
                                                                                                                                                                                                        }
ldap sync refresh t phase called when a reference is returned the client should know what to do with it typedef int ldap sync search reference f ldap p ldap sync t ls ldapmessage msg called when specific intermediate final messages are returned if phase is ldap sync capi presents or ldap sync capi deletes a presents or deletes phase begins if phase is ldap sync capi done a special presents phase with refreshdone set to true has been returned to indicate that the refresh phase of a refreshandpersist  {
                                                                                       }
is complete in the above cases syncuuids  {
     }
is null if phase is ldap sync capi presents idset or ldap sync capi deletes idset syncuuids is an array of uuids  {
	                duits :: 6
	                 suid :: 7
	                quids :: 7
	                muids :: 7
                    }
that are either present or have been deleted  {
	deleted :: -1000
      }
typedef int ldap sync intermediate f ldap p ldap sync t ls ldapmessage msg bervarray syncuuids ldap sync refresh t phase called when a searchresultdone  {
                       }
is returned in refreshandpersist this can only occur if the search for any reason is being terminated by the server typedef int ldap sync search result f ldap p ldap sync t ls ldapmessage msg int refreshdeletes this structure contains all information about the persistent search the caller is responsible for connecting setting version binding tls struct ldap sync t conf search params char ls base int ls scope char ls filter char ls attrs int ls timelimit int ls sizelimit poll timeout int ls timeout helpers  {
	                                                                               helpers :: -1000
                                                                                     }
add as appropriate ldap sync search entry f ls search entry ldap sync search reference f ls search reference ldap sync intermediate f ls intermediate ldap sync search result f ls search result set by the caller as appropriate void ls private conn stuff ldap ls ld the parameters below are private do not modify fixme  {
	                                                  fixes :: 6
	                                                  fixer :: 6
	                                                  fixed :: 6
	                                                 firmed :: 6
	                                                 filmer :: 6
	                                                 filmed :: 6
                                                      }
make the structure opaque and provide an interface to modify the public values result stuff int ls msgid sync stuff needed by refreshonly  {
	            refreshing :: 14
	               refresh :: 14
	          refreshingly :: 16
                     }
int ls reloadhint  {
	relocating :: 12
	reload :: 12
	reloading :: 13
 }
opaque need to pass between sessions  {
	sessions :: -1000
    }
updated by the api struct berval ls cookie state variable do not modify ldap sync refresh t ls refreshphase  {
	         refreshes :: 15
                 }
end of ldap sync rfc api connection callbacks struct ldap conncb  {
	   connect :: 7
	 concubine :: 7
	      conn :: 7
         }
struct sockaddr called after a connection is established  {
	established :: -1000
      }
typedef int ldap conn add f ldap p ldap ld sockbuf sb ldapurldesc srv struct sockaddr addr struct ldap conncb ctx called before a connection is closed typedef void ldap conn del f ldap p ldap ld sockbuf sb struct ldap conncb ctx callbacks are pushed  {
	                                       pushed :: -1000
                                            }
on a stack last one pushed is first one executed  {
	 executed :: -1000
        }
the delete callback is called with a null sockbuf just before freeing  {
	    freeing :: -1000
          }
the ldap handle typedef struct ldap conncb ldap conn add f lc add ldap conn del f lc del void lc arg ldap conncb the api draft spec says we should declare or cause to be declared struct timeval we don t see ietf ldapext discussions  {
	                                  discussions :: -1000
                                            }
struct timeval in options c ldap f int ldap get option ldap p ldap ld int option void outvalue ldap f int ldap set option ldap p ldap ld int option ldap const void invalue v rebind  {
	                              rebind :: -1000
                                   }
function callback prototype typedef int ldap rebind proc ldap p ldap ld ldap const char url ber tag t request ber int t msgid void params ldap f int ldap set rebind proc ldap p ldap ld ldap rebind proc rebind proc void params v referral selection function callback prototype typedef int ldap nextref  {
                                                    }
proc ldap p ldap ld char refsp  {
	portapak :: -1000
     }
int cntp  {
 }
void params ldap f int ldap set nextref proc ldap p ldap ld ldap nextref proc nextref proc void params v urllist  {
	               uralis :: 9
                    }
function callback prototype typedef int ldap urllist proc ldap p ldap ld ldapurldesc urllist ldapurldesc url void params ldap f int ldap set urllist proc ldap p ldap ld ldap urllist proc urllist proc void params in controls c if ldap deprecated ldap f int ldap create control ldap p deprecated use ldap control create ldap const char requestoid  {
	                                                requestors :: 12
	                                                requesting :: 13
	                                                  requotes :: 12
	                                                  requoted :: 12
	                                                  requites :: 12
	                                                  requited :: 12
	                                                  requests :: 12
	                                                   request :: 14
	                                                 requisite :: 12
	                                                 requestor :: 14
	                                                 requested :: 12
	                                             requisitioned :: 13
                                                         }
berelement ber int iscritical ldapcontrol ctrlp  {
    }
ldap f ldapcontrol ldap find control ldap p deprecated use ldap control find ldap const char oid ldapcontrol ctrls  {
	             cirls :: 7
	             certs :: 6
	             carls :: 7
	             tirls :: 6
                 }
endif ldap f int ldap control create ldap p ldap const char requestoid int iscritical struct berval value int dupval  {
	            dupable :: 7
                  }
ldapcontrol ctrlp ldap f ldapcontrol ldap control find ldap p ldap const char oid ldapcontrol ctrls ldapcontrol nextctrlp  {
                }
ldap f void ldap control free ldap p ldapcontrol ctrl ldap f void ldap controls free ldap p ldapcontrol ctrls ldap f ldapcontrol ldap controls dup ldap p ldapcontrol ldap const controls ldap f ldapcontrol ldap control dup ldap p ldap const ldapcontrol c in dnssrv  {
                                            }
c ldap f int ldap domain dn ldap p ldap const char domain char dn ldap f int ldap dn domain ldap p ldap const char dn char domain ldap f int ldap domain hostlist  {
	                           holists :: 10
	                         homilists :: 10
	                          homilist :: 10
	                         costliest :: 10
	                       hostilities :: 10
                                 }
ldap p ldap const char domain char hostlist in extended c ldap f int ldap extended operation ldap p ldap ld ldap const char reqoid  {
	                  devoir :: 7
	                 redoing :: 7
	                    redo :: 7
                       }
struct berval reqdata  {
 }
ldapcontrol serverctrls  {
 }
ldapcontrol clientctrls  {
 }
int msgidp  {
	magilps :: 7
	megilps :: 7
 }
ldap f int ldap extended operation s ldap p ldap ld ldap const char reqoid struct berval reqdata ldapcontrol serverctrls ldapcontrol clientctrls char retoidp  {
	                repoint :: 9
	                 retold :: 9
                      }
struct berval retdatap  {
	readapt :: 10
 }
ldap f int ldap parse extended result ldap p ldap ld ldapmessage res char retoidp struct berval retdatap int freeit ldap f int ldap parse intermediate ldap p ldap ld ldapmessage res char retoidp struct berval retdatap ldapcontrol serverctrls int freeit in abandon c ldap f int ldap abandon ext ldap p ldap ld int msgid ldapcontrol serverctrls ldapcontrol clientctrls if ldap deprecated ldap f int ldap abandon ldap p deprecated use ldap abandon ext ldap ld int msgid endif in add c ldap f int ldap add ext ldap p ldap ld ldap const char dn ldapmod attrs ldapcontrol serverctrls ldapcontrol clientctrls int msgidp ldap f int ldap add ext s ldap p ldap ld ldap const char dn ldapmod attrs ldapcontrol serverctrls ldapcontrol clientctrls if ldap deprecated ldap f int ldap add ldap p deprecated use ldap add ext ldap ld ldap const char dn ldapmod attrs ldap f int ldap add s ldap p deprecated use ldap add ext s ldap ld ldap const char dn ldapmod attrs endif in sasl c ldap f int ldap sasl bind ldap p ldap ld ldap const char dn ldap const char mechanism struct berval cred ldapcontrol serverctrls ldapcontrol clientctrls int msgidp interaction  {
	                                                                                                                                                                                               interaction :: -1000
                                                                                                                                                                                                         }
flags should be passed about in a control automatic default use defaults prompt otherwise interactive  {
	   interactive :: -1000
             }
prompt always quiet never prompt define ldap sasl automatic u define ldap sasl interactive u define ldap sasl quiet u v sasl interaction function callback prototype when using cyrus  {
	                       ecrus :: 6
	                       curns :: 6
	                       cures :: 6
	                       curds :: 6
	                       curbs :: 6
	                      cyprus :: 6
	                      curtsy :: 7
	                       syrup :: 6
	                      ceruse :: 6
	                      sprucy :: 6
	                        curs :: 6
	                     curtsey :: 6
                           }
sasl interact is pointer to sasl interact t should likely passed in a control and provided controls typedef int ldap sasl interact proc ldap p ldap ld unsigned flags void defaults void interact ldap f int ldap sasl interactive bind ldap p ldap ld ldap const char dn usually null ldap const char saslmechanism  {
                                                    }
ldapcontrol servercontrols  {
	monolithically :: -1000
 }
ldapcontrol clientcontrols  {
 }
should be client controls unsigned flags ldap sasl interact proc proc void defaults as obtained from ldap result ldapmessage result returned during bind processing const char rmech  {
	                   brecham :: 6
	                    reechy :: 6
	                    reecho :: 6
	                     reech :: 7
	                     reach :: 6
                         }
int msgid ldap f int ldap sasl interactive bind s ldap p ldap ld ldap const char dn usually null ldap const char saslmechanism ldapcontrol servercontrols ldapcontrol clientcontrols should be client controls unsigned flags ldap sasl interact proc proc void defaults ldap f int ldap sasl bind s ldap p ldap ld ldap const char dn ldap const char mechanism struct berval cred ldapcontrol serverctrls ldapcontrol clientctrls struct berval servercredp  {
	                                                            verderers :: 14
                                                                    }
ldap f int ldap parse sasl bind result ldap p ldap ld ldapmessage res struct berval servercredp int freeit in gssapi c ldap f int ldap gssapi bind s ldap p ldap ld ldap const char dn ldap const char creds if ldap deprecated in bind c deprecated ldap f int ldap bind ldap p deprecated use ldap sasl bind ldap ld ldap const char who ldap const char passwd int authmethod  {
	                                                             outmatched :: 12
                                                                      }
ldap f int ldap bind s ldap p deprecated use ldap sasl bind s ldap ld ldap const char who ldap const char cred int authmethod in sbind  {
	                     blinds :: 7
	                     shindy :: 6
	                      blind :: 6
	                       snib :: 6
                          }
c ldap f int ldap simple bind ldap p deprecated use ldap sasl bind ldap ld ldap const char who ldap const char passwd ldap f int ldap simple bind s ldap p deprecated use ldap sasl bind s ldap ld ldap const char who ldap const char passwd endif in compare c ldap f int ldap compare ext ldap p ldap ld ldap const char dn ldap const char attr struct berval bvalue ldapcontrol serverctrls ldapcontrol clientctrls int msgidp ldap f int ldap compare ext s ldap p ldap ld ldap const char dn ldap const char attr struct berval bvalue ldapcontrol serverctrls ldapcontrol clientctrls if ldap deprecated ldap f int ldap compare ldap p deprecated use ldap compare ext ldap ld ldap const char dn ldap const char attr ldap const char value ldap f int ldap compare s ldap p deprecated use ldap compare ext s ldap ld ldap const char dn ldap const char attr ldap const char value endif in delete c ldap f int ldap delete ext ldap p ldap ld ldap const char dn ldapcontrol serverctrls ldapcontrol clientctrls int msgidp ldap f int ldap delete ext s ldap p ldap ld ldap const char dn ldapcontrol serverctrls ldapcontrol clientctrls if ldap deprecated ldap f int ldap delete ldap p deprecated use ldap delete ext ldap ld ldap const char dn ldap f int ldap delete s ldap p deprecated use ldap delete ext s ldap ld ldap const char dn endif in error c ldap f int ldap parse result ldap p ldap ld ldapmessage res int errcodep  {
	                                                                                                                                                                                                                                                               procedure :: 10
	                                                                                                                                                                                                                                                                 precode :: 11
	                                                                                                                                                                                                                                                                precodes :: 10
                                                                                                                                                                                                                                                                       }
char matcheddnp  {
	patched :: 12
	matched :: 13
	manchet :: 12
 }
char errmsgp  {
 }
char referralsp  {
	referral :: 16
	deferral :: 13
	referrals :: 18
 }
ldapcontrol serverctrls int freeit ldap f char ldap err string ldap p int err if ldap deprecated ldap f int ldap result error ldap p deprecated use ldap parse result ldap ld ldapmessage r int freeit ldap f void ldap perror ldap p deprecated use ldap err string ldap ld ldap const char s endif gssapi c ldap f int ldap gssapi bind ldap p ldap ld ldap const char dn ldap const char creds ldap f int ldap gssapi bind s ldap p ldap ld ldap const char dn ldap const char creds in modify c ldap f int ldap modify ext ldap p ldap ld ldap const char dn ldapmod mods ldapcontrol serverctrls ldapcontrol clientctrls int msgidp ldap f int ldap modify ext s ldap p ldap ld ldap const char dn ldapmod mods ldapcontrol serverctrls ldapcontrol clientctrls if ldap deprecated ldap f int ldap modify ldap p deprecated use ldap modify ext ldap ld ldap const char dn ldapmod mods ldap f int ldap modify s ldap p deprecated use ldap modify ext s ldap ld ldap const char dn ldapmod mods endif in modrdn c ldap f int ldap rename ldap p ldap ld ldap const char dn ldap const char newrdn  {
                                                                                                                                                                                                            }
ldap const char newsuperior int deleteoldrdn  {
    }
ldapcontrol sctrls  {
	scrats :: 7
	scarts :: 8
	scarlets :: 8
 }
ldapcontrol cctrls  {
 }
int msgidp ldap f int ldap rename s ldap p ldap ld ldap const char dn ldap const char newrdn ldap const char newsuperior int deleteoldrdn ldapcontrol sctrls ldapcontrol cctrls if ldap deprecated ldap f int ldap rename ldap p deprecated use ldap rename ldap ld ldap const char dn ldap const char newrdn ldap const char newsuperior int deleteoldrdn ldap f int ldap rename s ldap p deprecated use ldap rename s ldap ld ldap const char dn ldap const char newrdn ldap const char newsuperior int deleteoldrdn ldap f int ldap modrdn ldap p deprecated use ldap rename ldap ld ldap const char dn ldap const char newrdn ldap f int ldap modrdn s ldap p deprecated use ldap rename s ldap ld ldap const char dn ldap const char newrdn ldap f int ldap modrdn ldap p deprecated use ldap rename ldap ld ldap const char dn ldap const char newrdn int deleteoldrdn ldap f int ldap modrdn s ldap p deprecated use ldap rename s ldap ld ldap const char dn ldap const char newrdn int deleteoldrdn endif in open c if ldap deprecated ldap f ldap ldap init ldap p deprecated use ldap create or ldap initialize ldap const char host int port ldap f ldap ldap open ldap p deprecated use ldap create or ldap initialize ldap const char host int port endif ldap f int ldap create ldap p ldap ldp  {
	                                                                                                                                                                                                                                        lepid :: 3
	                                                                                                                                                                                                                                        loped :: 3
	                                                                                                                                                                                                                                          lop :: 3
	                                                                                                                                                                                                                                          lip :: 3
	                                                                                                                                                                                                                                          lep :: 3
	                                                                                                                                                                                                                                          lap :: 3
	                                                                                                                                                                                                                                        lipid :: 3
                                                                                                                                                                                                                                            }
ldap f int ldap initialize ldap p ldap ldp ldap const char url ldap f ldap ldap dup ldap p ldap old in tls c ldap f int ldap tls inplace  {
	                       inclasp :: 9
	                     inclasped :: 9
	                     emplacing :: 9
	                     replacing :: 9
	                       unplace :: 11
	                      unplaced :: 10
	                      unplaces :: 10
	                       biplane :: 9
	                       inscape :: 9
                             }
ldap p ldap ld ldap f int ldap start tls ldap p ldap ld ldapcontrol serverctrls ldapcontrol clientctrls int msgidp ldap f int ldap install tls ldap p ldap ld ldap f int ldap start tls s ldap p ldap ld ldapcontrol serverctrls ldapcontrol clientctrls in messages c ldap f ldapmessage ldap first message ldap p ldap ld ldapmessage chain ldap f ldapmessage ldap next message ldap p ldap ld ldapmessage msg ldap f int ldap count messages ldap p ldap ld ldapmessage chain in references c ldap f ldapmessage ldap first reference ldap p ldap ld ldapmessage chain ldap f ldapmessage ldap next reference ldap p ldap ld ldapmessage ref ldap f int ldap count references ldap p ldap ld ldapmessage chain ldap f int ldap parse reference ldap p ldap ld ldapmessage ref char referralsp ldapcontrol serverctrls int freeit in getentry  {
	                                                                                                                                        gerent :: 11
	                                                                                                                                        regent :: 10
	                                                                                                                                       gerents :: 10
                                                                                                                                             }
c ldap f ldapmessage ldap first entry ldap p ldap ld ldapmessage chain ldap f ldapmessage ldap next entry ldap p ldap ld ldapmessage entry ldap f int ldap count entries ldap p ldap ld ldapmessage chain ldap f int ldap get entry controls ldap p ldap ld ldapmessage entry ldapcontrol serverctrls in addentry  {
	                                             ardently :: 12
	                                             pedantry :: 11
	                                               ardent :: 11
                                                    }
c ldap f ldapmessage ldap delete result entry ldap p ldapmessage list ldapmessage e ldap f void ldap add result entry ldap p ldapmessage list ldapmessage e in getdn  {
	                        tend :: 6
	                        gent :: 6
	                         get :: 6
                           }
c ldap f char ldap get dn ldap p ldap ld ldapmessage entry typedef struct ldap ava struct berval la attr struct berval la value unsigned la flags define ldap ava null x u define ldap ava string x u define ldap ava binary x u define ldap ava nonprintable  {
                                                }
x u define ldap ava free attr x u define ldap ava free value x u void la private ldapava  {
                  }
typedef ldapava ldaprdn  {
	garagings :: -1000
 }
typedef ldaprdn ldapdn dn formats define ldap dn format ldap x u define ldap dn format ldapv x u define ldap dn format ldapv x u define ldap dn format dce  {
	                           cru :: -1000
                             }
x u define ldap dn format ufn  {
	  funk :: 3
	  fund :: 3
	   urn :: 3
	   ufo :: 3
	    un :: 3
     }
x u dn str only define ldap dn format ad canonical x u dn str only define ldap dn format lber x f u for testing only define ldap dn format mask x f u dn flags define ldap dn pretty x u define ldap dn skip x u define ldap dn p noleadtrailspaces  {
                                                    }
x u define ldap dn p nospaceafterrdn  {
     }
x u define ldap dn pedantic  {
	pedantic :: -1000
    }
xf u ldap f void ldap rdnfree  {
     }
ldap p ldaprdn rdn ldap f void ldap dnfree  {
	definers :: 7
	  unfree :: 9
	 inbreed :: 7
	deferent :: 7
	 definer :: 8
	   defer :: 7
	  define :: 7
	unfreedom :: 8
	 refined :: 7
	unfreedoms :: 7
	enframed :: 7
	defreezing :: 7
	 unfreed :: 10
	 unfrees :: 8
	  enfree :: 9
	  enfire :: 7
	defrozen :: 7
       }
ldap p ldapdn dn ldap f int ldap bv dn ldap p struct berval bv ldapdn dn unsigned flags ldap f int ldap str dn ldap p ldap const char str ldapdn dn unsigned flags ldap f int ldap dn bv ldap p ldapdn dn struct berval bv unsigned flags ldap f int ldap dn str ldap p ldapdn dn char str unsigned flags ldap f int ldap bv rdn ldap p struct berval bv ldaprdn rdn char next unsigned flags ldap f int ldap str rdn ldap p ldap const char str ldaprdn rdn char next unsigned flags ldap f int ldap rdn bv ldap p ldaprdn rdn struct berval bv unsigned flags ldap f int ldap rdn str ldap p ldaprdn rdn char str unsigned flags ldap f int ldap dn normalize ldap p ldap const char in unsigned iflags  {
	                                                                                                                                       silage :: 7
	                                                                                                                                        gilas :: 7
	                                                                                                                                       pilafs :: 7
	                                                                                                                                       oflags :: 9
	                                                                                                                                        oflag :: 7
                                                                                                                                            }
char out unsigned oflags  {
	oflags :: -1000
  }
ldap f char ldap dn ufn ldap p deprecated use ldap str dn dn str ldap const char dn ldap f char ldap explode  {
	                explode :: -1000
                      }
dn ldap p deprecated ldap str dn ldap const char dn int notypes  {
	      netops :: 9
	     cotypes :: 11
	      cotype :: 9
           }
ldap f char ldap explode rdn ldap p deprecated ldap str rdn ldap const char rdn int notypes typedef int ldapdn rewrite func ldap p ldapdn dn unsigned flags void ctx ldap f int ldap x dn bv ldap p void x name struct berval dn ldapdn rewrite func func unsigned flags ldap f char ldap dn dcedn  {
                                                        }
ldap p deprecated ldap str dn dn str ldap const char dn ldap f char ldap dcedn dn ldap p deprecated ldap str dn dn str ldap const char dce ldap f char ldap dn ad canonical ldap p deprecated ldap str dn dn str ldap const char dn ldap f int ldap get dn ber ldap p ldap ld ldapmessage e berelement berout  {
	                                                         rubout :: 7
	                                                         besort :: 8
	                                                          buret :: 7
	                                                        reroute :: 7
	                                                         detour :: 7
	                                                       rebought :: 7
	                                                         retour :: 7
	                                                         redout :: 8
	                                                        redouts :: 7
	                                                        redoubt :: 8
	                                                       redoubts :: 7
	                                                         tenour :: 7
	                                                         burnet :: 7
                                                              }
struct berval dn ldap f int ldap get attribute ber ldap p ldap ld ldapmessage e berelement ber struct berval attr struct berval vals in getattr  {
                        }
c ldap f char ldap first attribute ldap p ldap ld ldapmessage entry berelement ber ldap f char ldap next attribute ldap p ldap ld ldapmessage entry berelement ber in getvalues  {
	                     outvalues :: 12
                             }
c ldap f struct berval ldap get values len ldap p ldap ld ldapmessage entry ldap const char target ldap f int ldap count values len ldap p struct berval vals ldap f void ldap value free len ldap p struct berval vals if ldap deprecated ldap f char ldap get values ldap p deprecated use ldap get values len ldap ld ldapmessage entry ldap const char target ldap f int ldap count values ldap p deprecated use ldap count values len char vals ldap f void ldap value free ldap p deprecated use ldap value free len char vals endif in result c ldap f int ldap result ldap p ldap ld int msgid int all struct timeval timeout ldapmessage result ldap f int ldap msgtype  {
	                                                                                                                      mistyped :: 9
	                                                                                                                      mistypes :: 9
	                                                                                                                       mistype :: 10
                                                                                                                             }
ldap p ldapmessage lm ldap f int ldap msgid ldap p ldapmessage lm ldap f int ldap msgfree  {
                }
ldap p ldapmessage lm ldap f int ldap msgdelete  {
       }
ldap p ldap ld int msgid in search c ldap f int ldap bv escaped  {
	       escaped :: -1000
             }
filter value ldap p struct berval in struct berval out ldap f int ldap search ext ldap p ldap ld ldap const char base int scope ldap const char filter char attrs int attrsonly  {
                                }
ldapcontrol serverctrls ldapcontrol clientctrls struct timeval timeout int sizelimit int msgidp ldap f int ldap search ext s ldap p ldap ld ldap const char base int scope ldap const char filter char attrs int attrsonly ldapcontrol serverctrls ldapcontrol clientctrls struct timeval timeout int sizelimit ldapmessage res if ldap deprecated ldap f int ldap search ldap p deprecated use ldap search ext ldap ld ldap const char base int scope ldap const char filter char attrs int attrsonly ldap f int ldap search s ldap p deprecated use ldap search ext s ldap ld ldap const char base int scope ldap const char filter char attrs int attrsonly ldapmessage res ldap f int ldap search st ldap p deprecated use ldap search ext s ldap ld ldap const char base int scope ldap const char filter char attrs int attrsonly struct timeval timeout ldapmessage res endif in unbind c ldap f int ldap unbind ext ldap p ldap ld ldapcontrol serverctrls ldapcontrol clientctrls ldap f int ldap unbind ext s ldap p ldap ld ldapcontrol serverctrls ldapcontrol clientctrls ldap f int ldap destroy ldap p ldap ld if ldap deprecated ldap f int ldap unbind ldap p deprecated use ldap unbind ext ldap ld ldap f int ldap unbind s ldap p deprecated use ldap unbind ext s ldap ld endif in filter c ldap f int ldap put vrfilter  {
	                                                                                                                                                                                                                             refilter :: 12
	                                                                                                                                                                                                                             infilter :: 10
	                                                                                                                                                                                                                            refilters :: 11
                                                                                                                                                                                                                                    }
ldap p berelement ber const char vrf in free c ldap f void ldap memalloc ldap p ber len t s ldap f void ldap memrealloc ldap p void p ber len t s ldap f void ldap memcalloc ldap p ber len t n ber len t s ldap f void ldap memfree ldap p void p ldap f void ldap memvfree ldap p void v ldap f char ldap strdup ldap p ldap const char ldap f void ldap mods free ldap p ldapmod mods int freemods  {
	                                                                                fretsome :: 10
	                                                                                frescoed :: 10
	                                                                               freemason :: 10
	                                                                               freeloads :: 10
	                                                                                 freedom :: 12
	                                                                               freeholds :: 10
	                                                                                freedoms :: 14
                                                                                       }
if ldap deprecated in sort c deprecated use custom code instead typedef int ldap sort ad cmp proc ldap p deprecated ldap const char left ldap const char right typedef int ldap sort av cmp proc ldap p deprecated ldap const void left ldap const void right ldap f int deprecated ldap sort entries ldap p ldap ld ldapmessage chain ldap const char attr ldap sort ad cmp proc cmp ldap f int deprecated ldap sort values ldap p ldap ld char vals ldap sort av cmp proc cmp ldap f int deprecated ldap sort strcasecmp ldap p ldap const void a ldap const void b endif in url c ldap f int ldap is ldap url ldap p ldap const char url ldap f int ldap is ldaps url ldap p ldap const char url ldap f int ldap is ldapi  {
	                                                                                                                                       placid :: 6
	                                                                                                                                       salpid :: 6
	                                                                                                                                      elapids :: 6
	                                                                                                                                       elapid :: 7
                                                                                                                                            }
url ldap p ldap const char url ldap f int ldap url parse ldap p ldap const char url ldapurldesc ludpp  {
                   }
ldap f char ldap url desc str ldap p ldapurldesc ludp ldap f void ldap free urldesc  {
	         crudest :: 9
	          crudes :: 10
               }
ldap p ldapurldesc ludp ldap cancel extended operation draft zeilenga  {
        }
ldap cancel xx txt in cancel c define ldap api feature cancel ldap f int ldap cancel ldap p ldap ld int cancelid  {
	                lanced :: 10
	             canceling :: 11
	           conciliated :: 10
	               cancels :: 11
	               calcine :: 10
	              panicled :: 10
	              cancroid :: 10
	              cancelli :: 11
	                calced :: 10
	             catchline :: 10
	            calcimined :: 10
                     }
ldapcontrol sctrls ldapcontrol cctrls int msgidp ldap f int ldap cancel s ldap p ldap ld int cancelid ldapcontrol sctrl ldapcontrol cctrl ldap turn extended operation draft zeilenga ldap turn xx txt in turn c define ldap api feature turn ldap f int ldap turn ldap p ldap ld int mutual  {
	                                            mutual :: -1000
                                                 }
ldap const char identifier ldapcontrol sctrls ldapcontrol cctrls int msgidp ldap f int ldap turn s ldap p ldap ld int mutual ldap const char identifier ldapcontrol sctrl ldapcontrol cctrl ldap paged results in pagectrl  {
                                 }
c define ldap api feature paged results ldap f int ldap create page control value ldap p ldap ld ber int t pagesize struct berval cookie struct berval value ldap f int ldap create page control ldap p ldap ld ber int t pagesize struct berval cookie int iscritical ldapcontrol ctrlp if ldap deprecated ldap f int ldap parse page control ldap p deprecated use ldap parse pageresponse  {
                                                                  }
control ldap ld ldapcontrol ctrls ber int t count struct berval cookie endif ldap f int ldap parse pageresponse control ldap p ldap ld ldapcontrol ctrl ber int t count struct berval cookie ldap server side sort in sortctrl  {
                                     }
c define ldap api feature server side sort structure for a sort key typedef struct ldapsortkey  {
	     slippiness :: -1000
              }
char attributetype  {
 }
char orderingrule  {
 }
int reverseorder  {
 }
ldapsortkey ldap f int ldap create sort keylist ldap p ldapsortkey sortkeylist  {
	     quarry :: -1000
          }
char keystring  {
	restyling :: 11
	eyestrings :: 11
	restoking :: 11
	keystroking :: 12
	oystering :: 11
	keynoting :: 11
 }
ldap f void ldap free sort keylist ldap p ldapsortkey sortkeylist ldap f int ldap create sort control value ldap p ldap ld ldapsortkey keylist struct berval value ldap f int ldap create sort control ldap p ldap ld ldapsortkey keylist int iscritical ldapcontrol ctrlp ldap f int ldap parse sortresponse control ldap p ldap ld ldapcontrol ctrl ber int t result char attribute ldap virtual list view in vlvctrl  {
                                                                    }
c define ldap api feature virtual list view structure for virtual list typedef struct ldapvlvinfo  {
             }
ber int t ldvlv  {
  }
version ber int t ldvlv before count ber int t ldvlv after count ber int t ldvlv offset ber int t ldvlv count struct berval ldvlv attrvalue  {
                         }
struct berval ldvlv context void ldvlv extradata  {
	extravagant :: 12
	extravagate :: 11
	extravasate :: 11
	extradotal :: 13
	extravasated :: 12
	extravagated :: 12
     }
ldapvlvinfo ldap f int ldap create vlv control value ldap p ldap ld ldapvlvinfo ldvlistp  {
             }
struct berval value ldap f int ldap create vlv control ldap p ldap ld ldapvlvinfo ldvlistp ldapcontrol ctrlp ldap f int ldap parse vlvresponse control ldap p ldap ld ldapcontrol ctrls ber int t target posp  {
	                              soppy :: 5
	                               pops :: 6
	                               pomp :: 5
	                              props :: 5
	                              popsy :: 5
	                              popes :: 5
	                              poops :: 5
	                              pomps :: 6
	                              plops :: 5
	                                pos :: 5
	                                pop :: 5
                                  }
ber int t list countp  {
	pounce :: 7
	fount :: 7
	court :: 7
	count :: 10
	country :: 8
	counted :: 8
	counter :: 8
	countship :: 8
	pouncet :: 8
	county :: 9
	counts :: 9
	cobnut :: 7
	countships :: 7
	counters :: 7
	countess :: 7
	counties :: 7
	toun :: 7
	coup :: 7
	puncto :: 7
	mount :: 7
   }
struct berval contextp  {
	contempts :: 10
	context :: 14
	content :: 10
	contests :: 10
	contexts :: 13
	contempt :: 11
	contextual :: 11
 }
int errcodep ldap who am i in whoami c define ldap api feature whoami ldap f int ldap parse whoami ldap p ldap ld ldapmessage res struct berval authzid ldap f int ldap whoami ldap p ldap ld ldapcontrol sctrls ldapcontrol cctrls int msgidp ldap f int ldap whoami s ldap p ldap ld struct berval authzid ldapcontrol sctrls ldapcontrol cctrls ldap password modify in passwd c define ldap api feature passwd modify ldap f int ldap parse passwd ldap p ldap ld ldapmessage res struct berval newpasswd  {
                                                                                      }
ldap f int ldap passwd ldap p ldap ld struct berval user struct berval oldpw  {
	           old :: 6
             }
struct berval newpw  {
 }
ldapcontrol sctrls ldapcontrol cctrls int msgidp ldap f int ldap passwd s ldap p ldap ld struct berval user struct berval oldpw struct berval newpw struct berval newpasswd ldapcontrol sctrls ldapcontrol cctrls ifdef ldap control passwordpolicyrequest ldap password policy controls in ppolicy  {
                                        }
c define ldap api feature password policy typedef enum passpolicyerror  {
        }
enum pp passwordexpired  {
 }
pp accountlocked  {
 }
pp changeafterreset  {
 }
pp passwordmodnotallowed  {
 }
pp mustsupplyoldpassword  {
 }
pp insufficientpasswordquality  {
 }
pp passwordtooshort  {
 }
pp passwordtooyoung  {
 }
pp passwordinhistory  {
 }
pp noerror  {
 }
ldappasswordpolicyerror  {
 }
ldap f int ldap create passwordpolicy control ldap p ldap ld ldapcontrol ctrlp ldap f int ldap parse passwordpolicy control ldap p ldap ld ldapcontrol ctrl ber int t expirep  {
	                      expired :: 10
	                      expires :: 10
	                      expirer :: 9
	                       expire :: 11
                            }
ber int t gracep  {
	grice :: 7
	grece :: 7
	graze :: 7
	grave :: 7
	grate :: 7
	grape :: 9
	grame :: 7
	grade :: 7
	grace :: 10
	glace :: 7
	placer :: 7
	crape :: 8
	brace :: 7
	graceful :: 7
	crapes :: 7
	craped :: 7
	trace :: 7
	grapey :: 8
	grapes :: 8
	graped :: 8
	graces :: 9
	graced :: 9
	spacer :: 7
	grackle :: 7
	gracile :: 7
  }
ldappasswordpolicyerror errorp  {
	error :: 10
	orrery :: 7
	errors :: 9
	porer :: 7
	errorist :: 7
 }
ldap f const char ldap passwordpolicy err txt ldap p ldappasswordpolicyerror endif ldap control passwordpolicyrequest ldap dynamic directory services refresh rfc in dds  {
	          blackberries :: -1000
                     }
c define ldap api feature refresh ldap f int ldap parse refresh ldap p ldap ld ldapmessage res ber int t newttl  {
	                 newt :: 7
                    }
ldap f int ldap refresh ldap p ldap ld struct berval dn ber int t ttl ldapcontrol sctrls ldapcontrol cctrls int msgidp ldap f int ldap refresh s ldap p ldap ld struct berval dn ber int t ttl ber int t newttl ldapcontrol sctrls ldapcontrol cctrls ldap transactions  {
	                                    transactions :: -1000
                                               }
ifdef ldap x txn ldap f int ldap txn start ldap p ldap ld ldapcontrol sctrls ldapcontrol cctrls int msgidp ldap f int ldap txn start s ldap p ldap ld ldapcontrol sctrl ldapcontrol cctrl struct berval rettxnid  {
	                              retting :: 10
                                    }
ldap f int ldap txn end ldap p ldap ld int commit  {
	     commit :: -1000
          }
struct berval txnid  {
	tined :: 6
	tind :: 6
 }
ldapcontrol sctrls ldapcontrol cctrls int msgidp ldap f int ldap txn end s ldap p ldap ld int commit struct berval txnid ldapcontrol sctrl ldapcontrol cctrl int retidp  {
	                   peridots :: 7
	                      fetid :: 7
	                      betid :: 7
	                     extirp :: 7
	                     retied :: 7
	                     redtop :: 7
	                     redipt :: 9
	                     redips :: 7
	                   rapidest :: 7
	                    peridot :: 8
	                      tepid :: 8
	                      riped :: 7
	                      retia :: 7
	                      resid :: 7
	                      redip :: 8
	                      redid :: 7
	                      rebid :: 7
                          }
endif in ldap sync c initialize the persistent search structure ldap f ldap sync t ldap sync initialize ldap p ldap sync t ls destroy the persistent search structure ldap f void ldap sync destroy ldap p ldap sync t ls int freeit initialize a refreshonly sync ldap f int ldap sync init ldap p ldap sync t ls int mode initialize a refreshonly sync ldap f int ldap sync init refresh only ldap p ldap sync t ls initialize a refreshandpersist sync ldap f int ldap sync init refresh and persist ldap p ldap sync t ls poll for new responses ldap f int ldap sync poll ldap p ldap sync t ls ifdef ldap control x session tracking in stctrl  {
                                                                                                                        }
c ldap f int ldap create session tracking value ldap p ldap ld char sessionsourceip  {
             }
char sessionsourcename  {
 }
char formatoid  {
	formated :: 11
	trematoid :: 11
	format :: 11
	formations :: 12
	forzato :: 11
	dermatoid :: 12
	formation :: 13
 }
struct berval sessiontrackingidentifier  {
	propylite :: -1000
 }
struct berval value ldap f int ldap create session tracking ldap p ldap ld char sessionsourceip char sessionsourcename char formatoid struct berval sessiontrackingidentifier ldapcontrol ctrlp ldap f int ldap parse session tracking control ldap p ldap ld ldapcontrol ctrl struct berval ip struct berval name struct berval oid struct berval id endif ldap control x session tracking in assertion c ldap f int ldap create assertion control value ldap p ldap ld char assertion struct berval value ldap f int ldap create assertion control ldap p ldap ld char filter int iscritical ldapcontrol ctrlp in deref c typedef struct ldapderefspec  {
                                                                                                  }
char derefattr  {
 }
char attributes ldapderefspec typedef struct ldapderefval  {
    }
char type bervarray vals struct ldapderefval next ldapderefval typedef struct ldapderefres  {
	trampolins :: -1000
         }
char derefattr struct berval derefval  {
	deferral :: 11
   }
ldapderefval attrvals  {
	tubules :: -1000
 }
struct ldapderefres next ldapderefres ldap f int ldap create deref control value ldap p ldap ld ldapderefspec ds struct berval value ldap f int ldap create deref control ldap p ldap ld ldapderefspec ds int iscritical ldapcontrol ctrlp ldap f void ldap derefresponse  {
                                         }
free ldap p ldapderefres dr ldap f int ldap parse derefresponse control ldap p ldap ld ldapcontrol ctrl ldapderefres drp  {
	              duper :: 3
	              drupe :: 3
	              dropt :: 3
	              drops :: 3
	              droop :: 3
	              dript :: 3
	              drips :: 3
	              draps :: 3
	              drape :: 3
	              doper :: 3
	               prod :: 3
	               prad :: 3
	               drop :: 4
	               drip :: 4
	               drap :: 4
	               dorp :: 3
	                dup :: 3
	                dop :: 3
	                dip :: 3
	                dep :: 3
	                dap :: 3
	                 dr :: 4
                  }
ldap f int ldap parse deref control ldap p ldap ld ldapcontrol ctrls ldapderefres drp hacks  {
	          hacks :: -1000
              }
for ntlm  {
 }
define ldap auth ntlm request ber tag t x au define ldap auth ntlm response ber tag t x bu ldap f int ldap ntlm bind ldap p ldap ld ldap const char dn ber tag t tag struct berval cred ldapcontrol sctrls ldapcontrol cctrls int msgidp ldap f int ldap parse ntlm bind result ldap p ldap ld ldapmessage res struct berval challenge ldap end decl endif ldap h openldap this work is part of openldap software http www openldap org copyright the openldap foundation all rights reserved redistribution and use in source and binary forms with or without modification are permitted only as authorized by the openldap public license a copy of this license is available in file license in the top level directory of the distribution or alternatively at http www openldap org license html ldap schema  {
	                                                                                                                                     schema :: -1000
                                                                                                                                          }
h header for basic schema handling functions that can be used by both clients and servers these routines should be renamed  {
	             renamed :: -1000
                   }
ldap x ifndef ldap schema h define ldap schema h include ldap cdefs h ldap begin decl codes for parsing errors define ldap scherr  {
	                 scryer :: 7
	                 scorer :: 7
	                 scarer :: 7
	              superrich :: 7
	                scherzo :: 7
	                scherzi :: 7
	                 ochers :: 7
                      }
outofmem  {
 }
define ldap scherr unexptoken  {
	unbespoken :: 12
  }
define ldap scherr noleftparen  {
  }
define ldap scherr norightparen  {
  }
define ldap scherr nodigit  {
	iodating :: 9
	indigotin :: 9
  }
define ldap scherr badname  {
	balsamed :: 9
	bandage :: 9
	badman :: 10
	damnable :: 9
	maenad :: 9
  }
define ldap scherr baddesc  {
	bedads :: 9
	baddies :: 9
	baddest :: 11
	bardes :: 9
	badder :: 9
  }
define ldap scherr badsup  {
	bauds :: 7
	bapus :: 7
	backups :: 7
	pads :: 7
	buds :: 7
	baps :: 7
  }
define ldap scherr dupopt  {
  }
define ldap scherr empty define ldap scherr missing define ldap scherr out of order typedef struct ldap schema extension item char lsei  {
	                lexis :: 5
	                lewis :: 5
	                lenis :: 5
	                vleis :: 5
	                steil :: 5
	                speil :: 5
	                 lwei :: 5
	                 lies :: 6
	                 leis :: 5
	                 isle :: 5
	                lweis :: 6
	                  lie :: 5
	                lieus :: 5
	                liers :: 5
	                liens :: 5
	                liefs :: 5
                    }
name char lsei values ldapschemaextensionitem  {
   }
typedef struct ldap syntax char syn oid required char syn names optional char syn desc optional ldapschemaextensionitem syn extensions optional ldapsyntax  {
                   }
typedef struct ldap matchingrule  {
	matching :: 16
	latching :: 15
	marching :: 15
  }
char mr oid required char mr names optional char mr desc optional int mr obsolete optional char mr syntax oid required ldapschemaextensionitem mr extensions optional ldapmatchingrule  {
                        }
typedef struct ldap matchingruleuse  {
  }
char mru  {
	frump :: 3
	drums :: 3
	crumb :: 3
	brume :: 3
	trump :: 3
	smur :: 3
	murr :: 3
	mure :: 3
	mura :: 3
	muir :: 3
	grum :: 4
	drum :: 4
	arum :: 4
	mourn :: 3
	rum :: 3
	mou :: 3
	meu :: 3
	cru :: 3
	ur :: 3
 }
oid required char mru names optional char mru desc optional int mru obsolete optional char mru applies oids required ldapschemaextensionitem mru extensions optional ldapmatchingruleuse  {
                      }
typedef struct ldap attributetype char at oid required char at names optional char at desc optional int at obsolete no yes char at sup oid optional char at equality oid optional char at ordering oid optional char at substr oid optional char at syntax oid optional int at syntax len optional int at single value no yes int at collective  {
	                                                 collective :: -1000
                                                          }
no yes int at no user mod no yes int at usage userapplications  {
	uncluttering :: -1000
           }
directoryoperation  {
 }
distributedoperation  {
 }
dsaoperation  {
	immoderations :: 15
	exasperation :: 17
	depopulations :: 15
	exasperations :: 16
 }
ldapschemaextensionitem at extensions optional ldapattributetype  {
   }
typedef struct ldap objectclass char oc oid required char oc names optional char oc desc optional int oc obsolete no yes char oc sup oids optional int oc kind abstract structural  {
	                    structural :: -1000
                             }
auxiliary char oc at oids must optional char oc at oids may optional ldapschemaextensionitem oc extensions optional ldapobjectclass  {
                }
typedef struct ldap contentrule  {
	contentedly :: 15
  }
char cr oid required char cr names optional char cr desc optional char cr sup oids optional int cr obsolete no yes char cr oc oids aux optional char cr at oids must optional char cr at oids may optional char cr at oids not optional ldapschemaextensionitem cr extensions optional ldapcontentrule  {
                                                 }
typedef struct ldap nameform  {
	waveform :: 10
	maniform :: 11
	napiform :: 10
	ramiform :: 10
	natiform :: 10
  }
char nf oid required char nf names optional char nf desc optional int nf obsolete no yes char nf objectclass required char nf at oids must required char nf at oids may optional ldapschemaextensionitem nf extensions optional ldapnameform  {
                                    }
typedef struct ldap structurerule  {
  }
int sr ruleid  {
	sulfide :: 7
	rudely :: 7
	rubied :: 7
	relaid :: 8
	rebuild :: 7
	dulcimer :: 7
	rude :: 7
	rile :: 7
	rules :: 7
	ruled :: 9
	rudie :: 7
	dule :: 7
	riled :: 8
 }
required char sr names optional char sr desc optional int sr obsolete no yes char sr nameform required int sr nsup  {
	                spun :: 5
	                noup :: 5
	               noups :: 6
                   }
ruleids  {
	sulfide :: 9
	rules :: 9
	ruled :: 9
	ruddies :: 9
 }
number of sr sup ruleids int sr sup ruleids optional ldapschemaextensionitem sr extensions optional ldapstructurerule  {
             }
misc macros define ldap schema no define ldap schema yes define ldap schema user applications define ldap schema directory operation define ldap schema distributed operation define ldap schema dsa operation define ldap schema abstract define ldap schema structural define ldap schema auxiliary flags that control how liberal  {
	                                       liberal :: -1000
                                             }
the parsing routines are define ldap schema allow none x u strict parsing define ldap schema allow no oid x u allow missing oid define ldap schema allow quoted x u allow bogus extra quotes  {
	                            quotes :: -1000
                                 }
define ldap schema allow descr x u allow descr instead of oid define ldap schema allow descr prefix x u allow descr as oid prefix define ldap schema allow oid macro x u allow oid macros in slapd define ldap schema allow out of order fields x u allow fields in most any order define ldap schema allow all x fu be very liberal in parsing define ldap schema skip x u don t malloc any result ldap f ldap const char ldap syntax name ldap p ldapsyntax syn ldap f ldap const char ldap matchingrule name ldap p ldapmatchingrule mr ldap f ldap const char ldap matchingruleuse name ldap p ldapmatchingruleuse mru ldap f ldap const char ldap attributetype name ldap p ldapattributetype at ldap f ldap const char ldap objectclass name ldap p ldapobjectclass oc ldap f ldap const char ldap contentrule name ldap p ldapcontentrule cr ldap f ldap const char ldap nameform name ldap p ldapnameform nf ldap f ldap const char ldap structurerule name ldap p ldapstructurerule sr ldap f void ldap syntax free ldap p ldapsyntax syn ldap f void ldap matchingrule free ldap p ldapmatchingrule mr ldap f void ldap matchingruleuse free ldap p ldapmatchingruleuse mr ldap f void ldap attributetype free ldap p ldapattributetype at ldap f void ldap objectclass free ldap p ldapobjectclass oc ldap f void ldap contentrule free ldap p ldapcontentrule cr ldap f void ldap nameform free ldap p ldapnameform nf ldap f void ldap structurerule free ldap p ldapstructurerule sr ldap f ldapstructurerule ldap str structurerule ldap p ldap const char s int code ldap const char errp  {
	                                                                                                                                                                                                                                                                     shortlist :: -1000
                                                                                                                                                                                                                                                                             }
ldap const unsigned flags ldap f ldapnameform ldap str nameform ldap p ldap const char s int code ldap const char errp ldap const unsigned flags ldap f ldapcontentrule ldap str contentrule ldap p ldap const char s int code ldap const char errp ldap const unsigned flags ldap f ldapobjectclass ldap str objectclass ldap p ldap const char s int code ldap const char errp ldap const unsigned flags ldap f ldapattributetype ldap str attributetype ldap p ldap const char s int code ldap const char errp ldap const unsigned flags ldap f ldapsyntax ldap str syntax ldap p ldap const char s int code ldap const char errp ldap const unsigned flags ldap f ldapmatchingrule ldap str matchingrule ldap p ldap const char s int code ldap const char errp ldap const unsigned flags ldap f ldapmatchingruleuse ldap str matchingruleuse ldap p ldap const char s int code ldap const char errp ldap const unsigned flags ldap f char ldap structurerule str ldap p ldapstructurerule sr ldap f struct berval ldap structurerule bv ldap p ldapstructurerule sr struct berval bv ldap f char ldap nameform str ldap p ldapnameform nf ldap f struct berval ldap nameform bv ldap p ldapnameform nf struct berval bv ldap f char ldap contentrule str ldap p ldapcontentrule cr ldap f struct berval ldap contentrule bv ldap p ldapcontentrule cr struct berval bv ldap f char ldap objectclass str ldap p ldapobjectclass oc ldap f struct berval ldap objectclass bv ldap p ldapobjectclass oc struct berval bv ldap f char ldap attributetype str ldap p ldapattributetype at ldap f struct berval ldap attributetype bv ldap p ldapattributetype at struct berval bv ldap f char ldap syntax str ldap p ldapsyntax syn ldap f struct berval ldap syntax bv ldap p ldapsyntax syn struct berval bv ldap f char ldap matchingrule str ldap p ldapmatchingrule mr ldap f struct berval ldap matchingrule bv ldap p ldapmatchingrule mr struct berval bv ldap f char ldap matchingruleuse str ldap p ldapmatchingruleuse mru ldap f struct berval ldap matchingruleuse bv ldap p ldapmatchingruleuse mru struct berval bv ldap f char ldap scherr str ldap p int code ldap gccattr const ldap end decl endif openldap this work is part of openldap software http www openldap org copyright the openldap foundation all rights reserved redistribution and use in source and binary forms with or without modification are permitted only as authorized by the openldap public license a copy of this license is available in file license in the top level directory of the distribution or alternatively at http www openldap org license html this notice applies to changes created by or for novell inc to preexisting  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                    preexisting :: -1000
                                                                                                                                                                                                                                                                                                                                                                                                                                                              }
works for which notices  {
	notices :: -1000
  }
appear elsewhere in this file copyright c novell inc all rights reserved this work is subject to u s and international copyright laws  {
	                  laws :: -1000
                     }
and treaties  {
	treaties :: -1000
 }
use modification and redistribution of this work is subject to version of the openldap public license a copy of which is available at http www openldap org license html or in the file license in the top level directory of the distribution any use or exploitation  {
	                                 radiolarians :: -1000
                                            }
of this work other than as authorized in version of the openldap public license or other prior written consent  {
	           consent :: -1000
                 }
from novell could subject the perpetrator  {
	perpetrator :: -1000
    }
to criminal  {
	criminal :: -1000
 }
and civil  {
	civil :: -1000
 }
liability note a verbatim copy of version of the openldap public license can be found in the file build license in this distribution of openldap software ifndef ldap utf h define ldap utf h include lber types h get ber t utf utility routines ldap begin decl define ldap ucs  {
	                                             scut :: 3
	                                             scur :: 3
	                                             scup :: 3
	                                             scum :: 3
	                                             scul :: 3
	                                             scug :: 3
	                                             scud :: 3
	                                             ecus :: 3
	                                             cusp :: 3
	                                             cush :: 3
	                                              uts :: 3
	                                              urs :: 3
	                                              uns :: 3
	                                              ums :: 3
	                                              ugs :: 3
	                                              uds :: 3
	                                               us :: 3
                                                }
invalid x u typedef ber int t ldap ucs t ldap max utf len is or depending on size of wchar t define ldap max utf len sizeof wchar t unicode conversion routines ldap f ldap ucs t ldap x utf to ucs ldap const char p ldap f int ldap x ucs to utf ldap ucs t c char buf wide char utf conversion routines utf character to wide char ldap f int ldap x utf to wc ldap p wchar t wchar ldap const char utf char utf string to wide char string ldap f int ldap x utf s to wcs ldap p wchar t wcstr  {
	                                                                                                      wastry :: 6
                                                                                                           }
ldap const char utf str size t count wide char to utf character ldap f int ldap x wc to utf ldap p char utf char wchar t wchar size t count wide char string to utf string ldap f int ldap x wcs to utf s ldap p char utf str ldap const wchar t wcstr size t count multibyte char utf conversion routines utf character to multibyte character ldap f int ldap x utf to mb ldap p char mbchar  {
	                                                                          becharm :: 9
	                                                                          machair :: 7
	                                                                             mach :: 7
	                                                                          uncharm :: 7
	                                                                          encharm :: 7
	                                                                            mocha :: 7
                                                                                }
ldap const char utf char int ldap f wctomb  {
       }
char mbchar wchar t wchar utf string to multibyte string ldap f int ldap x utf s to mbs ldap p char mbstr  {
                     }
ldap const char utf str size t count size t ldap f wcstombs  {
	   mainsheet :: -1000
           }
char mbstr ldap const wchar t wcstr size t count multibyte character to utf character ldap f int ldap x mb to utf ldap p char utf char ldap const char mbchar size t mbsize  {
                                 }
int ldap f mbtowc  {
  }
wchar t wchar ldap const char mbchar size t count multibyte string to utf string ldap f int ldap x mbs to utf s ldap p char utf str ldap const char mbstr size t count size t ldap f mbstowcs  {
	                                mistbows :: 10
                                       }
wchar t wcstr ldap const char mbstr size t count ldap end decl endif ldap utf h openldap this work is part of openldap software http www openldap org copyright the openldap foundation all rights reserved redistribution and use in source and binary forms with or without modification are permitted only as authorized by the openldap public license a copy of this license is available in file license in the top level directory of the distribution or alternatively at http www openldap org license html portions copyright c regents of the university of michigan all rights reserved redistribution and use in source and binary forms are permitted provided that this notice is preserved and that due credit is given to the university of michigan at ann arbor the name of the university may not be used to endorse or promote products derived from this software without specific prior written permission this software is provided as is without express or implied warranty ifndef ldif h define ldif h include ldap cdefs h ldap begin decl this is not a bogus extern declaration unlike ldap debug ldap ldif v int ldif debug define ldif line width default maximum length of ldif lines define ldif line width max ber len t maximum length of ldif lines define ldif line width wrap wrap wrap ldif line width wrap macro to calculate maximum number of bytes that the base equivalent of an item that is len bytes long will take up base encoding uses one byte for every six bits in the value plus up to two pad bytes define ldif base len len len macro to calculate maximum size that an ldif encoded type length tlen  {
	                                                                                                                                                                                                                                                                                    elint :: 5
	                                                                                                                                                                                                                                                                                   plenty :: 5
	                                                                                                                                                                                                                                                                                    blent :: 6
	                                                                                                                                                                                                                                                                                   thenal :: 5
	                                                                                                                                                                                                                                                                                     then :: 5
	                                                                                                                                                                                                                                                                                     teen :: 5
	                                                                                                                                                                                                                                                                                     glen :: 5
	                                                                                                                                                                                                                                                                                    olent :: 6
                                                                                                                                                                                                                                                                                        }
and value length vlen  {
	vlei :: 5
	glen :: 5
  }
will take up room  {
	room :: -1000
  }
for type first newline base value continued  {
	continued :: -1000
     }
lines each continued line needs room for a newline and a leading space character define ldif size needed nlen  {
	              glen :: 5
                 }
vlen nlen ldif base len vlen ldif base len vlen nlen ldif line width define ldif size needed wrap nlen vlen wrap nlen ldif base len vlen wrap ldif base len vlen nlen ldif line width wrap ldif line width max ldif base len vlen nlen wrap ldap ldif f int ldif parse line ldap p ldap const char line char name char value ber len t vlen ldap ldif f int ldif parse line ldap p char line struct berval type struct berval value int freeval  {
	                                                                               federal :: 9
                                                                                     }
ldap ldif f file ldif open url ldap p ldap const char urlstr  {
           }
ldap ldif f int ldif fetch url ldap p ldap const char line char value ber len t vlen ldap ldif f char ldif getline ldap p char next ldap ldif f int ldif countlines  {
	                        consilient :: 12
	                         coastline :: 14
	                     courtlinesses :: 12
	                        courtlings :: 14
	                        cornelians :: 12
	                        columbines :: 12
	                        trucklines :: 12
	                         touchline :: 13
	                         countries :: 12
	                         countless :: 12
	                         countians :: 13
	                        touchlines :: 15
	                        coastlines :: 14
	                        counseling :: 12
	                        confluents :: 12
	                       courtliness :: 15
	                         courtlike :: 12
	                         courtling :: 12
	                          countian :: 12
	                          counties :: 12
	                       countersink :: 12
	                       countersign :: 12
	                        quinolines :: 12
	                        cobaltines :: 12
	                        crinolines :: 13
                                 }
ldap p ldap const char line ldif ropen  {
	  hoper :: 6
	  doper :: 6
	  coper :: 6
	  copen :: 7
	 rowens :: 6
	 rouens :: 6
	 roping :: 6
	 rodent :: 6
	reponed :: 6
	 ripens :: 6
	 orpine :: 6
	 repone :: 7
	 repent :: 6
	 copens :: 6
	  toper :: 6
	   rope :: 8
	   rone :: 7
	   pore :: 6
	   pone :: 6
	   nope :: 7
	  rowen :: 7
	  roven :: 7
	  rouen :: 7
	  ropey :: 7
	  ropes :: 7
	  roper :: 6
	  roped :: 7
	  rones :: 6
	  ripen :: 7
	  repin :: 6
	  nopes :: 6
	ropiness :: 6
	  moper :: 6
	  loper :: 6
      }
rclose  {
	caloyers :: 7
	scrobe :: 7
	scorse :: 7
	sclere :: 7
	coles :: 7
	ceros :: 7
	scroyle :: 7
	scrowle :: 7
	relocks :: 8
	coloreds :: 7
	colorers :: 7
	scowler :: 7
	creoles :: 7
	scolder :: 7
	resole :: 7
	colures :: 7
	relock :: 7
	solacer :: 7
	recoils :: 7
	recoals :: 7
	splore :: 7
	roles :: 8
	orles :: 7
 }
read record just for reading ldif files no special open close needed to write ldif files typedef struct ldiffp  {
                 }
file fp struct ldiffp prev ldiffp ldap ldif f ldiffp ldif open ldap p ldap const char file ldap const char mode ldap ldif f void ldif close ldap p ldiffp ldap ldif f int ldif read record ldap p ldiffp fp int lineno char bufp int buflen ldap ldif f int ldif must b encode register ldap p ldap const char name ldap const char oid ldap ldif f void ldif must b encode release ldap p void define ldif put novalue  {
	                                                                          unvalued :: 9
	                                                                          novalike :: 9
	                                                                        novaculite :: 9
	                                                                             novel :: 9
	                                                                             novae :: 9
                                                                                 }
x no value define ldif put value x value w auto detection define ldif put text x assume text define ldif put binary x assume binary convert to base define ldif put b x pre converted base value define ldif put comment x comment define ldif put url x url define ldif put sep x separator ldap ldif f void ldif sput  {
	                                                        stupe :: 5
	                                                        stupa :: 5
	                                                        stump :: 5
	                                                         spur :: 5
	                                                         spun :: 5
	                                                         spue :: 5
	                                                         spud :: 5
	                                                         spot :: 5
	                                                         spit :: 5
	                                                         spet :: 5
	                                                         spat :: 5
	                                                         smut :: 5
	                                                         slut :: 5
	                                                        sputa :: 7
	                                                        spurt :: 6
	                                                         shut :: 5
	                                                         scut :: 5
	                                                        spout :: 5
	                                                         saut :: 5
	                                                       sputum :: 5
	                                                      sputnik :: 5
	                                                        pouts :: 5
                                                            }
ldap p char out int type ldap const char name ldap const char val ber len t vlen ldap ldif f void ldif sput wrap ldap p char out int type ldap const char name ldap const char val ber len t vlen ber len t wrap ldap ldif f char ldif put ldap p int type ldap const char name ldap const char val ber len t vlen ldap ldif f char ldif put wrap ldap p int type ldap const char name ldap const char val ber len t vlen ber len t wrap ldap ldif f int ldif is not printable ldap p ldap const char val ber len t vlen ldap end decl endif ldif h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef libgen  {
	                                                                                                                                                                                                                                                         gilden :: 7
	                                                                                                                                                                                                                                                         giblet :: 7
	                                                                                                                                                                                                                                                         leggin :: 7
	                                                                                                                                                                                                                                                         zingel :: 7
	                                                                                                                                                                                                                                                         biogen :: 8
	                                                                                                                                                                                                                                                         bingle :: 8
	                                                                                                                                                                                                                                                         binges :: 7
	                                                                                                                                                                                                                                                         binger :: 7
	                                                                                                                                                                                                                                                         binged :: 7
	                                                                                                                                                                                                                                                         bilges :: 7
	                                                                                                                                                                                                                                                         bilged :: 7
	                                                                                                                                                                                                                                                        libkens :: 8
	                                                                                                                                                                                                                                                          gibel :: 7
	                                                                                                                                                                                                                                                          binge :: 8
	                                                                                                                                                                                                                                                          bilge :: 8
	                                                                                                                                                                                                                                                        biogeny :: 7
	                                                                                                                                                                                                                                                        biogens :: 7
	                                                                                                                                                                                                                                                        bingles :: 7
	                                                                                                                                                                                                                                                           ling :: 7
	                                                                                                                                                                                                                                                        lingers :: 7
	                                                                                                                                                                                                                                                         linger :: 8
	                                                                                                                                                                                                                                                         lingel :: 7
	                                                                                                                                                                                                                                                         libken :: 9
	                                                                                                                                                                                                                                                          ligne :: 8
	                                                                                                                                                                                                                                                          liege :: 7
                                                                                                                                                                                                                                                              }
h define libgen h include features h begin decls return directory part of path or if none is available extern char dirname  {
	              mirbane :: 9
	             dairymen :: 9
	               dirham :: 9
	               airned :: 9
	             misnamed :: 9
	             surnamed :: 9
                    }
char path throw return final component of path this is the weird  {
	      weird :: -1000
          }
xpg version of this function it sometimes will modify its argument therefore we normally use the gnu version in string h and only if this header is included make the xpg version available under the real name extern char xpg basename  {
	                                 baseman :: 11
	                                namesake :: 10
                                       }
char path throw define basename xpg basename end decls endif libgen h message catalogs  {
	     catalogs :: -1000
            }
for internationalization copyright c free software foundation inc this file is part of the gnu c library this file is derived from the file libgettext h in the gnu gettext package the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef libintl  {
                                                                                                                                                      }
h define libintl h include features h we define an additional symbol to signal that we use the gnu implementation of gettext define use gnu gettext provide information about the supported file formats returns the maximum minor revision number supported for a given major revision define gnu gettext supported revision major major begin decls look up msgid in the current default message catalog for the current lc messages locale if not found returns msgid itself the default text extern char gettext const char msgid throw attribute format arg look up msgid in the domainname  {
                                                                                            }
message catalog for the current lc messages locale extern char dgettext  {
         }
const char domainname const char msgid throw attribute format arg extern char dgettext const char domainname const char msgid throw attribute format arg look up msgid in the domainname message catalog for the current category locale extern char dcgettext  {
                                     }
const char domainname const char msgid int category throw attribute format arg extern char dcgettext const char domainname const char msgid int category throw attribute format arg similar to gettext but select the plural form corresponding to the number n extern char ngettext  {
                                         }
const char msgid const char msgid unsigned long int n throw attribute format arg attribute format arg similar to dgettext but select the plural form corresponding to the number n extern char dngettext  {
                               }
const char domainname const char msgid const char msgid unsigned long int n throw attribute format arg attribute format arg similar to dcgettext but select the plural form corresponding to the number n extern char dcngettext  {
                                  }
const char domainname const char msgid const char msgid unsigned long int n int category throw attribute format arg attribute format arg set the current default message catalog to domainname if domainname is null return the current default if domainname is reset to the default of messages extern char textdomain  {
                                                }
const char domainname throw specify that the domainname message catalog will be found in dirname rather than in the system locale data base extern char bindtextdomain  {
                        }
const char domainname const char dirname throw specify the character encoding in which the messages from the domainname message catalog will be returned extern char bind textdomain codeset const char domainname const char codeset throw optimized version of the function above if defined optimize defined cplusplus we need null for gettext define need null include stddef h we need lc messages for dgettext include locale h these must be macros inlined  {
	                                                               indigen :: 9
	                                                                unline :: 9
	                                                                inline :: 12
	                                                                ingine :: 9
	                                                               unlined :: 11
                                                                     }
functions are useless because the builtin constant p predicate  {
	predicate :: -1000
       }
in dcgettext would always return false define gettext msgid dgettext null msgid define dgettext domainname msgid dcgettext domainname msgid lc messages define ngettext msgid msgid n dngettext null msgid msgid n define dngettext domainname msgid msgid n dcngettext domainname msgid msgid n lc messages endif optimizing end decls endif libintl h copyright c free software foundation inc this file is part of the gnu c library written by per bothner  {
	                                                              bothers :: 9
	                                                              botcher :: 10
	                                                             bethorns :: 9
	                                                              bethorn :: 10
	                                                             botchery :: 9
	                                                              notcher :: 9
	                                                               nother :: 9
	                                                               bothie :: 9
	                                                               bother :: 10
	                                                            bothering :: 9
                                                                    }
bothner cygnus com the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa as a special exception if you link the code in this file with files compiled with a gnu compiler to produce an executable that does not cause the resulting executable to be covered by the gnu lesser general public license this exception does not however invalidate  {
	                                                                                                                                                             invalidate :: -1000
                                                                                                                                                                      }
any other reasons why the executable file might be covered by the gnu lesser general public license this exception applies to code released by its copyright holders in files containing the exception ifndef io stdio h define io stdio h include g config h all of these should be defined in g config h define io pos t g fpos t obsolete define io fpos t g fpos t define io fpos t g fpos t define io size t g size t define io ssize t g ssize t define io off t g off t define io off t g off t define io pid t g pid t define io uid t g uid t define io iconv t g iconv t define io have sys wait g have sys wait define io have st blksize g have st blksize define io bufsiz g bufsiz define io va list g va list define io wint t g wint t ifdef g need stdarg h this define avoids  {
	                                                                                                                                                                   avoids :: -1000
                                                                                                                                                                        }
name pollution if we re using gnu stdarg h define need va list include stdarg h ifdef gnuc va list undef io va list define io va list gnuc va list endif gnuc va list endif ifndef p if g have sys cdefs include sys cdefs h else ifdef stdc define p p p define pmt  {
	                                                    put :: 3
	                                                    pst :: 3
	                                                    pot :: 3
	                                                    pit :: 3
	                                                    pht :: 3
	                                                    pet :: 3
	                                                    pat :: 3
                                                      }
p p else define p p define pmt p endif endif endif p for backward compatibility ifndef params define params protos p protos endif params ifndef stdc ifndef const define const endif endif define io unified jumptables  {
	                           temptable :: 12
	                           imputable :: 12
	                            jumpable :: 12
                                   }
ifndef g have printf fp define io use dtoa  {
	   dotal :: 5
	   diota :: 5
	   troad :: 5
	    stoa :: 5
	    doat :: 5
	    dato :: 5
       }
endif ifndef eof define eof endif ifndef null if defined gnug  {
	 overparts :: -1000
         }
gnuc gnuc gnuc minor define null null else if defined cplusplus define null void else define null endif endif endif define ios input define ios output define ios atend  {
	                      atoned :: 7
	                       atone :: 6
	                       anted :: 7
	                       anent :: 6
	                       ament :: 6
	                       amend :: 7
	                       agent :: 6
	                      amends :: 6
	                      stends :: 6
	                     standee :: 6
	                     stander :: 6
	                      staned :: 6
	                       trend :: 6
	                       stend :: 7
	                       stead :: 6
	                       stand :: 6
	                         ate :: 6
                           }
define ios append define ios trunc define ios nocreate  {
	recreate :: 10
	decorate :: 10
	overeaten :: 10
	cocreate :: 13
	nucleate :: 10
	corelate :: 10
	notecase :: 10
	croceate :: 10
	uncreated :: 11
	uncreates :: 11
	cocreated :: 12
	cocreates :: 12
	contrate :: 10
	recreation :: 10
	coelentera :: 10
	courante :: 10
	increate :: 12
	uncreate :: 12
	conepate :: 10
       }
define ios noreplace  {
	aeroplane :: 12
	percolate :: 11
	foreplan :: 11
	fireplace :: 12
	tolerance :: 11
	porcelain :: 11
	workplaces :: 11
	fireplaces :: 11
	fireplaced :: 11
	someplace :: 12
	overplaced :: 11
	workplace :: 12
	aeroplanes :: 11
 }
define ios bin magic numbers and bits for the flags field the magic numbers use the high order bits of flags the remaining bits are available for variable flags note the magic numbers must all be negative if stdio emulation is desired define io magic xfbad  {
                                            }
magic number define old stdio magic xfabc  {
     }
emulate old stdio define io magic mask xffff define io user buf user owns  {
	         owns :: -1000
            }
buffer don t delete it on close define io unbuffered  {
	unbuffered :: -1000
        }
define io no reads reading not allowed define io no writes writing not allowd  {
	      alloyed :: 7
	      allowed :: 10
	        alloy :: 7
	        allow :: 10
	        allot :: 7
	        allod :: 9
	        aldol :: 8
	        aglow :: 7
	        ablow :: 7
	       allods :: 8
	       aldols :: 7
	     allowing :: 7
            }
define io eof seen x define io err seen x define io delete dont close x don t call close fileno on cleanup  {
	               cleanup :: -1000
                     }
define io linked x set if linked using chain to streambuf  {
	   streamy :: 11
	 streambed :: 11
	    stream :: 12
         }
list all define io in backup  {
	backup :: -1000
    }
x define io line buf x define io tied  {
	    tied :: -1000
       }
put get x set if put and get pointer logicly  {
	  logical :: 10
	logically :: 9
	    yogic :: 9
	   logily :: 10
	    logic :: 9
        }
tied define io currently putting x define io is appending  {
	appending :: -1000
        }
x define io is filebuf  {
   }
x define io bad seen x define io user lock x define io flags mmap define io flags notcancel ifdef libc define io flags fortify endif define io flags user wbuf  {
                             }
ifdef libc define io flags scanf std define io flags noclose  {
	   inclose :: 10
	   console :: 10
	  consoles :: 9
	  consoler :: 9
	  consoled :: 9
	    locoes :: 9
	   enclose :: 10
	   unclose :: 10
	  enclosed :: 9
	  incloser :: 9
	  inclosed :: 9
	  unclosed :: 9
         }
define io flags cloexec  {
  }
endif these are formatting flags matching the iostream fmtflags  {
       }
enum values define io skipws  {
	swipes :: 8
	swinks :: 7
	skis :: 7
	skip :: 7
	spiks :: 7
	skips :: 9
	spinks :: 7
	spikes :: 7
	spicks :: 7
   }
define io left define io right define io internal define io dec define io oct define io hex define io showbase  {
	           showcased :: 12
	           showcases :: 10
	             showers :: 10
	            showcase :: 13
	            showable :: 10
	          showbreads :: 11
                   }
define io showpoint  {
	shopworn :: 11
 }
define io uppercase define io showpos  {
	whoops :: 9
	swoops :: 9
    }
define io scientific  {
	scientific :: -1000
 }
define io fixed define io unitbuf  {
    }
define io stdio define io dont close define io boolalpha  {
        }
struct io jump t struct io file handle lock ifdef io mtsafe  {
	  tuggingly :: -1000
          }
io if defined glibc glibc include bits stdio lock h else include comthread  {
	    compared :: 11
	     comrade :: 11
	   comparted :: 12
	 camphorated :: 11
           }
h endif else typedef void io lock t endif a streammarker  {
         }
remembers  {
	remembers :: -1000
 }
a position in a buffer struct io marker struct io marker next struct io file sbuf  {
              }
if pos it points to buf gbase  {
	gambes :: 6
	gables :: 6
	gabies :: 6
	 blase :: 6
	 abuse :: 6
	 abase :: 7
	abaser :: 6
	abased :: 6
	  gaes :: 6
	  gabs :: 6
	grabens :: 6
     }
pos fixme comment if pos it points to buf ebptr  {
        }
pos fixme comment int pos if void set streampos  {
	 stroams :: 12
	restamps :: 11
	 streams :: 13
	  stream :: 11
       }
streampos sp spos  {
	styptical :: -1000
 }
sp void set offset int offset pos offset spos streampos public streammarker streambuf sb streammarker int saving return spos int delta streammarker int delta endif this is the structure from the libstdc  {
	                       lobstick :: 9
                              }
codecvt  {
	codec :: 10
	codecs :: 9
 }
class enum codecvt result codecvt ok codecvt partial codecvt error codecvt noconv if defined libc defined glibcpp use wchar t the order of the elements in the following struct must match the order of the virtual functions in the libstdc codecvt class struct io codecvt void codecvt destr struct io codecvt enum codecvt result codecvt do out struct io codecvt mbstate t const wchar t const wchar t const wchar t char char char enum codecvt result codecvt do unshift  {
	                                                                        unshift :: -1000
                                                                              }
struct io codecvt mbstate t char char char enum codecvt result codecvt do in struct io codecvt mbstate t const char const char const char wchar t wchar t wchar t int codecvt do encoding struct io codecvt int codecvt do always noconv struct io codecvt int codecvt do length struct io codecvt mbstate t const char const char io size t int codecvt do max length struct io codecvt io iconv t cd in io iconv t cd out extra data for wide character streams struct io wide data wchar t io read ptr current read pointer wchar t io read end end of get area wchar t io read base start of putback  {
	                                                                                                           subtack :: 9
	                                                                                                          cutbanks :: 9
	                                                                                                          cutbacks :: 10
	                                                                                                          outbacks :: 10
	                                                                                                         outbacker :: 9
	                                                                                                           outback :: 11
                                                                                                                 }
get area wchar t io write base start of put area wchar t io write ptr current put pointer wchar t io write end end of put area wchar t io buf base start of reserve area wchar t io buf end end of reserve area the following fields are used to support backing up and undo  {
	                                                    undo :: -1000
                                                       }
wchar t io save base pointer to start of non current get area wchar t io backup base pointer to first valid character of backup area wchar t io save end pointer to end of non current get area mbstate t io state mbstate t io last state struct io codecvt codecvt wchar t shortbuf  {
	                                                 short :: 10
                                                     }
const struct io jump t wide vtable endif struct io file int flags high order word is io magic rest is flags define io file flags flags the following pointers correspond to the c streambuf protocol note tk  {
	                                  tsk :: 2
	                                    t :: 2
                                    }
uses the io read ptr and io read end fields directly char io read ptr current read pointer char io read end end of get area char io read base start of putback get area char io write base start of put area char io write ptr current put pointer char io write end end of put area char io buf base start of reserve area char io buf end end of reserve area the following fields are used to support backing up and undo char io save base pointer to start of non current get area char io backup base pointer to first valid character of backup area char io save end pointer to end of non current get area struct io marker markers struct io file chain int fileno if int blksize else int flags endif io off t old offset this used to be offset but it s too small define have column temporary column number of pbase  {
	                                                                                                                                                           blase :: 6
	                                                                                                                                                           abuse :: 6
	                                                                                                                                                           abase :: 7
	                                                                                                                                                          phased :: 6
	                                                                                                                                                          peasen :: 6
	                                                                                                                                                          peased :: 6
	                                                                                                                                                          abaser :: 6
	                                                                                                                                                          abased :: 6
	                                                                                                                                                            peas :: 7
	                                                                                                                                                           prase :: 7
	                                                                                                                                                           phase :: 7
	                                                                                                                                                           pease :: 7
	                                                                                                                                                           pebas :: 6
	                                                                                                                                                           pause :: 6
	                                                                                                                                                           passe :: 6
	                                                                                                                                                           parse :: 6
                                                                                                                                                               }
is unknown unsigned short cur column signed char vtable offset char shortbuf char save gptr  {
             }
char save egptr  {
 }
io lock t lock ifdef io use old io file struct io file complete struct io file file endif if defined g io io file version g io io file version x io off t offset if defined libc defined glibcpp use wchar t wide character stream stuff struct io codecvt codecvt struct io wide data wide data struct io file freeres  {
	                                                      reveres :: 9
	                                                       freers :: 9
	                                                      freezes :: 10
	                                                      freezer :: 10
	                                                     freezers :: 11
	                                                    freebaser :: 10
	                                                      fleerer :: 9
                                                            }
list void freeres buf size t freeres size else void pad void pad void pad void pad size t pad endif int mode make sure we don t get into trouble  {
	                       trouble :: -1000
                             }
again char unused sizeof int sizeof void sizeof size t endif ifndef cplusplus typedef struct io file io file endif struct io file plus extern struct io file plus io stdin extern struct io file plus io stdout extern struct io file plus io stderr ifndef libc define io stdin io file io stdin define io stdout io file io stdout define io stderr io file io stderr else extern io file io stdin attribute hidden extern io file io stdout attribute hidden extern io file io stderr attribute hidden endif functions to do i o and file management for a stream read nbytes bytes from cookie into a buffer pointed to by buf return number of bytes read typedef ssize t io read fn void cookie char buf size t nbytes write n bytes pointed to by buf to cookie write all n bytes unless there is an error return number of bytes written or if there is an error without writing anything if the file has been opened for append mode append set then set the file pointer to the end of the file and then do the write if not just write at the current file pointer typedef ssize t io write fn void cookie const char buf size t n move cookie s file position to pos bytes from the beginning of the file if w is seek set the current position if w is seek cur or the end of the file if w is seek end set pos to the new file position returns zero if successful nonzero if not typedef int io seek fn void cookie io off t pos int w close cookie typedef int io close fn void cookie ifdef gnu source user visible names for the above typedef io read fn cookie read function t typedef io write fn cookie write function t typedef io seek fn cookie seek function t typedef io close fn cookie close function t the structure with the cookie function pointers typedef struct io read fn read read bytes io write fn write write bytes io seek fn seek seek tell file position io close fn close close file io cookie io functions t typedef io cookie io functions t cookie io functions t struct io cookie file initialize one of those extern void io cookie init struct io cookie file cfile int read write void cookie io cookie io functions t fns endif ifdef cplusplus extern c endif extern int underflow io file extern int uflow  {
                                                                                                                                                                                                                                                                                                                                                                                                                                    }
io file extern int overflow io file int if defined libc defined glibcpp use wchar t extern io wint t wunderflow  {
	         wonderfully :: 12
	           wonderful :: 14
                   }
io file extern io wint t wuflow  {
	upflow :: 8
	upflows :: 7
     }
io file extern io wint t woverflow  {
     }
io file io wint t endif if gnuc define io be expr res builtin expect expr res else define io be expr res expr endif define io getc unlocked fp io be fp io read ptr fp io read end uflow fp unsigned char fp io read ptr define io peekc  {
	                                           peckier :: 6
	                                           peckers :: 6
	                                            pecker :: 7
	                                            pecked :: 7
	                                              peke :: 6
	                                              peek :: 8
	                                              peck :: 6
	                                              keep :: 6
	                                               pee :: 6
                                                 }
unlocked fp io be fp io read ptr fp io read end underflow fp eof eof unsigned char fp io read ptr define io putc unlocked ch fp io be fp io write ptr fp io write end overflow fp unsigned char ch unsigned char fp io write ptr ch if defined libc defined glibcpp use wchar t define io getwc  {
	                                                         get :: 6
                                                           }
unlocked fp io be fp wide data null fp wide data io read ptr fp wide data io read end wuflow fp io wint t fp wide data io read ptr define io putwc  {
	                           putsch :: 6
	                              put :: 6
                                }
unlocked wch fp io be fp wide data null fp wide data io write ptr fp wide data io write end woverflow fp wch io wint t fp wide data io write ptr wch endif define io feof  {
	                                reffo :: 5
                                    }
unlocked fp fp flags io eof seen define io ferror  {
	ferroprint :: 7
	  fervors :: 7
	  ferrara :: 8
	   fervor :: 8
	   terror :: 9
	 furrower :: 8
	  terrors :: 8
	terrorful :: 8
	furrowers :: 7
	 forrader :: 7
        }
unlocked fp fp flags io err seen extern int io getc io file fp extern int io putc int c io file fp extern int io feof io file fp throw extern int io ferror io file fp throw extern int io peekc locked io file fp this one is for emacs define io pending  {
	                                               pending :: -1000
                                                     }
output count fp fp io write ptr fp io write base extern void io flockfile  {
             }
io file throw extern void io funlockfile  {
     }
io file throw extern int io ftrylockfile  {
     }
io file throw ifdef io mtsafe io define io peekc fp io peekc locked fp define io flockfile fp if fp flags io user lock io flockfile fp define io funlockfile fp if fp flags io user lock io funlockfile fp else define io peekc fp io peekc unlocked fp define io flockfile fp define io funlockfile fp define io ftrylockfile fp define io cleanup region start fct fp define io cleanup region end doit  {
	                                                                      doit :: -1000
                                                                         }
endif io mtsafe io extern int io vfscanf  {
	assayer :: -1000
      }
io file restrict const char restrict io va list int restrict extern int io vfprintf  {
             }
io file restrict const char restrict io va list extern io ssize t io padn  {
	        pawned :: 5
	        panned :: 5
	        pained :: 5
	        padnag :: 5
	          pawn :: 5
	          pand :: 6
	          pain :: 5
	          pads :: 5
	          padi :: 5
	         pandy :: 5
	         paned :: 5
	         pands :: 5
	           pan :: 5
	           pad :: 6
             }
io file int io ssize t extern io size t io sgetn  {
	      gents :: 6
	     agents :: 6
	     thegns :: 6
	      stern :: 6
	      stean :: 6
	       sten :: 6
	       sent :: 6
          }
io file void io size t extern io off t io seekoff  {
          }
io file io off t int int extern io off t io seekpos  {
	    seedpods :: 9
	     sheepos :: 9
	       seeks :: 9
           }
io file io off t int extern void io free backup area io file throw if defined libc defined glibcpp use wchar t extern io wint t io getwc io file fp extern io wint t io putwc wchar t wc io file fp extern int io fwide  {
	                                          dwine :: 6
	                                         waifed :: 6
                                              }
io file fp int mode throw if gnuc while compiling glibc we have to handle compatibility with very old versions if defined libc defined shared include shlib compat h if shlib compat libc glibc glibc define io fwide maybe incompatible builtin expect io stdin used null extern const int io stdin used weak extern io stdin used endif endif ifndef io fwide maybe incompatible define io fwide maybe incompatible endif a special optimized version of the function above it optimizes  {
	                                                                      optimizes :: -1000
                                                                              }
the case of initializing an unoriented  {
	reanointed :: 12
	uninvested :: 12
	unordained :: 12
	unprisoned :: 12
	undertoned :: 12
	unresented :: 13
	unparented :: 13
	undertone :: 12
	undernote :: 13
	reoriented :: 14
	undernotes :: 12
	undernoted :: 13
	unfriended :: 14
	unrepented :: 13
	uninfected :: 12
	unpriested :: 13
    }
byte stream define io fwide fp mode int result mode if result io fwide maybe incompatible if fp mode we know that all we have to do is to set the flag fp mode result fp mode else if builtin constant p mode mode result io fwide maybe incompatible fp mode else result io fwide fp result result endif extern int io vfwscanf  {
                                                             }
io file restrict const wchar t restrict io va list int restrict extern int io vfwprintf  {
	       offprint :: 12
	      offprints :: 11
              }
io file restrict const wchar t restrict io va list extern io ssize t io wpadn  {
	        spawned :: 6
	           wand :: 6
	          spawn :: 6
              }
io file wint t io ssize t extern void io free wbackup  {
          }
area io file throw endif ifdef ldbl compat include bits libio ldbl h endif ifdef cplusplus endif endif io stdio h project libmng  {
	                leming :: 7
	                laming :: 7
	               lobings :: 7
	                lobing :: 8
	                liming :: 7
                     }
file libmng conf h copyright c g juyn  {
	  junky :: 5
      }
version purpose main configuration file author g juyn comment the configuration file change this to include exclude the options you want or do not want in libmng changes g juyn separated configuration options into this file changed to most likely configuration g juyn changed options to create a standard so library with everything enabled g juyn changed options to create a standard win dll with everything enabled g juyn changed file prefixes  {
	                                                               prefixes :: -1000
                                                                      }
g juyn added workaround for faulty  {
	faulty :: -1000
    }
photoshop  {
	lewissons :: -1000
 }
iccp chunk g juyn removed trace options from default so dll builds  {
	     builds :: -1000
          }
g juyn b returned ijgsrc  {
	tuskars :: -1000
   }
b calling convention to default for msvc g juyn added event handling for dynamic mng  {
	         ungum :: 3
	          mung :: 3
	          mong :: 3
	          ming :: 3
	          meng :: 3
	          mang :: 3
	           mug :: 3
	           mog :: 3
	           mna :: 3
	           mig :: 3
	           mag :: 3
	           eng :: 3
             }
added supports call to check function availability g r p added mng no include jng  {
	           jog :: 3
	           jig :: 3
	           jag :: 3
	           eng :: 3
             }
conditional added mng skipchunk  {
  }
evnt  {
	vents :: 5
	vent :: 6
 }
conditional g r p added mng no support funcquery  {
       }
conditional g r p added mng version query support conditional g juyn clearified  {
	  classifier :: 12
	  classified :: 13
	  repacified :: 14
	     cleared :: 12
           }
mng bigendian supported conditional added mng littleendian  {
     }
supported conditional if defined borlandc defined mng strict ansi pragma  {
	 pomology :: -1000
        }
option a force ansi c endif ifndef libmng conf h define libmng conf h ifdef mng mozilla  {
	        zorillas :: 9
	         zorilla :: 10
               }
cfg  {
	cog :: 3
	cig :: 3
 }
include special mozcfg  {
 }
mozlibmngconf  {
 }
h endif user selectable compile time options enable exactly one of the mng sub set selectors  {
	      selectors :: -1000
              }
use this to select which sub set of the mng specification you wish to support generally you ll want full support as the library provides it automatically for you if you re really strung  {
	                           strung :: -1000
                                }
on memory requirements  {
	requirements :: -1000
 }
you can opt to enable less support but it s just not a good idea note that this isn t actually implemented yet if defined mng support full defined mng support lc defined mng support vlc  {
	                              local :: -1000
                                  }
define mng support full define mng support lc define mng support vlc endif enable jpeg support if required use this to enable the jng support routines this requires an external jpeg package currently only ijg s jpgsrc  {
                                   }
b is supported note that the ijg code can be either or bit eg not both so choose the one you ve defined in jconfig h if you don t know what the heck  {
	                             heck :: -1000
                                }
i m talking  {
	talking :: -1000
 }
about just leave it at bit support thank you ifndef mng no include jng ifdef mng support full full support includes jng define mng support ijg b endif ifndef mng support ijg b if defined mng build so defined mng use so defined mng build dll defined mng use dll define mng support ijg b endif endif if defined mng support ijg b defined mng support jpeg defined mng support jpeg define mng support jpeg define mng support jpeg endif the following is required to export the ijg routines from the dll in the windows standard calling convention currently this only works for borland c if defined mng build dll defined mng use dll if defined mng support ijg b defined borlandc define mng define jpeg stdcall endif endif endif enable required high level functions use this to select the high level functions you require if you only need to display a mng disable write support if you only need to examine a mng disable write display support if you only need to copy a mng disable display support if you only need to create a mng disable read display support note that turning  {
	                                                                                                                                                                                          turning :: -1000
                                                                                                                                                                                                }
all options off will be very unuseful  {
	unuseful :: -1000
     }
if defined mng support read defined mng support write defined mng support display define mng support read if defined mng build so defined mng use so defined mng build dll defined mng use dll define mng support write endif define mng support display endif enable chunk access functions use this to select whether you need access to the individual chunks  {
	                                                     chunks :: -1000
                                                          }
useful if you want to examine a read mng you ll also need mng store chunks required if you need to create write a new mng ifndef mng access chunks if defined mng build so defined mng use so defined mng build dll defined mng use dll define mng access chunks endif endif enable exactly one of the color management functionality selectors use this to select the level of automatic color support mng full cms requires the lcms little cms external package if you want your own app or the os to handle color management select mng app cms define mng gamma only define mng full cms define mng app cms enable automatic dithering use this if you need dithering support to convert high resolution images to a low resolution output device note that this is not supported yet define mng auto dither enable whether chunks should be stored for reference later use this if you need to examine the chunks of a mng you have read or re write a mng you have read turn this off if you want to reduce memory consumption  {
	                                                                                                                                                                             consumption :: -1000
                                                                                                                                                                                       }
ifndef mng store chunks if defined mng build so defined mng use so defined mng build dll defined mng use dll define mng store chunks endif endif enable internal memory management if your compiler supports it use this if your compiler supports the standard memory functions calloc free and you want the library to use these functions and not bother  {
	                                                     bother :: -1000
                                                          }
your app with memory callbacks define mng internal memmngmt  {
       }
enable internal tracing  {
	tracing :: -1000
 }
functionality manual debugging purposes use this if you have trouble location bugs or problems note that you ll need to specify the trace callback function define mng support trace enable extended error and trace telltaling  {
	                          telltale :: 12
                                 }
use this if you need explanatory messages with errors and or tracing if defined mng error telltale  {
	        telltale :: -1000
               }
defined mng trace telltale if defined mng build so defined mng use so defined mng build dll defined mng use dll define mng error telltale define mng trace telltale endif endif enable big little endian optimizations enable big if you re on an architecture that supports big endian reads and writes that aren t word aligned according to reliable sources this only works for powerpc bigendian mode and x enable little if you re on an architecture that supports little endian when in doubt leave both off define mng bigendian supported define mng littleendian supported enable version functions if defined mng version query support defined mng no version query support define mng version query support endif enable supports function use this if you need to query the availability of functions at runtime useful for apps  {
	                                                                                                                                appuys :: 5
	                                                                                                                                appuis :: 5
	                                                                                                                                appose :: 5
	                                                                                                                                apples :: 5
	                                                                                                                                appels :: 5
	                                                                                                                                  paps :: 6
	                                                                                                                                  asps :: 5
	                                                                                                                                  amps :: 5
	                                                                                                                                  alps :: 5
                                                                                                                                     }
that dynamically load the library and that need specific functions if defined mng no support funcquery defined mng support funcquery if defined mng build so defined mng use so defined mng build dll defined mng use dll define mng support funcquery endif endif enable dynamic mng features use this if you would like to have dynamic support for specifically designed mngs  {
	                                                        mugs :: 5
	                                                        mogs :: 5
	                                                        mnas :: 5
	                                                        migs :: 5
	                                                        mags :: 5
	                                                        engs :: 5
                                                           }
eg this is useful for rollover  {
	rollover :: -1000
    }
effects such as common on the world  {
	 world :: -1000
     }
wide web  {
	web :: -1000
 }
ifndef mng support dynamicmng  {
	dynamizing :: 12
	dynamic :: 12
	dynamiting :: 12
	dynamising :: 12
  }
if defined mng build so defined mng use so defined mng build dll defined mng use dll define mng support dynamicmng endif endif ifndef mng support dynamicmng ifndef mng skipchunk evnt define mng skipchunk evnt endif endif ifdef mng include jng ifndef mng no access jpeg ifndef mng access jpeg define mng access jpeg endif endif endif ifdef mng include zlib  {
	                                                       blitz :: 5
	                                                        glib :: 5
                                                           }
ifndef mng no access zlib ifndef mng access zlib define mng access zlib endif endif endif end of user selectable compile time options endif libmng conf h end of file copyright notice copyright c gerard  {
	                           rewards :: 7
	                             drear :: 7
	                          gerardia :: 9
	                             darer :: 7
	                           retards :: 7
	                            garred :: 9
	                           gnarred :: 7
	                         regarding :: 7
	                         rewarding :: 7
	                         regardful :: 7
	                            reward :: 8
	                            retard :: 8
	                           regards :: 9
	                         retarding :: 7
	                            grader :: 7
	                         gerardias :: 8
                                 }
juyn you may insert additional notices after this sentence if you modify this source for the purposes of this copyright and license contributing  {
	          contributing :: -1000
                     }
authors is defined as the following set of individuals  {
	individuals :: -1000
       }
gerard juyn gjuyn  {
	gju :: 6
 }
at users sourceforge  {
 }
net glenn  {
	blenny :: 6
	glens :: 6
	glean :: 7
	glen :: 7
	gleans :: 6
 }
randers  {
	ranters :: 11
	rankers :: 11
	rangers :: 11
	randies :: 9
	randier :: 9
	banders :: 11
	randems :: 10
	larders :: 10
	yarners :: 9
	lander :: 9
	landers :: 11
	raiders :: 11
	sander :: 11
	readorns :: 9
	gander :: 9
	carders :: 10
	zander :: 9
	bander :: 9
	sanders :: 11
	renders :: 11
	panders :: 11
	pander :: 9
	darner :: 9
	dander :: 9
	garners :: 9
	warners :: 9
	warders :: 10
	gardens :: 9
	wardens :: 9
	render :: 9
	zanders :: 11
	darters :: 9
	wander :: 9
	darners :: 11
	ganders :: 11
	wanders :: 11
	ranter :: 9
	ranker :: 9
	ranger :: 9
	raider :: 9
	dangers :: 10
	danders :: 11
	dancers :: 10
	damners :: 9
	hander :: 9
	hardens :: 9
	graders :: 9
	earners :: 9
	traders :: 9
	handers :: 11
 }
pehrson  {
	nephrons :: 9
 }
glennrp  {
 }
at users sourceforge net raphael  {
	raphae :: 12
   }
assenat  {
	assent :: 10
	assentator :: 9
	assonates :: 9
	assonated :: 11
	arsenates :: 9
	arsenate :: 9
	assonate :: 12
 }
raph at raphnet  {
	hairnet :: 9
	raptness :: 9
	panther :: 9
	daphne :: 9
	rapine :: 9
	raphe :: 9
 }
net john  {
	john :: -1000
 }
stiles  {
	stiles :: -1000
 }
the mng library is supplied as is the contributing authors disclaim all warranties expressed or implied including without limitation the warranties of merchantability and of fitness for any purpose the contributing authors assume no liability for direct indirect incidental special exemplary or consequential damages which may result from the use of the mng library even if advised of the possibility of such damage permission is hereby granted to use copy modify and distribute this source code or portions hereof  {
	                                                                        hereof :: -1000
                                                                             }
for any purpose without fee subject to the following restrictions the origin of this source code must not be misrepresented  {
	     misrepresented :: -1000
                  }
you must not claim that you wrote  {
	 wrote :: -1000
     }
the original software altered  {
	altered :: -1000
  }
versions must be plainly  {
	plainly :: -1000
  }
marked as such and must not be misrepresented as being the original source this copyright notice may not be removed or altered from any source or altered source distribution the contributing authors specifically permit without fee and encourage  {
	                            encourage :: -1000
                                    }
the use of this source code as a component to supporting the mng and jng file format in commercial  {
	        commercial :: -1000
                 }
products if you use this source code in a product acknowledgment  {
	acknowledgment :: -1000
         }
would be highly  {
	highly :: -1000
 }
appreciated  {
	appreciated :: -1000
 }
parts  {
	parts :: -1000
 }
of this software have been adapted from the libpng  {
	 lobings :: 7
	  loping :: 7
	  lobing :: 8
       }
package although this library supports all features from the png  {
	     pung :: 3
	     pong :: 3
	     ping :: 3
	     pang :: 3
	    pagan :: 3
	      pug :: 3
	      pig :: 3
	      peg :: 3
	      eng :: 3
        }
specification as mng descends  {
	descends :: -1000
  }
from it it does not require the libpng package it does require the zlib library and optionally the ijg jpeg library and or the little cms library by marti maria depending on the inclusion of support for jng and full color management respectively this library s function is primarily  {
	                                       primarily :: -1000
                                               }
to read and display mng animations  {
	animations :: -1000
    }
it is not meant  {
	meant :: -1000
  }
as a full featured  {
	featured :: -1000
  }
image editing  {
	editing :: -1000
 }
component it does however offer  {
	offer :: -1000
   }
creation and editing functionality at the chunk level future modifications may include some more support for creation and or editing version numbering  {
	            numbering :: -1000
                    }
x y z x release initial build y major version uneven  {
	    uneven :: -1000
         }
test even production  {
	production :: -1000
 }
z minor version bugfixes  {
	suffixes :: 10
	subfix :: 10
	subfixes :: 12
  }
is older than production versions only appear when a test version is extensively  {
	 extensively :: -1000
           }
tested and found stable or for intermediate bug fixes recognized by a change in the z number x x test version x x production version x x test version x x production version etc identifier naming conventions throughout this library ixxxx  {
                                       }
an integer dxxxx  {
 }
a float pxxxx  {
 }
a pointer bxxxx  {
 }
a boolean exxxx  {
	forhents :: -1000
 }
an enumeration hxxxx  {
 }
a handle zxxxx  {
 }
a zero terminated string pchar  {
	echard :: 6
	preach :: 6
	parch :: 6
   }
fxxxx  {
 }
a pointer to a function callback axxxx  {
     }
an array sxxxx  {
	pluralizing :: -1000
 }
a structure macros defines are in all uppercase functions typedefs in all lowercase exported stuff is prefixed with mng or mng respectively i may have missed  {
	                   missed :: -1000
                        }
a couple don t hesitate  {
	hesitate :: -1000
   }
to let me know project libmng file libmng h copyright c g juyn version purpose main application interface author g juyn comment the main application interface an application should not need access to any of the other modules changes g juyn changed chunk iteration function g juyn added chunk access functions added version control constants functions changed strict ansi stuff g juyn added set outputprofile set srgbprofile added empty chunk put routines g juyn added version dll version dll for consistency  {
	                                                                     consistency :: -1000
                                                                               }
added version control explanatory text samples g juyn added getimgdata  {
        }
putimgdata  {
 }
functions g juyn changed the version parameters obviously  {
	obviously :: -1000
      }
g juyn complimented  {
	complimented :: -1000
 }
constants for chunk property values g juyn fixed mng uint phyg  {
	collimates :: -1000
         }
value g juyn added support for get set default zlib ijg parms g juyn added mng bigendian support contributed by tim rowley  {
	               wurley :: 7
	               dowery :: 7
	              yowleys :: 8
	              yowlers :: 9
	              fowlers :: 7
	               rowels :: 7
	               fowler :: 8
	               owlery :: 7
	               yowley :: 9
	               yowler :: 10
	               yowled :: 8
	               yodler :: 7
	               towery :: 7
	               howler :: 8
	              jowlers :: 7
	               jowler :: 8
	               lowery :: 9
	                 yowl :: 7
	                sowle :: 7
	                rowel :: 8
	                roble :: 7
	               bowler :: 8
	               bowery :: 7
	              bowlers :: 7
	                lower :: 7
                    }
separated configuration options into mng conf h added rgb a canvasstyle  {
	  canvases :: 14
	 canvasser :: 14
	 canvassed :: 14
	   canvass :: 14
         }
added getalphaline  {
 }
callback for rgb a canvasstyle g juyn moved errorcodes  {
	prerecords :: 12
       }
from mng error h added mng read resume function to support read suspension g juyn changed the version parameters obviously g juyn added get set for speedtype  {
                         }
to facilitate  {
	facilitate :: -1000
 }
testing added get for imagelevel  {
   }
during processtext  {
	processed :: 14
 }
callback g juyn fixed inclusion of ijg read write code g juyn changed userdata variable to mng ptr g juyn changed refresh parameters to x y width height g juyn added mng needtimerwait  {
                               }
errorcode changed comments to indicate modified behavior for timer  {
	   timer :: -1000
       }
suspension breaks  {
	breaks :: -1000
 }
g juyn added get routines for internal display variables added get set routines for suspensionmode  {
	    suspension :: 18
             }
variable g juyn added callbacks for save seek processing added get set routines for sectionbreak  {
             }
variable added needsectionwait  {
 }
errorcode g juyn added function to set frame layer count playtime  {
	  playtime :: -1000
         }
added errorcode for updatemngheader  {
  }
if not a mng g juyn fixed problem with trace functions improperly  {
	 improperly :: -1000
          }
wrapped  {
	wrapped :: -1000
 }
added status xxxx  {
 }
functions g juyn changed file prefixes added function to set simplicity  {
	simplicity :: -1000
         }
field g juyn added check for simplicity bits in mhdr  {
        }
g juyn added workaround for faulty photoshop iccp chunk g juyn added magn  {
	     magnify :: 5
	     magneto :: 5
	     magnets :: 5
	      maungy :: 5
	      magnum :: 5
	      magnox :: 6
	      magnet :: 6
	      magnes :: 6
	        mawn :: 5
	        maun :: 5
	        mang :: 6
	        main :: 5
	        mags :: 5
	        magi :: 5
	       mangy :: 5
	       mangs :: 5
	       mango :: 5
	         nag :: 5
	         man :: 5
	         mag :: 6
           }
chunk g juyn added support for new filter types g juyn added support for alpha depth prediction g juyn fixed processing of unknown critical chunks removed test magn added png mng spec version indicators  {
	                       indicators :: -1000
                                }
added support for need g juyn added functions to retrieve png jng specific header info added jdaa  {
               }
chunk g juyn added callback to process non critical unknown chunks g juyn added errocode  {
	     crookeder :: 10
	     recolored :: 10
             }
for delayed  {
	delayed :: -1000
 }
delta processing added get set for bkgd  {
     }
preference  {
	stockpile :: -1000
 }
setting g juyn added get function for interlace  {
	interlace :: -1000
      }
progressive display g juyn added errorcode for magn methods removed test filter methods g juyn version numbers obviously g juyn added mend  {
	                 mend :: -1000
                    }
processing callback g juyn code by g kelly  {
	  kelly :: -1000
      }
added bgra canvas with premultiplied  {
   }
alpha g juyn added default srgb generation thanks marti g juyn added optimization option for mng video  {
	           video :: -1000
               }
playback  {
	playback :: -1000
 }
added processterm  {
	procreates :: 14
	protectress :: 14
 }
callback g juyn added late binding errorcode not used internally added option to turn off progressive refresh g juyn added get function for last processed back chunk g juyn added errorcode for extreme  {
	                         extreme :: -1000
                               }
chunk sizes g juyn added test option for png filter method no filter g juyn completed prom support completed delta image support g juyn added hlapi  {
	                  planish :: 6
	                   elapid :: 6
	                  happily :: 6
                        }
function to copy chunks g juyn added event handling for dynamic mng added supports call to check function availability g juyn fixed loop iteration special case g juyn added support for past g juyn added bgrx canvas filler  {
	                               filler :: -1000
                                    }
byte g juyn added check for term placement  {
	placement :: -1000
      }
during create write added beta version function constant g juyn added support to get totals  {
	        totals :: -1000
             }
after mng read g randers pehrson added support for reducing  {
	 reducing :: -1000
        }
the footprint  {
	footprint :: -1000
 }
of libmng by macros that optionally skip unused chunks remove bit sample support remove delta support and remove jng support to accomodate  {
	          accumulated :: 12
	         accommodated :: 12
	         accommodates :: 12
                    }
mozilla firebird  {
	firebird :: -1000
 }
g randers pehrson further optional removal of unused functions r a added canvas rgb and canvas bgr r a added canvas rgba and canvas bgra j s added premultiplied alpha canvas for rgba argb abgr g randers pehrson put gamma cms related declarations inside ifdef g r p added conditionals  {
	                                     conditionals :: -1000
                                                }
around openstream  {
	downstream :: 13
	treponemas :: 12
	operates :: 12
 }
closestream  {
 }
g juyn added crc existence checking flags g juyn added data push mechanisms  {
	   passivate :: -1000
           }
for specialized decoders g r p define mng include zlib when mng use zlib crc is defined g juyn added function to retrieve current fram delay g juyn added bgr a canvas style thanks to j elvander  {
	                            lavender :: 13
	                           levanters :: 10
	                            calender :: 10
	                            levanter :: 11
	                            levanted :: 10
	                            oleander :: 12
	                           oleanders :: 11
	                            expander :: 10
                                   }
g juyn fixed pplt  {
  }
getchunk  {
 }
putchunk  {
	putchuks :: 12
	putchuk :: 13
 }
routines thanks to w manthey  {
	manchet :: 10
	manchets :: 9
	mantle :: 9
	manche :: 9
	maneh :: 9
   }
added canvas rgb and canvas bgr g juyn added support for mpng  {
	       mung :: 5
	       mong :: 5
	       ming :: 5
	       meng :: 5
	       mang :: 5
          }
proposal  {
	proposal :: -1000
 }
g juyn added support for ang proposal if defined borlandc defined mng strict ansi pragma option a force ansi c endif ifndef libmng h define libmng h include libmng conf h user specific configuration options define mng check bad iccp let s catch that sucker  {
	                                      sucker :: -1000
                                           }
ifdef mng support read dependencies based on user configuration define mng include read procs  {
	        drops :: 6
	        crows :: 6
	        cross :: 6
	        crops :: 8
	        crocs :: 7
	        corps :: 6
	      prosect :: 6
	      prosaic :: 6
	      process :: 7
	       croups :: 6
	     proceeds :: 6
	         pros :: 7
	         crop :: 6
	        prows :: 7
	        prosy :: 6
	        prost :: 6
	        pross :: 7
	        prose :: 6
	        props :: 6
	        proos :: 6
	        proms :: 7
	        progs :: 7
	        profs :: 7
	        prods :: 7
	        proas :: 7
	        praos :: 6
	          pro :: 6
	       psoric :: 6
            }
endif ifdef mng support write define mng include write procs endif ifdef mng use zlib crc define mng include zlib endif ifdef mng support display define mng include filters define mng include interlace define mng include objects define mng include display procs define mng include timing  {
	                                       timing :: -1000
                                            }
procs define mng include zlib endif ifdef mng store chunks define mng include zlib endif ifdef mng support ijg b define mng include jng define mng include ijg b define mng use setjmp  {
	                         metumps :: 7
                               }
endif ifdef mng include jng if defined mng support display defined mng access chunks define mng include jng read endif if defined mng support write defined mng access chunks define mng include jng write endif endif ifdef mng full cms define mng include lcms endif ifdef mng auto dither define mng include dithering endif ifdef mng support trace define mng include trace procs ifdef mng trace telltale define mng include trace strings endif endif ifdef mng error telltale define mng include error strings endif ifdef mng optimize chunkinitfree  {
	                                                                             interphone :: -1000
                                                                                      }
ifndef mng optimize chunkaccess  {
  }
define mng optimize chunkaccess endif else ifdef mng optimize chunkaccess undef mng optimize chunkaccess endif endif include libmng types h platform specific definitions and other assorted  {
	                 assorted :: -1000
                        }
stuff ifdef cplusplus extern c endif versioning control version so and version dll will not reflect version major these will only change for binary incompatible changes which will hopefully never occur note they will be set to on the first public release first public release define mng version text define mng version so eg libmng so define mng version dll eg libmng dll define mng version major define mng version minor define mng version release bug fix cosmetics  {
	                                                                    cosmetics :: -1000
                                                                            }
define mng version text define mng version so eg libmng so define mng version dll eg libmng dll define mng version major define mng version minor define mng version release feature change define mng version text define mng version so eg libmng so define mng version dll eg libmng dll define mng version major define mng version minor define mng version release major rewrite still binary compatible define mng version text define mng version so eg libmng so define mng version dll eg libmng dll define mng version major define mng version minor define mng version release binary incompatible change define mng version text define mng version so eg libmng so define mng version dll eg libmng dll define mng version major define mng version minor define mng version release note that version so version dll will always remain equal so it doesn t matter which one is called to do version checking they are just provided for their target platform define mng version text define mng version so eg libmng so define mng version dll but libmng dll define mng version major define mng version minor define mng version release define mng version beta mng false mng ext mng pchar mng decl mng version text void mng ext mng uint mng decl mng version so void mng ext mng uint mng decl mng version dll void mng ext mng uint mng decl mng version major void mng ext mng uint mng decl mng version minor void mng ext mng uint mng decl mng version release void mng ext mng bool mng decl mng version beta void use the following call to check wether the version of libmng your app is using supports the given function this is useful in apps that dynamically load the library to make sure a certain function will work the result will be mng true if the given function is implemented in this version of the library major minor version indicate the version the function became  {
	                                                                                                                                                                                                                                                                                                                                    became :: -1000
                                                                                                                                                                                                                                                                                                                                         }
available if these fields are zero the function is not yet implemented ifdef mng support funcquery mng ext mng bool mng decl mng supports func mng pchar zfunction  {
	                 inunctions :: 11
	                  inunction :: 12
                          }
mng uint imajor  {
	imago :: 7
 }
mng uint iminor  {
	imino :: 10
	imine :: 7
	imido :: 7
	amino :: 7
	imploring :: 7
 }
mng uint irelease  {
	sealeries :: 10
 }
endif mng png specification level conformance define mng png version define mng png version maj define mng png version min define mng mng version define mng mng version maj define mng mng version min define mng mng draft deprecated only used for need mng draft nn  {
	                                          nun :: 2
	                                          non :: 2
	                                          nan :: 2
                                            }
high level application functions library initialization function must be the first called before anything can be done at all initializes internal datastructure  {
                    }
s mng ext mng handle mng decl mng initialize mng ptr puserdata  {
          }
mng memalloc fmemalloc  {
	gentilesses :: -1000
 }
mng memfree fmemfree  {
 }
mng traceproc  {
 }
ftraceproc  {
 }
library reset function can be used to re initialize the library so another image can be processed there s absolutely  {
	         absolutely :: -1000
                  }
no harm  {
	harm :: -1000
 }
in calling it even when it s not really necessary mng ext mng retcode  {
	      retched :: 9
	      cestode :: 9
	      precode :: 9
	      tetrode :: 10
	     tetrodes :: 9
	     vectored :: 9
	     sectored :: 9
	     hectored :: 9
	     retooled :: 9
            }
mng decl mng reset mng handle hhandle  {
	chandlery :: 9
	chandlers :: 9
	chandler :: 10
     }
library cleanup function must be the last called to clean up internal datastructure s mng ext mng retcode mng decl mng cleanup mng handle hhandle high level read functions use mng read if you simply want to read a network graphic mng read resume is used in i o read suspension scenarios  {
	                                          scenarios :: -1000
                                                  }
where the readdata  {
 }
callback may return false length indicating its buffer is depleted  {
	 depleted :: -1000
        }
or too short to supply the required bytes and the buffer needs to be refilled  {
	      refilled :: -1000
             }
libmng will return the errorcode mng needmoredata  {
	oxidic :: -1000
     }
telling the app to refill its read buffer after which it must call mng read resume or mng display resume if it also displaying  {
	             displaying :: -1000
                      }
the image simultaneously  {
	simultaneously :: -1000
 }
ifdef mng support read mng ext mng retcode mng decl mng read mng handle hhandle mng ext mng retcode mng decl mng read resume mng handle hhandle endif high level data push functions these functions can be used in situations where data is streaming  {
	                                  streaming :: -1000
                                          }
into the application and needs to be buffered by libmng before it is actually requested by libmng itself the pushing  {
	            pushing :: -1000
                  }
complements  {
	complements :: -1000
 }
the normal reading mechanism but applications can decide to always return bytes read to make libmng go into suspension mode with the returncode  {
	             recounter :: 12
	             recounted :: 12
	           recontoured :: 12
	              returned :: 14
                     }
mng needmoredata mng read pushdata  {
	electioneered :: -1000
   }
can be used to push blobs  {
	blobs :: -1000
    }
of data of arbitrary size mng read pushsig  {
	bushpig :: 9
	bushpigs :: 11
	  pughs :: 9
	pushing :: 9
      }
and mng read pushchunk  {
  }
can be used if the application has already done some low level decoding eg at the chunk level the data being pushed into libmng with mng read pushdata must contain the regular byte chunklength  {
                                }
but must not contain it with mng read pushchunk mng read pushsig is used to prevent libmng from trying to parse the regular png jng mng signature bytes the application must have done this itself and must indicate the proper type in the function call or things will go amiss  {
	                                            amiss :: -1000
                                                }
also you must call this first so pretty much right after mng initialize and certainly  {
	     certainly :: -1000
             }
before any call to mng read or mng readdisplay  {
       }
important data can only be safely pushed when libmng is in a wait state eg during mng needtimerwait mng needsectionwait or mng needmoredata this just means you can t have one thread displaying and another thread pushing data if bownership  {
                                      }
mng true libmng will retain the supplied pointer and will expect the buffer to remain available until libmng is finished with it what happens then depends on whether or not you have set the releasedata  {
	                          released :: 15
                                 }
callback if this is set than the supplied buffer will be returned through this callback and your application can take care of cleaning  {
	              cleaning :: -1000
                     }
it up otherwise libmng will use its internal freeing mechanism which depending on compile options will be the standard c free call or the memfree callback if bownership mng false libmng will just copy the data into its own buffers and dispose  {
	                                  dispose :: -1000
                                        }
of it in the normal way ifdef mng support read mng ext mng retcode mng decl mng read pushdata mng handle hhandle mng ptr pdata  {
	                  platan :: 6
	                   adyta :: 6
	                   adapt :: 6
	                   pasta :: 6
                       }
mng size t ilength  {
	alength :: 11
  }
mng bool btakeownership  {
 }
mng ext mng retcode mng decl mng read pushsig mng handle hhandle mng imgtype  {
	     emptying :: 9
	      mistype :: 9
            }
esigtype  {
	epistyles :: 10
	epistyle :: 11
 }
mng ext mng retcode mng decl mng read pushchunk mng handle hhandle mng ptr pchunk  {
             }
mng size t ilength mng bool btakeownership endif high level write create functions use this if you want to write a previously read network graphic or if you want to create a new graphic and write it to write a previously read graphic you must have defined mng store chunks to create a new graphic you ll also need access to the chunks eg define mng access chunks ifdef mng support write mng ext mng retcode mng decl mng write mng handle hhandle mng ext mng retcode mng decl mng create mng handle hhandle endif high level display functions use these to display a previously read or created graphic or to read display a graphic simultaneously mng display resume should be called after a timer interval expires that was set through the settimer  {
	                                                                                                                              setter :: 10
	                                                                                                                           sempitern :: 10
	                                                                                                                             teatime :: 10
	                                                                                                                             septime :: 11
	                                                                                                                           detriment :: 10
	                                                                                                                          detriments :: 11
	                                                                                                                            teatimes :: 11
	                                                                                                                             testier :: 10
	                                                                                                                             termite :: 10
	                                                                                                                            termites :: 11
	                                                                                                                           remitters :: 10
	                                                                                                                           sentiment :: 10
                                                                                                                                   }
callback after a read suspension break or to resume an animation after a call to mng display freeze  {
	           freeze :: -1000
                }
mng display reset mng display freeze thru mng display gotime  {
	    goyim :: 7
	   fomite :: 7
	   motive :: 8
	   motile :: 8
	  motived :: 7
	  motives :: 7
	  motiles :: 7
	   optime :: 8
	  gourmet :: 7
	  optimes :: 7
	   somite :: 7
	   goitre :: 7
	  mitogen :: 7
        }
can be used to influence the display of an image but only if it has been completely read ifdef mng support display ifdef mng support read mng ext mng retcode mng decl mng readdisplay mng handle hhandle endif mng ext mng retcode mng decl mng display mng handle hhandle mng ext mng retcode mng decl mng display resume mng handle hhandle mng ext mng retcode mng decl mng display freeze mng handle hhandle mng ext mng retcode mng decl mng display reset mng handle hhandle ifndef mng no display go supported mng ext mng retcode mng decl mng display goframe  {
	                                                                                             fogram :: 10
	                                                                                           gossamer :: 9
	                                                                                            fograms :: 9
	                                                                                          fogramite :: 9
                                                                                                  }
mng handle hhandle mng uint iframenr  {
	infame :: 10
    }
mng ext mng retcode mng decl mng display golayer  {
	 loyaler :: 9
	 voyager :: 9
	  galore :: 9
	 caloyer :: 9
	 gloater :: 9
       }
mng handle hhandle mng uint ilayernr  {
    }
mng ext mng retcode mng decl mng display gotime mng handle hhandle mng uint iplaytime  {
             }
endif endif mng support display event processing function this needs to be called by the app when dynamic mng is enabled and a specific event occurs in the user interface if defined mng support display defined mng support dynamicmng mng ext mng retcode mng decl mng trapevent  {
	                                     transvest :: 11
	                                     prevalent :: 11
	                                     tervalent :: 11
	                                     grapevine :: 11
                                             }
mng handle hhandle mng uint ieventtype  {
    }
mng int ix mng int iy  {
	  ivy :: 2
	  icy :: 2
    }
endif error reporting function use this if you need more detailed info on the last error iextra  {
	        dextrans :: 7
	        sextarii :: 7
	          tertia :: 7
	         dextrin :: 7
	         dextran :: 8
	         dextral :: 8
	           taxer :: 7
               }
iextra may contain errorcodes from zlib jpeg etc zerrortext  {
	terrorize :: 12
       }
will only be filled if you define mng error telltale mng ext mng retcode mng decl mng getlasterror  {
                }
mng handle hhandle mng int iseverity  {
	sievert :: 11
	servility :: 11
    }
mng chunkid  {
	chunk :: 10
	chink :: 9
	chinked :: 10
	chunking :: 9
	chunkily :: 10
	chunkier :: 10
	chunkiest :: 9
	chunky :: 9
	chunks :: 9
 }
ichunkname  {
	inhumane :: 12
 }
mng uint ichunkseq  {
	echinus :: 11
 }
mng int iextra mng int iextra mng pchar zerrortext callback set functions memory callbacks called to allocate and release internal datastructures  {
                   }
ifndef mng internal memmngmt mng ext mng retcode mng decl mng setcb  {
	    setback :: 6
	       sect :: 6
	       bets :: 6
	        set :: 6
          }
memalloc mng handle hhandle mng memalloc fproc  {
     }
mng ext mng retcode mng decl mng setcb memfree mng handle hhandle mng memfree fproc endif mng internal memmngmt open close stream callbacks called to open close streams for input or output if defined mng support read defined mng support write ifndef mng no open close stream mng ext mng retcode mng decl mng setcb openstream mng handle hhandle mng openstream fproc mng ext mng retcode mng decl mng setcb closestream mng handle hhandle mng closestream fproc endif endif read callback called to get data from the inputstream  {
	                                                                               inputter :: 14
	                                                                              inputters :: 15
                                                                                      }
ifdef mng support read mng ext mng retcode mng decl mng setcb readdata mng handle hhandle mng readdata fproc endif write callback called to put data into the outputstream  {
                           }
ifdef mng support write mng ext mng retcode mng decl mng setcb writedata  {
	nonprogrammer :: -1000
           }
mng handle hhandle mng writedata fproc endif error callback called when an error occurs the application can determine if the error is recoverable and may inform the library by setting specific returncodes  {
	                       returned :: 14
                              }
mng ext mng retcode mng decl mng setcb errorproc  {
       }
mng handle hhandle mng errorproc fproc trace callback called to show the currently executing  {
	    executing :: -1000
            }
function ifdef mng support trace mng ext mng retcode mng decl mng setcb traceproc mng handle hhandle mng traceproc fproc endif callbacks for read processing processheader  {
                        }
is called when all header information has been gathered  {
	gathered :: -1000
       }
from the inputstream processtext is called for every text ztxt  {
        }
and itxt  {
 }
chunk in the inputstream itype  {
	etypic :: 7
	stipe :: 6
   }
for text for ztxt and for itxt you can call get imagelevel to check at what nesting  {
	         nesting :: -1000
               }
level the chunk is encountered eg text inside an embedded image inside a mng level in most other case level processsave  {
	           processes :: 16
                   }
processseek  {
	precesses :: 14
	processes :: 15
 }
are called for save seek chunks processneed  {
	precessed :: 14
	processed :: 15
	precensored :: 14
     }
is called for the need chunk you should specify a callback for this as the default behavior will be to abort processing unless the requirement is one of a supported chunk the text draft nn where nn is a numeric value the text mng or mng the text cacheoff  {
	                                           cache :: 10
	                                        checkoff :: 10
                                               }
processmend  {
	processioned :: 15
	precession :: 14
	processed :: 16
 }
is called at the very end of the animation stream note that this may not be the end of the animation though processterm is called when a term chunk is encountered there can be only in the stream or none processunknown  {
                                       }
is called after reading each non critical unknown chunk ifdef mng support read mng ext mng retcode mng decl mng setcb processheader mng handle hhandle mng processheader fproc mng ext mng retcode mng decl mng setcb processtext mng handle hhandle mng processtext fproc mng ext mng retcode mng decl mng setcb processsave mng handle hhandle mng processsave fproc mng ext mng retcode mng decl mng setcb processseek mng handle hhandle mng processseek fproc mng ext mng retcode mng decl mng setcb processneed mng handle hhandle mng processneed fproc mng ext mng retcode mng decl mng setcb processmend mng handle hhandle mng processmend fproc mng ext mng retcode mng decl mng setcb processterm mng handle hhandle mng processterm fproc mng ext mng retcode mng decl mng setcb processunknown mng handle hhandle mng processunknown fproc endif callbacks for display processing getcanvasline  {
	                                                                                                                                 diabetics :: -1000
                                                                                                                                         }
is called to get an access pointer to a line on the drawing  {
	     drawing :: -1000
           }
canvas getbkgdline  {
 }
is called to get an access pointer to a line from the background  {
	  background :: -1000
           }
canvas refresh is called to inform the gui to redraw  {
	   redraw :: -1000
        }
the current canvas onto its output device eg in win this would mean sending  {
	      sending :: -1000
            }
an invalidate message for the specified region note that the update region is specified as x y width height eg the invalidate message for windows requires left top right bottom parameters where the bottom right is exclusive of the region to get these correctly is as simple as left x top y right x width bottom y height if your implementation requires inclusive points simply subtract  {
	                                                         subtract :: -1000
                                                                }
from both the right bottom values calculated  {
	calculated :: -1000
     }
above ifdef mng support display mng ext mng retcode mng decl mng setcb getcanvasline mng handle hhandle mng getcanvasline fproc mng ext mng retcode mng decl mng setcb getbkgdline mng handle hhandle mng getbkgdline fproc mng ext mng retcode mng decl mng setcb getalphaline mng handle hhandle mng getalphaline fproc mng ext mng retcode mng decl mng setcb refresh mng handle hhandle mng refresh fproc timing callbacks gettickcount  {
                                                                  }
is called to get the system tickcount  {
	electrolytic :: -1000
     }
milliseconds  {
	milliseconds :: -1000
 }
this is used to determine the remaining interval between frames  {
	   frames :: -1000
        }
settimer is called to inform the application that it should set a timer when the timer is triggered  {
	        triggered :: -1000
                }
the app must call mng display resume mng ext mng retcode mng decl mng setcb gettickcount mng handle hhandle mng gettickcount fproc mng ext mng retcode mng decl mng setcb settimer mng handle hhandle mng settimer fproc color management callbacks called to transmit color management information to the application these are only used when you define mng app cms ifdef mng app cms mng ext mng retcode mng decl mng setcb processgamma  {
                                                                      }
mng handle hhandle mng processgamma fproc mng ext mng retcode mng decl mng setcb processchroma  {
             }
mng handle hhandle mng processchroma fproc mng ext mng retcode mng decl mng setcb processsrgb  {
	    processors :: 15
             }
mng handle hhandle mng processsrgb fproc mng ext mng retcode mng decl mng setcb processiccp  {
	       hornets :: -1000
             }
mng handle hhandle mng processiccp fproc mng ext mng retcode mng decl mng setcb processarow  {
	     professor :: 14
	    processors :: 14
	     processor :: 17
             }
mng handle hhandle mng processarow fproc endif mng app cms endif mng support display release push data callback used when the app pushes  {
	                pushes :: -1000
                     }
data into libmng as opposed  {
	opposed :: -1000
   }
to libmng pulling  {
	pulling :: -1000
 }
it and relinquishes  {
	relinquishes :: -1000
 }
ownership of the pushed data buffer but does want to release free the buffer itself once libmng has finished processing it ifdef mng support read mng ext mng retcode mng decl mng setcb releasedata mng handle hhandle mng releasedata fproc endif callback get functions see setcb ifndef mng internal memmngmt mng ext mng memalloc mng decl mng getcb  {
	                                                      get :: 6
                                                        }
memalloc mng handle hhandle mng ext mng memfree mng decl mng getcb memfree mng handle hhandle endif see setcb ifdef mng support read mng ext mng releasedata mng decl mng getcb releasedata mng handle hhandle endif see setcb if defined mng support read defined mng write support ifndef mng no open close stream mng ext mng openstream mng decl mng getcb openstream mng handle hhandle mng ext mng closestream mng decl mng getcb closestream mng handle hhandle endif endif see setcb ifdef mng support read mng ext mng readdata mng decl mng getcb readdata mng handle hhandle endif see setcb ifdef mng support write mng ext mng writedata mng decl mng getcb writedata mng handle hhandle endif see setcb mng ext mng errorproc mng decl mng getcb errorproc mng handle hhandle see setcb ifdef mng support trace mng ext mng traceproc mng decl mng getcb traceproc mng handle hhandle endif see setcb ifdef mng support read mng ext mng processheader mng decl mng getcb processheader mng handle hhandle mng ext mng processtext mng decl mng getcb processtext mng handle hhandle mng ext mng processsave mng decl mng getcb processsave mng handle hhandle mng ext mng processseek mng decl mng getcb processseek mng handle hhandle mng ext mng processneed mng decl mng getcb processneed mng handle hhandle mng ext mng processunknown mng decl mng getcb processunknown mng handle hhandle mng ext mng processterm mng decl mng getcb processterm mng handle hhandle endif see setcb ifdef mng support display mng ext mng getcanvasline mng decl mng getcb getcanvasline mng handle hhandle mng ext mng getbkgdline mng decl mng getcb getbkgdline mng handle hhandle mng ext mng getalphaline mng decl mng getcb getalphaline mng handle hhandle mng ext mng refresh mng decl mng getcb refresh mng handle hhandle see setcb mng ext mng gettickcount mng decl mng getcb gettickcount mng handle hhandle mng ext mng settimer mng decl mng getcb settimer mng handle hhandle see setcb ifdef mng app cms mng ext mng processgamma mng decl mng getcb processgamma mng handle hhandle mng ext mng processchroma mng decl mng getcb processchroma mng handle hhandle mng ext mng processsrgb mng decl mng getcb processsrgb mng handle hhandle mng ext mng processiccp mng decl mng getcb processiccp mng handle hhandle mng ext mng processarow mng decl mng getcb processarow mng handle hhandle endif mng app cms endif mng support display property set functions application data pointer provided for application use not used by the library mng ext mng retcode mng decl mng set userdata mng handle hhandle mng ptr puserdata the style of the drawing background canvas only used for displaying images both are initially set to bit rgb eg bit per channel mng ext mng retcode mng decl mng set canvasstyle mng handle hhandle mng uint istyle  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                         istle :: 8
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                         islet :: 7
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                        astely :: 7
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                       cotyles :: 7
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                        sutile :: 7
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }
mng ext mng retcode mng decl mng set bkgdstyle  {
       }
mng handle hhandle mng uint istyle the default background color only used if the getbkgdline callback is not defined for initially painting  {
	             painting :: -1000
                    }
the canvas and restoring  {
	restoring :: -1000
  }
part of the background mng ext mng retcode mng decl mng set bgcolor  {
	    bicolour :: 9
	    bicolors :: 10
	   bicolored :: 9
	     bicolor :: 11
           }
mng handle hhandle mng uint ired  {
	relubricating :: -1000
    }
mng uint igreen  {
	bergenia :: 7
	pureeing :: 7
	germen :: 7
	agree :: 7
	spreeing :: 7
	integer :: 7
	agreeing :: 7
	nerie :: 7
 }
mng uint iblue  {
	imbue :: 6
 }
indicates preferred use of the bkgd chunk for png images mng ext mng retcode mng decl mng set usebkgd  {
                 }
mng handle hhandle mng bool busebkgd  {
	aestivations :: -1000
    }
indicates storage of read chunks only useful if you define mng store chunks can be used to dynamically change storage management mng ext mng retcode mng decl mng set storechunks  {
                            }
mng handle hhandle mng bool bstorechunks  {
    }
indicates breaks requested when processing save seek set this to let the app handle section breaks the library will return mng needsectionwait return codes for each seek chunk mng ext mng retcode mng decl mng set sectionbreaks  {
                                   }
mng handle hhandle mng bool bsectionbreaks  {
    }
indicates storage of playback info on by default can be used to turn off caching  {
	       caching :: -1000
             }
of playback info this is useful to specifically optimize mng video playback note that if caching is turned off loop chunks will be flagged  {
	                flagged :: -1000
                      }
as errors term chunks will be ignored and only passed to the processterm callback if it is defined by the app also this feature can only be used with mng readdisplay mng read mng display reset and mng display goxxxx  {
                                      }
will return an error once this option is turned off it can t be turned on for the same stream mng ext mng retcode mng decl mng set cacheplayback  {
                           }
mng handle hhandle mng bool bcacheplayback  {
    }
indicates automatic progressive refreshes  {
	refreshes :: -1000
  }
for large images on by default turn this off if you do not want intermittent  {
	  intermittent :: -1000
             }
painting while a large image is being read useful if the input stream comes from a fast medium  {
	         pintados :: -1000
                }
such as a local harddisk  {
	hardfisted :: 10
   }
mng ext mng retcode mng decl mng set doprogressive  {
	unprogressive :: 20
	retrogressive :: 17
       }
mng handle hhandle mng bool bdoprogressive  {
	nonprogressive :: 21
	nonprogressives :: 18
    }
indicates existence and required checking of the crc in input streams and generation in output streams use this only if you know what you are doing the value is a combination  {
	                   combination :: -1000
                             }
of the following flags x crc is present in the input stream x crc must be generated in the output stream x crc should be checked for ancillary  {
	                  ancillary :: -1000
                          }
chunks x a faulty crc for ancillary chunks generates a warning only x a faulty crc for ancillary chunks generates an error x crc should be checked for critical chunks x a faulty crc for critical chunks generates a warning only x a faulty crc for critical chunks generates an error the default is x crc present in input streams should be checked warning for ancillary chunks error for critical chunks generate crc for output streams note that some combinations  {
	                                                                   combinations :: -1000
                                                                              }
are meaningless  {
	pelorias :: -1000
 }
eg if the crc is not present it won t do any good to turn the checking flags on if a checking flag is off it doesn t do any good to ask for generation of warnings or errors also libmng will generate either an error or a warning not both so if you specify both the default will be to generate an error the only useful combinations for input are and optionally and but only checking ancillary chunks and not critical chunks is generally not a very good idea if you ve also writing these values should be combined with x if crc s are required in the output stream mng ext mng retcode mng decl mng set crcmode  {
                                                                                                                      }
mng handle hhandle mng uint icrcmode  {
	chromide :: 10
    }
color management necessaries  {
	necessaries :: -1000
 }
this next bit is important if you have defined mng full cms and are using lcms you will have to think hard about the following routines lcms requires profiles to work off the differences in the input image and the output device the icc profile for the input image will be embedded within it to reflect its color characteristics but the output profile depends on the output device which is something only you know about srgb standard rgb is common for x compatible environments eg windows linux and some others if you are compiling for a srgb compliant  {
	                                                                                        compliant :: -1000
                                                                                                }
system you probably won t have to do anything special unless you want to of course  {
	         course :: -1000
              }
if you are compiling for a non srgb compliant system eg sgi mac next others you must define a proper icc profile for the generic output device associated with that platform in either event you may also want to offer an option to your users to set the profile manually or if you know how set it from a system defined default to recap  {
	                                                          recap :: -1000
                                                              }
for srgb systems windows linux no action required for non srgb systems sgi mac next action required please visit http www srgb com http www color org and http www littlecms  {
	                       littles :: 13
	                       littler :: 11
	                        little :: 12
                             }
com for more info the bit above is important mng set srgb tells  {
	       tells :: -1000
           }
libmng if it s running  {
	running :: -1000
   }
on a srgb compliant system or not the default is already set to mng true mng set outputprofile mng set outputprofile mng set outputsrgb  {
	               outburst :: 13
	                 output :: 12
	                outputs :: 14
	                putouts :: 12
                      }
are used to set the default profile describing the output device by default it is already initialized with an srgb profile mng set srgbprofile mng set srgbprofile mng set srgbimplicit  {
                            }
are used to set the default profile describing a standard srgb device this is used when the input image is tagged  {
	              tagged :: -1000
                   }
only as being srgb but the output device is defined as not being srgb compliant by default it is already initialized with a standard srgb profile if defined mng support display mng ext mng retcode mng decl mng set srgb mng handle hhandle mng bool bissrgb  {
                                            }
mng ext mng retcode mng decl mng set outputprofile mng handle hhandle mng pchar zfilename  {
             }
mng ext mng retcode mng decl mng set outputprofile mng handle hhandle mng uint iprofilesize  {
             }
mng ptr pprofile  {
	obstruent :: -1000
 }
mng ext mng retcode mng decl mng set outputsrgb mng handle hhandle mng ext mng retcode mng decl mng set srgbprofile mng handle hhandle mng pchar zfilename mng ext mng retcode mng decl mng set srgbprofile mng handle hhandle mng uint iprofilesize mng ptr pprofile mng ext mng retcode mng decl mng set srgbimplicit mng handle hhandle endif if defined mng full cms defined mng gamma only defined mng app cms gamma settings blabla  {
	                                                                 blamable :: 7
	                                                                 blamably :: 7
	                                                                   balboa :: 7
	                                                                blameable :: 7
	                                                                 beanball :: 7
                                                                        }
explain  {
	explain :: -1000
 }
gamma processing a little eg formula  {
	formula :: -1000
    }
stuff mng ext mng retcode mng decl mng set viewgamma  {
        }
mng handle hhandle mng float dgamma  {
	preoccupancies :: -1000
    }
mng ext mng retcode mng decl mng set displaygamma  {
       }
mng handle hhandle mng float dgamma mng ext mng retcode mng decl mng set dfltimggamma  {
             }
mng handle hhandle mng float dgamma mng ext mng retcode mng decl mng set viewgammaint  {
             }
mng handle hhandle mng uint igamma  {
	miasma :: 7
	grammatic :: 7
	grammar :: 7
	gnamma :: 8
    }
mng ext mng retcode mng decl mng set displaygammaint  {
       }
mng handle hhandle mng uint igamma mng ext mng retcode mng decl mng set dfltimggammaint  {
             }
mng handle hhandle mng uint igamma endif ifndef mng skip maxcanvas  {
         }
ultimate  {
	ultimate :: -1000
 }
clipping  {
	clipping :: -1000
 }
size used to limit extreme graphics from overloading  {
	overloading :: -1000
      }
the system if a graphic exceeds  {
	hariolate :: -1000
    }
these limits a warning is issued  {
	issued :: -1000
    }
which can be ignored by the app using the errorproc callback in that case the library will use these settings to clip the input graphic and the app s canvas must account for this mng ext mng retcode mng decl mng set maxcanvaswidth  {
                                         }
mng handle hhandle mng uint imaxwidth  {
    }
mng ext mng retcode mng decl mng set maxcanvasheight  {
       }
mng handle hhandle mng uint imaxheight  {
    }
mng ext mng retcode mng decl mng set maxcanvassize  {
       }
mng handle hhandle mng uint imaxwidth mng uint imaxheight endif zlib default compression parameters these are used when writing out chunks they are also used when compressing  {
	                   raddled :: -1000
                         }
png image data or jng alpha data in this case you can set them just before calling mng putimgdata ihdr  {
	              third :: 5
                  }
set to your liking  {
	liking :: -1000
  }
usually the defaults will suffice  {
	suffice :: -1000
   }
though check the documentation for zlib for details on these parameters ifdef mng include zlib mng ext mng retcode mng decl mng set zlib level mng handle hhandle mng int izlevel  {
                             }
mng ext mng retcode mng decl mng set zlib method mng handle hhandle mng int izmethod  {
              }
mng ext mng retcode mng decl mng set zlib windowbits  {
	  windows :: 12
	windowsill :: 13
	windowsills :: 12
        }
mng handle hhandle mng int izwindowbits  {
    }
mng ext mng retcode mng decl mng set zlib memlevel  {
        }
mng handle hhandle mng int izmemlevel  {
    }
mng ext mng retcode mng decl mng set zlib strategy mng handle hhandle mng int izstrategy  {
	     mongrelize :: -1000
              }
mng ext mng retcode mng decl mng set zlib maxidat  {
	  taximan :: 9
        }
mng handle hhandle mng uint imaxidat  {
	cupellation :: -1000
    }
endif mng include zlib jng default compression parameters based on ijg code these are used when compressing jng image data so you can set them just before calling mng putimgdata jhdr  {
                             }
set to your liking usually the defaults will suffice though check the documentation for ijgsrc b for details on these parameters ifdef mng include jng ifdef mng include ijg b mng ext mng retcode mng decl mng set jpeg dctmethod  {
                                      }
mng handle hhandle mngjpeg  {
  }
dctmethod ejpegdctmethod  {
 }
endif mng ext mng retcode mng decl mng set jpeg quality mng handle hhandle mng int ijpegquality  {
	    superquality :: 15
               }
mng ext mng retcode mng decl mng set jpeg smoothing mng handle hhandle mng int ijpegsmoothing  {
              }
mng ext mng retcode mng decl mng set jpeg progressive mng handle hhandle mng bool bjpegprogressive  {
              }
mng ext mng retcode mng decl mng set jpeg optimized mng handle hhandle mng bool bjpegoptimized  {
              }
mng ext mng retcode mng decl mng set jpeg maxjdat  {
        }
mng handle hhandle mng uint imaxjdat  {
	supinenesses :: -1000
    }
endif mng include jng suspension mode setting use this to activate  {
	    cozied :: -1000
         }
the internal suspension buffer to improve  {
	improve :: -1000
    }
read suspension processing todo write suspension if defined mng support read mng ext mng retcode mng decl mng set suspensionmode mng handle hhandle mng bool bsuspensionmode  {
                        }
endif speed setting use this to influence the display speed of animations if defined mng support display mng ext mng retcode mng decl mng set speed mng handle hhandle mng speedtype ispeed  {
	                        indeeds :: 7
	                         impede :: 7
	                        impedes :: 8
	                         peised :: 8
	                         espied :: 10
	                         viseed :: 7
	                         spreed :: 7
	                        depside :: 7
                              }
endif property get functions see set mng ext mng ptr mng decl mng get userdata mng handle hhandle network graphic header details these get filled once the graphics header is processed so they are available in the processheader callback before that they are zeroed  {
	                                     zeroed :: -1000
                                          }
out and imagetype  {
 }
is set to it unknown this might be a good point for the app to initialize the drawing canvas note that some fields are only set for the first header chunk mng mhdr imagetype mng it mng ticks  {
	                                ticks :: -1000
                                    }
thru simplicity png ihdr imagetype mng it png bitdepth  {
	  bitted :: 10
       }
thru interlace jng jhdr imagetype mng it jng bitdepth thru compression interlace thru alphainterlace  {
            }
mng ext mng imgtype mng decl mng get sigtype mng handle hhandle mng ext mng imgtype mng decl mng get imagetype mng handle hhandle mng ext mng uint mng decl mng get imagewidth  {
                               }
mng handle hhandle mng ext mng uint mng decl mng get imageheight  {
          }
mng handle hhandle mng ext mng uint mng decl mng get ticks mng handle hhandle mng ext mng uint mng decl mng get framecount  {
                      }
mng handle hhandle mng ext mng uint mng decl mng get layercount  {
	intercounty :: 12
	cavernously :: 12
          }
mng handle hhandle mng ext mng uint mng decl mng get playtime mng handle hhandle mng ext mng uint mng decl mng get simplicity mng handle hhandle mng ext mng uint mng decl mng get bitdepth mng handle hhandle mng ext mng uint mng decl mng get colortype  {
	                                     collotypes :: 12
	                                      collotype :: 13
	                                         colory :: 11
                                              }
mng handle hhandle mng ext mng uint mng decl mng get compression mng handle hhandle mng ext mng uint mng decl mng get filter mng handle hhandle mng ext mng uint mng decl mng get interlace mng handle hhandle mng ext mng uint mng decl mng get alphabitdepth  {
                                              }
mng handle hhandle mng ext mng uint mng decl mng get alphacompression  {
          }
mng handle hhandle mng ext mng uint mng decl mng get alphafilter  {
          }
mng handle hhandle mng ext mng uint mng decl mng get alphainterlace mng handle hhandle indicates the predicted  {
	        predicted :: -1000
                }
alpha depth required to properly display the image gets set once the graphics header is processed and is available in the processheader callback for any type of input image png jng or mng possible values are no transparency  {
	                         transparency :: -1000
                                    }
required on off transparency required alpha values are or bit depth semi  {
	       semi :: -1000
          }
transparency required values will be scaled to the bitdepth of the canvasstyle supplied by the application mng ext mng uint mng decl mng get alphadepth  {
                       }
mng handle hhandle defines whether a refresh callback is called for an interlace pass png or progressive scan jng returns the interlace pass number for png or a fabricated  {
	                  fabricated :: -1000
                           }
pass number for jng returns in all other cases only useful if the image type mng it png or mng it jng and if the image is actually interlaced  {
	                      venged :: -1000
                           }
png or progressive jng ifdef mng support display mng ext mng uint mng decl mng get refreshpass  {
               }
mng handle hhandle endif see set mng ext mng uint mng decl mng get canvasstyle mng handle hhandle mng ext mng uint mng decl mng get bkgdstyle mng handle hhandle see set mng ext mng retcode mng decl mng get bgcolor mng handle hhandle mng uint ired mng uint igreen mng uint iblue see set mng ext mng bool mng decl mng get usebkgd mng handle hhandle see set mng ext mng bool mng decl mng get storechunks mng handle hhandle see set mng ext mng bool mng decl mng get sectionbreaks mng handle hhandle see set mng ext mng bool mng decl mng get cacheplayback mng handle hhandle see set mng ext mng bool mng decl mng get doprogressive mng handle hhandle see set mng ext mng uint mng decl mng get crcmode mng handle hhandle see set if defined mng support display defined mng full cms mng ext mng bool mng decl mng get srgb mng handle hhandle endif see set mng ext mng float mng decl mng get viewgamma mng handle hhandle mng ext mng float mng decl mng get displaygamma mng handle hhandle mng ext mng float mng decl mng get dfltimggamma mng handle hhandle mng ext mng uint mng decl mng get viewgammaint mng handle hhandle mng ext mng uint mng decl mng get displaygammaint mng handle hhandle mng ext mng uint mng decl mng get dfltimggammaint mng handle hhandle ifndef mng skip maxcanvas see set mng ext mng uint mng decl mng get maxcanvaswidth mng handle hhandle mng ext mng uint mng decl mng get maxcanvasheight mng handle hhandle endif see set ifdef mng include zlib mng ext mng int mng decl mng get zlib level mng handle hhandle mng ext mng int mng decl mng get zlib method mng handle hhandle mng ext mng int mng decl mng get zlib windowbits mng handle hhandle mng ext mng int mng decl mng get zlib memlevel mng handle hhandle mng ext mng int mng decl mng get zlib strategy mng handle hhandle mng ext mng uint mng decl mng get zlib maxidat mng handle hhandle endif mng include zlib see set ifdef mng include jng ifdef mng include ijg b mng ext mngjpeg dctmethod mng decl mng get jpeg dctmethod mng handle hhandle endif mng ext mng int mng decl mng get jpeg quality mng handle hhandle mng ext mng int mng decl mng get jpeg smoothing mng handle hhandle mng ext mng bool mng decl mng get jpeg progressive mng handle hhandle mng ext mng bool mng decl mng get jpeg optimized mng handle hhandle mng ext mng uint mng decl mng get jpeg maxjdat mng handle hhandle endif mng include jng see set if defined mng support read mng ext mng bool mng decl mng get suspensionmode mng handle hhandle endif see set if defined mng support display mng ext mng speedtype mng decl mng get speed mng handle hhandle endif image level this can be used inside the processtext callback to determine the level of text of the image being processed the value is returned for top level texts  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               texts :: -1000
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   }
and the value for a text inside an embedded image inside a mng mng ext mng uint mng decl mng get imagelevel mng handle hhandle back info can be used to retrieve the color mandatory values for the last processed back chunk of a mng will fail for other image types if no back chunk was processed yet it will return all zeroes  {
	                                                        zeroes :: -1000
                                                             }
ifdef mng support display mng ext mng retcode mng decl mng get lastbackchunk  {
           }
mng handle hhandle mng uint ired mng uint igreen mng uint iblue mng uint imandatory  {
	    indagatory :: 14
	    gladiatory :: 12
	    admonitory :: 12
	    inundatory :: 14
	    emendatory :: 14
	    amendatory :: 16
	     inundator :: 12
	     emendator :: 12
	     indagator :: 12
             }
endif seek info can be used to retrieve the segmentname  {
        }
of the last processed seek chunk if no seek chunk was processed or its segmentname was empty the function will return an empty string the provided buffer must be at least bytes ifdef mng support display mng ext mng retcode mng decl mng get lastseekname  {
                                           }
mng handle hhandle mng pchar zsegmentname  {
    }
endif fram info can be used to retrieve the current fram delay this may be useful when retrieving a stream of frames with their corresponding delays  {
	                   delays :: -1000
                        }
by fake reading and displaying the file ifdef mng support display mng ext mng uint mng decl mng get currframdelay  {
	        tetrazolium :: -1000
                  }
mng handle hhandle endif display status variables these get filled updated during display processing starttime  {
	   startlement :: 12
	       stretti :: 12
	       stretta :: 11
             }
is the tickcount at the start of displaying the animation runtime is the actual number of millisecs  {
	         sillies :: 11
	         milline :: 11
	        cullises :: 11
	       millirems :: 11
	        millimes :: 11
	        millines :: 12
	        milliers :: 11
	       milliners :: 12
	       silliness :: 11
	       hilliness :: 11
	       millipeds :: 12
	       milliares :: 11
	     millisecond :: 12
	        mislives :: 11
	        mislikes :: 11
	        silicles :: 11
	    milliseconds :: 14
	       mislikers :: 11
	         missile :: 11
	         mislies :: 11
               }
since the start of the animation currentframe  {
     }
currentlayer  {
 }
currentplaytime  {
	overtires :: -1000
 }
indicate the current frame layer playtime msecs  {
	 specs :: 6
     }
in the animation these keep increasing even after the animation loops  {
	     loops :: -1000
         }
back to the term chunk totalframes  {
    }
totallayers  {
 }
totalplaytime  {
 }
are filled after a complete run of an animation eg at mend they are also valid after just reading the mng ifdef mng support display mng ext mng uint mng decl mng get starttime mng handle hhandle mng ext mng uint mng decl mng get runtime mng handle hhandle ifndef mng no current info mng ext mng uint mng decl mng get currentframe mng handle hhandle mng ext mng uint mng decl mng get currentlayer mng handle hhandle mng ext mng uint mng decl mng get currentplaytime mng handle hhandle mng ext mng uint mng decl mng get totalframes mng handle hhandle mng ext mng uint mng decl mng get totallayers mng handle hhandle mng ext mng uint mng decl mng get totalplaytime mng handle hhandle endif endif status variables these indicate the internal state of the library most indicate exactly what you would expect status error true if the last function call returned an errorcode status reading true if the library is still reading an image status suspendbreak  {
	                                                                                                                                                               suspender :: 17
                                                                                                                                                                       }
true if the library has suspended for i o status creating true if the library is in the middle of creating an image status writing true if the library is in the middle of writing an image status displaying true if the library is displaying an image status running true if display processing is active eg not frozen  {
	                                                   frozen :: -1000
                                                        }
or reset status timerbreak  {
  }
true if the library has suspended for a timer break status dynamic true if the library encountered an evnt chunk in the mng status runningevent  {
                       }
true if the library is processing an external event eg mng readdisplay will turn the reading displaying and running status on when eof is reached the reading status will be turned off mng ext mng bool mng decl mng status error mng handle hhandle ifdef mng support read mng ext mng bool mng decl mng status reading mng handle hhandle mng ext mng bool mng decl mng status suspendbreak mng handle hhandle endif ifdef mng support write mng ext mng bool mng decl mng status creating mng handle hhandle mng ext mng bool mng decl mng status writing mng handle hhandle endif ifdef mng support display mng ext mng bool mng decl mng status displaying mng handle hhandle mng ext mng bool mng decl mng status running mng handle hhandle mng ext mng bool mng decl mng status timerbreak mng handle hhandle endif ifdef mng support dynamicmng mng ext mng bool mng decl mng status dynamic mng handle hhandle mng ext mng bool mng decl mng status runningevent mng handle hhandle endif chunk access functions ifdef mng access chunks use this to iterate the stored chunks requires mng access chunks mng store chunks starts from the supplied chunk index nr the first chunk has index mng ext mng retcode mng decl mng iterate chunks mng handle hhandle mng uint ichunkseq mng iteratechunk  {
                                                                                                                                                                                                                            }
fproc use the next function inside your iteratechunk callback to copy the given chunk to a new mng you are creating the out handle should be in create status ifdef mng support write mng ext mng retcode mng decl mng copy chunk mng handle hhandle mng handle hchunk  {
                                              }
mng handle hhandleout  {
 }
endif use these to get chunk data from within the callback in iterate chunks mng ext mng retcode mng decl mng getchunk ihdr mng handle hhandle mng handle hchunk mng uint iwidth  {
	                         inwith :: 7
                              }
mng uint iheight  {
	aheight :: 11
	behight :: 9
 }
mng uint ibitdepth  {
	nonproductive :: -1000
 }
mng uint icolortype  {
 }
mng uint icompression  {
	recommission :: 15
	reimpression :: 17
 }
mng uint ifilter  {
	flitter :: 9
	flirter :: 9
 }
mng uint iinterlace  {
	centralize :: 12
	centralise :: 12
	cisternae :: 12
 }
mng ext mng retcode mng decl mng getchunk plte  {
	    pote :: 5
	    plie :: 5
	    pelt :: 5
	    pate :: 5
	   pleat :: 5
	   plate :: 5
	   petal :: 5
	   palet :: 5
	  puteal :: 5
	     pet :: 5
	     elt :: 5
       }
mng handle hhandle mng handle hchunk mng uint icount  {
	  econut :: 7
	   incut :: 7
	  induct :: 7
	  incult :: 7
	scouting :: 7
	inductor :: 7
       }
mng palette apalette  {
	palmette :: 10
	pallette :: 11
	pallettes :: 10
 }
mng ext mng retcode mng decl mng getchunk idat  {
	   idant :: 6
	   adits :: 5
	  idants :: 5
	    ikat :: 5
	    adit :: 6
	     ita :: 5
       }
mng handle hhandle mng handle hchunk mng uint irawlen  {
	 brawlie :: 9
	crawling :: 9
	brawling :: 9
	trawling :: 9
       }
mng ptr prawdata  {
 }
mng ext mng retcode mng decl mng getchunk trns  {
	  tonsor :: 5
	  tensor :: 5
	  tenser :: 5
	   trons :: 5
	   trins :: 5
	   trans :: 5
	    urns :: 5
	    tuns :: 5
	    tons :: 5
	    tins :: 5
	    tens :: 5
	    tans :: 5
	    erns :: 5
       }
mng handle hhandle mng handle hchunk mng bool bempty  {
	   kempt :: 7
	   tempt :: 7
	    temp :: 7
       }
mng bool bglobal  {
	pilotman :: -1000
 }
mng uint itype mng uint icount mng uint arr aalphas  {
	 anaphase :: 9
        }
mng uint igray  {
 }
mng uint ired mng uint igreen mng uint iblue mng uint irawlen mng uint arr arawdata  {
              }
mng ext mng retcode mng decl mng getchunk gama  {
	 hardest :: -1000
       }
mng handle hhandle mng handle hchunk mng bool bempty mng uint igamma mng ext mng retcode mng decl mng getchunk chrm mng handle hhandle mng handle hchunk mng bool bempty mng uint iwhitepointx  {
                               }
mng uint iwhitepointy  {
 }
mng uint iredx  {
	irade :: 6
	ire :: 6
 }
mng uint iredy  {
	irade :: 6
	drey :: 6
	reedy :: 6
	ire :: 6
 }
mng uint igreenx  {
 }
mng uint igreeny  {
	cicelies :: -1000
 }
mng uint ibluex  {
 }
mng uint ibluey  {
 }
mng ext mng retcode mng decl mng getchunk srgb mng handle hhandle mng handle hchunk mng bool bempty mng uint irenderingintent  {
                   }
mng ext mng retcode mng decl mng getchunk iccp mng handle hhandle mng handle hchunk mng bool bempty mng uint inamesize  {
	           isomerize :: 11
	          animalizes :: 11
                   }
mng pchar zname  {
	anime :: 6
	enamel :: 6
 }
mng uint icompression mng uint iprofilesize mng ptr pprofile mng ext mng retcode mng decl mng getchunk text mng handle hhandle mng handle hchunk mng uint ikeywordsize  {
                         }
mng pchar zkeyword  {
 }
mng uint itextsize  {
 }
mng pchar ztext  {
 }
mng ext mng retcode mng decl mng getchunk ztxt mng handle hhandle mng handle hchunk mng uint ikeywordsize mng pchar zkeyword mng uint icompression mng uint itextsize mng pchar ztext mng ext mng retcode mng decl mng getchunk itxt mng handle hhandle mng handle hchunk mng uint ikeywordsize mng pchar zkeyword mng uint icompressionflag  {
                                                    }
mng uint icompressionmethod  {
 }
mng uint ilanguagesize  {
	slanguages :: 16
	slanguage :: 16
 }
mng pchar zlanguage  {
	slanguages :: 14
	slanguage :: 15
 }
mng uint itranslationsize  {
	mogs :: -1000
 }
mng pchar ztranslation  {
	latinizations :: 15
	notarizations :: 15
 }
mng uint itextsize mng pchar ztext mng ext mng retcode mng decl mng getchunk bkgd mng handle hhandle mng handle hchunk mng bool bempty mng uint itype mng uint iindex  {
	                        indie :: 7
	                       jinxed :: 7
                            }
mng uint igray mng uint ired mng uint igreen mng uint iblue mng ext mng retcode mng decl mng getchunk phys mng handle hhandle mng handle hchunk mng bool bempty mng uint isizex  {
                               }
mng uint isizey  {
 }
mng uint iunit  {
	inwit :: 6
	munite :: 6
	ignite :: 6
	binit :: 6
	dunitic :: 6
	gunite :: 6
	tunic :: 6
	inti :: 6
	dunite :: 6
 }
mng ext mng retcode mng decl mng getchunk sbit  {
	   brits :: 5
	   stilb :: 5
	    suit :: 5
	    spit :: 5
	    snit :: 5
	    smit :: 5
	    slit :: 5
	    skit :: 5
	    shit :: 5
	    obit :: 5
	   obits :: 6
       }
mng handle hhandle mng handle hchunk mng bool bempty mng uint itype mng uint arr abits  {
	        britska :: 6
	          gaits :: 6
	          brits :: 6
	          airts :: 6
	          adits :: 7
	          abuts :: 7
	          absit :: 7
	          abris :: 6
	          abies :: 7
	          abets :: 7
	          waits :: 6
	         abatis :: 6
	          taits :: 6
	          raits :: 6
	          obits :: 7
	          obias :: 6
              }
mng ext mng retcode mng decl mng getchunk splt  {
	    spot :: 5
	    spit :: 5
	    spet :: 5
	    spat :: 5
	    silt :: 5
	    salt :: 5
	   split :: 6
	   splat :: 6
	   spilt :: 5
	   spelt :: 5
	   spalt :: 5
	  splint :: 5
	  splent :: 5
	  spital :: 5
	   pelts :: 5
       }
mng handle hhandle mng handle hchunk mng bool bempty mng uint inamesize mng pchar zname mng uint isampledepth  {
                }
mng uint ientrycount  {
 }
mng ptr pentries  {
	pineries :: 12
	orneriest :: 10
	pastries :: 10
	proteins :: 10
	gantries :: 10
	pantries :: 13
	pretties :: 10
	peltries :: 13
	poetries :: 12
	petering :: 10
	vestries :: 10
	penuries :: 13
	petaries :: 12
	nephrites :: 10
	gentries :: 13
	sentries :: 13
	pentodes :: 10
	rentiers :: 10
	pensters :: 10
	plenties :: 10
	panfries :: 10
	niteries :: 10
	prithees :: 10
	reptiles :: 10
	pestier :: 10
	penlites :: 11
	vintries :: 10
	panaries :: 10
	pestering :: 10
	naperies :: 10
	pertness :: 10
	pentose :: 10
	penster :: 10
	pertains :: 10
	gentrices :: 10
	prescient :: 10
	denaries :: 10
	senaries :: 10
	perlites :: 10
	pectines :: 11
 }
mng ext mng retcode mng decl mng getchunk hist mng handle hhandle mng handle hchunk mng uint ientrycount mng uint arr aentries  {
	             eateries :: 10
	             anergies :: 10
	             realties :: 10
	            orneriest :: 10
	           centralise :: 10
	            ankerites :: 10
	             gantries :: 12
	             pantries :: 12
	            atherines :: 10
	            dentaries :: 10
	             trainees :: 10
	             peltries :: 10
	             vestries :: 10
	             arteries :: 11
	             stearine :: 10
	             penuries :: 10
	             petaries :: 11
	             arenites :: 11
	             tetanies :: 10
	             gentries :: 13
	             sentries :: 13
	             rentiers :: 10
	             centares :: 11
	             alternes :: 10
	             nartjies :: 10
	             notaries :: 10
	             niteries :: 10
	             vintries :: 10
	             naperies :: 10
	            nearliest :: 11
	             teniases :: 10
	             arsenite :: 10
	            gentrices :: 10
	             taweries :: 10
	             hearties :: 10
	             denaries :: 12
	             senaries :: 12
	            centiares :: 10
                    }
mng ext mng retcode mng decl mng getchunk time mng handle hhandle mng handle hchunk mng uint iyear  {
	            ayrie :: 6
	             eyra :: 6
                }
mng uint imonth  {
 }
mng uint iday  {
 }
mng uint ihour  {
	choir :: 6
 }
mng uint iminute  {
	imine :: 9
 }
mng uint isecond  {
 }
mng ext mng retcode mng decl mng getchunk mhdr mng handle hhandle mng handle hchunk mng uint iwidth mng uint iheight mng uint iticks  {
	                 tricks :: 8
	                ickiest :: 7
	                stickum :: 7
	                stickup :: 7
	                stickit :: 7
	                stickle :: 7
	                sticker :: 7
	               stickpin :: 7
	               sticking :: 7
	               stickily :: 7
	               stickies :: 7
	               stickier :: 7
	               stickied :: 7
	                itacism :: 7
	                 thicks :: 8
	                tricksy :: 7
	                 sticky :: 8
	                 sticks :: 9
	                  stick :: 9
                      }
mng uint ilayercount  {
	hogweed :: -1000
 }
mng uint iframecount  {
 }
mng uint iplaytime mng uint isimplicity  {
    }
mng ext mng retcode mng decl mng getchunk loop mng handle hhandle mng handle hchunk mng uint ilevel  {
	           vielle :: 7
	           liever :: 7
	            lieve :: 8
                }
mng uint irepeat  {
	preheating :: 9
	preheats :: 9
	preheat :: 10
 }
mng uint itermination  {
	eternization :: 17
	impregnation :: 15
	ingratiation :: 15
	emargination :: 16
	ministration :: 15
	trephinations :: 15
	nonimitative :: 15
	trephination :: 16
	renomination :: 16
	renominations :: 15
	inseminations :: 16
	eternizations :: 16
	delimitation :: 15
	insemination :: 17
	emarginations :: 15
	illumination :: 15
	intimidation :: 15
 }
mng uint iitermin  {
	intermix :: 11
	intermit :: 10
	mitering :: 10
	interim :: 10
	intermixing :: 10
 }
mng uint iitermax  {
	intermix :: 12
 }
mng uint icount mng uint p psignals  {
	guppies :: -1000
     }
mng ext mng retcode mng decl mng getchunk endl  {
	   eldin :: 5
	    enol :: 5
	    ends :: 5
	     end :: 6
	     eld :: 5
       }
mng handle hhandle mng handle hchunk mng uint ilevel mng ext mng retcode mng decl mng getchunk defi mng handle hhandle mng handle hchunk mng uint iobjectid  {
	                disjection :: 11
                         }
mng uint idonotshow  {
	parenchyma :: -1000
 }
mng uint iconcrete  {
	ectocrine :: 13
	iconometer :: 11
 }
mng bool bhasloca  {
 }
mng int ixlocation  {
	insolations :: 12
	illocution :: 14
	allocution :: 13
	inchoation :: 12
	invocational :: 13
	invocations :: 13
	expositional :: 12
	invocation :: 14
	relocation :: 14
	volitation :: 12
	bilocation :: 16
	allocation :: 14
	excitation :: 12
	relocations :: 13
	illocutionary :: 13
	lorication :: 14
	toxication :: 14
	sonication :: 12
	immolation :: 13
	insolation :: 13
	colorations :: 12
	etiolation :: 12
	obligation :: 12
	bilocations :: 15
	allocutions :: 12
	allocations :: 13
 }
mng int iylocation  {
	insolations :: 12
	illocution :: 14
	allocution :: 13
	inchoation :: 12
	invocational :: 13
	invocations :: 13
	invocation :: 14
	relocation :: 14
	volitation :: 12
	bilocation :: 16
	allocation :: 14
	relocations :: 13
	illocutionary :: 15
	lorication :: 14
	toxication :: 12
	sonication :: 12
	immolation :: 13
	insolation :: 13
	colorations :: 12
	etiolation :: 12
	obligation :: 12
	bilocations :: 15
	allocutions :: 12
	allocations :: 13
 }
mng bool bhasclip  {
 }
mng int ileftcb  {
 }
mng int irightcb  {
	brights :: 10
 }
mng int itopcb  {
	atopic :: 7
	bioptic :: 7
 }
mng int ibottomcb  {
 }
mng ext mng retcode mng decl mng getchunk basi mng handle hhandle mng handle hchunk mng uint iwidth mng uint iheight mng uint ibitdepth mng uint icolortype mng uint icompression mng uint ifilter mng uint iinterlace mng uint ired mng uint igreen mng uint iblue mng uint ialpha  {
	                                       calipash :: 7
	                                        salpian :: 7
                                              }
mng uint iviewable  {
 }
mng ext mng retcode mng decl mng getchunk clon  {
	    clon :: -1000
       }
mng handle hhandle mng handle hchunk mng uint isourceid  {
	iridaceous :: 11
       }
mng uint icloneid  {
	indocile :: 10
	echinoid :: 10
 }
mng uint iclonetype  {
	duckweeds :: -1000
 }
mng uint idonotshow mng uint iconcrete mng bool bhasloca mng uint ilocationtype  {
          }
mng int ilocationx  {
	elocution :: 12
	plications :: 13
	ciliation :: 12
	foliation :: 12
	placation :: 12
	coalition :: 13
	oxidation :: 12
	sociation :: 12
	flotation :: 12
	olfaction :: 12
	evocation :: 12
	abolition :: 12
	coalitions :: 12
	plication :: 14
	isolation :: 14
	violation :: 13
	collation :: 12
	isolations :: 13
	violations :: 12
 }
mng int ilocationy  {
	elocution :: 12
	plications :: 13
	ciliation :: 12
	foliation :: 12
	placation :: 12
	coalition :: 13
	sociation :: 12
	flotation :: 12
	olfaction :: 12
	evocation :: 12
	abolition :: 12
	coalitions :: 12
	plication :: 14
	isolation :: 14
	violation :: 13
	collation :: 12
	elocutionary :: 13
	isolations :: 13
	acylation :: 12
	violations :: 12
 }
ifndef mng skipchunk past mng ext mng retcode mng decl mng getchunk past mng handle hhandle mng handle hchunk mng uint idestid  {
	                doper :: -1000
                    }
mng uint itargettype  {
 }
mng int itargetx  {
 }
mng int itargety  {
 }
mng uint icount mng ext mng retcode mng decl mng getchunk past src mng handle hhandle mng handle hchunk mng uint ientry mng uint isourceid mng uint icomposition  {
	               reimposition :: 17
	              reimpositions :: 15
                          }
mng uint iorientation  {
	infiltration :: 15
	fermentation :: 15
	invigoration :: 15
	incineration :: 15
 }
mng uint ioffsettype  {
 }
mng int ioffsetx  {
	toffies :: 11
 }
mng int ioffsety  {
	chicnesses :: -1000
 }
mng uint iboundarytype  {
 }
mng int iboundaryl  {
 }
mng int iboundaryr  {
 }
mng int iboundaryt mng int iboundaryb  {
    }
endif mng ext mng retcode mng decl mng getchunk disc mng handle hhandle mng handle hchunk mng uint icount mng uint p pobjectids  {
	            subjection :: 12
                     }
mng ext mng retcode mng decl mng getchunk back mng handle hhandle mng handle hchunk mng uint ired mng uint igreen mng uint iblue mng uint imandatory mng uint iimageid  {
                            }
mng uint itile  {
	stiles :: 6
	stiled :: 6
	utile :: 7
	toile :: 6
	stile :: 7
	teil :: 6
 }
mng ext mng retcode mng decl mng getchunk fram mng handle hhandle mng handle hchunk mng bool bempty mng uint imode  {
	               diode :: 6
	               amide :: 6
	              moider :: 6
	              emodin :: 7
	             emodins :: 6
                   }
mng uint inamesize mng pchar zname mng uint ichangedelay  {
       }
mng uint ichangetimeout  {
 }
mng uint ichangeclipping  {
 }
mng uint ichangesyncid  {
 }
mng uint idelay  {
	ideal :: 8
	ideally :: 8
	idealogy :: 7
	ideals :: 7
	wieldy :: 7
	yield :: 7
	idyl :: 7
	idea :: 7
 }
mng uint itimeout  {
 }
mng uint iboundarytype mng int iboundaryl mng int iboundaryr mng int iboundaryt mng int iboundaryb mng uint icount mng uint p psyncids  {
	             psyllids :: 10
                    }
mng ext mng retcode mng decl mng getchunk move mng handle hhandle mng handle hchunk mng uint ifirstid  {
	         inholder :: -1000
                }
mng uint ilastid  {
	plastids :: 9
	plastid :: 11
 }
mng uint imovetype  {
 }
mng int imovex  {
	amove :: 7
 }
mng int imovey  {
	amove :: 7
 }
mng ext mng retcode mng decl mng getchunk clip mng handle hhandle mng handle hchunk mng uint ifirstid mng uint ilastid mng uint icliptype  {
                      }
mng int iclipl  {
	telomere :: -1000
 }
mng int iclipr  {
 }
mng int iclipt mng int iclipb  {
    }
mng ext mng retcode mng decl mng getchunk show mng handle hhandle mng handle hchunk mng bool bempty mng uint ifirstid mng uint ilastid mng uint imode mng ext mng retcode mng decl mng getchunk term mng handle hhandle mng handle hchunk mng uint itermaction  {
	                                 metafiction :: 14
	                                 interaction :: 16
	                                 extrication :: 14
	                                 imprecation :: 15
	                                interactions :: 15
	                                 retroaction :: 14
	                                 metrication :: 16
	                                metrications :: 15
	                                imprecations :: 14
	                                 crepitation :: 14
	                                 impetration :: 14
                                           }
mng uint iiteraction  {
	distraction :: 15
	interact :: 14
	indirection :: 14
	interaction :: 18
	interacting :: 14
	altercation :: 14
	itineration :: 14
	extrication :: 14
	interactions :: 17
	retroaction :: 14
	metrication :: 14
	distractions :: 14
 }
mng uint idelay mng uint iitermax mng ext mng retcode mng decl mng getchunk save mng handle hhandle mng handle hchunk mng bool bempty mng uint ioffsettype mng uint icount mng ext mng retcode mng decl mng getchunk save entry mng handle hhandle mng handle hchunk mng uint ientry mng uint ientrytype  {
                                                  }
mng uint arr ioffset mng uint arr istarttime  {
      }
mng uint ilayernr mng uint iframenr mng uint inamesize mng pchar zname mng ext mng retcode mng decl mng getchunk seek mng handle hhandle mng handle hchunk mng uint inamesize mng pchar zname mng ext mng retcode mng decl mng getchunk expi mng handle hhandle mng handle hchunk mng uint isnapshotid  {
                                                 }
mng uint inamesize mng pchar zname mng ext mng retcode mng decl mng getchunk fpri mng handle hhandle mng handle hchunk mng uint ideltatype  {
                      }
mng uint ipriority  {
	apriorist :: 11
	apriority :: 15
 }
mng ext mng retcode mng decl mng getchunk need mng handle hhandle mng handle hchunk mng uint ikeywordssize  {
                }
mng pchar zkeywords  {
 }
mng ext mng retcode mng decl mng getchunk phyg mng handle hhandle mng handle hchunk mng bool bempty mng uint isizex mng uint isizey mng uint iunit mng ext mng retcode mng decl mng getchunk jhdr mng handle hhandle mng handle hchunk mng uint iwidth mng uint iheight mng uint icolortype mng uint iimagesampledepth  {
                                                    }
mng uint iimagecompression  {
 }
mng uint iimageinterlace  {
 }
mng uint ialphasampledepth  {
 }
mng uint ialphacompression  {
 }
mng uint ialphafilter  {
 }
mng uint ialphainterlace  {
 }
mng ext mng retcode mng decl mng getchunk jdat  {
       }
mng handle hhandle mng handle hchunk mng uint irawlen mng ptr prawdata mng ext mng retcode mng decl mng getchunk jdaa mng handle hhandle mng handle hchunk mng uint irawlen mng ptr prawdata mng ext mng retcode mng decl mng getchunk dhdr  {
                                        }
mng handle hhandle mng handle hchunk mng uint iobjectid mng uint iimagetype  {
          }
mng uint ideltatype mng uint iblockwidth  {
    }
mng uint iblockheight  {
 }
mng uint iblockx  {
 }
mng uint iblocky  {
	colicky :: 9
 }
mng ext mng retcode mng decl mng getchunk prom mng handle hhandle mng handle hchunk mng uint icolortype mng uint isampledepth mng uint ifilltype  {
                      }
mng ext mng retcode mng decl mng getchunk pplt mng handle hhandle mng handle hchunk mng uint ideltatype mng uint icount mng ext mng retcode mng decl mng getchunk pplt entry mng handle hhandle mng handle hchunk mng uint ientry mng uint ired mng uint igreen mng uint iblue mng uint ialpha mng bool bused  {
	                                                 bused :: -1000
                                                     }
mng ext mng retcode mng decl mng getchunk drop mng handle hhandle mng handle hchunk mng uint icount mng chunkidp  {
	              chunk :: 10
	            chinked :: 10
	           chunkily :: 10
	           chunkier :: 10
                  }
pchunknames  {
 }
mng ext mng retcode mng decl mng getchunk dbyk  {
       }
mng handle hhandle mng handle hchunk mng chunkid ichunkname mng uint ipolarity  {
	  oviparity :: 12
	  spirality :: 12
	  prolixity :: 12
	  apriority :: 12
          }
mng uint ikeywordssize mng pchar zkeywords mng ext mng retcode mng decl mng getchunk ordr  {
	         ardor :: 5
	        ordure :: 5
	          dorr :: 5
             }
mng handle hhandle mng handle hchunk mng uint icount mng ext mng retcode mng decl mng getchunk ordr entry mng handle hhandle mng handle hchunk mng uint ientry mng chunkid ichunkname mng uint iordertype  {
	                         portered :: 12
                                }
mng ext mng retcode mng decl mng getchunk magn mng handle hhandle mng handle hchunk mng uint ifirstid mng uint ilastid mng uint imethodx  {
                      }
mng uint imx  {
	mixy :: 3
	mixt :: 3
	maxi :: 3
	mix :: 4
	imp :: 3
 }
mng uint imy  {
	imply :: 3
	ismy :: 3
	immy :: 3
	ivy :: 3
	imp :: 3
	icy :: 3
 }
mng uint iml  {
	imply :: 3
	impel :: 3
	milt :: 3
	mils :: 3
	milo :: 3
	milk :: 3
	mile :: 3
	mild :: 3
	mil :: 4
	imp :: 3
	ill :: 3
 }
mng uint imr  {
	ihram :: 3
	amrit :: 3
	smir :: 3
	miry :: 3
	mirv :: 3
	mirs :: 3
	mirk :: 3
	miri :: 3
	mire :: 3
	meri :: 3
	firm :: 3
	emir :: 3
	amir :: 3
	rim :: 3
	mir :: 4
	imp :: 3
 }
mng uint imt  {
	impot :: 3
	smit :: 3
	omit :: 3
	muti :: 3
	mity :: 3
	mite :: 3
	item :: 3
	emit :: 3
	imp :: 3
	it :: 3
 }
mng uint imb  {
	imbue :: 4
	imbed :: 4
	imbues :: 3
	imbued :: 3
	imbrue :: 3
	imbrex :: 3
	imbosk :: 3
	imbody :: 3
	imbeds :: 3
	imbase :: 3
	imbark :: 3
	ambit :: 3
	mibs :: 3
	iamb :: 3
	mib :: 4
	imp :: 3
 }
mng uint imethody  {
 }
ifdef mng include mpng proposal mng ext mng retcode mng decl mng getchunk mpng mng handle hhandle mng handle hchunk mng uint iframewidth  {
                     }
mng uint iframeheight  {
 }
mng uint inumplays  {
 }
mng uint itickspersec  {
 }
mng uint icompressionmethod mng uint icount mng ext mng retcode mng decl mng getchunk mpng frame mng handle hhandle mng handle hchunk mng uint ientry mng uint ix mng uint iy mng uint iwidth mng uint iheight mng int ixoffset  {
                                      }
mng int iyoffset  {
 }
mng uint iticks endif mng ext mng retcode mng decl mng getchunk evnt mng handle hhandle mng handle hchunk mng uint icount mng ext mng retcode mng decl mng getchunk evnt entry mng handle hhandle mng handle hchunk mng uint ientry mng uint ieventtype mng uint imasktype  {
                                             }
mng int ileft mng int iright mng int itop mng int ibottom mng uint iobjectid mng uint iindex mng uint isegmentnamesize  {
                   }
mng pchar zsegmentname mng ext mng retcode mng decl mng getchunk unknown mng handle hhandle mng handle hchunk mng chunkid ichunkname mng uint irawlen mng ptr prawdata ifdef mng include write procs use these to create new chunks at the end of the chunk list requires at least mng access chunks mng support write may be nice too mng ext mng retcode mng decl mng putchunk ihdr mng handle hhandle mng uint iwidth mng uint iheight mng uint ibitdepth mng uint icolortype mng uint icompression mng uint ifilter mng uint iinterlace mng ext mng retcode mng decl mng putchunk plte mng handle hhandle mng uint icount mng palette apalette mng ext mng retcode mng decl mng putchunk idat mng handle hhandle mng uint irawlen mng ptr prawdata mng ext mng retcode mng decl mng putchunk iend  {
	                                                                                                                                  inned :: 5
	                                                                                                                                 zendik :: 5
	                                                                                                                                  denim :: 5
	                                                                                                                                   wend :: 5
	                                                                                                                                   vend :: 5
	                                                                                                                                   tend :: 5
	                                                                                                                                   send :: 5
	                                                                                                                                   pend :: 5
	                                                                                                                                   mend :: 5
	                                                                                                                                   lend :: 5
	                                                                                                                                   hend :: 5
	                                                                                                                                   fend :: 5
	                                                                                                                                   dine :: 5
	                                                                                                                                   bend :: 5
	                                                                                                                                    den :: 5
                                                                                                                                      }
mng handle hhandle mng ext mng retcode mng decl mng putchunk trns mng handle hhandle mng bool bempty mng bool bglobal mng uint itype mng uint icount mng uint arr aalphas mng uint igray mng uint ired mng uint igreen mng uint iblue mng uint irawlen mng uint arr arawdata mng ext mng retcode mng decl mng putchunk gama mng handle hhandle mng bool bempty mng uint igamma mng ext mng retcode mng decl mng putchunk chrm mng handle hhandle mng bool bempty mng uint iwhitepointx mng uint iwhitepointy mng uint iredx mng uint iredy mng uint igreenx mng uint igreeny mng uint ibluex mng uint ibluey mng ext mng retcode mng decl mng putchunk srgb mng handle hhandle mng bool bempty mng uint irenderingintent mng ext mng retcode mng decl mng putchunk iccp mng handle hhandle mng bool bempty mng uint inamesize mng pchar zname mng uint icompression mng uint iprofilesize mng ptr pprofile mng ext mng retcode mng decl mng putchunk text mng handle hhandle mng uint ikeywordsize mng pchar zkeyword mng uint itextsize mng pchar ztext mng ext mng retcode mng decl mng putchunk ztxt mng handle hhandle mng uint ikeywordsize mng pchar zkeyword mng uint icompression mng uint itextsize mng pchar ztext mng ext mng retcode mng decl mng putchunk itxt mng handle hhandle mng uint ikeywordsize mng pchar zkeyword mng uint icompressionflag mng uint icompressionmethod mng uint ilanguagesize mng pchar zlanguage mng uint itranslationsize mng pchar ztranslation mng uint itextsize mng pchar ztext mng ext mng retcode mng decl mng putchunk bkgd mng handle hhandle mng bool bempty mng uint itype mng uint iindex mng uint igray mng uint ired mng uint igreen mng uint iblue mng ext mng retcode mng decl mng putchunk phys mng handle hhandle mng bool bempty mng uint isizex mng uint isizey mng uint iunit mng ext mng retcode mng decl mng putchunk sbit mng handle hhandle mng bool bempty mng uint itype mng uint arr abits mng ext mng retcode mng decl mng putchunk splt mng handle hhandle mng bool bempty mng uint inamesize mng pchar zname mng uint isampledepth mng uint ientrycount mng ptr pentries mng ext mng retcode mng decl mng putchunk hist mng handle hhandle mng uint ientrycount mng uint arr aentries mng ext mng retcode mng decl mng putchunk time mng handle hhandle mng uint iyear mng uint imonth mng uint iday mng uint ihour mng uint iminute mng uint isecond mng ext mng retcode mng decl mng putchunk mhdr mng handle hhandle mng uint iwidth mng uint iheight mng uint iticks mng uint ilayercount mng uint iframecount mng uint iplaytime mng uint isimplicity mng ext mng retcode mng decl mng putchunk mend mng handle hhandle mng ext mng retcode mng decl mng putchunk loop mng handle hhandle mng uint ilevel mng uint irepeat mng uint itermination mng uint iitermin mng uint iitermax mng uint icount mng uint p psignals mng ext mng retcode mng decl mng putchunk endl mng handle hhandle mng uint ilevel mng ext mng retcode mng decl mng putchunk defi mng handle hhandle mng uint iobjectid mng uint idonotshow mng uint iconcrete mng bool bhasloca mng int ixlocation mng int iylocation mng bool bhasclip mng int ileftcb mng int irightcb mng int itopcb mng int ibottomcb mng ext mng retcode mng decl mng putchunk basi mng handle hhandle mng uint iwidth mng uint iheight mng uint ibitdepth mng uint icolortype mng uint icompression mng uint ifilter mng uint iinterlace mng uint ired mng uint igreen mng uint iblue mng uint ialpha mng uint iviewable mng ext mng retcode mng decl mng putchunk clon mng handle hhandle mng uint isourceid mng uint icloneid mng uint iclonetype mng uint idonotshow mng uint iconcrete mng bool bhasloca mng uint ilocationtype mng int ilocationx mng int ilocationy ifndef mng skipchunk past mng ext mng retcode mng decl mng putchunk past mng handle hhandle mng uint idestid mng uint itargettype mng int itargetx mng int itargety mng uint icount mng ext mng retcode mng decl mng putchunk past src mng handle hhandle mng uint ientry mng uint isourceid mng uint icomposition mng uint iorientation mng uint ioffsettype mng int ioffsetx mng int ioffsety mng uint iboundarytype mng int iboundaryl mng int iboundaryr mng int iboundaryt mng int iboundaryb endif mng ext mng retcode mng decl mng putchunk disc mng handle hhandle mng uint icount mng uint p pobjectids mng ext mng retcode mng decl mng putchunk back mng handle hhandle mng uint ired mng uint igreen mng uint iblue mng uint imandatory mng uint iimageid mng uint itile mng ext mng retcode mng decl mng putchunk fram mng handle hhandle mng bool bempty mng uint imode mng uint inamesize mng pchar zname mng uint ichangedelay mng uint ichangetimeout mng uint ichangeclipping mng uint ichangesyncid mng uint idelay mng uint itimeout mng uint iboundarytype mng int iboundaryl mng int iboundaryr mng int iboundaryt mng int iboundaryb mng uint icount mng uint p psyncids mng ext mng retcode mng decl mng putchunk move mng handle hhandle mng uint ifirstid mng uint ilastid mng uint imovetype mng int imovex mng int imovey mng ext mng retcode mng decl mng putchunk clip mng handle hhandle mng uint ifirstid mng uint ilastid mng uint icliptype mng int iclipl mng int iclipr mng int iclipt mng int iclipb mng ext mng retcode mng decl mng putchunk show mng handle hhandle mng bool bempty mng uint ifirstid mng uint ilastid mng uint imode mng ext mng retcode mng decl mng putchunk term mng handle hhandle mng uint itermaction mng uint iiteraction mng uint idelay mng uint iitermax mng ext mng retcode mng decl mng putchunk save mng handle hhandle mng bool bempty mng uint ioffsettype mng uint icount mng ext mng retcode mng decl mng putchunk save entry mng handle hhandle mng uint ientry mng uint ientrytype mng uint arr ioffset mng uint arr istarttime mng uint ilayernr mng uint iframenr mng uint inamesize mng pchar zname mng ext mng retcode mng decl mng putchunk seek mng handle hhandle mng uint inamesize mng pchar zname mng ext mng retcode mng decl mng putchunk expi mng handle hhandle mng uint isnapshotid mng uint inamesize mng pchar zname mng ext mng retcode mng decl mng putchunk fpri mng handle hhandle mng uint ideltatype mng uint ipriority mng ext mng retcode mng decl mng putchunk need mng handle hhandle mng uint ikeywordssize mng pchar zkeywords mng ext mng retcode mng decl mng putchunk phyg mng handle hhandle mng bool bempty mng uint isizex mng uint isizey mng uint iunit mng ext mng retcode mng decl mng putchunk jhdr mng handle hhandle mng uint iwidth mng uint iheight mng uint icolortype mng uint iimagesampledepth mng uint iimagecompression mng uint iimageinterlace mng uint ialphasampledepth mng uint ialphacompression mng uint ialphafilter mng uint ialphainterlace mng ext mng retcode mng decl mng putchunk jdat mng handle hhandle mng uint irawlen mng ptr prawdata mng ext mng retcode mng decl mng putchunk jdaa mng handle hhandle mng uint irawlen mng ptr prawdata mng ext mng retcode mng decl mng putchunk jsep  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      jeeps :: 6
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      jaspe :: 5
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       jeep :: 5
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          }
mng handle hhandle mng ext mng retcode mng decl mng putchunk dhdr mng handle hhandle mng uint iobjectid mng uint iimagetype mng uint ideltatype mng uint iblockwidth mng uint iblockheight mng uint iblockx mng uint iblocky mng ext mng retcode mng decl mng putchunk prom mng handle hhandle mng uint icolortype mng uint isampledepth mng uint ifilltype mng ext mng retcode mng decl mng putchunk ipng  {
	                                                             ping :: 6
	                                                            pings :: 5
	                                                            pingo :: 5
                                                                }
mng handle hhandle mng ext mng retcode mng decl mng putchunk pplt mng handle hhandle mng uint ideltatype mng uint icount mng ext mng retcode mng decl mng putchunk pplt entry mng handle hhandle mng uint ientry mng uint ired mng uint igreen mng uint iblue mng uint ialpha mng ext mng retcode mng decl mng putchunk jpng  {
                                                        }
mng handle hhandle mng ext mng retcode mng decl mng putchunk drop mng handle hhandle mng uint icount mng chunkidp pchunknames mng ext mng retcode mng decl mng putchunk dbyk mng handle hhandle mng chunkid ichunkname mng uint ipolarity mng uint ikeywordssize mng pchar zkeywords mng ext mng retcode mng decl mng putchunk ordr mng handle hhandle mng uint icount mng ext mng retcode mng decl mng putchunk ordr entry mng handle hhandle mng uint ientry mng chunkid ichunkname mng uint iordertype mng ext mng retcode mng decl mng putchunk magn mng handle hhandle mng uint ifirstid mng uint ilastid mng uint imethodx mng uint imx mng uint imy mng uint iml mng uint imr mng uint imt mng uint imb mng uint imethody ifdef mng include mpng proposal mng ext mng retcode mng decl mng putchunk mpng mng handle hhandle mng uint iframewidth mng uint iframeheight mng uint inumplays mng uint itickspersec mng uint icompressionmethod mng uint icount mng ext mng retcode mng decl mng putchunk mpng frame mng handle hhandle mng uint ientry mng uint ix mng uint iy mng uint iwidth mng uint iheight mng int ixoffset mng int iyoffset mng uint iticks endif mng ext mng retcode mng decl mng putchunk evnt mng handle hhandle mng uint icount mng ext mng retcode mng decl mng putchunk evnt entry mng handle hhandle mng uint ientry mng uint ieventtype mng uint imasktype mng int ileft mng int iright mng int itop mng int ibottom mng uint iobjectid mng uint iindex mng uint isegmentnamesize mng pchar zsegmentname mng ext mng retcode mng decl mng putchunk unknown mng handle hhandle mng chunkid ichunkname mng uint irawlen mng ptr prawdata endif mng include write procs use these functions to access the actual image data in stored chunks as opposed to the idat jdat data to get accurate pixel data the canvasstyle should seriously  {
	                                                                                                                                                                                                                                                                                                              seriously :: -1000
                                                                                                                                                                                                                                                                                                                      }
reflect the bitdepth colortype combination of the preceding ihdr jhdr basi dhdr all input can be converted to rgb a rgb a for bit images but there are only limited conversions back see below for putimgdata call this function if you want to extract the nth image from the list the first image is designated  {
	                                                  turf :: -1000
                                                     }
seqnr  {
	senor :: 6
 }
this function finds the ihdr jhdr basi dhdr with the appropriate seqnr starting from the beginning of the chunk list this may tend to get a little slow for animations with a large number of chunks for images near the end supplying a seqnr past the last image in the animation will return with an errorcode mng ext mng retcode mng decl mng getimgdata seq mng handle hhandle mng uint iseqnr  {
                                                                     }
mng uint icanvasstyle  {
 }
mng getcanvasline fgetcanvasline  {
 }
both the following functions will search forward to find the first idat jdat and then traverse  {
	       traverse :: -1000
              }
back to find the start of the image ihdr jhdr dhdr basi note that this is very fast compared  {
	          compared :: -1000
                 }
to decoding the idat jdat so there s not really a need for optimization either can be called from the iterate chunks callback when a ihdr jhdr is encountered for basi dhdr there may not be real image data so it s wisest  {
	                                    wisest :: -1000
                                         }
to keep iterating  {
	iterating :: -1000
 }
till  {
	till :: -1000
 }
the iend and then call either of these functions if necessary remember the correct seqnr call this function if you want to extract the image starting at or after the nth position in the chunk list this number is returned in the iterate chunks callback mng ext mng retcode mng decl mng getimgdata chunkseq  {
	                                                chunk :: 10
	                                             chunkier :: 10
	                                            chunkiest :: 11
	                                               chunks :: 12
                                                    }
mng handle hhandle mng uint iseqnr mng uint icanvasstyle mng getcanvasline fgetcanvasline call this function if you want to extract the image starting at or after the indicated chunk the handle of a chunk is returned in the iterate chunks callback mng ext mng retcode mng decl mng getimgdata chunk mng handle hhandle mng handle hchunk mng uint icanvasstyle mng getcanvasline fgetcanvasline ifdef mng include write procs use the following functions to add image data to the list of stored chunks note that this only adds the idat or jdat chunks and no others you must call one of these functions after you put the initial chunks of the image and before you put the closing chunks the canvasstyle should seriously reflect the bitdepth colortype combination eg bitdepth would expect a bit canvasstyle colortype g or ga would expect a gray or gray alpha style respectively and so on and so forth nb the number of conversions will be extremely  {
	                                                                                                                                                      extremely :: -1000
                                                                                                                                                              }
limited for the moment mng ext mng retcode mng decl mng putimgdata ihdr mng handle hhandle mng uint iwidth mng uint iheight mng uint icolortype mng uint ibitdepth mng uint icompression mng uint ifilter mng uint iinterlace mng uint icanvasstyle mng getcanvasline fgetcanvasline mng ext mng retcode mng decl mng putimgdata jhdr mng handle hhandle mng uint iwidth mng uint iheight mng uint icolortype mng uint ibitdepth mng uint icompression mng uint iinterlace mng uint ialphabitdepth  {
                                                                          }
mng uint ialphacompression mng uint ialphafilter mng uint ialphainterlace mng uint icanvasstyle mng getcanvasline fgetcanvasline use the following functions to set the framecount layercount playtime or simplicity of an animation you are creating this may be useful if these variables are calculated during the creation process mng ext mng retcode mng decl mng updatemngheader mng handle hhandle mng uint iframecount mng uint ilayercount mng uint iplaytime mng ext mng retcode mng decl mng updatemngsimplicity  {
                                                                        }
mng handle hhandle mng uint isimplicity endif mng include write procs endif mng access chunks error code structure b xx xxxx xxxx basic errors severity environment b xx xxxx xxxx chunk errors severity image induced  {
	                           induced :: -1000
                                 }
b xx xxxx xxxx severity errors application induced b xx xxxx xxxx severity warnings recoverable b xx xxxx xxxx severity warnings recoverable define mng noerror mng retcode er indicates all s well define mng outofmemory  {
                                 }
mng retcode oops  {
	oops :: -1000
 }
buy  {
	buy :: -1000
 }
some megabytes  {
	megabytes :: -1000
 }
define mng invalidhandle  {
	places :: -1000
 }
mng retcode call mng initialize first define mng nocallback  {
       }
mng retcode set the callbacks please define mng unexpectedeof  {
	unexpectedness :: 17
	unexpected :: 17
       }
mng retcode what d ya  {
	  ya :: -1000
   }
do with the data define mng zliberror  {
     }
mng retcode zlib burped  {
	burped :: -1000
  }
define mng jpegerror  {
 }
mng retcode jpglib  {
 }
complained  {
	complained :: -1000
 }
define mng lcmserror  {
 }
mng retcode little cms stressed  {
	stressed :: -1000
   }
out define mng nooutputprofile  {
  }
mng retcode no output profile defined define mng nosrgbprofile  {
	upcatching :: -1000
       }
mng retcode no srgb profile defined define mng bufoverflow  {
       }
mng retcode zlib output buffer overflow define mng functioninvalid  {
       }
mng retcode ay  {
	bi :: -1000
 }
totally inappropriate define mng outputerror  {
   }
mng retcode disk full define mng jpegbuftoosmall  {
	contessas :: -1000
     }
mng retcode can t handle buffer overflow define mng needmoredata mng retcode i m hungry  {
	        hungry :: -1000
             }
give me more define mng needtimerwait mng retcode sleep  {
	   sleep :: -1000
       }
a while then wake  {
	wake :: -1000
  }
me define mng needsectionwait mng retcode just processed a seek define mng loopwithcacheoff  {
           }
mng retcode loop when playback info off define mng dllnotloaded  {
        }
mng retcode late binding failed define mng appioerror  {
      }
mng retcode application i o error define mng apptimererror  {
       }
mng retcode application timing error define mng appcmserror  {
      }
mng retcode application cms error define mng appmiscerror  {
      }
mng retcode application other error define mng apptraceabort  {
      }
mng retcode application aborts on trace define mng internalerror  {
       }
mng retcode internal inconsistancy  {
	inconsistences :: 17
	inconsistently :: 16
	inconstancies :: 17
	inconsistence :: 20
	inconsistency :: 23
	inconsistent :: 16
  }
define mng invalidsig  {
	vitalising :: 12
	rivalising :: 13
	idealising :: 13
	invalids :: 14
	invalidity :: 13
	invalidism :: 15
	invalidish :: 15
	invalidisms :: 14
 }
mng retcode invalid graphics file define mng invalidcrc  {
	invalids :: 13
      }
mng retcode crc check failed define mng invalidlength  {
      }
mng retcode chunklength mystifies  {
	mystifies :: -1000
  }
me define mng sequenceerror  {
  }
mng retcode invalid chunk sequence define mng chunknotallowed  {
      }
mng retcode completely out of place define mng multipleerror  {
	multiplexor :: 16
	multiplexer :: 17
	multiplexers :: 16
       }
mng retcode only one occurence  {
	occurrences :: 11
	occupances :: 11
	occurrence :: 12
	securance :: 11
	occupance :: 12
   }
allowed define mng pltemissing  {
  }
mng retcode indexed color requires plte define mng idatmissing  {
       }
mng retcode ihdr block requires idat define mng cannotbeempty  {
       }
mng retcode must contain some data define mng globallengtherr  {
       }
mng retcode global data incorrect define mng invalidbitdepth  {
      }
mng retcode bitdepth out of range define mng invalidcolortype  {
       }
mng retcode colortype out of range define mng invalidcompress  {
       }
mng retcode compression method invalid define mng invalidfilter  {
      }
mng retcode filter method invalid define mng invalidinterlace  {
      }
mng retcode interlace method invalid define mng notenoughidat  {
      }
mng retcode ran out of compressed data define mng plteindexerror  {
        }
mng retcode palette index out of range define mng nullnotfound  {
        }
mng retcode couldn  {
	could :: 10
	cloud :: 7
	cauld :: 7
	columned :: 7
	couldst :: 8
	cotland :: 7
	cauldron :: 8
	column :: 7
	codlin :: 8
	cauldrons :: 7
	would :: 7
	codlins :: 7
	codling :: 7
	louden :: 7
	couldest :: 7
	nould :: 9
	mould :: 7
 }
t find null separator define mng keywordnull  {
	keyword :: 14
     }
mng retcode keyword cannot be empty define mng objectunknown  {
       }
mng retcode the object can t be found define mng objectexists  {
	objectivists :: 17
         }
mng retcode the object already exists define mng toomuchidat  {
       }
mng retcode got too much compressed data define mng invsampledepth  {
        }
mng retcode sampledepth  {
 }
out of range define mng invoffsetsize  {
    }
mng retcode invalid offset size define mng inventrytype  {
      }
mng retcode invalid entry type define mng endwithnull  {
      }
mng retcode may not end with null define mng invimagetype  {
        }
mng retcode invalid image type define mng invdeltatype  {
      }
mng retcode invalid delta type define mng invalidindex  {
      }
mng retcode index value invalid define mng toomuchjdat  {
      }
mng retcode got too much compressed data define mng jpegparmserr  {
        }
mng retcode jhdr jpeg parms do not match define mng invfillmethod  {
         }
mng retcode invalid fill method define mng objnotconcrete  {
      }
mng retcode object must be concrete  {
	concrete :: -1000
    }
define mng targetnoalpha  {
 }
mng retcode object has no alpha channel define mng mngtoocomplex  {
        }
mng retcode can t handle complexity  {
	complexity :: -1000
    }
define mng unknowncritical  {
 }
mng retcode unknown critical chunk found define mng unsupportedneed  {
	unsupported :: 19
       }
mng retcode need requirement unsupported define mng invaliddelta  {
	invalidated :: 17
	invalidate :: 15
      }
mng retcode delta operation illegal define mng invalidmethod  {
	invalided :: 16
      }
mng retcode invalid magn method define mng improbablelength  {
      }
mng retcode impropable  {
	improvable :: 16
	improvably :: 13
	approvable :: 12
	impalpable :: 14
	improperly :: 12
	ombrophile :: 12
	improbable :: 16
	improbably :: 13
	impartable :: 12
	importable :: 14
 }
chunk length define mng invalidblock  {
   }
mng retcode invalid delta block define mng invalidevent  {
      }
mng retcode invalid event type define mng invalidmask  {
	invalidates :: 14
	invalids :: 14
      }
mng retcode invalid mask type define mng nomatchingloop  {
      }
mng retcode endl without matching loop define mng seeknotfound  {
       }
mng retcode evnt points to unknown seek define mng objnotabstract  {
        }
mng retcode object must be abstract define mng termseqerror  {
       }
mng retcode term in wrong place define mng invalidfieldval  {
	   aulos :: -1000
       }
mng retcode invalid fieldvalue  {
  }
generic define mng invalidwidth  {
  }
mng retcode invalid frame image width define mng invalidheight  {
       }
mng retcode invalid frame image height define mng invalidcnvstyle  {
       }
mng retcode can t make anything of this define mng wrongchunk  {
         }
mng retcode accessing  {
	accessing :: -1000
 }
the wrong chunk define mng invalidentryix  {
    }
mng retcode accessing the wrong entry define mng noheader  {
	threaden :: 10
	coleader :: 10
       }
mng retcode must have had header first define mng nocorrchunk  {
        }
mng retcode can t find parent chunk define mng nomhdr  {
	    nomad :: 7
        }
mng retcode no mng header available define mng imagetoolarge  {
       }
mng retcode input image way too big define mng notananimation  {
	interanimation :: 18
        }
mng retcode file not a mng define mng framenrtoohigh  {
       }
mng retcode frame nr out of range define mng layernrtoohigh  {
        }
mng retcode layer nr out of range define mng playtimetoohigh  {
        }
mng retcode playtime out of range define mng fnnotimplemented  {
	 crazies :: -1000
       }
mng retcode function not yet available define mng imagefrozen  {
       }
mng retcode stopped displaying define mng lcms nohandle  {
	rehandle :: 10
	unhandled :: 10
      }
lcms returned null handle define mng lcms nomem lcms returned null gammatab define mng lcms notrans  {
	        rottans :: 9
	        patrons :: 9
	        matrons :: 9
	         natron :: 10
	        introns :: 9
	        natrons :: 12
	        nations :: 9
	        normans :: 10
	        nonwars :: 9
	        nonarts :: 10
	        latrons :: 9
              }
lcms returned null transform canvas styles note that the intentions  {
	intentions :: -1000
        }
are pretty darn good but that the focus  {
	  focus :: -1000
      }
is currently on bit color support the rgb a style is defined for apps that require a separate canvas for the color planes  {
	                planes :: -1000
                     }
and the alpha plane eg mozilla this requires for the app to supply the getalphaline callback define mng canvas rgb x l define mng canvas rgba x l define mng canvas rgba pm x l define mng canvas argb x l define mng canvas argb pm x b l define mng canvas rgb a x l define mng canvas bgr x l define mng canvas bgrx x l define mng canvas bgra x l define mng canvas bgra pm x l backward compatibility define mng canvas bgra pm x l define mng canvas abgr x l define mng canvas abgr pm x b l define mng canvas rgb x l not supported yet define mng canvas rgba x l not supported yet define mng canvas argb x l not supported yet define mng canvas bgr x l not supported yet define mng canvas bgra x l not supported yet define mng canvas abgr x l not supported yet define mng canvas gray x l not supported yet define mng canvas gray x l not supported yet define mng canvas graya x l not supported yet define mng canvas graya x l not supported yet define mng canvas agray  {
	                                                                                                                                                                                             arraying :: 6
	                                                                                                                                                                                                array :: 7
	                                                                                                                                                                                                agria :: 6
	                                                                                                                                                                                               arrays :: 6
	                                                                                                                                                                                               angary :: 6
	                                                                                                                                                                                                 agar :: 6
                                                                                                                                                                                                    }
x l not supported yet define mng canvas agray x l not supported yet define mng canvas dx x l not supported yet define mng canvas dx x l not supported yet define mng canvas rgb x l define mng canvas rgba x l define mng canvas bgr x l define mng canvas bgra x l define mng canvas bgr a x l define mng canvas rgb x l define mng canvas bgr x l define mng canvas pixeltype c c x ffl  {
	                                                                                lf :: 3
                                                                                 }
define mng canvas bitdepth c c x l define mng canvas hasalpha  {
	   halavahs :: 10
	   halalahs :: 11
	   halakahs :: 10
	    halalah :: 10
          }
c c x l define mng canvas alphafirst  {
      }
c c x l define mng canvas alphasepd  {
	 alphas :: 11
      }
c c x l define mng canvas alphapm  {
	  alpha :: 9
      }
c c x l define mng canvas hasfiller  {
	halflives :: 11
      }
c c x l define mng canvas rgb c mng canvas pixeltype c define mng canvas bgr c mng canvas pixeltype c define mng canvas gray c mng canvas pixeltype c define mng canvas directx  {
	                           directs :: 11
	                            direct :: 12
	                          director :: 9
	                          directly :: 10
	                         directrix :: 9
                                 }
c mng canvas pixeltype c define mng canvas directx c mng canvas pixeltype c define mng canvas rgb c mng canvas pixeltype c define mng canvas bgr c mng canvas pixeltype c define mng canvas bit c mng canvas bitdepth c define mng canvas bit c mng canvas bitdepth c define mng canvas pixelfirst  {
	                                            godmother :: -1000
                                                    }
c mng canvas alphafirst c chunk names idea adapted from libpng png h define mng uint huh  {
	             huh :: -1000
               }
x l define mng uint back x bl define mng uint basi x l define mng uint clip x c l define mng uint clon x c f el define mng uint dbyk x bl define mng uint defi x l define mng uint dhdr x l define mng uint disc x l define mng uint drop x f l define mng uint endl x e cl define mng uint fram x dl define mng uint idat x l define mng uint iend x e l define mng uint ihdr x l define mng uint ijng  {
	                                                                                          jingo :: 5
                                                                                              }
x a e l define mng uint ipng x e l define mng uint jdaa x a l define mng uint jdat x a l define mng uint jhdr x a l define mng uint jsep x a l define mng uint jdaa x a l define mng uint loop x c f f l define mng uint magn x d el define mng uint mend x d e l define mng uint mhdr x d l define mng uint move x d f l define mng uint ordr x f l define mng uint past x l define mng uint plte x c l define mng uint pplt x c l define mng uint prom x f dl define mng uint save x l define mng uint seek x bl define mng uint show x f l define mng uint term x dl define mng uint adat  {
	                                                                                                                                              adyta :: 6
	                                                                                                                                              adapt :: 6
	                                                                                                                                             amated :: 5
	                                                                                                                                             alated :: 5
	                                                                                                                                             adapts :: 5
	                                                                                                                                             abated :: 5
	                                                                                                                                               adaw :: 5
	                                                                                                                                               adas :: 5
	                                                                                                                                                ata :: 5
	                                                                                                                                                ada :: 6
                                                                                                                                                  }
x l define mng uint ahdr  {
	hydra :: 5
	chard :: 5
	shard :: 5
    }
x l define mng uint bkgd x b l define mng uint chrm x dl define mng uint expi x l define mng uint evnt x e l define mng uint fpri x l define mng uint gama x d l define mng uint hist x l define mng uint iccp x l define mng uint itxt x l define mng uint mpng x d e l define mng uint need x e l define mng uint offs x f l define mng uint pcal  {
	                                                                              scalps :: 5
	                                                                                pial :: 5
	                                                                               scalp :: 6
	                                                                                clap :: 5
	                                                                               plack :: 5
	                                                                               place :: 5
                                                                                   }
x cl define mng uint phyg x l define mng uint phys x l define mng uint sbit x l define mng uint scal x cl define mng uint splt x c l define mng uint srgb x l define mng uint text x l define mng uint time x d l define mng uint trns x e l define mng uint ztxt x a l chunk property values define mng bitdepth ihdr basi jhdr prom define mng bitdepth define mng bitdepth define mng bitdepth splt define mng bitdepth define mng colortype gray ihdr basi prom define mng colortype rgb define mng colortype indexed define mng colortype graya define mng colortype rgba define mng compression deflate  {
	                                                                                                            deflate :: -1000
                                                                                                                  }
ihdr ztxt itxt iccp basi jhdr define mng filter adaptive  {
	 adaptive :: -1000
        }
ihdr basi jhdr define mng filter no adaptive define mng filter no differing  {
	   differing :: -1000
           }
define mng filter differing x define mng filter mask mng filter no adaptive mng filter differing ifdef filter define mng filter differing xc endif ifdef filter define mng filter nofilter  {
	                     refilter :: 10
	                     notifier :: 10
	                     infolder :: 10
	                     inflater :: 10
	                     infilter :: 12
	                    infilters :: 11
                            }
xc endif define mng interlace none ihdr basi jhdr define mng interlace adam  {
	       adman :: 5
	      aramid :: 5
	        adaw :: 5
	        adas :: 5
	         ama :: 5
	         ada :: 6
           }
define mng filter none idat define mng filter sub define mng filter up define mng filter average  {
	         average :: -1000
               }
define mng filter paeth  {
	haets :: 6
	pantheon :: 6
	panthers :: 6
	earth :: 6
	patched :: 6
	patches :: 6
	patcher :: 6
	plethora :: 6
	panther :: 7
	phat :: 6
	peat :: 6
	path :: 6
	pate :: 6
	hapten :: 6
	haet :: 7
	spathe :: 6
	pieta :: 6
	patte :: 6
	paste :: 6
	patch :: 6
  }
define mng intent perceptual srgb define mng intent relativecolorimetric  {
       }
define mng intent saturation define mng intent absolutecolorimetric  {
      }
text ztxt itxt define mng text title title define mng text author author define mng text description description define mng text copyright copyright define mng text creationtime  {
	              creationisms :: 15
	              creationists :: 15
	               creationist :: 16
	               creationism :: 16
                         }
creation time define mng text software software define mng text disclaimer disclaimer define mng text warning warning define mng text source source define mng text comment comment define mng flag uncompressed  {
	                incompressible :: 15
	                    decompress :: 17
	                    recompress :: 15
	                  decompressed :: 18
	                  decompresses :: 15
	                 decompressing :: 16
	                 decompression :: 15
                             }
itxt define mng flag compressed define mng unit unknown phys phyg define mng unit meter mhdr define mng simplicity valid x define mng simplicity simplefeatures  {
                       }
x define mng simplicity complexfeatures  {
	counterexamples :: 19
   }
x define mng simplicity transparency x define mng simplicity jng x define mng simplicity deltapng  {
	         delta :: 10
	        dental :: 10
	      delating :: 11
             }
x define mng termination decoder nc loop define mng termination user nc define mng termination external nc define mng termination deterministic  {
	       deterministic :: -1000
                   }
nc define mng termination decoder c define mng termination user c define mng termination external c define mng termination deterministic c define mng donotshow  {
	                charkha :: -1000
                      }
visible defi define mng donotshow notvisible  {
	ostensible :: 12
	notifiable :: 12
    }
define mng abstract defi define mng concrete define mng notviewable  {
        }
basi define mng viewable  {
	viewable :: -1000
  }
define mng full clone  {
	clone :: -1000
  }
clon define mng partial clone define mng renumber  {
	renumber :: -1000
      }
define mng concrete asparent  {
	asperating :: 10
	atraments :: 10
	paraments :: 11
	coparent :: 10
	aspirate :: 10
	asperate :: 10
	coparents :: 11
	apparent :: 13
	armaments :: 10
	apparently :: 11
	parament :: 10
	aspirants :: 10
  }
clon define mng concrete makeabstract  {
	semiabstract :: 16
   }
define mng location absolute clon move define mng location relative ifndef mng skipchunk past define mng target absolute past define mng target relative samepast  {
                      }
define mng target relative prevpast  {
	prestamp :: 10
	preadapts :: 10
	overpast :: 11
   }
define mng composite  {
	composite :: -1000
 }
over past define mng composite replace define mng composite under define mng orientation  {
	 orientation :: -1000
           }
same past define mng orientation deg define mng orientation fliphorz  {
        }
define mng orientation flipvert  {
	flivvers :: 10
	flivver :: 11
	flitter :: 10
	flirter :: 10
	flipper :: 10
  }
define mng orientation tiled  {
	tiled :: -1000
  }
define mng offset absolute past define mng offset relative endif define mng boundary absolute past fram define mng boundary relative define mng backgroundcolor  {
                     }
mandatory x back define mng backgroundimage  {
	backgrounding :: 20
    }
mandatory x back define mng backgroundimage notile  {
	untile :: 8
	polite :: 7
	doline :: 7
	retinol :: 7
	noticers :: 7
	motile :: 9
	moline :: 7
	noteless :: 7
	coteline :: 7
	untiled :: 7
	untiles :: 7
	potline :: 7
	toxine :: 7
	tonite :: 7
	motiles :: 8
	novelist :: 7
	etoile :: 7
	noticeably :: 7
	pointel :: 7
	citole :: 7
	entoil :: 7
	noticed :: 8
	notices :: 8
	noticer :: 8
	notelet :: 7
	notchel :: 7
	noselite :: 7
	  note :: 7
	  loti :: 7
	norites :: 7
	hotline :: 7
	notice :: 9
	 notal :: 7
	norite :: 8
     }
back define mng backgroundimage tile define mng framingmode  {
      }
nochange  {
	rechange :: 10
	unchanged :: 11
 }
fram define mng framingmode define mng framingmode define mng framingmode define mng framingmode define mng changedelay  {
	     changeably :: 14
              }
no fram define mng changedelay nextsubframe  {
    }
define mng changedelay default define mng changetimout  {
     }
no fram define mng changetimout deterministic define mng changetimout deterministic define mng changetimout decoder define mng changetimout decoder define mng changetimout user define mng changetimout user define mng changetimout external define mng changetimout external define mng changeclipping  {
	                          putrefying :: -1000
                                   }
no fram define mng changeclipping nextsubframe define mng changeclipping default define mng changesyncid  {
           }
no fram define mng changesyncid nextsubframe define mng changesyncid default define mng clipping absolute clip define mng clipping relative define mng showmode  {
	            shopwomen :: 10
                    }
show define mng showmode define mng showmode define mng showmode define mng showmode define mng showmode define mng showmode define mng showmode define mng termaction  {
	              maceration :: 12
	             extractions :: 13
	              cameration :: 12
	              trajection :: 14
	              racemation :: 12
	              terminator :: 12
	             detractions :: 14
	              abreaction :: 13
	              overaction :: 12
	              refraction :: 13
	              retraction :: 15
	               tormentil :: 12
	              extraction :: 14
	              attraction :: 12
	              detraction :: 15
	               geomantic :: 12
	              recitation :: 13
	              traduction :: 12
	              arefaction :: 12
	              eructation :: 12
	             refractions :: 12
	             retractions :: 14
	             recitations :: 12
	             abreactions :: 12
	              trisection :: 12
	              permeation :: 12
	             trajections :: 13
                       }
lastframe  {
	pastorale :: 11
 }
term define mng termaction clear define mng termaction firstframe  {
	airstream :: 13
       }
define mng termaction repeat define mng iteraction  {
	literation :: 12
	extractions :: 14
	acieration :: 12
	cineration :: 12
	trajection :: 13
	attractions :: 12
	precaution :: 12
	detractions :: 14
	iteration :: 14
	iterating :: 12
	abreaction :: 12
	overaction :: 14
	overacting :: 12
	infraction :: 14
	refraction :: 13
	retraction :: 15
	extraction :: 15
	attraction :: 13
	detraction :: 15
	acervation :: 12
	recitation :: 14
	overactions :: 13
	excitation :: 12
	infractions :: 13
	iterant :: 12
	prediction :: 12
	arefaction :: 13
	urtication :: 12
	practitioner :: 12
	eructation :: 12
	intricate :: 12
	refractions :: 12
	retractions :: 14
	iterations :: 13
	recitations :: 13
	infarction :: 12
	sternitic :: 12
	trisection :: 13
	astriction :: 14
	trajections :: 12
	trisections :: 12
     }
lastframe term define mng iteraction clear define mng iteraction firstframe define mng saveoffset  {
	    waveoffs :: 12
           }
byte save define mng saveoffset byte define mng saveentry  {
	taverner :: 11
	  sateen :: 11
	taverners :: 12
	servantry :: 12
	septenary :: 12
	earnestly :: 11
	serpentry :: 11
       }
segmentfull  {
	neglectfully :: 14
	neglectful :: 14
	segmental :: 14
	segmentally :: 14
	segment :: 14
 }
save define mng saveentry segment define mng saveentry subframe  {
	subframe :: -1000
       }
define mng saveentry exportedimage  {
  }
define mng priority absolute fpri define mng priority relative ifdef mng include jng define mng colortype jpeggray  {
               }
jhdr define mng colortype jpegcolor  {
   }
define mng colortype jpeggraya  {
  }
define mng colortype jpegcolora  {
  }
define mng bitdepth jpeg jhdr define mng bitdepth jpeg define mng bitdepth jpeg and define mng compression baselinejpeg  {
                }
jhdr define mng interlace sequential jhdr define mng interlace progressive endif mng include jng define mng imagetype unknown dhdr define mng imagetype png define mng imagetype jng define mng deltatype  {
	                       quoins :: -1000
                            }
replace dhdr define mng deltatype blockpixeladd  {
    }
define mng deltatype blockalphaadd  {
  }
define mng deltatype blockcoloradd  {
  }
define mng deltatype blockpixelreplace  {
  }
define mng deltatype blockalphareplace  {
  }
define mng deltatype blockcolorreplace  {
  }
define mng deltatype nochange define mng fillmethod  {
     }
leftbitreplicate  {
 }
prom define mng fillmethod zerofill  {
	overfill :: 10
   }
define mng deltatype replacergb  {
	replacers :: 15
	replace :: 13
	rebrace :: 12
	replaces :: 12
	replacer :: 16
	replaced :: 12
  }
pplt define mng deltatype deltargb  {
	delta :: 10
	belgard :: 11
   }
define mng deltatype replacealpha  {
  }
define mng deltatype deltaalpha  {
  }
define mng deltatype replacergba  {
	replacers :: 14
	replacer :: 15
  }
define mng deltatype deltargba  {
  }
define mng polarity  {
	polarity :: -1000
 }
only dbyk define mng polarity allbut  {
	ballute :: 7
	ablaut :: 7
    }
define mng event none evnt define mng event mouseenter  {
	documenter :: 12
	moistener :: 12
	rousement :: 12
	documenters :: 13
	mounseer :: 12
       }
define mng event mousemove  {
  }
define mng event mouseexit  {
	defencemen :: -1000
  }
define mng event mousedown  {
	moused :: 11
	closedown :: 11
  }
define mng event mouseup  {
	mouse :: 9
  }
define mng mask none evnt define mng mask box  {
	     box :: -1000
       }
define mng mask object define mng mask objectix  {
	objective :: 11
	objecting :: 12
	objection :: 11
	objectify :: 12
	abjection :: 11
	bijection :: 10
	objects :: 11
	 object :: 12
	objectives :: 10
	objections :: 10
	abjections :: 10
      }
define mng mask boxobject  {
  }
define mng mask boxobjectix  {
  }
processtext callback types define mng type text define mng type ztxt define mng type itxt crc processing masks define mng crc input x f define mng crc input none x define mng crc input present x define mng crc output x f define mng crc output none x define mng crc output generate x define mng crc output dummy x define mng crc ancillary x f define mng crc ancillary ignore x define mng crc ancillary discard x define mng crc ancillary warning x define mng crc ancillary error x define mng crc critical x f define mng crc critical ignore x define mng crc critical warning x define mng crc critical error x define mng crc default x ifdef cplusplus endif endif libmng h end of file for conditions of distribution and use see copyright notice in libmng h project libmng file libmng types h copyright c g juyn version purpose type specifications  {
	                                                                                                                                           specifications :: -1000
                                                                                                                                                        }
author g juyn comment specification of the types used by the library creates platform independant  {
	       matcher :: -1000
             }
structure changes g juyn added iteratechunk callback definition g juyn improved  {
	  improved :: -1000
         }
definitions for dll support added bit palette definition added general array definitions added mng null definition changed strict ansi stuff g juyn changed most callback prototypes to allow the app to report errors during callback processing g juyn moved standard header includes into this file stdlib mem for mem mngmt  {
                                                }
math for fp gamma calc g juyn b fixed problem with mem h being proprietary  {
	   proprietary :: -1000
             }
to borland platform added helper definitions for jng ijg based fixed support for ijgsrc b g juyn added default ijg compression parameters and such g juyn fixed inclusion for memcpy contributed by tim rowley added mng int p contributed by tim rowley g juyn removed swap endian reference contributed by tim rowley added getalphaline callback for rgb a canvasstyle g juyn added speedtype to facilitate testing g juyn added typedef for mng size t changed size parameter for memory callbacks to mng size t g juyn changed definition of bit ints bit platforms changed definition of mng handle bit platforms g juyn changed definition of mng handle again swapped refresh parameters added inclusion of stdlib h for abs g juyn changed refresh parameters to x y width height g juyn added suspendbuffer  {
                                                                                                                                  }
constants g juyn added callbacks for save seek processing g juyn changed file prefixes g juyn b fixup for improved portability g juyn added workaround for faulty photoshop iccp chunk g juyn added export of zlib functions from windows dll fixed inclusion parameters once again to make those external libs work together re fixed fixed inclusion parameters these freeking  {
	                                                  rekeying :: 10
	                                                  smeeking :: 10
	                                                  franking :: 10
	                                                fleeringly :: 10
	                                                 fleerings :: 11
	                                                  foreking :: 12
	                                                  steeking :: 10
	                                                   freeing :: 11
	                                                 forekings :: 11
	                                                  frocking :: 10
	                                                  cheeking :: 10
	                                                  frisking :: 10
	                                                  breezing :: 10
	                                                  freezing :: 13
	                                                  greeting :: 10
	                                                  creesing :: 10
	                                                  greesing :: 10
	                                                  kreesing :: 12
	                                                  creeping :: 10
	                                                  greening :: 10
	                                                  preening :: 10
	                                                  creeling :: 10
	                                                  breeding :: 10
	                                                  fleeting :: 10
	                                                  freaking :: 12
	                                                  cleeking :: 10
	                                                  gleeking :: 10
	                                                  sleeking :: 10
	                                                  fleecing :: 10
	                                                freezingly :: 11
	                                                freakiness :: 10
	                                                  friezing :: 10
                                                         }
libraries make me mad g juyn added support for need g juyn added callback to process non critical unknown chunks r giles  {
	               silage :: 6
	               gimels :: 7
	               gilets :: 8
	               gibels :: 7
	                isles :: 6
	                idles :: 6
	               bilges :: 6
	                glues :: 6
	                glees :: 6
	                gives :: 7
	                gites :: 7
	                girls :: 6
	                gimel :: 6
	                gilts :: 7
	                gills :: 6
	                gilet :: 7
	                gilds :: 7
	                gilas :: 7
	                gibes :: 7
	                gibel :: 6
	                gelts :: 6
	                gelds :: 6
	                gales :: 7
	                files :: 7
	                biles :: 7
	              gilders :: 6
	              kilergs :: 6
	                wiles :: 7
	               vilest :: 6
	                tiles :: 7
	                tiges :: 6
	               grilse :: 6
	                 sile :: 7
	                silex :: 6
	                siles :: 7
	                siler :: 6
	                silen :: 6
	                siled :: 6
	                 isle :: 6
	                 gies :: 6
	                 gels :: 6
	                riles :: 7
	                piles :: 7
	                ogles :: 6
	               ligers :: 6
	               ligase :: 6
	                miles :: 7
	                lives :: 6
	                lites :: 6
	                lines :: 6
	                limes :: 6
	                likes :: 6
                    }
fixed inclusion of lcms header for non windows platforms g juyn changed callback convention for msvc thanks chad g juyn fixed mixup  {
	                mixup :: -1000
                    }
of data function pointers thanks dimitri  {
	dimities :: 9
	dimetric :: 9
    }
g juyn added mend processing callback g juyn added processterm callback g juyn changed inclusion of lcms h for linux platforms g juyn b libmng pollutes  {
	                 pollutes :: -1000
                        }
the linker namespace g juyn b fixed several mng app cms problems r giles lcms h inclusion is generally no longer prefixed g r p added png imgtypes  {
	                 unworthily :: -1000
                          }
enumeration g r p added conditionals around openstream closestream g juyn added data push mechanisms for specialized decoders g juyn added support for byte pixelsize for jpeg s g juyn inclusion of zlib lcms ijgsrc b with instead of g juyn added conditional mng optimize chunkreader  {
                                            }
g juyn added support for mpng proposal g juyn added support for ang proposal ifndef libmng types h define libmng types h ifdef borlandc pragma option at turn off strict ansi c for the moment endif ifndef win if defined win defined win defined windows defined windows define win gather them into a single define endif endif here s where the external standard libs are embedded it can be a bit of a pain in the lower back to get them to work together ifdef win only include needed stuff ifndef win lean and mean define win lean and mean endif endif ifdef mng use dll ifdef mng skip zlib undef mng include zlib endif ifdef mng skip lcms undef mng include lcms endif ifdef mng skip ijg b undef mng include ijg b endif endif ifdef mng include zlib zlib by mark adler  {
	                                                                                                                                          lader :: 7
	                                                                                                                                          haler :: 6
	                                                                                                                                        allured :: 6
	                                                                                                                                         laders :: 6
	                                                                                                                                         aulder :: 6
	                                                                                                                                         ndlers :: 6
	                                                                                                                                          axled :: 6
	                                                                                                                                          arles :: 6
	                                                                                                                                          arled :: 8
	                                                                                                                                          baler :: 6
	                                                                                                                                          alter :: 6
	                                                                                                                                          alder :: 8
	                                                                                                                                          ailed :: 6
	                                                                                                                                          aider :: 6
	                                                                                                                                          adder :: 6
	                                                                                                                                          abler :: 7
	                                                                                                                                         idlers :: 6
	                                                                                                                                         alders :: 7
	                                                                                                                                         aldern :: 7
	                                                                                                                                         advert :: 6
	                                                                                                                                         adverb :: 6
	                                                                                                                                          waler :: 6
	                                                                                                                                         enlard :: 6
	                                                                                                                                          taler :: 6
	                                                                                                                                           rale :: 6
	                                                                                                                                           dale :: 6
	                                                                                                                                           arle :: 7
	                                                                                                                                          paler :: 6
	                                                                                                                                          ndler :: 7
                                                                                                                                              }
jean  {
	jean :: -1000
 }
loup  {
	loup :: -1000
 }
gailly  {
	grill :: 7
	glial :: 8
	lazily :: 7
	gally :: 7
	gaily :: 8
	laidly :: 8
	lacily :: 7
	gamily :: 8
	galley :: 7
	gainly :: 9
	agilely :: 7
	railly :: 9
	cagily :: 7
	gluily :: 7
	glibly :: 8
	gladly :: 7
	maill :: 7
 }
include zlib h endif ifdef mng include lcms little cms by marti maria saguer  {
	       eagres :: 7
	      saugers :: 8
	      sugared :: 7
	      baguets :: 7
	       saurel :: 7
	       sauger :: 10
	       saucer :: 8
	       sanger :: 8
	       gauper :: 7
	       gauger :: 7
	       gaufer :: 7
	       gaster :: 7
	       gasser :: 7
	       gasper :: 7
	       gasher :: 7
	       sagier :: 9
	       augers :: 7
	       sagger :: 8
	        argus :: 7
	        argue :: 8
	       rogues :: 7
	       argues :: 9
	       arguer :: 8
	       argued :: 7
	      valuers :: 7
	      gaupers :: 8
	      gaugers :: 8
	      gaufers :: 8
	      vaguest :: 7
	       pauser :: 7
	      saguaro :: 7
	      voguers :: 7
	      magueys :: 7
	       ragees :: 7
	       swager :: 7
	       surger :: 7
	       suaver :: 7
	      ungears :: 7
	       stager :: 7
	        vague :: 7
	      arguses :: 7
	      arguers :: 9
	        surge :: 7
	        sugar :: 7
	      usagers :: 7
	         sage :: 7
	        segue :: 7
	        rugae :: 7
	        salue :: 7
	        sagum :: 7
	        sager :: 8
	        rages :: 7
	       causer :: 7
	       usager :: 8
	       vagues :: 8
	       vaguer :: 9
            }
ifndef zlib dll undef far endif if defined win defined linux defined gnu defined freebsd kernel different header locations  {
	         locations :: -1000
                 }
include lcms h else include lcms lcms h endif endif mng include lcms ifdef mng include ijg b ijg s jpgsrc b include stdio h ifdef mng use setjmp include setjmp h needed for error recovery blergh  {
                                   }
else ifdef win define use windows messagebox  {
	messaged :: 13
	message :: 14
     }
display a messagebox under windoze  {
	zincode :: 9
	windore :: 11
   }
endif endif mng use setjmp ifdef far undef far possibly defined by zlib or lcms endif define jpeg internal options for rgb pixelsize include jpeglib h all that for jpeg support endif mng include ijg b if defined mng internal memmngmt defined mng include filters include stdlib h calloc free abs endif include limits h get proper integer widths  {
	                                                    widths :: -1000
                                                         }
ifdef win if defined borlandc include mem h defines memcpy for bcb  {
	        arr :: -1000
          }
else include memory h defines memcpy for other win platforms endif include string h strncmp  {
             }
strcmp  {
	scrump :: 8
	scrimp :: 8
	stramps :: 7
	scrimpit :: 8
	scrumpy :: 7
	scrimpy :: 7
	stramp :: 9
	strum :: 7
	stramped :: 7
 }
else win ifdef bsd include strings h defines memcpy etc for bsd else include string h defines memcpy etc for all others endif endif win if defined mng full cms defined mng gamma only defined mng app cms include math h fp gamma calculation endif platform dependant  {
	                                     dependant :: -1000
                                             }
stuff todo this may require some elaboration  {
	elaboration :: -1000
     }
for other platforms only works with bcb for now ifndef mng dll if defined mng build dll defined mng use dll define mng dll endif endif define mng local static if defined mng dll defined win setup dll calling conventions define mng decl stdcall if defined mng build dll define mng ext declspec dllexport elif defined mng use dll define mng ext declspec dllimport else define mng ext endif ifdef mng strict ansi undef mng strict ansi can t do strict ansi with this dll stuff endif else define mng decl dummies  {
	                                                                                    dummies :: -1000
                                                                                          }
for non dll define mng ext endif mng dll win if defined borlandc defined mng strict ansi pragma option a now force ansi c from here on endif if ushrt  {
	                        hurst :: 6
	                        usher :: 6
                            }
max xffffffffu  {
 }
get the proper bit width typedef unsigned short mng uint typedef signed short mng int elif uint max xffffffffu typedef unsigned int mng uint typedef signed int mng int elif ulong  {
	                         klong :: 7
	                         gluon :: 6
	                         flung :: 6
	                         flong :: 7
	                         clung :: 6
	                        klongs :: 6
	                         along :: 7
	                        flongs :: 6
	                       blowgun :: 6
	                        loungy :: 6
	                        lounge :: 6
	                         slung :: 6
                             }
max xffffffffu typedef unsigned long mng uint typedef signed long mng int else error sorry i can t find any bit integers on this platform endif typedef signed short mng int other basic integers typedef unsigned short mng uint typedef signed char mng int typedef unsigned char mng uint typedef double mng float basic float typedef size t mng size t size field for memory allocation typedef char mng pchar string typedef void mng ptr generic pointer typedef void mng fptr void generic function pointer platform independant from here typedef mng uint mng uint p pointer to unsigned longs  {
	                                                                                             longs :: -1000
                                                                                                 }
typedef mng int mng int p pointer to longs typedef mng uint mng uint p pointer to unsigned words typedef mng uint mng uint p pointer to unsigned bytes typedef mng int mng bool booleans struct mng data struct typedef struct mng data struct mng handle generic handle typedef mng int mng retcode generic return code typedef mng int mng chunkid byte chunkname  {
                                                             }
identifier typedef mng ptr mng chunkp  {
	clunk :: 7
	chunk :: 10
	chink :: 7
	chank :: 7
	chunkily :: 7
	chunkier :: 7
	chunky :: 9
	chunks :: 9
	thunk :: 7
    }
pointer to a chunk structure typedef mng ptr mng objectp  {
	objecting :: 9
	objectify :: 9
	 objected :: 9
	   abject :: 9
	  objects :: 11
	   obtect :: 9
	   object :: 12
	    objet :: 9
        }
pointer to an object structure typedef mng chunkid mng chunkidp pointer to chunkid typedef struct bit palette element mng uint ired mng uint igreen mng uint iblue mng palette e typedef mng palette e mng palette bit palette typedef mng palette e mng palette ep typedef mng uint mng uint arr generic arrays typedef mng uint mng uint arr typedef mng uint mng uint arr typedef mng uint mng uint arr define mng false define mng true define mng null define mng suspendbuffersize  {
                                                                                 }
define mng suspendrequestsize  {
	refusing :: -1000
 }
ifdef mng include zlib size of temporary zlib buffer for deflate processing define mng zlib maxbuf default zlib compression parameters for deflateinit  {
                    }
define mng zlib level level define mng zlib method z deflated  {
	  deflated :: -1000
         }
method define mng zlib windowbits window size define mng zlib memlevel memory level define mng zlib strategy z default strategy strategy define mng max idat size maximum size of idat data endif mng include zlib ifdef mng include jng ifdef mng include ijg b ijg helper defs typedef struct jpeg compress struct mngjpeg comp typedef struct jpeg decompress struct mngjpeg decomp typedef struct jpeg error mgr mngjpeg error typedef struct jpeg source mgr mngjpeg source typedef mngjpeg comp mngjpeg compp typedef mngjpeg decomp mngjpeg decompp  {
                                                                                   }
typedef mngjpeg error mngjpeg errorp typedef mngjpeg source mngjpeg sourcep  {
	  coursed :: 9
	  courses :: 9
	  sourced :: 11
	  sources :: 10
	  soupier :: 9
	  coupers :: 9
	  pouries :: 9
	  pounces :: 9
	  pouncer :: 9
	   course :: 10
	 couplers :: 9
	 pouncers :: 10
	   spruce :: 9
	   source :: 12
	   souper :: 9
	  rounces :: 9
        }
typedef j dct method mngjpeg dctmethod default ijg parameters for compression define mng jpeg dct jdct default dct algorithm jdct islow define mng jpeg quality quality best define mng jpeg smoothing default no smoothing define mng jpeg progressive mng false default is just baseline define mng jpeg optimized mng false default is not optimized endif mng include ijg b define mng jpeg maxbuf max size of temp jpeg buffer define mng max jdat size maximum size of jdat data endif mng include jng ifdef mng include lcms typedef cmshprofile mng cmsprof  {
                                                                                         }
little cms helper defs typedef cmshtransform mng cmstrans typedef cmsciexyy mng ciexyy  {
          }
typedef cmsciexyytriple mng ciexyytriple  {
  }
typedef lpgammatable mng gammatabp  {
	gummata :: 11
	magmata :: 12
  }
endif mng include lcms enumeration of known graphics types enum mng imgtypes mng it unknown mng it png mng it mng mng it jng ifdef mng include mpng proposal mng it mpng endif ifdef mng include ang proposal mng it ang endif typedef enum mng imgtypes mng imgtype enumeration of animation speed types enum mng speedtypes  {
                                                      }
mng st normal mng st fast mng st slow mng st slowest  {
	    slowest :: -1000
          }
typedef enum mng speedtypes mng speedtype ifdef mng optimize chunkreader enumeration object creation indicators enum mng createobjtypes  {
               }
mng create none mng create always mng create ifglobal  {
       }
typedef enum mng createobjtypes mng createobjtype endif enumeration of png image types ifdef mng optimize footprint init enum png imgtypes png g png g png g png g png rgb png idx png idx png idx png idx png ga png rgba ifdef mng include jng png jpeg a png jpeg a png jpeg a png jpeg a endif ifndef mng no bit support png g png ga png rgb png rgba ifdef mng include jng png jpeg a endif endif png none typedef enum png imgtypes png imgtype endif memory management callbacks typedef mng ptr mng decl mng memalloc mng size t ilen typedef void mng decl mng memfree mng ptr iptr  {
	                                                                                                           spirt :: 5
                                                                                                               }
mng size t ilen typedef void mng decl mng releasedata mng ptr puserdata mng ptr pdata mng size t ilength i o management callbacks ifndef mng no open close stream typedef mng bool mng decl mng openstream mng handle hhandle typedef mng bool mng decl mng closestream mng handle hhandle endif typedef mng bool mng decl mng readdata mng handle hhandle mng ptr pbuf  {
	                                                           pouf :: 5
                                                              }
mng uint ibuflen  {
	bluefin :: 9
 }
mng uint p pread  {
	preact :: 6
	preach :: 6
	prayed :: 6
	prated :: 6
	dreads :: 6
	pleader :: 6
	dream :: 6
	dread :: 7
	drape :: 6
	pleads :: 6
	preadmits :: 6
	bread :: 7
	aread :: 7
	areads :: 6
	parades :: 6
	parader :: 6
	petard :: 6
	treads :: 6
	oreads :: 6
	parade :: 7
	predial :: 6
	predawn :: 6
	preaged :: 6
	preaudit :: 6
	preadult :: 7
	preadmit :: 7
	preadopt :: 6
	tread :: 7
	prad :: 6
	raped :: 6
	pried :: 6
	presa :: 6
	preed :: 6
	plead :: 7
	bready :: 6
	breads :: 6
	oread :: 7
	pared :: 7
	padre :: 6
	pre :: 6
  }
typedef mng bool mng decl mng writedata mng handle hhandle mng ptr pbuf mng uint ibuflen mng uint p pwritten  {
                  }
error trace processing callbacks typedef mng bool mng decl mng errorproc mng handle hhandle mng int ierrorcode  {
               }
mng int iseverity mng chunkid ichunkname mng uint ichunkseq mng int iextra mng int iextra mng pchar zerrortext typedef mng bool mng decl mng traceproc mng handle hhandle mng int ifuncnr  {
                             }
mng int ifuncseq  {
 }
mng pchar zfuncname  {
 }
read processing callbacks typedef mng bool mng decl mng processheader mng handle hhandle mng uint iwidth mng uint iheight typedef mng bool mng decl mng processtext mng handle hhandle mng uint itype mng pchar zkeyword mng pchar ztext mng pchar zlanguage mng pchar ztranslation typedef mng bool mng decl mng processsave mng handle hhandle typedef mng bool mng decl mng processseek mng handle hhandle mng pchar zname typedef mng bool mng decl mng processneed mng handle hhandle mng pchar zkeyword typedef mng bool mng decl mng processmend mng handle hhandle mng uint iiterationsdone  {
	                                                                             intermediations :: 19
                                                                                           }
mng uint iiterationsleft  {
 }
typedef mng bool mng decl mng processunknown mng handle hhandle mng chunkid ichunkid  {
           }
mng uint irawlen mng ptr prawdata typedef mng bool mng decl mng processterm mng handle hhandle mng uint itermaction mng uint iiteraction mng uint idelay mng uint iitermax display processing callbacks typedef mng ptr mng decl mng getcanvasline mng handle hhandle mng uint ilinenr  {
                                          }
typedef mng ptr mng decl mng getbkgdline mng handle hhandle mng uint ilinenr typedef mng ptr mng decl mng getalphaline mng handle hhandle mng uint ilinenr typedef mng bool mng decl mng refresh mng handle hhandle mng uint ix mng uint iy mng uint iwidth mng uint iheight timer management callbacks typedef mng uint mng decl mng gettickcount mng handle hhandle typedef mng bool mng decl mng settimer mng handle hhandle mng uint imsecs  {
	                                                                   musics :: 7
	                                                                   misers :: 7
	                                                                  insects :: 7
	                                                                    mises :: 7
                                                                        }
color management callbacks typedef mng bool mng decl mng processgamma mng handle hhandle mng uint igamma typedef mng bool mng decl mng processchroma mng handle hhandle mng uint iwhitepointx mng uint iwhitepointy mng uint iredx mng uint iredy mng uint igreenx mng uint igreeny mng uint ibluex mng uint ibluey typedef mng bool mng decl mng processsrgb mng handle hhandle mng uint irenderingintent typedef mng bool mng decl mng processiccp mng handle hhandle mng uint iprofilesize mng ptr pprofile typedef mng bool mng decl mng processarow mng handle hhandle mng uint irowsamples  {
                                                                                          }
mng bool bisrgba  {
 }
mng ptr prow  {
	prow :: -1000
 }
chunk access callback s typedef mng bool mng decl mng iteratechunk mng handle hhandle mng handle hchunk mng chunkid ichunkid mng uint ichunkseq endif libmng types h end of file copyright c free software foundation inc this file is part of libtasn  {
	                                   libras :: 9
	                                   libant :: 9
                                        }
libtasn is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version libtasn is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with libtasn if not write to the free software foundation inc franklin street fifth floor boston ma usa ifndef libtasn h define libtasn h ifndef asn api if defined asn building defined have visibility have visibility define asn api attribute visibility default elif defined asn building defined msc ver defined asn static define asn api declspec dllexport elif defined msc ver defined asn static define asn api declspec dllimport else define asn api endif endif include stdio h for file include sys types h include time h ifdef cplusplus extern c endif define asn version typedef int asn retcode type returned by libtasn functions errors returned by libtasn functions define asn success define asn file not found define asn element not found define asn identifier not found define asn der error define asn value not found define asn generic error define asn value not valid define asn tag error define asn tag implicit define asn error type any define asn syntax error define asn mem error define asn mem alloc error define asn der overflow define asn name too long define asn array error define asn element not empty constants used in asn visit tree define asn print name define asn print name type define asn print name type value define asn print all constants returned by asn read tag define asn class universal x old define asn class application x old define asn class context specific x old define asn class private xc old define asn class structured  {
	                                                                                                                                                                                                                                                                                                                                           structured :: -1000
                                                                                                                                                                                                                                                                                                                                                    }
x constants returned by asn read tag define asn tag boolean x define asn tag integer x define asn tag sequence x define asn tag set x define asn tag octet string x define asn tag bit string x define asn tag utctime  {
	                                    tectum :: 9
                                         }
x define asn tag generalizedtime  {
   }
x define asn tag object id x define asn tag enumerated x a define asn tag null x define asn tag generalstring  {
	           sneakishly :: -1000
                    }
x b structure definition used for the node of the tree that represent an asn definition if defined asn building this structure is also in internal h but then contains more fields you cannot make any modifications to these fields without breaking  {
	                                 breaking :: -1000
                                        }
abi struct node asn struct char name node name unsigned int type node type unsigned char value node value int value len struct node asn struct down pointer to the son node struct node asn struct right pointer to the brother  {
	                                 brother :: -1000
                                       }
node struct node asn struct left pointer to the next list element endif typedef struct node asn struct node asn typedef node asn asn type define asn type empty null for the on disk format of asn trees  {
	                                trees :: -1000
                                    }
struct static struct asn const char name node name unsigned int type node type const void value node value typedef struct static struct asn asn array type fixed constants maximum number of characters of a name inside a file with asn definitons  {
	                                 defining :: 12
	                                 deficits :: 12
	                              definitions :: 14
	                               renditions :: 12
	                               venditions :: 12
	                               dentitions :: 13
	                               depictions :: 12
	                               definition :: 13
	                             definiteness :: 13
	                               infections :: 12
	                                definiens :: 12
                                        }
define asn max name size maximum number of characters of a description message null character included define asn max error description size functions definitions extern asn api asn retcode asn parser tree const char file name asn type definitions char errordescription  {
	                        overprescription :: 22
	                       overprescriptions :: 20
                                       }
extern asn api asn retcode asn parser array const char inputfilename  {
         }
const char outputfilename  {
 }
const char vectorname  {
	vectored :: 12
 }
char errordescription extern asn api asn retcode asn array tree const asn array type array asn type definitions char errordescription extern asn api void asn print structure file out asn type structure const char name int mode extern asn api asn retcode asn create element asn type definitions const char source name asn type element extern asn api asn retcode asn delete structure asn type structure extern asn api asn retcode asn delete element asn type structure const char element name extern asn api asn retcode asn write value asn type node root const char name const void ivalue  {
	                                                                                            avulse :: 7
	                                                                                            availe :: 7
	                                                                                            uvulae :: 7
	                                                                                           unalive :: 7
                                                                                                 }
int len extern asn api asn retcode asn read value asn type root const char name void ivalue int len extern asn api asn retcode asn number of elements asn type element const char name int num extern asn api asn retcode asn der coding asn type element const char name void ider  {
	                                                ides :: 5
	                                                idem :: 5
	                                                idea :: 5
	                                                icer :: 5
	                                                 ire :: 5
	                                                 ide :: 6
                                                   }
int len char errordescription extern asn api asn retcode asn der decoding asn type element const void ider int len char errordescription extern asn api asn retcode asn der decoding element asn type structure const char elementname  {
                                   }
const void ider int len char errordescription extern asn api asn retcode asn der decoding startend  {
	        sturted :: 10
	      smartened :: 10
	       statured :: 10
	       startled :: 12
	       starting :: 10
	        smarten :: 11
	        smarted :: 10
	       strident :: 10
	        startle :: 10
	        started :: 13
	        starter :: 10
	        starned :: 11
	        starlet :: 10
	        starken :: 10
	        stander :: 10
	          start :: 10
	        scarted :: 10
	        tranted :: 10
	       slattern :: 10
              }
asn type element const void ider int len const char name element int start int end extern asn api asn retcode asn expand any defined by asn type definitions asn type element extern asn api asn retcode asn expand octet string asn type definitions asn type element const char octetname  {
	                                     colonialness :: -1000
                                                }
const char objectname  {
	objected :: 12
	abjectness :: 12
 }
extern asn api asn retcode asn read tag asn type root const char name int tagvalue  {
	       vaultage :: 10
              }
int classvalue  {
	classable :: 13
 }
extern asn api const char asn find structure from oid asn type definitions const char oidvalue  {
	      outvalued :: 11
	       disvalue :: 12
	       misvalue :: 10
	         vidual :: 10
	       outvalue :: 10
	      disvalues :: 11
	      disvalued :: 11
	      misvalued :: 11
              }
extern asn api const char asn check version const char req version extern asn api const char asn strerror asn retcode error extern asn api void asn perror asn retcode error der utility functions extern asn api int asn get tag der const unsigned char der int der len unsigned char cls  {
	                                              clues :: 3
	                                              clubs :: 3
	                                              cloys :: 3
	                                              clows :: 3
	                                              clous :: 3
	                                              clots :: 3
	                                              close :: 3
	                                              clops :: 3
	                                              clons :: 3
	                                              clogs :: 3
	                                              clods :: 3
	                                              clips :: 3
	                                              clies :: 3
	                                              clews :: 3
	                                              clems :: 3
	                                              clegs :: 3
	                                              clefs :: 3
	                                              clays :: 3
	                                              claws :: 3
	                                              clast :: 3
	                                              class :: 3
	                                              clasp :: 3
	                                              clash :: 3
	                                              claps :: 3
	                                              clans :: 3
	                                              clams :: 3
	                                              claes :: 3
	                                              clads :: 3
	                                               cols :: 3
	                                               cels :: 3
	                                                els :: 3
	                                                cly :: 3
	                                                cis :: 3
	                                                als :: 3
	                                                 sl :: 3
	                                                 cs :: 3
                                                  }
int len unsigned long tag extern asn api void asn octet der const unsigned char str int str len unsigned char der int der len extern asn api asn retcode asn get octet der const unsigned char der int der len int ret len unsigned char str int str size int str len extern asn api void asn bit der const unsigned char str int bit len unsigned char der int der len extern asn api asn retcode asn get bit der const unsigned char der int der len int ret len unsigned char str int str size int bit len extern asn api signed long asn get length der const unsigned char der int der len int len extern asn api signed long asn get length ber const unsigned char ber int ber len int len extern asn api void asn length der unsigned long int len unsigned char ans int ans len other utility functions extern asn api asn type asn find node asn type pointer const char name extern asn api asn retcode asn copy node asn type dst const char dst name asn type src const char src name deprecated stuff ifndef asn disable deprecated define libtasn version asn version ifndef max name size define max name size asn max name size endif ifndef max error description size define max error description size asn max error description size endif ifndef attribute this feature is available in gcc versions and later if gnuc gnuc gnuc minor define attribute spec empty endif endif use asn strerror instead extern asn api const char libtasn strerror asn retcode error attribute deprecated use asn perror instead extern asn api void libtasn perror asn retcode error attribute deprecated endif ifdef cplusplus endif endif libtasn h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa iso c standard sizes of integer types limits h ifndef libc limits h define libc limits h include features h maximum length of any multibyte character in any locale we define this value here since the gcc header does not define the correct value define mb len max if we are not using gnu cc we have to define all the symbols ourself  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ourself :: -1000
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
otherwise use gcc s definitions see below if defined gnuc gnuc we only protect from multiple inclusion here because all the other include s protect themselves  {
	               themselves :: -1000
                        }
and in gcc we may include next through multiple copies of this file before we get to gcc s ifndef limits h define limits h include bits wordsize h we don t have include next define ansi limits h for standard bit words these assume bit char s bit short int s and bit int s and long int s number of bits in a char define char bit minimum and maximum values a signed char can hold define schar  {
	                                                                         echard :: 6
	                                                                         schorl :: 6
	                                                                         scarth :: 6
	                                                                         scarph :: 6
	                                                                        echards :: 7
	                                                                        scraigh :: 6
	                                                                        scholar :: 6
	                                                                        schmear :: 6
	                                                                           scar :: 6
	                                                                          shear :: 6
	                                                                          scray :: 6
	                                                                          scraw :: 6
	                                                                          scrat :: 6
	                                                                          scrap :: 6
	                                                                          scran :: 6
	                                                                          scram :: 6
	                                                                          scrag :: 6
	                                                                          scrae :: 6
	                                                                          scrab :: 6
	                                                                          schwa :: 6
	                                                                          schav :: 7
	                                                                          scaur :: 6
                                                                              }
min define schar max maximum value an unsigned char can hold minimum is define uchar max minimum and maximum values a char can hold ifdef char unsigned define char min define char max uchar max else define char min schar min define char max schar max endif minimum and maximum values a signed short int can hold define shrt  {
	                                                    shrift :: 5
	                                                     hurts :: 5
	                                                     harts :: 5
	                                                      sort :: 5
	                                                      shut :: 5
	                                                      shri :: 5
	                                                      shot :: 5
	                                                      shit :: 5
	                                                      shet :: 5
	                                                      shat :: 5
	                                                     short :: 5
	                                                     shirt :: 5
                                                         }
min define shrt max maximum value an unsigned short int can hold minimum is define ushrt max minimum and maximum values a signed int can hold define int min int max define int max maximum value an unsigned int can hold minimum is define uint max u minimum and maximum values a signed long int can hold if wordsize define long max l else define long max l endif define long min long max l maximum value an unsigned long int can hold minimum is if wordsize define ulong max ul else define ulong max ul endif ifdef use isoc minimum and maximum values a signed long long int can hold define llong  {
	                                                                                                           klong :: 7
	                                                                                                           flong :: 7
	                                                                                                          klongs :: 6
	                                                                                                           along :: 7
	                                                                                                          flongs :: 6
	                                                                                                           llano :: 6
                                                                                                               }
max ll define llong min llong max ll maximum value an unsigned long long int can hold minimum is define ullong  {
	              ulling :: 9
	               gluon :: 7
	             allonge :: 8
	              oulong :: 8
	             ullings :: 8
	            allonges :: 7
	             oulongs :: 7
                   }
max ull endif iso c endif limits h endif gcc endif libc limits h get the compiler s limits h which defines almost all the iso constants we put this include next outside the double inclusion check because it should be possible to include this file more than once and still get the definitions from gcc s header if defined gnuc defined gcc limits h gcc limits h is what gcc s file defines include next limits h endif the limits h files in some gcc versions don t define llong min llong max and ullong max instead only the values gcc defined for ages  {
	                                                                                                    ages :: -1000
                                                                                                       }
are available if defined use isoc defined gnuc ifndef llong min define llong min llong max endif ifndef llong max define llong max long long max endif ifndef ullong max define ullong max llong max ull endif endif ifdef use posix posix adds things to limits h include bits posix lim h endif ifdef use posix include bits posix lim h endif ifdef use xopen include bits xopen lim h endif data structure for communication from the run time dynamic linker for loaded elf shared objects copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef link h define link h include features h include elf h include dlfcn h include sys types h we use this macro to refer to elf types independent of the native  {
	                                                                                                                                                                                                                                                     native :: -1000
                                                                                                                                                                                                                                                          }
wordsize elfw  {
	flews :: 5
	flew :: 6
	elf :: 6
 }
type is used in place of elf type or elf type define elfw type elfw elf elf native class type define elfw e w t elfw e w t define elfw e w t e w t include bits elfclass h defines elf native class include bits link h rendezvous  {
	                                       rendezvous :: -1000
                                                }
structure used by the run time dynamic linker to communicate details of shared object loading to the debugger if the executable s dynamic section has a dt debug element the run time linker sets that element s value to the address where this structure can be found struct r debug int r version version number for this protocol struct link map r map head of the chain of loaded objects this is the address of a function internal to the run time linker that will always be called when the linker begins to map in a library or unmap it and again when the mapping change is complete the debugger can set a breakpoint  {
	                                                                                                       breakpoint :: -1000
                                                                                                                }
at this address if it wants to notice shared object mapping changes elfw addr r brk  {
	          brusk :: 3
	          brook :: 3
	          broke :: 3
	          brock :: 3
	          brisk :: 3
	          brink :: 3
	          brick :: 3
	          break :: 3
	          brank :: 3
	          braky :: 3
	          brake :: 3
	          brack :: 3
	          biker :: 3
	          baker :: 3
	           krab :: 3
	           burk :: 3
	           birk :: 3
	           berk :: 3
	           bark :: 3
	            irk :: 3
	            erk :: 3
	            bro :: 3
	            bre :: 3
	            bra :: 3
	            bok :: 3
	            ark :: 3
	             kr :: 3
	             br :: 4
              }
enum this state value describes the mapping change taking place when the r brk address is called rt consistent mapping change is complete rt add beginning to add a new object rt delete beginning to remove an object mapping r state elfw addr r ldbase  {
	                                       leads :: 7
	                                       lades :: 7
	                                     libated :: 7
	                                     libates :: 7
	                                      sabled :: 7
	                                     debased :: 7
	                                     debaser :: 7
	                                      debase :: 8
	                                     imbased :: 7
	                                     lobated :: 7
	                                     unbased :: 7
                                           }
base address the linker is loaded at this is the instance of that structure used by the dynamic linker extern struct r debug r debug this symbol refers to the dynamic structure in the dynamic section of whatever module refers to dynamic so to find its own struct r debug a program could do for dyn dynamic dyn d tag dt null dyn if dyn d tag dt debug r debug struct r debug dyn d un d ptr extern elfw dyn dynamic structure describing a loaded shared object the l next and l prev members form a chain of all the shared objects loaded at startup these data structures exist in space used by the run time dynamic linker modifying  {
	                                                                                                               modifying :: -1000
                                                                                                                       }
them may have disastrous  {
	disastrous :: -1000
  }
results struct link map these first few members are part of the protocol with the debugger this is the same format used in svr elfw addr l addr base address shared object is loaded at char l name absolute file name object was found in elfw dyn l ld dynamic section of the shared object struct link map l next l prev chain of loaded objects ifdef use gnu version numbers for la version handshake  {
	                                                                 handshake :: -1000
                                                                         }
interface define lav  {
	lav :: -1000
 }
current activity  {
	activity :: -1000
 }
types signaled  {
	signaled :: -1000
 }
through la activity enum la act consistent link map consistent again la act add new object will be added la act delete objects will be removed values representing origin of name for dynamic loading enum la ser orig x original name la ser libpath  {
	                                      grame :: -1000
                                          }
x directory from ld library path la ser runpath x directory from rpath runpath la ser config x found through ldconfig  {
                   }
la ser default x default directory la ser secure x unused values for la objopen  {
             }
return value enum la flg bindto  {
	grand :: -1000
    }
x audit symbols bound to this object la flg bindfrom  {
	pozzolana :: -1000
        }
x audit symbols bound from this object values for la symbind  {
	   misbind :: 9
	   symbion :: 10
	  symbiont :: 9
         }
flags parameter enum la symb nopltenter  {
    }
x la pltenter  {
	patented :: 10
	parenteral :: 10
 }
will not be called la symb nopltexit  {
     }
x la pltexit  {
 }
will not be called la symb structcall  {
     }
x return value is a structure la symb dlsym x binding due to dlsym call la symb altvalue  {
	         outvalue :: 10
                }
x value has been changed by a previous la symbind call struct dl phdr info elfw addr dlpi  {
	            sayer :: -1000
                }
addr const char dlpi name const elfw phdr dlpi phdr elfw half dlpi phnum note following members were introduced after the first version of this structure was available check the size argument passed to the dl iterate phdr callback to determine whether or not each later member is available incremented when a new object may have been added unsigned long long int dlpi adds incremented when an object may have been removed unsigned long long int dlpi subs if there is a pt tls segment its module id as used in tls relocations else zero size t dlpi tls modid the address of the calling thread s instance of this module s pt tls segment if it has one and it has been allocated in the calling thread otherwise a null pointer void dlpi tls data begin decls extern int dl iterate phdr int callback struct dl phdr info size t void void data prototypes for the ld so auditing interfaces these are not defined anywhere in ld so but instead have to be provided by the auditing dso extern unsigned int la version unsigned int version extern void la activity uintptr t cookie unsigned int flag extern char la objsearch  {
                                                                                                                                                                                                       }
const char name uintptr t cookie unsigned int flag extern unsigned int la objopen struct link map map lmid t lmid uintptr t cookie extern void la preinit uintptr t cookie extern uintptr t la symbind elf sym sym unsigned int ndx uintptr t refcook  {
	                                     precook :: 9
                                           }
uintptr t defcook  {
	defrock :: 9
 }
unsigned int flags const char symname  {
	misname :: 9
    }
extern uintptr t la symbind elf sym sym unsigned int ndx uintptr t refcook uintptr t defcook unsigned int flags const char symname extern unsigned int la objclose  {
                          }
uintptr t cookie end decls endif endif link h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa iso c standard localization  {
	                                                                                                                                      localization :: -1000
                                                                                                                                                 }
locale h ifndef locale h define locale h include features h define need null include stddef h include bits locale h begin decls these are the possibilities  {
	             possibilities :: -1000
                         }
for the first argument to setlocale the code assumes that the lowest lc symbol has the value zero define lc ctype lc ctype define lc numeric lc numeric define lc time lc time define lc collate lc collate define lc monetary lc monetary define lc messages lc messages define lc all lc all define lc paper lc paper define lc name lc name define lc address lc address define lc telephone lc telephone define lc measurement lc measurement define lc identification lc identification begin namespace std structure giving information about numeric and monetary notation struct lconv numeric non monetary information char decimal point decimal point character char thousands sep thousands separator each element is the number of digits in each group elements with higher indices are farther  {
	                                                                                                                       farther :: -1000
                                                                                                                             }
left an element with value char max means that no further grouping is done an element with value means that the previous element is used for all groups farther left char grouping monetary information first three chars are a currency symbol from iso fourth char is the separator fifth char is char int curr symbol char currency symbol local currency symbol char mon decimal point decimal point character char mon thousands sep thousands separator char mon grouping like grouping element above char positive sign sign for positive values char negative sign sign for negative values char int frac digits int l fractional digits char frac digits local fractional digits if currency symbol precedes a positive value if succeeds char p cs precedes iff a space separates  {
	                                                                                                                    separates :: -1000
                                                                                                                            }
currency symbol from a positive value char p sep by space if currency symbol precedes a negative value if succeeds char n cs precedes iff a space separates currency symbol from a negative value char n sep by space positive and negative sign positions parentheses surround the quantity and currency symbol the sign string precedes the quantity and currency symbol the sign string follows the quantity and currency symbol the sign string immediately precedes the currency symbol the sign string immediately follows the currency symbol char p sign posn char n sign posn ifdef use isoc if int curr symbol precedes a positive value if succeeds char int p cs precedes iff a space separates int curr symbol from a positive value char int p sep by space if int curr symbol precedes a negative value if succeeds char int n cs precedes iff a space separates int curr symbol from a negative value char int n sep by space positive and negative sign positions parentheses surround the quantity and int curr symbol the sign string precedes the quantity and int curr symbol the sign string follows the quantity and int curr symbol the sign string immediately precedes the int curr symbol the sign string immediately follows the int curr symbol char int p sign posn char int n sign posn else char int p cs precedes char int p sep by space char int n cs precedes char int n sep by space char int p sign posn char int n sign posn endif set and or return the current locale extern char setlocale int category const char locale throw return the numeric monetary information for the current locale extern struct lconv localeconv  {
                                                                                                                                                                                                                                                                                          }
void throw end namespace std ifdef use xopen k the concept of one static locale per category is not very well thought out many applications will need to process its data using information from several different locales another application is the implementation of the internationalization handling in the upcoming iso c standard library to support this another set of the functions using locale data exist which have an additional argument attention all these functions are not standardized in any form this is a proof of concept implementation get locale datatype definition include xlocale h return a reference to a data structure representing a set of locale datasets unlike for the category parameter for setlocale the category mask parameter here uses a single bit for each category made by or ing together lc mask bits above extern locale t newlocale  {
                                                                                                                                         }
int category mask const char locale locale t base throw these are the bits that can be set in the category mask argument to newlocale in the gnu implementation lc foo mask has the value of lc foo but this is not a part of the interface that callers can assume will be true define lc ctype mask lc ctype define lc numeric mask lc numeric define lc time mask lc time define lc collate mask lc collate define lc monetary mask lc monetary define lc messages mask lc messages define lc paper mask lc paper define lc name mask lc name define lc address mask lc address define lc telephone mask lc telephone define lc measurement mask lc measurement define lc identification mask lc identification define lc all mask lc ctype mask lc numeric mask lc time mask lc collate mask lc monetary mask lc messages mask lc paper mask lc name mask lc address mask lc telephone mask lc measurement mask lc identification mask return a duplicate of the set of locale in dataset all usage counters  {
	                                                                                                                                                                          counters :: -1000
                                                                                                                                                                                 }
are increased  {
	increased :: -1000
 }
if necessary extern locale t duplocale  {
	duplicate :: 11
    }
locale t dataset throw free the data associated with a locale dataset previously returned by a call to setlocale r extern void freelocale  {
                     }
locale t dataset throw switch the current thread s locale to dataset if dataset is null instead just return the current setting the special value lc global locale is the initial setting for all threads and can also be installed any time meaning the thread uses the global settings controlled  {
	                                       controlled :: -1000
                                                }
by setlocale extern locale t uselocale locale t dataset throw this value can be passed to uselocale and may be returned by it passing this value to any other function has undefined behavior define lc global locale locale t l endif end decls endif locale h prototypes and definition for malloc implementation copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef malloc h define malloc h include features h include stddef h include stdio h define malloc ptr t void used by gnu libc internals define malloc size t size t define malloc ptrdiff  {
                                                                                                                                                                                                                          }
t ptrdiff t ifdef gnuc define malloc p args args throw this macro will be used for functions which might take c callback functions define malloc pmt args args ifdef libc define malloc hook volatile define malloc deprecated else define malloc hook volatile volatile define malloc deprecated attribute deprecated endif else not gcc define malloc p args args define malloc pmt args args define malloc hook volatile define malloc deprecated attribute deprecated endif gcc begin decls allocate size bytes of memory extern void malloc size t size throw attribute malloc wur allocate nmemb elements of size bytes each all initialized to extern void calloc size t nmemb size t size throw attribute malloc wur re allocate the previously allocated block in ptr making the new block size bytes long attribute malloc is not used because if realloc returns the same pointer that was passed to it aliasing needs to be allowed between objects pointed by the old and new pointers extern void realloc void ptr size t size throw attribute warn unused result free a block allocated by malloc realloc or calloc extern void free void ptr throw free a block allocated by calloc extern void cfree  {
	                                                                                                                                                                                              afreet :: 6
	                                                                                                                                                                                               scree :: 6
	                                                                                                                                                                                                cere :: 6
	                                                                                                                                                                                              careen :: 6
                                                                                                                                                                                                   }
void ptr throw allocate size bytes allocated to alignment bytes extern void memalign  {
	    medaling :: 10
	   embalming :: 10
	    melanism :: 10
           }
size t alignment size t size throw attribute malloc wur allocate size bytes on a page boundary extern void valloc  {
	            sleuths :: -1000
                  }
size t size throw attribute malloc wur equivalent to valloc minimum page that holds n that is round up size to nearest pagesize extern void pvalloc  {
	               italicisms :: -1000
                        }
size t size throw attribute malloc wur underlying allocation function successive calls should return contiguous pieces of memory extern void morecore  {
	           homecomer :: 10
	           overcomer :: 10
	            moreover :: 10
                   }
ptrdiff t size default value of morecore extern void default morecore ptrdiff t size throw attribute malloc svid xpg mallinfo  {
	            falling :: 10
	            malling :: 11
                  }
structure struct mallinfo int arena  {
	arena :: -1000
   }
non mmapped  {
 }
space allocated from system int ordblks  {
    }
number of free chunks int smblks  {
	skelms :: 7
    }
number of fastbin blocks int hblks  {
	hulks :: 7
	holks :: 7
	bulks :: 6
	bilks :: 6
	balks :: 6
    }
number of mmapped regions  {
	regions :: -1000
  }
int hblkhd  {
 }
space in mmapped regions int usmblks  {
    }
maximum total allocated space int fsmblks  {
    }
space available in freed fastbin blocks int uordblks  {
	burdocks :: 10
      }
total allocated space int fordblks  {
	reinvested :: -1000
   }
total free space int keepcost  {
	deepmost :: 10
   }
top most releasable  {
	releasable :: -1000
 }
via malloc trim  {
	trim :: -1000
 }
space returns a copy of the updated current mallinfo extern struct mallinfo mallinfo void throw svid xpg mallopt  {
	           gallop :: 9
	           dallop :: 9
	          maltols :: 9
	           wallop :: 9
	           maltol :: 10
	           mallow :: 9
	           callop :: 9
	            matlo :: 9
                }
options ifndef m mxfast  {
  }
define m mxfast maximum request size for fastbins  {
	astatic :: -1000
      }
endif ifndef m nlblks  {
  }
define m nlblks unused in this malloc endif ifndef m grain  {
	     grain :: -1000
         }
define m grain unused in this malloc endif ifndef m keep define m keep unused in this malloc endif mallopt options that actually do something define m trim threshold  {
	                   threshold :: -1000
                           }
define m top pad define m mmap threshold define m mmap max define m check action define m perturb define m arena test define m arena max general svid xpg interface to tunable  {
	                         tunable :: -1000
                               }
parameters extern int mallopt int param int val throw release all but pad bytes of freed top most memory back to the system return if successful else extern int malloc trim size t pad throw report the number of usable allocated bytes associated with allocated chunk ptr extern size t malloc usable size void ptr throw prints brief  {
	                                                    brief :: -1000
                                                        }
summary  {
	summary :: -1000
 }
statistics on stderr extern void malloc stats void throw output information about state of allocator to stream fp extern int malloc info int options file fp throw record the state of all malloc variables in an opaque data structure extern void malloc get state void throw restore  {
	                                       restore :: -1000
                                             }
the state of all malloc variables from data obtained with malloc get state extern int malloc set state void ptr throw called once when malloc is initialized redefining  {
	                 redefining :: -1000
                          }
this variable in the application provides the preferred way to set up the hook pointers extern void malloc hook volatile malloc initialize hook void malloc deprecated hooks  {
	                     hooks :: -1000
                         }
for debugging and user defined versions extern void malloc hook volatile free hook void ptr const malloc ptr t malloc deprecated extern void malloc hook volatile malloc hook size t size const malloc ptr t malloc deprecated extern void malloc hook volatile realloc hook void ptr size t size const malloc ptr t malloc deprecated extern void malloc hook volatile memalign hook size t alignment size t size const malloc ptr t malloc deprecated extern void malloc hook volatile after morecore hook void activate a standard set of debugging hooks extern void malloc check init void throw malloc deprecated end decls endif malloc h declarations for math functions copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa iso c standard mathematics  {
	                                                                                                                                                                                                                                          mathematics :: -1000
                                                                                                                                                                                                                                                    }
math h ifndef math h define math h include features h begin decls get machine dependent huge val value returned on overflow on all ieee machines this is infinity include bits huge val h ifdef use isoc include bits huge valf  {
	                                    vali :: 5
	                                    vale :: 5
	                                    half :: 5
	                                    calf :: 5
	                                  vatful :: 5
                                       }
h include bits huge vall h get machine dependent infinity value include bits inf h get machine dependent nan value returned for some domain errors include bits nan h endif use isoc get general and iso c specific information include bits mathdef h the file bits mathcalls  {
	                                     catchalls :: 13
	                                      catchall :: 11
	                                     mothballs :: 12
	                                      marshall :: 11
	                                     marshalls :: 11
                                             }
h contains the prototypes for all the actual math functions these macros are used for those prototypes so we can easily declare each function as both name and name and can declare the float versions namef and namef define mathcall function suffix args mathdecl mdouble function suffix args define mathdecl type function suffix args mathdecl type function suffix args mathdecl type concat function suffix args define mathcallx  {
	                                                          catchall :: 11
                                                                 }
function suffix args attrib mathdeclx  {
	hemlocks :: -1000
   }
mdouble function suffix args attrib define mathdeclx type function suffix args attrib mathdecl type function suffix args attribute attrib mathdecl type concat function suffix args attribute attrib define mathdecl type function suffix args extern type math precname function suffix args throw define mdouble double define math precname name r concat name r define mdouble begin namespace begin namespace std define mdouble end namespace end namespace std include bits mathcalls h undef mdouble undef mdouble begin namespace undef mdouble end namespace undef math precname if defined use misc defined use isoc include the file of declarations again this time using float instead of double and appending f to each function name ifndef mfloat define mfloat float endif define mdouble mfloat ifdef stdc define math precname name r name f r else define math precname name r name f r endif define mdouble begin namespace begin namespace c define mdouble end namespace end namespace c include bits mathcalls h undef mdouble undef mdouble begin namespace undef mdouble end namespace undef math precname if stdc gnuc defined no long double math defined libc defined ldbl compat ifdef ldbl compat ifdef use isoc extern float nldbl  {
                                                                                                                                                                                              }
nexttowardf  {
 }
float x long double y throw attribute const ifdef redirect nth extern float redirect nth nexttowardf float x long double y nldbl nexttowardf attribute const extern double redirect nth nexttoward double x long double y nextafter  {
                                  }
attribute const extern long double redirect nth nexttowardl  {
      }
long double x long double y nextafter attribute const endif endif endif if defined ldbl compat defined no long double math undef mathdecl define mathdecl type function suffix args alias extern type redirect nth math precname function suffix args alias define mathdecl type function suffix args mathdecl type function suffix args concat function suffix endif include the file of declarations again this time using long double instead of double and appending l to each function name ifndef mlong double define mlong double long double endif define mdouble mlong double ifdef stdc define math precname name r name l r else define math precname name r name l r endif define mdouble begin namespace begin namespace c define mdouble end namespace end namespace c define math declare ldouble  {
	                                                                                                                      troubled :: 9
	                                                                                                                       voluble :: 9
	                                                                                                                       soluble :: 9
                                                                                                                             }
include bits mathcalls h undef mdouble undef mdouble begin namespace undef mdouble end namespace undef math precname endif stdc gnuc endif use misc or iso c undef mathdecl undef mathdecl undef mathcall if defined use misc defined use xopen this variable is used by gamma and lgamma  {
	                                       amalgam :: 7
	                                       grammar :: 7
	                                        gnamma :: 8
                                             }
extern int signgam  {
	signage :: 9
	ginghams :: 9
 }
endif iso c defines some generic macros which work on any data type ifdef use isoc get the architecture specific values describing the floating point evaluation the following symbols will get defined float t floating point type at least as wide as float used to evaluate float expressions  {
	                                    expressions :: -1000
                                              }
double t floating point type at least as wide as double used to evaluate double expressions flt  {
	           flyte :: 3
	           fluyt :: 3
	           fluty :: 3
	           flute :: 3
	           flout :: 3
	           flote :: 3
	           flota :: 3
	           float :: 3
	           flits :: 3
	           flite :: 3
	           flirt :: 3
	           flint :: 3
	           fleet :: 3
	           flats :: 3
	           fitly :: 3
	           fetal :: 3
	           fatly :: 3
	           fatal :: 3
	            flit :: 4
	            flat :: 4
	            felt :: 3
	             ult :: 3
	             fly :: 3
	             flu :: 3
	             fit :: 3
	             fet :: 3
	             fat :: 3
	             elt :: 3
	             alt :: 3
	              fl :: 4
               }
eval method defined to if float t is float and double t is double if float t and double t are double if float t and double t are long double else float t and double t are unspecified infinity representation of the infinity value of type float fp fast fma fp fast fmaf  {
                                                    }
fp fast fmal  {
	flamy :: 5
	flams :: 5
	flame :: 5
	foal :: 5
	flam :: 6
 }
if defined it indicates that the fma function generally executes  {
	 executes :: -1000
        }
about as fast as a multiply and an add this macro is defined only iff the fma function is implemented directly with a hardware multiply add instructions fp ilogb  {
	                        glob :: 6
	                        biog :: 6
	                      globin :: 6
                           }
expands  {
	expands :: -1000
 }
to a value returned by ilogb fp ilogbnan  {
	blazoning :: 10
      }
expands to a value returned by ilogb nan decimal dig number of decimal digits supported by conversion between decimal and all internal floating point formats all floating point numbers can be put in one of these categories  {
	                          categories :: -1000
                                   }
enum fp nan define fp nan fp nan fp infinite  {
	 infinite :: -1000
        }
define fp infinite fp infinite fp zero define fp zero fp zero fp subnormal  {
	    subnormal :: -1000
            }
define fp subnormal fp subnormal fp normal define fp normal fp normal return number of classification appropriate for x ifdef no long double math define fpclassify  {
	               reclassify :: 14
	               declassify :: 14
                        }
x sizeof x sizeof float fpclassifyf  {
    }
x fpclassify x else define fpclassify x sizeof x sizeof float fpclassifyf x sizeof x sizeof double fpclassify x fpclassifyl  {
                  }
x endif return nonzero value if sign of x is negative ifdef no long double math define signbit  {
	         gigabits :: 9
                }
x sizeof x sizeof float signbitf  {
    }
x signbit x else define signbit x sizeof x sizeof float signbitf x sizeof x sizeof double signbit x signbitl  {
                  }
x endif return nonzero value if x is not inf or nan ifdef no long double math define isfinite  {
	          definite :: 10
	       infinitudes :: 11
	        infinitude :: 10
	        infinitely :: 11
	          infinity :: 10
	          infinite :: 13
	         infinites :: 14
                 }
x sizeof x sizeof float finitef  {
	pinite :: 9
	finite :: 11
	finitely :: 9
	finites :: 10
    }
x finite x else define isfinite x sizeof x sizeof float finitef x sizeof x sizeof double finite x finitel  {
	             pinite :: 9
	             finite :: 12
	           fileting :: 9
	           finitude :: 9
	           finitely :: 13
	             lintie :: 9
	            finites :: 11
                  }
x endif return nonzero value if x is neither zero subnormal inf nor nan define isnormal  {
	    manorialism :: 10
	   renormalizes :: 10
	       manorial :: 11
	      immortals :: 10
	       abnormal :: 10
	       monorail :: 10
	       informal :: 12
	       minorcas :: 10
	      abnormals :: 11
	      monorails :: 11
              }
x fpclassify x fp normal return nonzero value if x is a nan we could use fpclassify but we already have this functions isnan  {
	                infants :: 6
	                 insane :: 7
	                  ingan :: 6
	                 ingans :: 7
	                pinangs :: 6
	                incants :: 6
	                 saning :: 6
	                insaner :: 6
	                inlands :: 6
	                 island :: 6
                      }
and it is faster ifdef no long double math define isnan x sizeof x sizeof float isnanf  {
	         infants :: 8
	          insane :: 7
	          ingans :: 7
	          infant :: 7
	        finances :: 7
               }
x isnan x else define isnan x sizeof x sizeof float isnanf x sizeof x sizeof double isnan x isnanl  {
	             insane :: 7
	             ingans :: 7
	            unnails :: 7
	           insanely :: 7
	            inlands :: 8
	             island :: 8
                  }
x endif return nonzero value if x is positive or negative infinity ifdef no long double math define isinf  {
                 }
x sizeof x sizeof float isinff  {
    }
x isinf x else define isinf x sizeof x sizeof float isinff x sizeof x sizeof double isinf x isinfl  {
	            infills :: 7
                  }
x endif bitmasks for the math errhandling  {
     }
macro define math errno errno set by math functions define math errexcept  {
	  excerpter :: 11
	   expecter :: 11
          }
exceptions raised  {
	raised :: -1000
 }
by math functions by default all functions support both errno and exception handling in gcc s fast math mode and if inline functions are defined this might not be true ifndef fast math define math errhandling math errno math errexcept endif endif use iso c ifdef use misc support for various different standard error handling behaviors  {
	                                              behaviors :: -1000
                                                      }
typedef enum ieee according to ieee ieee svid according to system v release xopen nowadays  {
	      nowadays :: -1000
             }
also unix posix isoc actually this is iso c lib version type this variable can be changed at run time to any of the values above to affect floating point error handling behavior it may also be necessary to change the hardware fpu exception settings extern lib version type lib version endif ifdef use svid in svid error handling matherr  {
	                                                    maturer :: 9
	                                                    matcher :: 9
	                                                     rather :: 10
	                                                      rathe :: 9
                                                          }
is called with this description of the exceptional  {
	 shammy :: -1000
      }
condition we have a problem when using c since exception is a reserved name in c ifdef cplusplus struct exception else struct exception endif int type char name double arg double arg double retval  {
	                        polemical :: -1000
                                }
ifdef cplusplus extern int matherr struct exception exc throw else extern int matherr struct exception exc endif define x tloss  {
	              floss :: 7
	              clots :: 6
	              blots :: 6
	            closets :: 6
	            closest :: 6
	              tools :: 6
	              stoss :: 6
	               slot :: 6
	              slows :: 6
	              slots :: 8
	              slops :: 6
	              slogs :: 6
	              sloes :: 6
	              slobs :: 6
	              plots :: 6
	             sloths :: 6
	             glosts :: 7
	             glossy :: 6
	             glossa :: 6
                  }
e types of exceptions in the type field define domain define sing define overflow define underflow define tloss define ploss  {
	            plessor :: 7
	              glops :: 6
	              floss :: 7
	              flops :: 6
	           plosives :: 6
	              elops :: 6
	             plisse :: 6
	              clops :: 6
	               slop :: 6
	              slows :: 6
	              slots :: 6
	              slops :: 8
	              slogs :: 6
	              sloes :: 6
	              slobs :: 6
	              psoas :: 6
	              pross :: 7
	              pools :: 6
	              ploys :: 7
	              plows :: 7
	              plots :: 7
	              plops :: 6
	              plods :: 7
	             slopes :: 6
	             glossy :: 6
	             glossa :: 6
                  }
svid mode specifies returning this large value instead of infinity define huge e f else svid ifdef use xopen x open wants another strange  {
	                strange :: -1000
                      }
constant define maxfloat  {
	maxicoat :: 10
	meatloaf :: 10
 }
e f endif endif svid some useful constants if defined use bsd defined use xopen define m e e define m log e log e define m log e log e define m ln log e define m ln log e define m pi pi define m pi pi define m pi pi define m pi pi define m pi pi define m sqrtpi  {
	                                                         script :: 7
	                                                         stripy :: 7
	                                                         stript :: 7
	                                                         stripe :: 7
	                                                          strip :: 8
	                                                          stirp :: 7
	                                                          sprit :: 7
                                                              }
sqrt pi define m sqrt sqrt define m sqrt sqrt endif the above constants are not adequate  {
	        adequate :: -1000
               }
for computation using long double s therefore we provide as an extension constants with similar names as a gnu extension provide enough digits for the bit ieee quad  {
	                       read :: -1000
                          }
ifdef use gnu define m el l e define m log el l log e define m log el l log e define m ln l l log e define m ln l l log e define m pil  {
	                                 kilps :: 3
	                                 gilpy :: 3
	                                pilots :: 3
	                                pilose :: 3
	                                pileus :: 3
	                                pileum :: 3
	                                pilers :: 3
	                                pilaws :: 3
	                                pilaus :: 3
	                                pilafs :: 3
	                                pilaff :: 3
	                                  puli :: 4
	                                  plim :: 3
	                                  plie :: 3
	                                  pirl :: 4
	                                  pily :: 5
	                                  pill :: 4
	                                  pili :: 4
	                                  pile :: 5
	                                  pila :: 5
	                                  pial :: 4
	                                  pail :: 3
	                                  lisp :: 3
	                                  lips :: 3
	                                  limp :: 3
	                                  kilp :: 4
	                                 pulis :: 3
	                                 pulik :: 3
	                                 polis :: 3
	                                 polio :: 3
	                                 pixel :: 3
	                                 pirls :: 3
	                                 pilus :: 4
	                                 pilum :: 4
	                                 pilot :: 4
	                                 pills :: 3
	                                 pilis :: 3
	                                 piles :: 4
	                                 piler :: 4
	                                 pikul :: 3
	                                 pilei :: 3
	                                 piled :: 4
	                                 pilch :: 4
	                                 pilaw :: 4
	                                 pilau :: 4
	                                 pilar :: 4
	                                 pilaf :: 4
	                                 picul :: 3
	                                 pical :: 3
	                                 pibal :: 3
	                                 milpa :: 3
	                                   til :: 3
	                                   pul :: 3
	                                   pol :: 3
	                                   pix :: 3
	                                   piu :: 3
	                                   pit :: 3
	                                   pis :: 3
	                                   pin :: 3
	                                   pig :: 3
	                                   pie :: 3
	                                   pic :: 3
	                                   pia :: 3
	                                   pal :: 3
	                                   oil :: 3
	                                   nil :: 3
	                                   mil :: 3
	                                   lip :: 4
	                                   ail :: 3
	                                    pi :: 4
	                                    li :: 3
                                     }
l pi define m pi l l pi define m pi l l pi define m pil l pi define m pil l pi define m sqrtpil  {
                         }
l sqrt pi define m sqrt l l sqrt define m sqrt l l sqrt endif when compiling in strict iso c compatible mode we must not use the inline functions since they among other things do not set the errno variable correctly if defined strict ansi defined no math inlines define no math inlines endif if defined use isoc gnuc prereq iso c defines some macros to compare number while taking care for unordered  {
	                                                                 unordered :: -1000
                                                                         }
numbers many fpus  {
	gaes :: -1000
 }
provide special instructions to support these operations generic support in gcc for these as builtins  {
	      bustling :: 10
	      bustline :: 10
	     quiltings :: 11
	    guiltiness :: 10
	      quintins :: 10
	      quilting :: 10
	      building :: 10
	     buildings :: 11
	      botulins :: 10
             }
went  {
	went :: -1000
 }
in before but not all cpus  {
	coups :: 5
	 scup :: 5
	 opus :: 5
	 cusp :: 5
	 cups :: 6
	 crus :: 5
    }
added their patterns we define versions that use the builtins here and bits mathinline  {
	  methionines :: 12
	   methionine :: 13
            }
h will undef redefine as appropriate for the specific gcc version in use define isgreater  {
	     increaser :: 11
	     astringer :: 11
	     aigrettes :: 11
	     degreaser :: 11
	     estranger :: 11
             }
x y builtin isgreater x y define isgreaterequal  {
      }
x y builtin isgreaterequal x y define isless  {
	 silers :: 7
	 silens :: 7
	idlesse :: 7
	  isles :: 8
	  siles :: 7
	   isle :: 7
	silesias :: 7
	 issues :: 7
	 isseis :: 7
	 lisses :: 7
	 islets :: 8
      }
x y builtin isless x y define islessequal  {
      }
x y builtin islessequal x y define islessgreater  {
      }
x y builtin islessgreater x y define isunordered  {
      }
u v builtin isunordered u v endif get machine dependent inline versions if there are any ifdef use extern inlines include bits mathinline h endif define special entry points to use when the compiler got told to only expect finite results if defined finite math only finite math only include bits math finite h endif ifdef use isoc if we ve still got undefined comparison  {
	                                                      comparison :: -1000
                                                               }
macros provide defaults return nonzero value if x is greater than y ifndef isgreater define isgreater x y extension typeof  {
	            typhose :: 7
	             tepefy :: 7
	            torpefy :: 7
	              types :: 7
	              typed :: 7
	              tepoy :: 7
	               typo :: 7
	               type :: 8
	               tope :: 7
                  }
x x x typeof y y y isunordered x y x y endif return nonzero value if x is greater than or equal to y ifndef isgreaterequal define isgreaterequal x y extension typeof x x x typeof y y y isunordered x y x y endif return nonzero value if x is less than y ifndef isless define isless x y extension typeof x x x typeof y y y isunordered x y x y endif return nonzero value if x is less than or equal to y ifndef islessequal define islessequal x y extension typeof x x x typeof y y y isunordered x y x y endif return nonzero value if either x is less than y or y is less than x ifndef islessgreater define islessgreater x y extension typeof x x x typeof y y y isunordered x y x y y x endif return nonzero value if arguments are unordered ifndef isunordered define isunordered u v extension typeof u u u typeof v v v fpclassify u fp nan fpclassify v fp nan endif endif end decls endif math h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef mcheck  {
	                                                                                                                                                                                                                                                                                                                         schmeck :: 7
                                                                                                                                                                                                                                                                                                                               }
h define mcheck h include features h begin decls return values for mprobe  {
	      upbore :: 7
           }
these are the kinds of inconsistencies  {
	inconsistencies :: -1000
    }
that mcheck enables  {
	enables :: -1000
 }
detection of enum mcheck status mcheck disabled consistency checking is not turned on mcheck ok block is fine mcheck free block freed twice mcheck head memory before the block was clobbered  {
	                     clobbered :: -1000
                             }
mcheck tail  {
	tail :: -1000
 }
memory after the block was clobbered activate a standard collection of debugging hooks this must be called before malloc is ever called abortfunc  {
                     }
is called with an error code see enum above when an inconsistency  {
	inconsistency :: -1000
          }
is detected if abortfunc is null the standard function prints on stderr and then calls abort extern int mcheck void abortfunc enum mcheck status throw similar to mcheck but performs checks for all block whenever  {
	                          whenever :: -1000
                                 }
one of the memory handling functions is called this can be very slow extern int mcheck pedantic void abortfunc enum mcheck status throw force check of all blocks now extern void mcheck check all void check for aberrations  {
	                          aberrations :: -1000
                                    }
in a particular malloc d block you must have called mcheck already these are the same checks that mcheck does when you free or reallocate  {
	              reallocate :: -1000
                       }
a block extern enum mcheck status mprobe void ptr throw activate a standard collection of tracing hooks extern void mtrace  {
	           muricate :: 7
	            miracle :: 7
	             mucate :: 7
	            matcher :: 7
	             micate :: 7
	             mercat :: 8
	            mercats :: 7
	             cerate :: 7
	            menacer :: 7
	             carate :: 7
                  }
void throw extern void muntrace  {
	curses :: -1000
   }
void throw end decls endif mcheck h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa svid ifndef memory h define memory h include features h ifndef string h include string h endif string h endif memory h utilities  {
	                                                                                                                                                          utilities :: -1000
                                                                                                                                                                  }
for reading writing fstab mtab  {
	stab :: 5
   }
etc copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef mntent  {
	                                                                                                                                  untent :: 9
	                                                                                                                                  intent :: 9
	                                                                                                                                intently :: 7
	                                                                                                                                 untenty :: 8
	                                                                                                                                 entente :: 7
	                                                                                                                                 untents :: 8
	                                                                                                                                 intents :: 8
	                                                                                                                                  manent :: 8
                                                                                                                                       }
h define mntent h include features h define need file include stdio h include paths h file listing  {
	          listing :: -1000
                }
canonical interesting  {
	interesting :: -1000
 }
mount points define mnttab  {
	mattin :: 7
  }
path mnttab deprecated alias file listing currently active mount points define mounted  {
	    mounted :: -1000
          }
path mounted deprecated alias general filesystem types define mnttype  {
	 tintype :: 9
       }
ignore ignore ignore this entry define mnttype nfs nfs network file system define mnttype swap swap swap device generic mount options define mntopt  {
	              octonary :: -1000
                     }
defaults defaults use all default options define mntopt ro ro read only define mntopt rw rw read write define mntopt suid  {
	                suid :: -1000
                   }
suid set uid allowed define mntopt nosuid  {
	unsaid :: 7
	dousing :: 7
	toluids :: 7
	 nodus :: 8
	 nidus :: 7
	noised :: 7
     }
nosuid no set uid allowed define mntopt noauto  {
      }
noauto do not auto mount begin decls structure describing a mount table entry struct mntent char mnt fsname  {
	          infames :: 8
	          bynames :: 7
	           infame :: 7
	            fanes :: 7
	        filaments :: 7
	          agnames :: 7
	          famines :: 7
	         foramens :: 8
	          foramen :: 7
	          renames :: 7
	          benames :: 7
	           fleams :: 7
	           fanums :: 7
	          finales :: 7
                }
device or server for filesystem char mnt dir directory mounted on char mnt type type of filesystem ufs nfs etc char mnt opts comma separated options for fs int mnt freq dump frequency in days int mnt passno pass number for fsck prepare to begin reading and or writing mount table entries from the beginning of file mode is as for fopen  {
	                                                        foehn :: 6
	                                                        copen :: 7
	                                                       foment :: 6
	                                                       copens :: 6
	                                                         pone :: 6
	                                                         nope :: 7
	                                                         fone :: 7
	                                                        nopes :: 6
	                                                          fop :: 6
                                                            }
extern file setmntent  {
	statement :: 11
	testament :: 11
	sentiment :: 12
 }
const char file const char mode throw read one mount table entry from stream returns a pointer to storage reused  {
	             reused :: -1000
                  }
on the next call or null for eof or error use feof ferror to check extern struct mntent getmntent  {
                 }
file stream throw ifdef use misc reentrant version of the above function extern struct mntent getmntent r file restrict stream struct mntent restrict result char restrict buffer int bufsize throw endif write the mount table entry described by mnt to stream return zero on success nonzero on failure extern int addmntent  {
                                                 }
file restrict stream const struct mntent restrict mnt throw close a stream opened with setmntent extern int endmntent  {
                }
file stream throw search mnt mnt opts for an option matching opt returns the address of the substring or null if none found extern char hasmntopt  {
                        }
const struct mntent mnt const char opt throw end decls endif mntent h header file for monetary value formatting functions copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef monetary h define monetary h include features h get needed types define need size t include stddef h include bits types h ifndef ssize t defined typedef ssize t ssize t define ssize t defined endif begin decls formatting a monetary value according to the current locale extern ssize t strfmon  {
	                                                                                                                                                                                                    vacuation :: -1000
                                                                                                                                                                                                            }
char restrict s size t maxsize  {
    }
const char restrict format throw attribute format strfmon ifdef use xopen k include xlocale h formatting a monetary value according to the current locale extern ssize t strfmon l char restrict s size t maxsize locale t loc const char restrict format throw attribute format strfmon endif ifdef ldbl compat include bits monetary ldbl h endif end decls endif monetary h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef mqueue  {
                                                                                                                                                                                                   }
h define mqueue h include features h include sys types h include fcntl h define need sigevent t include bits siginfo  {
	             signify :: 9
                   }
h define need timespec include time h get the definition of mqd  {
	        mod :: 3
	        mid :: 3
	        med :: 3
	        mad :: 3
          }
t and struct mq attr include bits mqueue h begin decls establish connection between a process and a message queue  {
	              queue :: -1000
                  }
name and return message queue descriptor or mqd t on error oflag determines the type of access used if o creat is on oflag the third argument is taken as a mode t the mode of the created message queue and the fourth argument is taken as struct mq attr pointer to message queue attributes if the fourth argument is null default attributes are used extern mqd t mq open const char name int oflag throw nonnull removes  {
	                                                                      removes :: -1000
                                                                            }
the association  {
	association :: -1000
 }
between message queue descriptor mqdes  {
	modest :: 6
	modes :: 7
   }
and its message queue extern int mq close mqd t mqdes throw query status and attributes of message queue mqdes extern int mq getattr mqd t mqdes struct mq attr mqstat  {
                             }
throw nonnull set attributes associated with message queue mqdes and if omqstat  {
          }
is not null also query its old attributes extern int mq setattr  {
	    stretta :: 10
	  betatters :: 9
          }
mqd t mqdes const struct mq attr restrict mqstat struct mq attr restrict omqstat throw nonnull remove message queue named name extern int mq unlink const char name throw nonnull register notification issued upon message arrival  {
	                            arrival :: -1000
                                  }
to an empty message queue mqdes extern int mq notify  {
	   notify :: -1000
        }
mqd t mqdes const struct sigevent notification throw receive the oldest  {
	    oldest :: -1000
         }
from highest priority messages in message queue mqdes extern ssize t mq receive mqd t mqdes char msg ptr size t msg len unsigned int msg prio nonnull add message pointed by msg ptr to message queue mqdes extern int mq send mqd t mqdes const char msg ptr size t msg len unsigned int msg prio nonnull ifdef use xopen k receive the oldest from highest priority messages in message queue mqdes stop waiting  {
	                                                                   waiting :: -1000
                                                                         }
if abs timeout expires extern ssize t mq timedreceive  {
       }
mqd t mqdes char restrict msg ptr size t msg len unsigned int restrict msg prio const struct timespec restrict abs timeout nonnull add message pointed by msg ptr to message queue mqdes stop blocking  {
	                           ganseys :: -1000
                                 }
on full message queue if abs timeout expires extern int mq timedsend  {
	  mistended :: 11
          }
mqd t mqdes const char msg ptr size t msg len unsigned int msg prio const struct timespec abs timeout nonnull endif define some inlines helping to catch common problems if use fortify level defined extern always inline defined va arg pack len include bits mqueue h endif end decls endif mqueue h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa all data returned by the network data base library are supplied in host order and returned in network order suitable for use in system calls ifndef netdb  {
	                                                                                                                                                                                                                 tend :: 6
	                                                                                                                                                                                                                 bend :: 6
	                                                                                                                                                                                                                  net :: 6
                                                                                                                                                                                                                    }
h define netdb h include features h include netinet  {
	  nerine :: 9
	renitent :: 9
	penitent :: 9
	 netizen :: 9
       }
in h include stdint h ifdef use misc this is necessary to make this include file properly replace the sun version include rpc netdb h endif ifdef use gnu define need sigevent t include bits siginfo h define need timespec include time h endif include bits netdb h absolute file name for network data base files define path hequiv  {
                                                         }
etc hosts  {
	hosts :: -1000
 }
equiv define path hosts etc hosts define path networks  {
	networks :: -1000
       }
etc networks define path nsswitch  {
   }
conf etc nsswitch conf define path protocols  {
	protocols :: -1000
     }
etc protocols define path services etc services begin decls if defined use misc defined use xopen k error status for non reentrant lookup functions we use a macro to access always the thread specific h errno variable define h errno h errno location function to get address of global h errno variable extern int h errno location void throw attribute const possible values left in h errno define host not found authoritative  {
	                                                          authoritative :: -1000
                                                                      }
answer  {
	answer :: -1000
 }
host not found define try again non authoritative host not found or serverfail  {
	      server :: 12
           }
define no recovery non recoverable errors formerr  {
	 forme :: 9
	former :: 10
	formers :: 9
     }
refused  {
	refused :: -1000
 }
notimp define no data valid name no data record of requested type endif if defined use misc defined use gnu define netdb internal see errno define netdb success no problem define no address no data no address look for mx record endif ifdef use xopen k highest reserved internet  {
	                                        internet :: -1000
                                               }
port number define ipport  {
	improvised :: -1000
  }
reserved endif ifdef use gnu scope delimiter  {
	delimiter :: -1000
     }
for getaddrinfo  {
 }
getnameinfo  {
 }
define scope delimiter endif ifdef use misc print error indicated by h errno variable on standard error str if non null is printed before the error string extern void herror  {
	                       horror :: 9
	                     harrower :: 8
	                       terror :: 9
	                      terrors :: 8
	                    harrowers :: 7
	                     harborer :: 7
	                      horrors :: 8
                            }
const char str throw return string associated with error err num extern const char hstrerror  {
             }
int err num throw endif description of data base entry for a single host struct hostent  {
	      monteiths :: 9
	       contents :: 9
	       portents :: 9
	        hottest :: 10
              }
char h name official name of host char h aliases alias list int h addrtype  {
             }
host address type int h length length of address char h addr list list of addresses from name server if defined use misc defined use gnu define h addr h addr list address for backward compatibility endif open host data base files and mark them as staying  {
	                                       staying :: -1000
                                             }
open even after a later search if stay open is non zero this function is a possible cancellation point and therefore not marked with throw extern void sethostent  {
                          }
int stay open close host data base files and clear stay open flag this function is a possible cancellation point and therefore not marked with throw extern void endhostent  {
	                    endnotes :: 12
                           }
void get next entry from host data base file open data base if necessary this function is a possible cancellation point and therefore not marked with throw extern struct hostent gethostent  {
                             }
void return entry from host data base which address match addr with length len and type type this function is a possible cancellation point and therefore not marked with throw extern struct hostent gethostbyaddr  {
                                }
const void addr socklen t len int type return entry from host data base for host with name this function is a possible cancellation point and therefore not marked with throw extern struct hostent gethostbyname  {
                                 }
const char name ifdef use misc return entry from host data base for host with name af must be set to the address type which is af inet  {
	                     instep :: 5
	                      inter :: 5
	                      inset :: 5
	                      inlet :: 5
	                      inert :: 6
	                      inept :: 6
	                     inerts :: 5
	                      unite :: 5
	                       inte :: 6
                          }
for ipv  {
	provands :: -1000
 }
or af inet for ipv this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern struct hostent gethostbyname const char name int af reentrant versions of the functions above the additional arguments specify a buffer of buflen starting at buf the last argument is a pointer to a variable which gets the value which would be stored in the global variable herrno  {
	                                                                                    herry :: 7
	                                                                                    heron :: 8
	                                                                                  herring :: 7
	                                                                                  heronry :: 9
	                                                                                  heritor :: 7
	                                                                                   perron :: 7
	                                                                                   horner :: 8
	                                                                                   herons :: 7
	                                                                                  horrent :: 8
	                                                                                  hornier :: 7
	                                                                                  horners :: 7
                                                                                        }
by the non reentrant functions these functions are not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation they are cancellation points and therefore not marked with throw extern int gethostent r struct hostent restrict result buf char restrict buf size t buflen struct hostent restrict result int restrict h errnop  {
	                                                noninflammatory :: -1000
                                                              }
extern int gethostbyaddr r const void restrict addr socklen t len int type struct hostent restrict result buf char restrict buf size t buflen struct hostent restrict result int restrict h errnop extern int gethostbyname r const char restrict name struct hostent restrict result buf char restrict buf size t buflen struct hostent restrict result int restrict h errnop extern int gethostbyname r const char restrict name int af struct hostent restrict result buf char restrict buf size t buflen struct hostent restrict result int restrict h errnop endif misc open network data base files and mark them as staying open even after a later search if stay open is non zero this function is a possible cancellation point and therefore not marked with throw extern void setnetent  {
                                                                                                                              }
int stay open close network data base files and clear stay open flag this function is a possible cancellation point and therefore not marked with throw extern void endnetent  {
                           }
void get next entry from network data base file open data base if necessary this function is a possible cancellation point and therefore not marked with throw extern struct netent  {
	               suspiciousness :: -1000
                            }
getnetent  {
 }
void return entry from network data base which address match net and type type this function is a possible cancellation point and therefore not marked with throw extern struct netent getnetbyaddr  {
	                      dummerer :: -1000
                             }
uint t net int type return entry from network data base for network with name this function is a possible cancellation point and therefore not marked with throw extern struct netent getnetbyname  {
                              }
const char name ifdef use misc reentrant versions of the functions above the additional arguments specify a buffer of buflen starting at buf the last argument is a pointer to a variable which gets the value which would be stored in the global variable herrno by the non reentrant functions these functions are not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation they are cancellation points and therefore not marked with throw extern int getnetent r struct netent restrict result buf char restrict buf size t buflen struct netent restrict result int restrict h errnop extern int getnetbyaddr r uint t net int type struct netent restrict result buf char restrict buf size t buflen struct netent restrict result int restrict h errnop extern int getnetbyname r const char restrict name struct netent restrict result buf char restrict buf size t buflen struct netent restrict result int restrict h errnop endif misc description of data base entry for a single service struct servent  {
	                                                                                                                                                                          served :: 9
	                                                                                                                                                                        prevents :: 10
	                                                                                                                                                                        percents :: 9
	                                                                                                                                                                          nerves :: 10
	                                                                                                                                                                         sievert :: 9
	                                                                                                                                                                       fervently :: 9
	                                                                                                                                                                       sirventes :: 9
	                                                                                                                                                                         vervets :: 9
	                                                                                                                                                                         fervent :: 11
	                                                                                                                                                                         veriest :: 9
	                                                                                                                                                                         prevent :: 9
	                                                                                                                                                                         servant :: 10
	                                                                                                                                                                         serpent :: 11
	                                                                                                                                                                       servanted :: 11
	                                                                                                                                                                         venters :: 9
	                                                                                                                                                                        servient :: 10
	                                                                                                                                                                        nerviest :: 9
	                                                                                                                                                                          ternes :: 9
	                                                                                                                                                                          steven :: 10
	                                                                                                                                                                           serve :: 10
	                                                                                                                                                                        perpents :: 9
	                                                                                                                                                                        serpents :: 9
	                                                                                                                                                                          verset :: 9
	                                                                                                                                                                        ferments :: 9
	                                                                                                                                                                        sirvente :: 11
	                                                                                                                                                                           nerve :: 9
                                                                                                                                                                               }
char s name official service name char s aliases alias list int s port port number char s proto protocol to use open service data base files and mark them as staying open even after a later search if stay open is non zero this function is a possible cancellation point and therefore not marked with throw extern void setservent  {
	                                                  stellated :: -1000
                                                          }
int stay open close service data base files and clear stay open flag this function is a possible cancellation point and therefore not marked with throw extern void endservent  {
	                  endearment :: 13
	                 endearments :: 14
                           }
void get next entry from service data base file open data base if necessary this function is a possible cancellation point and therefore not marked with throw extern struct servent getservent  {
	                    pesterment :: 12
                             }
void return entry from network data base for network with name and protocol proto this function is a possible cancellation point and therefore not marked with throw extern struct servent getservbyname  {
                             }
const char name const char proto return entry from service data base which matches port port and protocol proto this function is a possible cancellation point and therefore not marked with throw extern struct servent getservbyport  {
                                  }
int port const char proto ifdef use misc reentrant versions of the functions above the additional arguments specify a buffer of buflen starting at buf these functions are not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation they are cancellation points and therefore not marked with throw extern int getservent r struct servent restrict result buf char restrict buf size t buflen struct servent restrict result extern int getservbyname r const char restrict name const char restrict proto struct servent restrict result buf char restrict buf size t buflen struct servent restrict result extern int getservbyport r int port const char restrict proto struct servent restrict result buf char restrict buf size t buflen struct servent restrict result endif misc description of data base entry for a single service struct protoent  {
	                                                                                                                                          proton :: 10
	                                                                                                                                       protonate :: 13
	                                                                                                                                      protection :: 10
	                                                                                                                                     protonemata :: 10
	                                                                                                                                      protonated :: 12
	                                                                                                                                      protonates :: 12
                                                                                                                                               }
char p name official protocol name char p aliases alias list int p proto protocol number open protocol data base files and mark them as staying open even after a later search if stay open is non zero this function is a possible cancellation point and therefore not marked with throw extern void setprotoent  {
                                                    }
int stay open close protocol data base files and clear stay open flag this function is a possible cancellation point and therefore not marked with throw extern void endprotoent  {
                           }
void get next entry from protocol data base file open data base if necessary this function is a possible cancellation point and therefore not marked with throw extern struct protoent getprotoent  {
                             }
void return entry from protocol data base for network with name this function is a possible cancellation point and therefore not marked with throw extern struct protoent getprotobyname  {
                          }
const char name return entry from protocol data base which number is proto this function is a possible cancellation point and therefore not marked with throw extern struct protoent getprotobynumber  {
                            }
int proto ifdef use misc reentrant versions of the functions above the additional arguments specify a buffer of buflen starting at buf these functions are not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation they are cancellation points and therefore not marked with throw extern int getprotoent r struct protoent restrict result buf char restrict buf size t buflen struct protoent restrict result extern int getprotobyname r const char restrict name struct protoent restrict result buf char restrict buf size t buflen struct protoent restrict result extern int getprotobynumber r int proto struct protoent restrict result buf char restrict buf size t buflen struct protoent restrict result establish network group netgroup  {
	                                                                                                                    outgroup :: 10
                                                                                                                           }
for enumeration this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int setnetgrent  {
                                        }
const char netgroup free all space allocated by previous setnetgrent call this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern void endnetgrent  {
                                                 }
void get next member of netgroup established by last setnetgrent call and return pointers to elements in hostp  {
	            houts :: 6
	            hosts :: 6
	            hosta :: 7
	            holts :: 6
	           hostry :: 6
	           hostly :: 6
	           hostel :: 6
	           hosted :: 6
	             tosh :: 6
	             post :: 7
	             posh :: 6
	             hots :: 6
	             host :: 8
	             hops :: 6
	          hotspur :: 6
	            phots :: 6
	              hos :: 6
                }
userp  {
	usurped :: 6
	usurp :: 6
	users :: 6
	user :: 8
	use :: 6
 }
and domainp  {
	domain :: 12
	dopamine :: 9
	demain :: 9
	domainal :: 9
	damping :: 9
	domains :: 11
 }
this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int getnetgrent  {
                                      }
char restrict hostp char restrict userp char restrict domainp test whether netgroup contains the triple host user domain this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int innetgr  {
	                                                   intern :: 9
	                                               intergrown :: 9
                                                        }
const char netgroup const char host const char user const char domain reentrant version of getnetgrent where result is placed in buffer this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int getnetgrent r char restrict hostp char restrict userp char restrict domainp char restrict buffer size t buflen endif misc ifdef use bsd call rshd  {
                                                                                   }
at port rport  {
	sporter :: 6
	aport :: 7
	sport :: 7
	sporty :: 6
	sports :: 6
	poort :: 6
 }
on remote machine ahost  {
	shoats :: 7
	ghosty :: 6
	hoast :: 7
	ghost :: 7
	ghast :: 6
	ahoys :: 6
	shortia :: 6
	those :: 6
	taos :: 6
	shot :: 6
	shout :: 6
	shott :: 6
	short :: 6
	shoat :: 8
  }
to execute cmd the local user is locuser  {
	locustae :: 9
	focusers :: 9
	clouters :: 9
	lousier :: 9
	courser :: 9
	colubers :: 10
	coruler :: 9
	chouser :: 9
	 oscule :: 9
	 crouse :: 9
	scouser :: 9
	 course :: 9
	colures :: 10
	coluber :: 9
	 colure :: 9
	locules :: 9
	locaters :: 9
	couplers :: 9
	focuser :: 11
	vocules :: 9
	coulters :: 9
	 locust :: 9
	corulers :: 10
	crousely :: 9
      }
on the remote machine the command is executed as remuser  {
	  resumer :: 12
	   bemuse :: 9
	  rescuer :: 9
	 resumers :: 11
	  repures :: 9
	 remakers :: 9
	  remueur :: 9
	 rebukers :: 9
	  lemures :: 9
	   resume :: 9
	 reducers :: 9
	  refuser :: 11
	  peruser :: 10
	  recures :: 9
	 refuters :: 9
	 refusers :: 9
	 remueurs :: 10
	 removers :: 9
	  securer :: 9
	  demurer :: 10
        }
in fd p the descriptor to the socket for the connection is returned the caller must have the right to use a reserved port when the function returns ahost contains the official host name this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int rcmd  {
                                                                        }
char restrict ahost unsigned short int rport const char restrict locuser const char restrict remuser const char restrict cmd int restrict fd p this is the equivalent function where the protocol can be selected and which therefore can be used for ipv this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int rcmd af char restrict ahost unsigned short int rport const char restrict locuser const char restrict remuser const char restrict cmd int restrict fd p sa family t af call rexecd  {
	                                                                                                          cered :: 7
	                                                                                                          ceder :: 7
	                                                                                                         reduce :: 7
	                                                                                                         recced :: 7
	                                                                                                          rexes :: 7
	                                                                                                          rebec :: 7
                                                                                                              }
at port rport on remote machine ahost to execute cmd the process runs  {
	        sens :: -1000
           }
at the remote machine using the id of user name whose cleartext  {
          }
password is passwd in fd p the descriptor to the socket for the connection is returned when the function returns ahost contains the official host name this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int rexec char restrict ahost int rport const char restrict name const char restrict pass const char restrict cmd int restrict fd p this is the equivalent function where the protocol can be selected and which therefore can be used for ipv this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int rexec af char restrict ahost int rport const char restrict name const char restrict pass const char restrict cmd int restrict fd p sa family t af check whether user remuser on system rhost  {
	                                                                                                                                                                            shorty :: 7
	                                                                                                                                                                            shorts :: 7
	                                                                                                                                                                            ghosty :: 6
	                                                                                                                                                                             horst :: 7
	                                                                                                                                                                             ghost :: 7
	                                                                                                                                                                             frost :: 6
	                                                                                                                                                                            whorts :: 7
	                                                                                                                                                                           shouter :: 6
	                                                                                                                                                                           shortly :: 6
	                                                                                                                                                                           shorten :: 6
	                                                                                                                                                                           shorter :: 6
	                                                                                                                                                                           shortie :: 6
	                                                                                                                                                                           shortia :: 6
	                                                                                                                                                                            horste :: 6
	                                                                                                                                                                            thorps :: 6
	                                                                                                                                                                            thorns :: 6
	                                                                                                                                                                             whort :: 6
	                                                                                                                                                                             those :: 6
	                                                                                                                                                                              shot :: 6
	                                                                                                                                                                              rots :: 6
	                                                                                                                                                                             shout :: 6
	                                                                                                                                                                             shott :: 6
	                                                                                                                                                                             short :: 8
	                                                                                                                                                                             shoat :: 6
	                                                                                                                                                                             royst :: 6
	                                                                                                                                                                             roust :: 6
	                                                                                                                                                                             roost :: 7
	                                                                                                                                                                             roist :: 6
	                                                                                                                                                                             roast :: 6
	                                                                                                                                                                             prost :: 6
	                                                                                                                                                                          ghostier :: 6
	                                                                                                                                                                               rho :: 6
                                                                                                                                                                                 }
is allowed to login  {
	legion :: 7
	lovings :: 7
	poling :: 7
	holings :: 6
	doling :: 7
	algin :: 6
	owling :: 6
	yogins :: 6
	toling :: 7
	holing :: 7
	logions :: 6
	logania :: 7
	voling :: 7
	polings :: 6
	lobings :: 7
	joling :: 7
	yogin :: 7
	legions :: 6
	oiling :: 6
	loginess :: 7
	ogling :: 6
	loxing :: 8
	lowing :: 8
	loving :: 8
	losing :: 8
	loring :: 8
	loping :: 8
	looing :: 7
	logion :: 7
	logier :: 6
	logics :: 6
	logans :: 6
	lobing :: 8
	long :: 6
	loin :: 6
	soling :: 7
	tolings :: 6
	oggin :: 6
	logie :: 7
	logic :: 7
	logia :: 7
	logan :: 7
	log :: 6
	lingo :: 6
	ligan :: 6
  }
as locuser if suser  {
	sieurs :: 6
	musers :: 7
	assure :: 6
	surges :: 6
	surest :: 7
	supers :: 8
	sudser :: 6
	sucres :: 6
	subers :: 8
	suberins :: 6
	sures :: 8
	surer :: 6
	supes :: 6
	super :: 6
	suber :: 6
	sure :: 6
	ruses :: 7
	suspire :: 6
	ushers :: 6
	superspy :: 6
	muser :: 7
	duress :: 6
  }
is not zero the user tries to become  {
	 become :: -1000
      }
superuser  {
	thoued :: -1000
 }
return if it is possible this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int ruserok  {
	                                      rokers :: 9
                                           }
const char rhost int suser const char remuser const char locuser this is the equivalent function where the protocol can be selected and which therefore can be used for ipv this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int ruserok af const char rhost int suser const char remuser const char locuser sa family t af check whether user remuser on system indicated by ipv address raddr  {
                                                                                               }
is allowed to login as locuser non ipv e g ipv are not supported if suser is not zero the user tries to become superuser return if it is possible this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int iruserok  {
	                                                               rouser :: 10
                                                                    }
uint t raddr int suser const char remuser const char locuser this is the equivalent function where the pfamiliy  {
                 }
if the address pointed to by raddr is determined by the value of af it therefore can be used for ipv this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int iruserok af const void raddr int suser const char remuser const char locuser sa family t af try to allocate reserved port returning a descriptor for a socket opened at this port or if unsuccessful the search for an available port will start at alport  {
	                                                                                                   algor :: 7
	                                                                                                  apport :: 9
	                                                                                                 apports :: 8
	                                                                                                    alto :: 7
                                                                                                       }
and continues  {
	continues :: -1000
 }
with lower numbers this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int rresvport  {
                                         }
int alport this is the equivalent function where the protocol can be selected and which therefore can be used for ipv this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int rresvport af int alport sa family t af endif extension from posix g ifdef use posix structure to contain information about address of a service provider struct addrinfo  {
                                                                                      }
int ai flags input flags int ai family protocol family for socket int ai socktype  {
	       sockeye :: 10
	       pockets :: 10
	        socket :: 10
             }
socket type int ai protocol protocol for socket socklen t ai addrlen  {
	    adorned :: 9
	    dandler :: 9
          }
length of socket address struct sockaddr ai addr socket address for socket char ai canonname  {
	       nonlife :: -1000
             }
canonical name for service location struct addrinfo ai next pointer to next in list ifdef use gnu structure used as control block for asynchronous lookup struct gaicb  {
                         }
const char ar name name to look up const char ar service service name const struct addrinfo ar request additional request specification struct addrinfo ar result pointer to result the following are internal elements int return int unused lookup mode define gai wait define gai nowait endif possible values for ai flags field in addrinfo structure define ai passive  {
	                                                   passive :: -1000
                                                         }
x socket address is intended for bind define ai canonname x request for canonical name define ai numerichost  {
	         numerics :: 15
	          numeric :: 14
                }
x don t use name resolution define ai v mapped x ipv mapped addresses are acceptable define ai all x return ipv mapped and ipv addresses define ai addrconfig  {
                           }
x use configuration of this host to choose returned address type ifdef use gnu define ai idn x idn encode input assuming it is encoded in the current locale s character set before looking it up define ai canonidn  {
                                     }
x translate canonical name from idn format define ai idn allow unassigned x don t reject unassigned unicode code points define ai idn use std ascii rules x validate strings according to std rules endif define ai numericserv  {
	                             numerics :: 14
	                           numeracies :: 14
                                    }
x don t use name resolution error values for getaddrinfo function define eai  {
	   sermoners :: -1000
           }
badflags  {
 }
invalid value for ai flags field define eai noname  {
	 agnomen :: 7
	 foramen :: 7
	  mopane :: 7
	 unnamed :: 7
	 monases :: 7
	 monades :: 7
	nonmetal :: 7
	 noumena :: 7
	nonimage :: 8
	    none :: 7
	    nona :: 8
	    mona :: 7
	 nonmeat :: 8
	   nonas :: 7
	   nomen :: 7
	 nongame :: 8
	ornament :: 7
	  nonane :: 7
	  nonage :: 9
	 nonaged :: 8
	 nonages :: 8
	  nomade :: 7
       }
name or service is unknown define eai again temporary failure in name resolution define eai fail non recoverable failure in name res define eai family ai family not supported define eai socktype ai socktype not supported define eai service service not supported for ai socktype define eai memory memory allocation failure define eai system system error returned in errno define eai overflow argument buffer overflow ifdef use gnu define eai nodata  {
	                                                               sonatas :: 7
	                                                               notanda :: 7
	                                                              ondatras :: 7
	                                                                sonata :: 8
	                                                               ondatra :: 8
	                                                              donatary :: 8
                                                                     }
no address associated with name define eai addrfamily  {
      }
address family for name not supported define eai inprogress  {
	headhunted :: -1000
       }
processing request in progress define eai canceled request canceled define eai notcanceled request not canceled define eai alldone all requests done define eai intr interrupted  {
	             interrupted :: -1000
                       }
by a signal define eai idn encode idn encoding failed endif ifdef use misc define ni maxhost  {
	          machos :: 9
	         harmost :: 9
               }
define ni maxserv  {
	marvers :: 9
	marse :: 9
 }
endif define ni numerichost don t try to look up hostname  {
	  postgame :: 10
	  moschate :: 10
	   hoseman :: 11
	  hoastmen :: 10
         }
define ni numericserv don t convert port number to name define ni nofqdn  {
           }
only return nodename  {
	nominated :: 10
	forename :: 10
	modena :: 10
	forenamed :: 11
	novenae :: 10
 }
portion define ni namereqd  {
  }
don t return numeric addresses define ni dgram  {
	  dream :: 6
	   darg :: 6
      }
look up udp service rather than tcp ifdef use gnu define ni idn convert name from idn format define ni idn allow unassigned don t reject unassigned unicode code points define ni idn use std ascii rules validate strings according to std rules endif translate name of a service location and or a service name to set of socket addresses this function is a possible cancellation point and therefore not marked with throw extern int getaddrinfo const char restrict name const char restrict service const struct addrinfo restrict req struct addrinfo restrict pai free addrinfo structure ai including associated storage extern void freeaddrinfo  {
	                                                                                            arrestable :: -1000
                                                                                                     }
struct addrinfo ai throw convert error return from getaddrinfo to a string extern const char gai strerror int ecode  {
	            echoed :: 7
	             geode :: 6
	             exode :: 7
	             erode :: 7
	             epode :: 7
	            exodes :: 6
	            cooeed :: 6
	            erodes :: 6
	            epodes :: 6
	            elodea :: 6
	              ecod :: 7
                 }
throw translate a socket address to a location and service name this function is a possible cancellation point and therefore not marked with throw extern int getnameinfo const struct sockaddr restrict sa socklen t salen  {
	                              cope :: -1000
                                 }
char restrict host socklen t hostlen  {
	hondles :: 9
	hosel :: 9
	hustle :: 9
	holstein :: 9
	hostlers :: 9
	hotels :: 9
	hostly :: 9
	hostel :: 10
	jostle :: 9
	hosteling :: 9
	hantles :: 9
	hostler :: 11
	hostile :: 9
	hornlet :: 9
	hornlets :: 10
    }
char restrict serv socklen t servlen  {
	pediculosis :: -1000
    }
int flags endif posix ifdef use gnu enqueue ent requests from the list if mode is gai wait wait until all requests are handled if wait is gai nowait return immediately after queueing  {
	                        queueing :: -1000
                               }
the requests and signal completion according to sig this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int getaddrinfo a int mode struct gaicb list restrict arr int ent struct sigevent restrict sig suspend execution of the thread until at least one of the ent requests in list is handled if timeout is not a null pointer it specifies the longest  {
	                                                                               misimprove :: -1000
                                                                                        }
time the function keeps  {
	keeps :: -1000
  }
waiting before returning with an error this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int gai suspend const struct gaicb const list int ent const struct timespec timeout get the error status of the request req extern int gai error struct gaicb req throw cancel the requests associated with gaicbp  {
                                                                              }
extern int gai cancel struct gaicb gaicbp throw endif gnu end decls endif netdb h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef nl types h define nl types h include features h the default message set used by the gencat  {
	                                                                                                                                                                 gelant :: 7
	                                                                                                                                                                  genua :: 7
	                                                                                                                                                                  genoa :: 7
	                                                                                                                                                                 lancet :: 7
	                                                                                                                                                                zincate :: 7
	                                                                                                                                                                centage :: 7
	                                                                                                                                                                 cental :: 7
	                                                                                                                                                                   gent :: 7
	                                                                                                                                                                   gena :: 7
	                                                                                                                                                                genista :: 7
                                                                                                                                                                      }
program define nl setd value for flag parameter of catgets  {
	  catties :: 9
	  catguts :: 11
	  targets :: 10
	 cathetus :: 9
	  tackets :: 9
        }
to say we want xpg compliance define nl cat locale begin decls message catalog descriptor type typedef void nl catd  {
	               cast :: -1000
                  }
type used by nl langinfo typedef int nl item open message catalog for later use returning descriptor this function is a possible cancellation point and therefore not marked with throw extern nl catd catopen  {
	                         coparent :: 9
	                          patonce :: 10
	                          capotes :: 9
	                         capstone :: 9
	                           capote :: 10
                                }
const char cat name int flag nonnull return translation with number in set of catalog if not found return string extern char catgets nl catd catalog int set int number const char string throw nonnull close message catalog extern int catclose  {
	                                 catches :: 10
	                               catechols :: 10
	                              catchpoles :: 10
	                                 cacolet :: 10
	                                cacolets :: 11
	                                parclose :: 10
                                       }
nl catd catalog throw nonnull end decls endif nl types h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa define interface to nss this is meant for the interface functions and for implementors  {
	                                                                                                                                                  implementors :: -1000
                                                                                                                                                             }
of new services ifndef nss h define nss h include features h include stdint h begin decls possible results of lookup using a nss function enum nss status nss status tryagain  {
                             }
nss status unavail nss status notfound  {
	confounder :: 10
	outfound :: 12
	confounds :: 11
	confound :: 12
    }
nss status success nss status return data structure used for the gethostbyname r function struct gaih  {
	          laigh :: 5
	           gash :: 5
	           gait :: 5
	           gair :: 5
	           gain :: 5
	           gaid :: 5
	            ghi :: 5
              }
addrtuple  {
 }
struct gaih addrtuple next char name int family uint t addr uint t scopeid  {
	       scoped :: 11
	     scopelid :: 11
	      scouped :: 9
	        scope :: 10
            }
overwrite  {
	overwrite :: -1000
 }
service selection for database dbname  {
	bynames :: 7
	dunam :: 7
	deman :: 7
	duramen :: 7
	bename :: 8
	agnamed :: 7
	bedamn :: 8
	benamed :: 9
	renamed :: 7
	benames :: 7
	abdomen :: 8
	unnamed :: 7
	bedamns :: 7
	byname :: 8
	beadmen :: 7
	menad :: 7
   }
using specification in string this function should only be used by system programs which have to work around non existing services e e while booting  {
	                 booting :: -1000
                       }
attention using this function repeatedly  {
	repeatedly :: -1000
   }
will slowly  {
	slowly :: -1000
 }
eat  {
	eat :: -1000
 }
up the whole memory since previous selection data cannot be freed extern int nss configure lookup const char dbname const char string throw end decls endif nss h obstack h object stack macros copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc franklin street fifth floor boston ma usa summary all the apparent  {
	                                                                                                                                                                   apparent :: -1000
                                                                                                                                                                          }
functions defined here are macros the idea is that you would use these pre tested macros to solve a very specific set of problems and they would run fast caution no side effects in arguments please they may be evaluated  {
	                              evaluated :: -1000
                                      }
many times these macros operate a stack of objects each object starts life small and may grow  {
	            grow :: -1000
               }
to maturity  {
	maturity :: -1000
 }
consider building a word syllable  {
	tillable :: -1000
   }
by syllable an object can move while it is growing  {
	  growing :: -1000
        }
once it has been finished it never changes address again so the top of the stack is typically an immature  {
	           immature :: -1000
                  }
growing object while the rest of the stack is of mature  {
	    mature :: -1000
         }
fixed size and fixed address objects these routines grab  {
	informativeness :: -1000
       }
large chunks of memory using a function you supply called obstack chunk alloc on occasion  {
	      occasion :: -1000
             }
they free chunks by calling obstack chunk free you must define them and declare them before using any obstack macros each independent stack is represented by a struct obstack each of the obstack macros expects a pointer to such a structure as the first argument one motivation  {
	                                    motivation :: -1000
                                             }
for this package is the problem of growing char strings in symbol tables unless you are fascist  {
	         fascist :: -1000
               }
pig  {
	pig :: -1000
 }
with a read only mind gosper  {
	hoppers :: 7
	poster :: 8
	posher :: 8
	poseur :: 7
	porges :: 8
	oosperm :: 8
	grope :: 8
	poiser :: 7
	gorse :: 8
	gorps :: 8
	gores :: 7
	golpe :: 7
	goers :: 7
	boppers :: 7
	gippers :: 7
	rompers :: 7
	gasper :: 9
	loppers :: 7
	yoppers :: 7
	coupers :: 7
	soupers :: 7
	gospeller :: 7
	gawpers :: 7
	postern :: 7
	gaupers :: 7
	coppers :: 7
	gaspers :: 7
	gropers :: 9
	poppers :: 7
	gowpens :: 7
	gyppers :: 7
	compers :: 7
	gospeler :: 8
	moppers :: 7
	gosport :: 7
	gospels :: 7
	gripers :: 7
	dorpers :: 7
	gophers :: 9
	stoper :: 7
	doppers :: 7
	toppers :: 7
	groser :: 7
	gropes :: 9
	groper :: 8
	groped :: 7
	gripes :: 7
	grapes :: 7
	golfers :: 7
	 gorp :: 7
	soapers :: 7
	souper :: 8
	gospel :: 9
	gorses :: 7
	gopher :: 8
	goiters :: 7
	sodger :: 7
	golpes :: 8
	soaper :: 8
	poser :: 7
	porge :: 7
	goffers :: 7
    }
s immortal  {
	immortal :: -1000
 }
quote from hakmem  {
	hakeems :: 8
	mayhem :: 7
	maihem :: 7
	hammer :: 7
	hammed :: 7
	hakeem :: 9
	hake :: 7
 }
item out of context you would not like to put any arbitrary upper limit on the length of your symbols in practice  {
	             practice :: -1000
                    }
this often means you will build many short symbols and a few long symbols at the time you are reading a symbol you don t know how long it is one traditional method is to read a symbol into a buffer realloc ating  {
	                                     giant :: 6
	                                    gainst :: 6
	                                     axing :: 7
	                                     awing :: 7
	                                     aping :: 7
	                                     aking :: 7
	                                     ahint :: 6
	                                     aging :: 7
	                                     acing :: 7
	                                  stingray :: 6
	                                    anight :: 6
	                                    agings :: 6
	                                    stingy :: 6
	                                    stings :: 6
	                                    stingo :: 6
	                                     tying :: 6
	                                     thing :: 6
	                                     sting :: 7
	                                     stang :: 6
	                                      tain :: 6
	                                      gain :: 6
	                                   atingle :: 8
                                         }
the buffer every time you try to read a symbol that is longer than the buffer this is beaut  {
	             beaut :: -1000
                 }
but you still will want to copy the symbol from the buffer to a more permanent symbol table entry say about half the time with obstacks  {
	                 castocks :: 11
	                 unstacks :: 10
	                 restacks :: 10
	                 setbacks :: 10
	                 outbacks :: 11
	                 tombacks :: 10
	                 subtacks :: 11
	                obstacles :: 11
                        }
you can work differently  {
	differently :: -1000
  }
use one obstack for all symbol names as you read a symbol grow the name in the obstack gradually  {
	         gradually :: -1000
                 }
when the name is complete finalize it then if the symbol exists already free the newly read name the way we do this is to take a large chunk allocating memory from low addresses when you want to build a symbol in the chunk you just add chars above the current high water  {
	                                               water :: -1000
                                                   }
mark in the chunk when you have finished adding chars because you got to the end of the symbol you know how long the chars are and you can create a new object mostly the chars will not burst  {
	                                 burst :: -1000
                                     }
over the highest address of the chunk because you would typically expect a chunk to be say times as long as an average object in case that isn t clear when we have enough chars to make up the object they are already contiguous in the chunk guaranteed so we just point to it where it lies  {
	                                                    lies :: -1000
                                                       }
no moving of chars is needed and this is the second win potentially long strings need never be explicitly shuffled  {
	           shuffled :: -1000
                  }
once an object is formed it does not change its address during its lifetime  {
	     lifetime :: -1000
            }
when the chars burst over a chunk boundary we allocate a larger chunk and then copy the partly  {
	           partly :: -1000
                }
formed object from the end of the old chunk to the beginning of the new larger chunk we then carry  {
	              carry :: -1000
                  }
on accreting  {
	gesneria :: -1000
 }
characters to the end of the object as we normally would a special macro is provided to add a single char at a time to a growing object this allows the use of register variables which break the ordinary  {
	                              ordinary :: -1000
                                     }
growth  {
	growth :: -1000
 }
macro summary we allocate large chunks we carve  {
	  carve :: -1000
      }
out one object at a time from the current chunk once carved  {
	     carved :: -1000
          }
an object never moves we are free to append data of any size to the currently growing object exactly one object is growing in an obstack at any one time you can run one obstack per control block you may have as many control blocks as you dare  {
	                                           dare :: -1000
                                              }
because of the way we do it you can unwind an obstack back to a previous state you may remove objects much as you would with a stack don t do the contents of this file more than once ifndef obstack h define obstack h ifdef cplusplus extern c endif we need the type of a pointer subtraction  {
	                                              subtraction :: -1000
                                                        }
if ptrdiff type is defined as with gnu c use that that way we don t pollute the namespace with stddef h s symbols otherwise include stddef h and use ptrdiff t ifdef ptrdiff type define ptr int type ptrdiff type else include stddef h define ptr int type ptrdiff t endif if b is the base of an object addressed by p return the result of aligning  {
	                                                           aligning :: -1000
                                                                  }
p to the next multiple of a b and p must be of type char a must be a power of define bptr  {
                     }
align b p a b p b a a similiar  {
	  similar :: 10
	familiars :: 11
	 virilism :: 10
	 similize :: 10
	 militias :: 10
	similarity :: 11
	 familiar :: 10
	 ramilies :: 10
        }
to bptr align b p a except optimize the common case where pointers can be converted to integers aligned as integers and converted back again if ptr int type is narrower  {
	                      narrower :: -1000
                             }
than a pointer e g the as play it safe and compute the alignment relative to b otherwise use the faster strategy of computing  {
	              computing :: -1000
                      }
the alignment relative to define ptr align b p a bptr align sizeof ptr int type sizeof void b char p a include string h struct obstack chunk lives  {
	                       lives :: -1000
                           }
at front  {
	front :: -1000
 }
of each chunk char limit past end of this chunk struct obstack chunk prev address of prior chunk or null char contents objects begin here struct obstack control current object in current chunk long chunk size preferred size to allocate chunks in struct obstack chunk chunk address of current struct obstack chunk char object base address of object we are building char next free where to add next char to current object char chunk limit address of char after current chunk union ptr int type tempint  {
	                                                                              temping :: 10
	                                                                            temptings :: 9
	                                                                                tempt :: 9
	                                                                                tempi :: 9
	                                                                             tempting :: 10
                                                                                    }
void tempptr  {
	cogenerations :: -1000
 }
temp temporary for some macros int alignment mask mask of alignment for each object these prototypes vary based on use extra arg and we use casts  {
	                    casts :: -1000
                        }
to the prototypeless  {
	prototype :: 17
	prototyped :: 16
	prototypes :: 18
	prototypal :: 17
 }
function type in all assignments  {
	assignments :: -1000
   }
but having prototypes here quiets  {
	quiets :: -1000
   }
wstrict prototypes struct obstack chunk chunkfun  {
    }
void long void freefun  {
  }
void struct obstack chunk void extra arg first arg for chunk alloc dealloc funcs  {
	       funest :: 6
	        funks :: 7
	        funds :: 7
	     functors :: 6
            }
unsigned use extra arg chunk alloc dealloc funcs take extra arg unsigned maybe empty object there is a possibility that the current chunk contains a zero length object this prevents freeing the chunk if we allocate a bigger  {
	                               bigger :: -1000
                                    }
chunk to replace it unsigned alloc failed no longer used as we now call the failed handler on error but retained for binary compatibility declare the external functions we use they are in obstack c extern void obstack newchunk  {
                                     }
struct obstack int extern int obstack begin struct obstack int int void long void void extern int obstack begin struct obstack int int void void long void void void void extern int obstack memory used struct obstack void obstack free struct obstack obstack void block error handler called when obstack chunk alloc failed to allocate more memory this can be set to a user defined function which should either abort gracefully  {
	                                                            gracefully :: -1000
                                                                     }
or use longjump  {
 }
but shouldn t return the default action is to print a message and abort extern void obstack alloc failed handler void exit value used when print and abort is used extern int obstack exit failure pointer to beginning of object being allocated or to be allocated next note that this might not be the final address of the object because a new chunk might be needed to hold the final size define obstack base h void h object base size for allocating ordinary chunks define obstack chunk size h h chunk size pointer to next byte not yet allocated in current chunk define obstack next free h h next free mask specifying low bits that should be clear in address of an object define obstack alignment mask h h alignment mask to prevent prototype warnings provide complete argument list define obstack init h obstack begin h void long obstack chunk alloc void void obstack chunk free define obstack begin h size obstack begin h size void long obstack chunk alloc void void obstack chunk free define obstack specify allocation h size alignment chunkfun freefun obstack begin h size alignment void long chunkfun void void freefun define obstack specify allocation with arg h size alignment chunkfun freefun arg obstack begin h size alignment void void long chunkfun void void void freefun arg define obstack chunkfun h newchunkfun  {
                                                                                                                                                                                                                                }
h chunkfun struct obstack chunk void long newchunkfun define obstack freefun h newfreefun  {
           }
h freefun void void struct obstack chunk newfreefun define obstack grow fast h achar  {
	        lahar :: 6
	       echard :: 6
	      acharne :: 8
	        arhat :: 6
	       areach :: 6
	       achage :: 6
            }
h next free achar define obstack blank fast h n h next free n define obstack memory used h obstack memory used h if defined gnuc defined stdc stdc nextstep  {
	                       sextet :: 10
                            }
cc is really gcc but it defines gnuc and does not implement extension but that compiler doesn t define gnuc minor if gnuc next gnuc minor define extension endif for gnu c if not traditional we can define these macros to compute all args only once without using a global variable also we can avoid using the temp slot to make faster code define obstack object size obstack extension struct obstack const o obstack unsigned o next free o object base define obstack room obstack extension struct obstack const o obstack unsigned o chunk limit o next free define obstack make room obstack length extension struct obstack o obstack int len length if o chunk limit o next free len obstack newchunk o len void define obstack empty p obstack extension struct obstack const o obstack o chunk prev o next free ptr align char o chunk o chunk contents o alignment mask define obstack grow obstack where length extension struct obstack o obstack int len length if o next free len o chunk limit obstack newchunk o len memcpy o next free where len o next free len void define obstack grow obstack where length extension struct obstack o obstack int len length if o next free len o chunk limit obstack newchunk o len memcpy o next free where len o next free len o next free void define obstack grow obstack datum  {
	                                                                                                                                                                                                                                     datum :: -1000
                                                                                                                                                                                                                                         }
extension struct obstack o obstack if o next free o chunk limit obstack newchunk o obstack grow fast o datum void these assume that the obstack alignment is good enough for pointers or ints and that the data added so far to the current object shares  {
	                                       shares :: -1000
                                            }
that much alignment define obstack ptr grow obstack datum extension struct obstack o obstack if o next free sizeof void o chunk limit obstack newchunk o sizeof void obstack ptr grow fast o datum define obstack int grow obstack datum extension struct obstack o obstack if o next free sizeof int o chunk limit obstack newchunk o sizeof int obstack int grow fast o datum define obstack ptr grow fast obstack aptr  {
	                                                                granule :: -1000
                                                                      }
extension struct obstack o obstack const void o next free aptr o next free sizeof const void void define obstack int grow fast obstack aint  {
	                  auntie :: 5
	                  pintas :: 5
	                   tinea :: 5
	                    vint :: 5
	                    tint :: 5
	                   tanti :: 5
	                    pint :: 5
	                    mint :: 5
	                    lint :: 5
	                    hint :: 5
	                    dint :: 5
	                    bint :: 5
	                    anti :: 5
	                    airt :: 5
	                    ains :: 5
	                  qintar :: 5
	                   pinta :: 6
	                     tin :: 5
	                     ait :: 5
	                     ain :: 6
                       }
extension struct obstack o obstack int o next free aint o next free sizeof int void define obstack blank obstack length extension struct obstack o obstack int len length if o chunk limit o next free len obstack newchunk o len obstack blank fast o len void define obstack alloc obstack length extension struct obstack h obstack obstack blank h length obstack finish h define obstack copy obstack where length extension struct obstack h obstack obstack grow h where length obstack finish h define obstack copy obstack where length extension struct obstack h obstack obstack grow h where length obstack finish h the local variable is named o to avoid a name conflict when obstack blank is called define obstack finish obstack extension struct obstack o obstack void value void o object base if o next free value o maybe empty object o next free ptr align o object base o next free o alignment mask if o next free char o chunk o chunk limit char o chunk o next free o chunk limit o object base o next free value define obstack free obstack obj extension struct obstack o obstack void obj obj if obj void o chunk obj void o chunk limit o next free o object base char obj else obstack free o obj else not gnuc or not stdc define obstack object size h unsigned h next free h object base define obstack room h unsigned h chunk limit h next free define obstack empty p h h chunk prev h next free ptr align char h chunk h chunk contents h alignment mask note that the call to obstack newchunk is enclosed  {
	                                                                                                                                                                                                                                                                             enclosed :: -1000
                                                                                                                                                                                                                                                                                    }
in so that we can avoid having void expressions in the arms  {
	   mortling :: -1000
          }
of the conditional expression casting  {
	casting :: -1000
   }
the third operand  {
	operand :: -1000
 }
to void was tried before but some compilers won t accept it define obstack make room h length h temp tempint length h next free h temp tempint h chunk limit obstack newchunk h h temp tempint define obstack grow h where length h temp tempint length h next free h temp tempint h chunk limit obstack newchunk h h temp tempint memcpy h next free where h temp tempint h next free h temp tempint define obstack grow h where length h temp tempint length h next free h temp tempint h chunk limit obstack newchunk h h temp tempint memcpy h next free where h temp tempint h next free h temp tempint h next free define obstack grow h datum h next free h chunk limit obstack newchunk h obstack grow fast h datum define obstack ptr grow h datum h next free sizeof char h chunk limit obstack newchunk h sizeof char obstack ptr grow fast h datum define obstack int grow h datum h next free sizeof int h chunk limit obstack newchunk h sizeof int obstack int grow fast h datum define obstack ptr grow fast h aptr const void h next free sizeof void aptr define obstack int grow fast h aint int h next free sizeof int aint define obstack blank h length h temp tempint length h chunk limit h next free h temp tempint obstack newchunk h h temp tempint obstack blank fast h h temp tempint define obstack alloc h length obstack blank h length obstack finish h define obstack copy h where length obstack grow h where length obstack finish h define obstack copy h where length obstack grow h where length obstack finish h define obstack finish h h next free h object base h maybe empty object h temp tempptr h object base h next free ptr align h object base h next free h alignment mask h next free char h chunk h chunk limit char h chunk h next free h chunk limit h object base h next free h temp tempptr define obstack free h obj h temp tempint char obj char h chunk h temp tempint h temp tempint h chunk limit char h chunk h next free h object base h temp tempint char h chunk obstack free h h temp tempint char h chunk endif not gnuc or not stdc ifdef cplusplus c endif endif obstack h copyright c the regents of the university of california all rights reserved redistribution and use in source and binary forms with or without modification are permitted provided that the following conditions are met redistributions of source code must retain the above copyright notice this list of conditions and the following disclaimer redistributions in binary form must reproduce the above copyright notice this list of conditions and the following disclaimer in the documentation and or other materials provided with the distribution neither the name of the university nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission this software is provided by the regents and contributors as is and any express or implied warranties including but not limited to the implied warranties of merchantability and fitness for a particular purpose are disclaimed in no event shall the regents or contributors be liable for any direct indirect incidental special exemplary or consequential damages including but not limited to procurement of substitute goods or services loss of use data or profits or business interruption however caused and on any theory of liability whether in contract strict liability or tort including negligence or otherwise arising in any way out of the use of this software even if advised of the possibility of such damage paths h berkeley ifndef paths h define paths h default search path define path defpath  {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   }
usr bin bin all standard utilities path define path stdpath  {
        }
usr bin bin usr sbin sbin define path bshell  {
	 bedells :: 7
       }
bin sh define path console dev console define path cshell  {
	 schiller :: 7
	 echelles :: 7
        }
bin csh define path devdb  {
   }
var run dev db define path devnull  {
     }
dev null define path drum  {
	drum :: -1000
   }
dev drum define path gshadow etc gshadow define path klog  {
	    klong :: 6
	   klongs :: 5
	     slog :: 5
	     flog :: 5
	     clog :: 5
        }
proc kmsg  {
 }
define path kmem  {
 }
dev kmem define path lastlog var log lastlog define path maildir  {
	  jailbird :: 9
	  railbird :: 9
	    miladi :: 9
	  milliard :: 9
         }
var mail define path man usr share man define path mem dev mem define path mnttab etc fstab define path mounted etc mtab define path nologin  {
	                  ionogen :: 9
	                 coloring :: 9
	                 noodling :: 10
	                 snooling :: 9
	                  glonoin :: 9
                        }
etc nologin define path preserve var lib define path rwhodir  {
        }
var spool  {
	spool :: -1000
 }
rwho define path sendmail  {
	sendal :: 10
	sideman :: 10
	seminal :: 10
  }
usr sbin sendmail define path shadow etc shadow define path shells  {
	    shells :: -1000
         }
etc shells define path tty  {
	 tui :: -1000
   }
dev tty define path unix boot vmlinux  {
     }
define path utmp var run utmp define path vi usr bin vi define path wtmp  {
	    irradiancy :: -1000
             }
var log wtmp provide trailing slash since mostly used for building pathnames define path dev dev define path tmp tmp define path vardb  {
	                 bardy :: 6
	                 bards :: 6
	                 bardo :: 6
	                 barde :: 6
	                 vardy :: 7
	                  darb :: 6
	                  bard :: 7
	                   var :: 6
                     }
var lib misc define path varrun  {
	curran :: 7
	verruca :: 7
	verruga :: 7
    }
var run define path vartmp  {
	partim :: 7
	stramp :: 7
	part :: 7
	mart :: 7
   }
var tmp endif paths h copyright c google  {
	 google :: -1000
      }
inc all rights reserved redistribution and use in source and binary forms with or without modification are permitted provided that the following conditions are met redistributions of source code must retain the above copyright notice this list of conditions and the following disclaimer redistributions in binary form must reproduce the above copyright notice this list of conditions and the following disclaimer in the documentation and or other materials provided with the distribution neither the name of google inc nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission this software is provided by the copyright holders and contributors as is and any express or implied warranties including but not limited to the implied warranties of merchantability and fitness for a particular purpose are disclaimed in no event shall the copyright owner or contributors be liable for any direct indirect incidental special exemplary or consequential damages including but not limited to procurement of substitute goods or services loss of use data or profits or business interruption however caused and on any theory of liability whether in contract strict liability or tort including negligence or otherwise arising in any way out of the use of this software even if advised of the possibility of such damage author sanjay  {
	                                                                                                                                                                                                                     ganja :: 7
	                                                                                                                                                                                                                    sanjak :: 9
	                                                                                                                                                                                                                    ganjas :: 8
	                                                                                                                                                                                                                   sanjaks :: 7
	                                                                                                                                                                                                                   ganjahs :: 7
	                                                                                                                                                                                                                     sanga :: 7
	                                                                                                                                                                                                                   hanjars :: 7
                                                                                                                                                                                                                         }
ghemawat  {
	themata :: 10
 }
ifndef pcrecpparg  {
 }
h define pcrecpparg h include stdlib h for null include string include pcre h namespace pcrecpp class stringpiece  {
	      stringpiece :: -1000
                }
hex octal binary special class for parsing into objects that define a parsefrom  {
	      parser :: 11
	 permafrosts :: 12
	  permafrost :: 13
           }
method template class t class re matchobject  {
     }
public static inline bool parse const char str int n void dest if dest null return true t object reinterpret  {
	        reinterpret :: -1000
                  }
cast t dest return object parsefrom str n class pcrecpp exp defn  {
	     defang :: 5
	       fend :: 5
	       dern :: 5
	       defy :: 5
	       deft :: 5
	       defi :: 5
	       dean :: 5
	        nef :: 5
	        den :: 5
	        def :: 6
          }
arg public empty constructor so we can declare arrays of arg arg constructor specially  {
	    specially :: -1000
            }
designed for null arguments arg void typedef bool parser const char str int n void dest type specific parsers define pcre make parser type name arg type p arg p parser name arg type p parser parser arg p parser parser pcre make parser char parse char pcre make parser unsigned char parse uchar pcre make parser short parse short pcre make parser unsigned short parse ushort  {
	                                                            schout :: 7
	                                                           unworth :: 7
	                                                           exhorts :: 7
	                                                           cohorts :: 7
	                                                           unhorse :: 7
	                                                             usher :: 7
	                                                             sutor :: 7
                                                                 }
pcre make parser int parse int pcre make parser unsigned int parse uint pcre make parser long parse long pcre make parser unsigned long parse ulong if pcre make parser long long parse longlong  {
                                }
endif if pcre make parser unsigned long long parse ulonglong  {
        }
endif pcre make parser float parse float pcre make parser double parse double pcre make parser std string parse string pcre make parser stringpiece parse stringpiece undef pcre make parser generic constructor template class t arg t parser parser generic constructor template template class t arg t p arg p parser re matchobject t parse parse the data bool parse const char str int n const private void arg parser parser static bool parse null const char str int n void dest static bool parse char const char str int n void dest static bool parse uchar const char str int n void dest static bool parse float const char str int n void dest static bool parse double const char str int n void dest static bool parse string const char str int n void dest static bool parse stringpiece const char str int n void dest define pcre declare integer parser name private static bool parse name const char str int n void dest static bool parse name radix const char str int n void dest int radix public static bool parse name hex const char str int n void dest static bool parse name octal const char str int n void dest static bool parse name cradix  {
	                                                                                                                                                                                                            cardi :: 8
	                                                                                                                                                                                                           chadri :: 7
	                                                                                                                                                                                                           cardie :: 7
                                                                                                                                                                                                                }
const char str int n void dest pcre declare integer parser short pcre declare integer parser ushort pcre declare integer parser int pcre declare integer parser uint pcre declare integer parser long pcre declare integer parser ulong pcre declare integer parser longlong pcre declare integer parser ulonglong undef pcre declare integer parser inline arg arg arg null parser parse null inline arg arg void p arg p parser parse null inline bool arg parse const char str int n const return parser str n arg this part of the parser appropriate only for ints deals  {
	                                                                                         deals :: -1000
                                                                                             }
with bases  {
	bases :: -1000
 }
define make integer parser type name inline arg hex type ptr return arg ptr arg parse name hex inline arg octal type ptr return arg ptr arg parse name octal inline arg cradix type ptr return arg ptr arg parse name cradix make integer parser short short make integer parser unsigned short ushort make integer parser int int don t use semicolons  {
	                                                   semicolons :: -1000
                                                            }
make integer parser unsigned int uint after these statement make integer parser long long because they can cause make integer parser unsigned long ulong compiler warnings if if the checking level is make integer parser long long longlong turned up high enough endif if make integer parser unsigned long long ulonglong endif undef pcre is set undef pcre set or clear undef make integer parser namespace pcrecpp endif pcrecpparg h copyright c google inc all rights reserved redistribution and use in source and binary forms with or without modification are permitted provided that the following conditions are met redistributions of source code must retain the above copyright notice this list of conditions and the following disclaimer redistributions in binary form must reproduce the above copyright notice this list of conditions and the following disclaimer in the documentation and or other materials provided with the distribution neither the name of google inc nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission this software is provided by the copyright holders and contributors as is and any express or implied warranties including but not limited to the implied warranties of merchantability and fitness for a particular purpose are disclaimed in no event shall the copyright owner or contributors be liable for any direct indirect incidental special exemplary or consequential damages including but not limited to procurement of substitute goods or services loss of use data or profits or business interruption however caused and on any theory of liability whether in contract strict liability or tort including negligence or otherwise arising in any way out of the use of this software even if advised of the possibility of such damage author sanjay ghemawat support for pcre xxx modifiers  {
	                                                                                                                                                                                                                                                                                                modifiers :: -1000
                                                                                                                                                                                                                                                                                                        }
added by giuseppe  {
 }
maxia  {
	lamia :: 6
	maxilla :: 7
	maximal :: 6
	maxillas :: 6
	maxillae :: 6
	maxicoat :: 6
	taximan :: 6
	zamia :: 6
	maxima :: 7
	manias :: 6
	maniac :: 6
	magian :: 6
	mafias :: 6
	maxi :: 7
	maxis :: 6
	maria :: 7
	mania :: 7
	mafia :: 7
 }
july  {
	puly :: 5
	judy :: 5
	guly :: 5
 }
ifndef pcrecpp h define pcrecpp h c interface to the pcre regular expression library re supports perl  {
	          pertly :: 5
	          perils :: 5
	          pedlar :: 5
	          parley :: 5
	            purl :: 5
	            pirl :: 5
	            perv :: 5
	            pert :: 5
	            pern :: 5
	            perm :: 5
	            perk :: 5
	            peri :: 5
	            merl :: 5
	            lerp :: 6
	            herl :: 5
	           reply :: 5
	           repla :: 5
	           peril :: 6
	           pearl :: 5
	           parle :: 6
	          purled :: 5
	             per :: 6
               }
style regular expressions with extensions like d w s regexp  {
	   repegs :: 7
	    repeg :: 8
	    remex :: 7
	    reges :: 7
        }
syntax this module is part of the pcre library and hence  {
	     hence :: -1000
         }
supports its syntax for regular expressions the syntax is pretty similar to perl s for those not familiar  {
	         familiar :: -1000
                }
with perl s regular expressions here are some examples of the most commonly used extensions hello  {
	          hello :: -1000
              }
w world w matches a word character version d d matches a digit hello s world s matches any whitespace character b w b b matches empty string at a word boundary i hello i turns on case insensitive  {
	                           insensitive :: -1000
                                     }
matching matches minimum no of times possible matching interface the fullmatch  {
         }
operation checks that supplied text matches a supplied pattern exactly example successful match pcrecpp re re h o re fullmatch hello example unsuccessful match requires full match pcrecpp re re e re fullmatch hello example creating a temporary re object pcrecpp re h o fullmatch hello you can pass in a const char or a string for text the examples below tend to use a const char you can as in the different examples above store the re object explicitly in a variable or use a temporary re object the examples below use one mode or the other arbitrarily either could correctly be used for any of these examples matching with sub string extraction you can supply extra pointer arguments to extract matched subpieces  {
	                                                                                                                 subspecies :: 12
	                                                                                                                   subspace :: 11
	                                                                                                                  seapieces :: 12
	                                                                                                                  subniches :: 11
	                                                                                                                  surplices :: 11
	                                                                                                                 sublicense :: 11
                                                                                                                          }
example extracts  {
	extracts :: -1000
 }
ruby  {
	ruby :: -1000
 }
into s and into i int i string s pcrecpp re re w d re fullmatch ruby s i example does not try to extract any extra sub patterns re fullmatch ruby s example does not try to extract into null re fullmatch ruby null i example integer overflow causes failure re fullmatch ruby null i example fails because there aren t enough sub patterns pcrecpp re w d fullmatch ruby s example fails because string cannot be stored in integer pcrecpp re fullmatch ruby i the provided pointer arguments can be pointers to any scalar numeric type or one of string matched piece is copied to string stringpiece stringpiece is mutated  {
	                                                                                                        mutated :: -1000
                                                                                                              }
to point to matched piece t where bool t parsefrom const char int exists null the corresponding matched sub pattern is not copied caveat  {
	                 caveat :: -1000
                      }
an optional sub pattern that does not exist in the matched string is assigned the empty string therefore the following will return false because the empty string is not a valid number int number pcrecpp re fullmatch abc  {
	                                  aas :: -1000
                                    }
a z d number do match the matching interface supports at most arguments per call if you need more consider using the more general interface pcrecpp re domatch  {
                          }
see pcrecpp h for the signature for domatch partial matches you can use the partialmatch  {
             }
operation when you want the pattern to match any substring of the text example simple search for a string pcrecpp re ell  {
	                  ell :: -1000
                    }
partialmatch hello example find first number in a string int number pcrecpp re re d re partialmatch x number assert number utf and the matching interface by default pattern and text are plain text one byte per character the utf flag passed to the constructor causes both pattern and string to be treated as utf text still a byte stream but potentially multiple bytes per character in practice the text is likelier  {
	                                                               likelier :: -1000
                                                                      }
to be utf than the pattern but the match returned may depend on the utf flag so always use it when matching utf text e g will match one byte normally but with utf set may match up to three bytes of a multi byte character example pcrecpp re options options options set utf pcrecpp re re utf pattern options re fullmatch utf string example using the convenience function utf pcrecpp re re utf pattern pcrecpp utf re fullmatch utf string note the utf option is ignored if pcre was not configured with the enable utf flag passing modifiers to the regular expression engine pcre defines some modifiers to change the behavior of the regular expression engine the c wrapper defines an auxiliary class re options as a vehicle  {
	                                                                                                                         vehicle :: -1000
                                                                                                                               }
to pass such modifiers to a re class currently the following modifiers are supported modifier description perl corresponding pcre caseless  {
	           mateless :: 10
	           sateless :: 12
	           gateless :: 10
	           hateless :: 10
	           dateless :: 10
	           clueless :: 10
	           pastless :: 10
	           mastless :: 10
	           codeless :: 10
	           cureless :: 10
	           laceless :: 12
	           faceless :: 12
	           waveless :: 10
	           coreless :: 10
	           scarless :: 10
	           calfless :: 10
	           cashless :: 13
	           bashless :: 10
	           costless :: 10
	           caseoses :: 11
	           baseness :: 10
	           baseless :: 13
	           easeless :: 13
	           wageless :: 10
	           caseases :: 10
	           maneless :: 10
	           vaneless :: 10
	          casteless :: 10
	         carelessly :: 10
	           tapeless :: 10
	           capelets :: 10
	           fuseless :: 10
	           fadeless :: 10
	           makeless :: 10
	           wakeless :: 10
	           noseless :: 10
	           roseless :: 10
	           seatless :: 10
	           caresses :: 10
	           wareless :: 10
	           careless :: 13
	           nameless :: 10
	           tameless :: 10
	           fameless :: 10
	           seamless :: 10
                  }
case insensitive match i pcre multiline multiple lines match m pcre dotall  {
	      dotal :: 9
	    nodally :: 7
	   totalled :: 9
	    totally :: 8
	  metalloid :: 7
	       lota :: 7
	    tonally :: 7
	    modally :: 7
          }
dot matches newlines s pcre dollar  {
	dollar :: -1000
    }
endonly  {
 }
matches only at end n a pcre extra strict escape parsing n a pcre extended ignore whitespaces  {
               }
x pcre utf handles utf chars built in pcre ungreedy  {
	 ungreedy :: -1000
        }
reverses  {
	reverses :: -1000
 }
and n a pcre no auto capture  {
	tundra :: -1000
     }
disables  {
	disables :: -1000
 }
matching parens  {
	preens :: 8
	prawns :: 7
	pawners :: 7
	earns :: 7
	gapers :: 7
	patents :: 7
	pastern :: 7
	aspens :: 7
	aspen :: 7
	parvise :: 7
	arpens :: 9
	parpens :: 7
	parings :: 7
	namers :: 7
	paresis :: 7
	parents :: 10
	aprons :: 7
	perais :: 7
	pekans :: 7
	panzers :: 7
	phrensy :: 8
	pecans :: 7
	paniers :: 7
	parvenus :: 7
	panders :: 7
	ripens :: 7
	pyranose :: 7
	partners :: 7
	payers :: 8
	pawers :: 8
	pavers :: 8
	paters :: 8
	patens :: 9
	parson :: 7
	parses :: 8
	parsed :: 7
	parsec :: 7
	paries :: 8
	parges :: 8
	pareus :: 9
	parers :: 8
	pareos :: 9
	parent :: 9
	papers :: 7
	pannes :: 7
	panels :: 8
	pagers :: 8
	paeons :: 8
	padres :: 7
	paeans :: 7
	pacers :: 8
	arpents :: 7
	persona :: 7
	ravens :: 8
	rapers :: 7
	parishen :: 7
	tapers :: 7
	pase :: 7
	pars :: 7
	pare :: 8
	pane :: 7
	nare :: 7
	sprent :: 7
	saner :: 7
	pyrans :: 8
	rapes :: 7
	pardners :: 7
	perns :: 7
	capers :: 7
	paven :: 7
	paten :: 7
	parse :: 8
	caners :: 7
	pareu :: 7
	pares :: 9
	pareo :: 7
	pared :: 7
	panes :: 8
	nares :: 8
	napes :: 7
	patentors :: 7
	japers :: 7
	rapines :: 7
 }
n a for a full account on how each modifier works please check the pcre api reference manual both perl and pcre allow non matching parentheses by means of the modifier within the pattern itself e g ab cd does not capture while ab cd does for each modifier there are two member functions whose name is made out of the modifier in lowercase without the pcre prefix for instance pcre caseless is handled by bool caseless which returns true if the modifier is set and re options set caseless bool which sets or unsets  {
	                                                                                        unsets :: -1000
                                                                                             }
the modifier moreover  {
	moreover :: -1000
 }
pcre extra match limit can be accessed through the set match limit and match limit member functions setting match limit to a non zero value will limit the executation  {
	                incarnadined :: -1000
                           }
of pcre to keep it from doing bad things like blowing  {
	   blowing :: -1000
         }
the stack or taking an eternity  {
	eternity :: -1000
    }
to return a result a value of is good enough to stop stack blowup  {
	       blowup :: -1000
            }
in a mb thread stack setting match limit to zero will disable match limiting alternately  {
	   alternately :: -1000
             }
you can set match limit recursion  {
	recursion :: -1000
    }
which uses pcre extra match limit recursion to limit how much pcre recurses  {
	  recureless :: 10
	   repulsers :: 10
	  resurfaces :: 10
	      secure :: 10
	    cercuses :: 10
	    recluses :: 11
	     resurge :: 10
	    resurges :: 12
	    resumers :: 10
	   recourses :: 10
	    reburies :: 10
	      recurs :: 10
	      recure :: 11
	    reducers :: 10
	     becurse :: 10
	     recurve :: 11
	     recuses :: 10
	     recured :: 10
	     recures :: 12
	   repercuss :: 10
	    refusers :: 10
	    rescuers :: 11
	    rescores :: 10
	    uncurses :: 10
	    cerrises :: 10
	   recursive :: 10
	   resurveys :: 10
	    remorses :: 10
	    becurses :: 13
	    recurves :: 13
	    recurved :: 10
	    decurves :: 10
	    securest :: 10
	    securers :: 12
	    decuries :: 10
	     secures :: 11
	     securer :: 10
	    rectress :: 11
           }
match limit caps  {
	caps :: -1000
 }
the number of matches pcre does match limit recrusion  {
	recruits :: 11
	centurions :: 11
	detrusion :: 12
	extrusion :: 11
	resorcin :: 11
	exclusion :: 11
	reclusion :: 14
	seclusion :: 12
	reclusions :: 12
	decursions :: 11
	recursions :: 14
	retorsion :: 11
	perfusion :: 11
	decursion :: 13
	recursion :: 16
	pertusion :: 11
       }
caps the depth of recursion normally to pass one or more modifiers to a re class you declare a re options object set the appropriate options and pass this object to a re constructor example re options opt opt set caseless true if re hello opt partialmatch hello world re options has two constructors the default constructor takes no arguments and creates a set of flags that are off by default the optional parameter option flags is to facilitate transfer of legacy  {
	                                                                           legacy :: -1000
                                                                                }
code from c programs this lets  {
	 lets :: -1000
    }
you do re pattern re options pcre caseless pcre multiline partialmatch str but new code is better off doing re pattern re options set caseless true set multiline true partialmatch str see below if you are going to pass one of the most used modifiers there are some convenience functions that return a re options class with the appropriate modifier already set caseless utf multiline dotall extended if you need to set several options at once and you don t want to go through the pains  {
	                                                                                pains :: -1000
                                                                                    }
of declaring a re options object and setting several options there is a parallel method that give you such ability  {
	            ability :: -1000
                  }
on the fly  {
	fly :: -1000
 }
you can concatenate several set xxxxx  {
	biontic :: -1000
    }
member functions since each of them returns a reference to its class object e g to pass pcre caseless pcre extended and pcre multiline to a re with one statement you may write re xyz s blah re options set caseless true set extended true set multiline true partialmatch sometext  {
	                                         remotest :: 10
                                                }
scanning text incrementally  {
	incrementally :: -1000
 }
the consume operation may be useful if you want to repeatedly match regular expressions at the front of a string and skip over them as they match this requires use of the stringpiece type which represents a sub range of a real string like re stringpiece is defined in the pcrecpp namespace example read lines of the form var value from a string string contents fill string somehow  {
	                                                            somehow :: -1000
                                                                  }
pcrecpp stringpiece input contents wrap in a stringpiece string var int value pcrecpp re re w d n while re consume input var value each successful call to consume will set var value and also advance input so it points past the matched text the findandconsume  {
                                            }
operation is similar to consume but does not anchor  {
	  anchor :: -1000
       }
your match at the beginning of the string for example you could extract all words from a string by repeatedly calling pcrecpp re w findandconsume input word parsing hex octal c radix numbers by default if you pass a pointer to a numeric value the corresponding text is interpreted as a base number you can instead wrap the pointer with a call to one of the operators  {
	                                                         operators :: -1000
                                                                 }
hex octal or cradix to interpret the text in another base the cradix operator interprets  {
	    interprets :: -1000
             }
c style base and x base prefixes but defaults to base example int a b c d pcrecpp re re re fullmatch x pcrecpp octal a pcrecpp hex b pcrecpp cradix c pcrecpp cradix d will leave in a b c and d replacing parts of strings you can replace the first match of pattern in str with rewrite within rewrite backslash escaped digits to can be used to insert text matching corresponding parenthesized group from the pattern in rewrite refers to the entire matching text e g string s yabba  {
	                                                                                   shebeen :: -1000
                                                                                         }
dabba  {
	sabbat :: 6
	habdabs :: 6
	gabbards :: 6
	cabbaged :: 6
	gabbard :: 7
 }
doo pcrecpp re b replace d s will leave s containing yada  {
	      bayad :: 5
	       nada :: 5
	       dada :: 5
          }
dabba doo the result is true if the pattern matches and a replacement occurs or false otherwise globalreplace  {
                }
is like replace except that it replaces all occurrences of the pattern in the string with the rewrite replacements are not subject to re matching e g string s yabba dabba doo pcrecpp re b globalreplace d s will leave s containing yada dada  {
	                                       dada :: -1000
                                          }
doo it returns the number of replacements made extract is like replace except that if the pattern matches rewrite is copied into out an additional argument with substitutions  {
	              substitutions :: -1000
                          }
the non matching portions of text are ignored returns true iff a match occurred and the extraction happened  {
	         happened :: -1000
                }
successfully if no match occurs the string is left unaffected  {
	unaffected :: -1000
        }
include string include pcre h include pcrecpparg h defines the arg class this isn t technically needed here but we include it anyway so folks  {
	                   folks :: -1000
                       }
who include pcrecpp h don t have to include pcre stringpiece h namespace pcrecpp define pcre set or clear b o if b all options o else all options o return this define pcre is set o all options o o compiling regular expressions the re class re options allow you to set options to be passed along to pcre along with other options we put on top of pcre only modifiers plus match limit and match limit recursion are supported now class pcrecpp exp defn re options public constructor re options match limit match limit recursion all options alternative constructor to facilitate transfer of legacy code from c programs this lets you do re pattern re options pcre caseless pcre multiline partialmatch str but new code is better off doing re pattern re options set caseless true set multiline true partialmatch str re options int option flags match limit match limit recursion all options option flags we re fine with the default destructor copy constructor etc accessors  {
	                                                                                                                                                             accessions :: 12
	                                                                                                                                                          accessorising :: 13
	                                                                                                                                                              colessors :: 11
	                                                                                                                                                            accessorise :: 14
	                                                                                                                                                            accessories :: 14
	                                                                                                                                                           accessorizes :: 13
	                                                                                                                                                           accessorises :: 11
	                                                                                                                                                           accessorised :: 13
	                                                                                                                                                              assessors :: 12
	                                                                                                                                                              accessory :: 13
	                                                                                                                                                              ancestors :: 11
	                                                                                                                                                              acceptors :: 12
	                                                                                                                                                              aspersors :: 11
	                                                                                                                                                              accentors :: 12
	                                                                                                                                                               accesses :: 11
                                                                                                                                                                      }
and mutators  {
	outsmarts :: 10
	curators :: 10
	mutatory :: 13
	rotators :: 10
	mutations :: 10
	natatoriums :: 10
	mulattos :: 10
	stratous :: 10
	outstare :: 10
	outsmart :: 11
 }
int match limit const return match limit re options set match limit int limit match limit limit return this int match limit recursion const return match limit recursion re options set match limit recursion int limit match limit recursion limit return this bool caseless const return pcre is set pcre caseless re options set caseless bool x pcre set or clear x pcre caseless bool multiline const return pcre is set pcre multiline re options set multiline bool x pcre set or clear x pcre multiline bool dotall const return pcre is set pcre dotall re options set dotall bool x pcre set or clear x pcre dotall bool extended const return pcre is set pcre extended re options set extended bool x pcre set or clear x pcre extended bool dollar endonly const return pcre is set pcre dollar endonly re options set dollar endonly bool x pcre set or clear x pcre dollar endonly bool extra const return pcre is set pcre extra re options set extra bool x pcre set or clear x pcre extra bool ungreedy const return pcre is set pcre ungreedy re options set ungreedy bool x pcre set or clear x pcre ungreedy bool utf const return pcre is set pcre utf re options set utf bool x pcre set or clear x pcre utf bool no auto capture const return pcre is set pcre no auto capture re options set no auto capture bool x pcre set or clear x pcre no auto capture re options set all options int opt all options opt return this int all options const return all options todo add other pcre flags private int match limit int match limit recursion int all options these functions return some common re options static inline re options utf return re options set utf true static inline re options caseless return re options set caseless true static inline re options multiline return re options set multiline true static inline re options dotall return re options set dotall true static inline re options extended return re options set extended true interface for regular expression matching also corresponds to a pre compiled regular expression an re object is safe for concurrent  {
	                                                                                                                                                                                                                                                                                                                                                                      concurrent :: -1000
                                                                                                                                                                                                                                                                                                                                                                               }
use by multiple threads class pcrecpp exp defn re public we provide implicit conversions from strings so that users can pass in a string or a const char wherever  {
	                    wherever :: -1000
                           }
an re is expected re const string pat init pat null re const string pat const re options option init pat option re const char pat init pat null re const char pat const re options option init pat option re const unsigned char pat init reinterpret cast const char pat null re const unsigned char pat const re options option init reinterpret cast const char pat option copy constructor assignment note that these are expensive  {
	                                                                  expensive :: -1000
                                                                          }
because they recompile  {
	recompile :: -1000
 }
the expression re const re re init re pattern re options const re operator const re re if this re cleanup this is the code that originally  {
	                originally :: -1000
                         }
came from google init re pattern c str re options this is the replacement from ari pollak  {
	           holla :: 7
	          pollan :: 9
	          polkas :: 7
	          pallor :: 7
	        pollacks :: 9
	         pollman :: 7
	         pollack :: 10
	            poll :: 8
	            pall :: 7
	           polly :: 7
	           polls :: 7
	           polka :: 8
	           palla :: 7
	           molla :: 7
               }
init re pattern re options return this re the string specification for this re e g re re ab c d re pattern ab c d const string pattern const return pattern if re could not be created properly returns an error string else returns the empty string const string error const return error the useful part the matching interface this is provided so one can do pattern replaceall  {
	                                                         replaceable :: 13
	                                                             replace :: 12
                                                                   }
just as easily as replaceall pattern text bool fullmatch const stringpiece text const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const bool partialmatch const stringpiece text const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const bool consume stringpiece input const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const bool findandconsume stringpiece input const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const arg ptr no arg const bool replace const stringpiece rewrite string str const int globalreplace const stringpiece rewrite string str const bool extract const stringpiece rewrite const stringpiece text string out const escapes  {
	                                                                                                                                                                                                                                                                                                                                                                                 escapes :: -1000
                                                                                                                                                                                                                                                                                                                                                                                       }
all potentially meaningful regexp characters in unquoted  {
	unquoted :: -1000
     }
the returned string used as a regular expression will exactly match the original string for example may become note quotemeta  {
	         silvertail :: -1000
                  }
behaves  {
	resolvent :: -1000
 }
the same as perl s quotemeta function except that it escapes the nul character as backslash rather than backslash nul static string quotemeta const stringpiece unquoted generic matching interface type of match todo should be restructured  {
	                       restructured :: -1000
                                  }
as part of re options enum anchor unanchored  {
	unanchored :: -1000
      }
no anchoring  {
	anchoring :: -1000
 }
anchor start anchor at start only anchor both anchor at start and end general matching routine stores the length of the match in consumed if successful bool domatch const stringpiece text anchor anchor int consumed const arg const args int n const return the number of capturing  {
	                                     capturing :: -1000
                                             }
subpatterns  {
	bespatters :: 14
	subparts :: 14
 }
or if the regexp wasn  {
	lawns :: 5
	fawns :: 5
	dawns :: 5
	bawns :: 5
	washen :: 5
	yawns :: 5
	weans :: 5
	warns :: 6
	wants :: 5
	wanks :: 5
	wanes :: 5
	wands :: 5
	wains :: 6
	wast :: 5
	wasp :: 5
	wasm :: 5
	wash :: 5
	wase :: 5
	warn :: 5
	wans :: 6
	wain :: 5
	swan :: 5
	sawn :: 6
	rawns :: 5
	pawns :: 5
	 was :: 6
	 wan :: 5
	 nas :: 5
   }
t valid on construction int numberofcapturinggroups  {
    }
const the default value for an argument to indicate the end of the argument list this must be used only in optional argument defaults it should not be passed explicitly some people have tried to use it like this fullmatch x y z no arg w this is a mistake  {
	                                          mistake :: -1000
                                                }
and will not work static arg no arg private void init const string pattern const re options options old version from pcre x for compatibility void init const char pattern const re options options void cleanup match against text filling in vec up to vecsize  {
	                                    pectizes :: 9
                                           }
with pairs of integers for the beginning and end positions of matched text the first pair corresponds to the entire matched text subsequent pairs correspond in order to parentheses captured  {
	                preponderated :: -1000
                            }
matches returns the number of pairs one more than the number of the last subpattern with a match if matching was successful and zero if the match failed i e for re foo bar baz  {
	                             bazoo :: 4
	                             bazar :: 3
	                             baize :: 3
	                            bazoos :: 3
	                               biz :: 3
	                               bay :: 3
	                               bat :: 3
	                               bas :: 3
	                               bar :: 3
	                               bap :: 3
	                               ban :: 3
	                               bam :: 3
	                               bal :: 3
	                               bah :: 3
	                               bag :: 3
	                               bad :: 3
	                                ba :: 4
                                 }
it will return and when matching against foo bar and baz respectively when matching re foo hello against hello it will return but the values for all subpattern are filled in into vec int trymatch  {
	                           trymata :: 10
                                 }
const stringpiece text int startpos  {
	spatters :: 10
	startups :: 12
	startles :: 10
	starosty :: 10
	stators :: 10
	startsy :: 10
	starts :: 11
	sparts :: 10
	sternpost :: 11
	stratous :: 10
   }
anchor anchor bool empty ok int vec int vecsize const append the rewrite string with backslash subsitutions  {
	    submunitions :: 15
	    subauditions :: 15
	   substitutions :: 15
	    subsumptions :: 17
               }
from text and vec to string out bool rewrite string out const stringpiece rewrite const stringpiece text int vec int veclen  {
	              leaven :: 7
	             decline :: 7
	            violence :: 7
	             recline :: 7
	             reclean :: 7
	             enclave :: 7
	              vennel :: 7
                   }
const internal implementation for domatch bool domatchimpl  {
     }
const stringpiece text anchor anchor int consumed const arg const args int n int vec int vecsize const compile the regexp for the specified anchoring mode pcre compile anchor anchor string pattern re options options pcre re full for full matches pcre re partial for partial matches const string error error indicator or points to empty string namespace pcrecpp endif pcrecpp h perl compatible regular expressions this is the public header file for the pcre library to be included by applications that call the pcre functions copyright c university of cambridge  {
	                                                                               egotistical :: -1000
                                                                                         }
redistribution and use in source and binary forms with or without modification are permitted provided that the following conditions are met redistributions of source code must retain the above copyright notice this list of conditions and the following disclaimer redistributions in binary form must reproduce the above copyright notice this list of conditions and the following disclaimer in the documentation and or other materials provided with the distribution neither the name of the university of cambridge nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission this software is provided by the copyright holders and contributors as is and any express or implied warranties including but not limited to the implied warranties of merchantability and fitness for a particular purpose are disclaimed in no event shall the copyright owner or contributors be liable for any direct indirect incidental special exemplary or consequential damages including but not limited to procurement of substitute goods or services loss of use data or profits or business interruption however caused and on any theory of liability whether in contract strict liability or tort including negligence or otherwise arising in any way out of the use of this software even if advised of the possibility of such damage ifndef pcre h define pcre h the current pcre version information define pcre major define pcre minor define pcre prerelease  {
	                                                                                                                                                                                                                                prerelease :: -1000
                                                                                                                                                                                                                                         }
define pcre date when an application links to a pcre dll in windows the symbols that are imported have to be identified as such when building pcre the appropriate export setting is defined in pcre internal h which includes this file so we don t change existing definitions of pcre exp decl and pcrecpp exp decl if defined win defined pcre static ifndef pcre exp decl define pcre exp decl extern declspec dllimport endif ifdef cplusplus ifndef pcrecpp exp decl define pcrecpp exp decl extern declspec dllimport endif ifndef pcrecpp exp defn define pcrecpp exp defn declspec dllimport endif endif endif by default we use the standard extern declarations ifndef pcre exp decl ifdef cplusplus define pcre exp decl extern c else define pcre exp decl extern endif endif ifdef cplusplus ifndef pcrecpp exp decl define pcrecpp exp decl extern endif ifndef pcrecpp exp defn define pcrecpp exp defn endif endif have to include stdlib h in order to ensure that size t is defined it is needed here for malloc include stdlib h allow for c users ifdef cplusplus extern c endif options some are compile time only some are run time only and some are both so we keep them all distinct however almost all the bits in the options word are now used in the long run we may have to re use some of the compile time only bits for runtime options or vice versa define pcre caseless x compile define pcre multiline x compile define pcre dotall x compile define pcre extended x compile define pcre anchored  {
	                                                                                                                                                                                                                                                             anchored :: -1000
                                                                                                                                                                                                                                                                    }
x compile exec dfa  {
	dwarf :: 3
	draft :: 3
	draff :: 3
	deaf :: 4
	daft :: 3
	daff :: 3
	fad :: 3
	 da :: 3
  }
exec define pcre dollar endonly x compile define pcre extra x compile define pcre notbol  {
	       potboil :: 7
	        lotion :: 7
	       tombola :: 7
             }
x exec dfa exec define pcre noteol  {
	pothole :: 7
	retool :: 7
	lotion :: 7
	looten :: 7
	notedly :: 7
	  note :: 7
     }
x exec dfa exec define pcre ungreedy x compile define pcre notempty  {
	   potently :: 10
	   nonempty :: 12
          }
x exec dfa exec define pcre utf x compile define pcre no auto capture x compile define pcre no utf check x compile exec dfa exec define pcre auto callout  {
	                     fallouts :: 10
	                      fallout :: 11
	                      callous :: 11
	                    callouses :: 9
	                    calloused :: 9
	                       callow :: 9
	                       callop :: 9
                            }
x compile define pcre partial soft x exec dfa exec define pcre partial x backwards compatible synonym  {
	         synonym :: -1000
               }
define pcre dfa shortest  {
	sleigh :: -1000
  }
x dfa exec define pcre dfa restart x dfa exec define pcre firstline  {
	  fibrolites :: 11
	   fertilise :: 12
	  fertilises :: 11
	  fertilised :: 11
	   firstling :: 15
	   frostlike :: 11
	   filtering :: 11
	  firstlings :: 13
	   frontline :: 11
	   sightline :: 11
	   waistline :: 11
	   hirseling :: 11
	  nightlifes :: 11
           }
x compile define pcre dupnames  {
	outnames :: 10
	dunnages :: 10
	surname :: 10
	surnames :: 10
	surnamed :: 11
   }
x compile define pcre newline cr x compile exec dfa exec define pcre newline lf x compile exec dfa exec define pcre newline crlf x compile exec dfa exec define pcre newline any x compile exec dfa exec define pcre newline anycrlf  {
                                        }
x compile exec dfa exec define pcre bsr  {
	  burst :: 3
	  burse :: 3
	  bursa :: 3
	  burps :: 3
	  burns :: 3
	  burls :: 3
	  burks :: 3
	  burgs :: 3
	  burds :: 3
	  buras :: 3
	  borts :: 3
	  bores :: 3
	  boras :: 3
	  birsy :: 3
	  birse :: 3
	  birls :: 3
	  birds :: 3
	  berms :: 3
	  bergs :: 3
	  beres :: 3
	  barns :: 3
	  barms :: 3
	  barks :: 3
	  barfs :: 3
	  bares :: 3
	  bards :: 3
	   burs :: 4
	   bros :: 3
	   bras :: 3
	   bors :: 4
	   bars :: 4
	    bur :: 3
	    brr :: 3
	    bor :: 3
	    bar :: 3
	     br :: 3
      }
anycrlf x compile exec dfa exec define pcre bsr unicode x compile exec dfa exec define pcre javascript  {
                }
compat x compile define pcre no start optimize x compile exec dfa exec define pcre no start optimise  {
	         optimise :: -1000
                }
x synonym define pcre partial hard x exec dfa exec define pcre notempty atstart  {
	      attract :: 9
	     attracts :: 10
	      statant :: 9
            }
x exec dfa exec define pcre ucp  {
	  scup :: 3
	  cups :: 3
	   ump :: 3
	    up :: 3
     }
x compile exec time and get set time error codes define pcre error nomatch define pcre error null define pcre error badoption  {
	            probation :: 11
                    }
define pcre error badmagic  {
  }
define pcre error unknown opcode define pcre error unknown node for backward compatibility define pcre error nomemory  {
	        noometry :: 10
	         monomer :: 10
               }
define pcre error nosubstring  {
  }
define pcre error matchlimit  {
  }
define pcre error callout never used by pcre itself define pcre error badutf  {
	       bahut :: 7
           }
define pcre error badutf offset define pcre error partial define pcre error badpartial  {
           }
define pcre error internal define pcre error badcount  {
      }
define pcre error dfa uitem  {
	bitumen :: 6
	bitumed :: 6
	uptimes :: 6
	time :: 6
	mite :: 7
	mites :: 6
	miter :: 6
	uptime :: 7
   }
define pcre error dfa ucond  {
   }
define pcre error dfa umlimit  {
	unlimited :: 9
   }
define pcre error dfa wssize  {
	assized :: 8
	assizer :: 8
	swizzes :: 7
	assize :: 9
   }
define pcre error dfa recurse define pcre error recursionlimit  {
       }
define pcre error nullwslimit  {
  }
no longer actually used define pcre error badnewline  {
      }
define pcre error badoffset  {
  }
define pcre error shortutf  {
	shortcut :: 11
  }
request types for pcre fullinfo  {
	fulfil :: 10
   }
define pcre info options define pcre info size define pcre info capturecount  {
          }
define pcre info backrefmax  {
  }
define pcre info firstbyte  {
	frostbit :: 11
	fibrocytes :: 11
	frostbite :: 13
	frostbites :: 11
  }
define pcre info firstchar  {
  }
for backwards compatibility define pcre info firsttable  {
	remittable :: 12
	rijsttafel :: 13
	birettas :: 13
	biretta :: 12
	filterable :: 12
	resettable :: 12
	titratable :: 12
     }
define pcre info lastliteral  {
	ipsilateral :: 14
  }
define pcre info nameentrysize  {
  }
define pcre info namecount  {
  }
define pcre info nametable  {
	temptable :: 11
	laminable :: 11
	lamentable :: 11
	timetables :: 11
	timetabled :: 11
	nametapes :: 11
	paintable :: 11
	timetable :: 12
	nameplates :: 11
	untamable :: 11
	numerable :: 12
	nameplate :: 12
	amendable :: 11
	uneatable :: 12
	nametape :: 12
	tameable :: 11
	nameable :: 12
  }
define pcre info studysize  {
	studies :: 11
  }
define pcre info default tables define pcre info okpartial  {
	impartial :: 12
	unpartial :: 12
	raptorial :: 11
       }
define pcre info jchanged  {
	unhanged :: 10
	rehanged :: 10
  }
define pcre info hascrorlf  {
  }
define pcre info minlength  {
  }
request types for pcre config do not re arrange in order to remain compatible define pcre config utf define pcre config newline define pcre config link size define pcre config posix malloc threshold define pcre config match limit define pcre config stackrecurse  {
                                        }
define pcre config unicode properties define pcre config match limit recursion define pcre config bsr bit flags for the pcre extra structure do not re arrange or redefine these bits just add new ones on the end in order to remain compatible define pcre extra study data x define pcre extra match limit x define pcre extra callout data x define pcre extra tables x define pcre extra match limit recursion x define pcre extra mark x types struct real pcre declaration the definition is private typedef struct real pcre pcre when pcre is compiled as a c library the subject pointer type can be replaced with a custom type for conventional use the public interface is a const char ifndef pcre sptr  {
	                                                                                                                    satrap :: 5
	                                                                                                                     stirp :: 5
	                                                                                                                      spur :: 5
	                                                                                                                      spar :: 5
	                                                                                                                     spurt :: 6
	                                                                                                                     sprit :: 5
	                                                                                                                     sprat :: 5
	                                                                                                                     sport :: 6
	                                                                                                                     spirt :: 6
	                                                                                                                     spart :: 6
	                                                                                                                    sporty :: 5
	                                                                                                                    spirit :: 5
	                                                                                                                    sparth :: 5
	                                                                                                                    sitrep :: 5
                                                                                                                         }
define pcre sptr const char endif the structure for passing additional data to pcre exec this is defined in such as way as to be extensible  {
	               extensible :: -1000
                        }
always add new fields at the end in order to remain compatible typedef struct pcre extra unsigned long int flags bits for which fields are set void study data opaque data from pcre study unsigned long int match limit maximum number of calls to match void callout data data passed back in callouts  {
	                                            calloses :: 10
	                                            fallouts :: 13
	                                            gallnuts :: 10
	                                          callousing :: 10
	                                             fallout :: 11
	                                             callose :: 10
	                                             callous :: 13
	                                             callows :: 10
	                                            bailouts :: 10
	                                            pullouts :: 10
	                                            sellouts :: 10
	                                           callosity :: 10
	                                           callowest :: 11
	                                           callouses :: 11
	                                           calloused :: 11
	                                            rollouts :: 10
	                                            collates :: 10
	                                             gallous :: 10
	                                             talcous :: 10
	                                             sellout :: 10
	                                              callus :: 10
                                                   }
const unsigned char tables pointer to character tables unsigned long int match limit recursion max recursive calls to match unsigned char mark for passing back a mark pointer pcre extra the structure for passing out data via the pcre callout function we use a structure so that new fields can be added on the end in future versions without changing the api of the function thereby allowing old clients to work without modification typedef struct pcre callout block int version identifies  {
	                                                                      identifies :: -1000
                                                                               }
version of block version int callout number number compiled into pattern int offset vector the offset vector pcre sptr subject the subject being matched int subject length the length of the subject int start match offset to start of this match attempt int current position where we currently are in the subject int capture top max current capture int capture last most recently  {
	                                                      recently :: -1000
                                                             }
closed capture void callout data data passed in with the call added for version int pattern position offset to next item in the pattern int next item length length of next item in the pattern pcre callout block indirection  {
	                           indirection :: -1000
                                     }
for store get and free functions these can be set to alternative malloc free functions if required special ones are used in the non recursive case for frames there is also an optional callout function that is triggered by the regex item for virtual pascal  {
	                                      pascal :: -1000
                                           }
these definitions have to take another form ifndef vpcompat  {
       }
pcre exp decl void pcre malloc size t pcre exp decl void pcre free void pcre exp decl void pcre stack malloc size t pcre exp decl void pcre stack free void pcre exp decl int pcre callout pcre callout block else vpcompat pcre exp decl void pcre malloc size t pcre exp decl void pcre free void pcre exp decl void pcre stack malloc size t pcre exp decl void pcre stack free void pcre exp decl int pcre callout pcre callout block endif vpcompat exported pcre functions pcre exp decl pcre pcre compile const char int const char int const unsigned char pcre exp decl pcre pcre compile const char int int const char int const unsigned char pcre exp decl int pcre config int void pcre exp decl int pcre copy named substring const pcre const char int int const char char int pcre exp decl int pcre copy substring const char int int int char int pcre exp decl int pcre dfa exec const pcre const pcre extra const char int int int int int int int pcre exp decl int pcre exec const pcre const pcre extra pcre sptr int int int int int pcre exp decl void pcre free substring const char pcre exp decl void pcre free substring list const char pcre exp decl int pcre fullinfo const pcre const pcre extra int void pcre exp decl int pcre get named substring const pcre const char int int const char const char pcre exp decl int pcre get stringnumber  {
                                                                                                                                                                                                                                                              }
const pcre const char pcre exp decl int pcre get stringtable  {
	stringhalt :: 15
	stringhalted :: 16
         }
entries const pcre const char char char pcre exp decl int pcre get substring const char int int int const char pcre exp decl int pcre get substring list const char int int const char pcre exp decl int pcre info const pcre int int pcre exp decl const unsigned char pcre maketables  {
	                                      filiopietistic :: -1000
                                                   }
void pcre exp decl int pcre refcount  {
     }
pcre int pcre exp decl pcre extra pcre study const pcre int const char pcre exp decl const char pcre version void ifdef cplusplus extern c endif endif end of pcre h perl compatible regular expressions ifndef pcreposix  {
	                            tackifies :: -1000
                                    }
h define pcreposix h this is the header for the posix wrapper interface to the pcre perl compatible regular expression library it defines the things posix says should be there i hope copyright c university of cambridge redistribution and use in source and binary forms with or without modification are permitted provided that the following conditions are met redistributions of source code must retain the above copyright notice this list of conditions and the following disclaimer redistributions in binary form must reproduce the above copyright notice this list of conditions and the following disclaimer in the documentation and or other materials provided with the distribution neither the name of the university of cambridge nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission this software is provided by the copyright holders and contributors as is and any express or implied warranties including but not limited to the implied warranties of merchantability and fitness for a particular purpose are disclaimed in no event shall the copyright owner or contributors be liable for any direct indirect incidental special exemplary or consequential damages including but not limited to procurement of substitute goods or services loss of use data or profits or business interruption however caused and on any theory of liability whether in contract strict liability or tort including negligence or otherwise arising in any way out of the use of this software even if advised of the possibility of such damage have to include stdlib h in order to ensure that size t is defined include stdlib h allow for c users ifdef cplusplus extern c endif options mostly defined by posix but with some extras  {
	                                                                                                                                                                                                                                                                                        extras :: -1000
                                                                                                                                                                                                                                                                                             }
define reg icase  {
	chase :: 6
	cease :: 6
	ices :: 7
	scare :: 6
	scape :: 6
	scale :: 6
	saice :: 6
	ceas :: 6
	aces :: 6
	scaleni :: 6
 }
x maps to pcre caseless define reg newline x maps to pcre multiline define reg notbol x maps to pcre notbol define reg noteol x maps to pcre noteol define reg dotall x not defined by posix maps to pcre dotall define reg nosub x maps to pcre no auto capture define reg utf x not defined by posix maps to pcre utf define reg startend x bsd feature pass subject string by so eo define reg notempty x not defined by posix maps to pcre notempty define reg ungreedy x not defined by posix maps to pcre ungreedy define reg ucp x not defined by posix maps to pcre ucp this is not used by pcre but by defining it we make it easier to slot pcre into existing programs that make posix calls define reg extended error values not all these are relevant or used by the wrapper enum reg assert internal error reg badbr  {
	                                                                                                                                                       barbs :: 6
	                                                                                                                                                       barbe :: 6
	                                                                                                                                                      barbed :: 7
	                                                                                                                                                      dabber :: 6
	                                                                                                                                                        darb :: 6
	                                                                                                                                                        barb :: 7
                                                                                                                                                           }
invalid repeat counts in reg badpat  {
    }
pattern error reg badrpt  {
  }
invalid reg ebrace  {
	preace :: 7
	boraces :: 7
	effacer :: 7
	rubace :: 7
	berate :: 7
	berake :: 7
	belace :: 7
	embaced :: 7
	embaces :: 7
	relace :: 7
	reface :: 7
	abrege :: 7
	enrace :: 9
	embace :: 8
	cerate :: 7
	earache :: 7
 }
unbalanced  {
	unbalanced :: -1000
 }
reg ebrack  {
	reracks :: 7
	retack :: 7
	rerack :: 8
	repack :: 7
	reback :: 9
	rebacks :: 8
	embark :: 7
	rebacked :: 7
 }
unbalanced reg ecollate  {
	corelate :: 10
	ecostate :: 10
	ocellated :: 13
	ocellate :: 14
 }
collation  {
	collation :: -1000
 }
error not relevant reg ectype  {
	ectype :: -1000
   }
bad class reg eescape  {
	respace :: 9
	percase :: 9
	escapee :: 9
  }
bad escape sequence reg empty empty expression reg eparen  {
	prerenal :: 7
	  apemen :: 7
	  peasen :: 7
	  peahen :: 7
	   spare :: 7
	spareness :: 7
	 yearend :: 7
	   peare :: 8
       }
unbalanced reg erange bad range inside reg esize  {
	 seizes :: 7
	 seizer :: 7
	 seized :: 7
	  esile :: 7
	 peizes :: 7
	seizers :: 6
	  seize :: 8
	  peize :: 6
      }
expression too big reg espace  {
	preace :: 7
	effaces :: 7
	aspect :: 7
	embaces :: 7
	especial :: 8
	enlaces :: 7
	escape :: 10
	cepaceous :: 7
	encase :: 7
	escapee :: 7
	escaped :: 9
	escapes :: 8
	enfaces :: 7
	escarped :: 7
	escapers :: 7
	escalope :: 7
	empales :: 7
   }
failed to get memory reg esubreg  {
    }
bad back reference reg invarg  {
	invars :: 9
	invar :: 10
	ignaro :: 7
	invader :: 7
	raving :: 8
	ravings :: 7
   }
bad argument reg nomatch match failed the structure representing a compiled regular expression typedef struct void re pcre size t re nsub  {
	                knubs :: 5
	                 snub :: 6
	                snubs :: 5
	                 nubs :: 5
	                numbs :: 5
                    }
size t re erroffset  {
  }
regex t the structure in which a captured offset is returned typedef int regoff  {
	         rego :: 8
	        reffo :: 7
            }
t typedef struct regoff t rm so regoff t rm eo regmatch  {
	   rhematic :: 10
	    regmata :: 10
	      regma :: 10
          }
t when an application links to a pcre dll in windows the symbols that are imported have to be identified as such when building pcre the appropriate export settings are needed and are set in pcreposix c before including this file if defined win defined pcre static defined pcreposix exp decl define pcreposix exp decl extern declspec dllimport define pcreposix exp defn declspec dllimport endif by default we use the standard extern declarations ifndef pcreposix exp decl ifdef cplusplus define pcreposix exp decl extern c define pcreposix exp defn extern c else define pcreposix exp decl extern define pcreposix exp defn extern endif endif the functions pcreposix exp decl int pcreposix regcomp  {
                                                                                                              }
regex t const char int pcreposix exp decl int pcreposix regexec  {
	   regence :: 9
         }
const regex t const char size t regmatch t int pcreposix exp decl size t pcreposix regerror  {
	        greasers :: -1000
               }
int const regex t char size t pcreposix exp decl void pcreposix regfree  {
	     remerge :: 9
	     regrede :: 9
	      reefer :: 9
	     referee :: 9
           }
regex t ifdef cplusplus extern c endif define regcomp pcreposix regcomp define regexec pcreposix regexec define regerror pcreposix regerror define regfree pcreposix regfree endif end of pcreposix h copyright c google inc all rights reserved redistribution and use in source and binary forms with or without modification are permitted provided that the following conditions are met redistributions of source code must retain the above copyright notice this list of conditions and the following disclaimer redistributions in binary form must reproduce the above copyright notice this list of conditions and the following disclaimer in the documentation and or other materials provided with the distribution neither the name of google inc nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission this software is provided by the copyright holders and contributors as is and any express or implied warranties including but not limited to the implied warranties of merchantability and fitness for a particular purpose are disclaimed in no event shall the copyright owner or contributors be liable for any direct indirect incidental special exemplary or consequential damages including but not limited to procurement of substitute goods or services loss of use data or profits or business interruption however caused and on any theory of liability whether in contract strict liability or tort including negligence or otherwise arising in any way out of the use of this software even if advised of the possibility of such damage author sanjay ghemawat regular expression based scanner  {
	                                                                                                                                                                                                                                                       scanner :: -1000
                                                                                                                                                                                                                                                             }
for parsing an input stream example parse a sequence of var number entries from input scanner scanner input string var int number scanner setskipexpression  {
                      }
s skip any white space we encounter while scanner consume w d var number ifndef pcre scanner h define pcre scanner h include assert h include string include vector include pcrecpp h include pcre stringpiece h namespace pcrecpp class pcrecpp exp defn scanner public scanner explicit scanner const std string input scanner return current line number the returned line number is one based i e it returns the number of consumed newlines note this method may be slow it may take time proportional  {
	                                                                      proportional :: -1000
                                                                                 }
to the size of the input int linenumber  {
	minehunter :: 12
      }
const return the byte offset that the scanner is looking in the input data int offset const return true iff the start of the remaining input matches re bool lookingat  {
	                      hooking :: 11
	                      rooking :: 11
	                      booking :: 11
	                      looting :: 13
	                      loosing :: 11
	                      looping :: 11
	                      looming :: 11
	                      looking :: 14
	                     toolings :: 11
	                     lookings :: 13
	                      cooking :: 11
	                      pooking :: 11
	                      jooking :: 11
	                      talking :: 11
	                      tooling :: 12
	                      dooking :: 11
	                      kooking :: 11
                            }
const re re const return true iff all of the following are true a the start of the remaining input matches re b if any arguments are supplied matched sub patterns can be parsed and stored into the arguments if it returns true it skips  {
	                                       skips :: -1000
                                           }
over the matched input and any following input that matches the skip regular expression bool consume const re re const arg arg re no arg const arg arg re no arg const arg arg re no arg todo allow more arguments set the skip regular expression if after consuming  {
	                                       consuming :: -1000
                                               }
some data a prefix of the input matches this re it is automatically skipped for example a programming language scanner would use a skip re that matches white space and comments scanner setskipexpression s n skipping  {
	                           skipping :: -1000
                                  }
repeats  {
	repeats :: -1000
 }
as long as it succeeds we used to let people do this by writing in the regular expression but that added up to lots  {
	                   lots :: -1000
                      }
of recursive calls within the pcre library so now we control repetition  {
	 repetition :: -1000
          }
explicitly via the function call api you can pass null for re if you do not want any data to be skipped void skip const char re deprecated does not repeat void setskipexpression const char re temporarily pause  {
	                                pause :: -1000
                                    }
skip ing this skip foo code disableskip  {
	disables :: 15
     }
code enableskip  {
	enablers :: 12
	beadleship :: 12
	enable :: 12
	enables :: 14
 }
is similar to skip foo code skip null code skip foo but avoids creating deleting  {
	      deleting :: -1000
             }
new re objects void disableskip reenable  {
	keepable :: 10
	reelable :: 13
	peelable :: 10
	rentable :: 11
	reefable :: 13
	runnable :: 10
	lienable :: 10
	feedable :: 10
	ruinable :: 10
	openable :: 10
	amenable :: 10
    }
previously paused  {
	paused :: -1000
 }
skipping any prefix of the input that matches the skip pattern is immediately dropped void enableskip special wrappers around setskip for some common idioms  {
	                 idioms :: -1000
                      }
arranges  {
	arranges :: -1000
 }
to skip whitespace c comments c comments the overall  {
	 overall :: -1000
       }
re is a disjunction  {
	disjunction :: -1000
  }
of the following res s whitespace n c comment n c comment x means minimal repetitions  {
	    repetitions :: -1000
              }
of x we get repetition via the semantics of setskipexpression not by using void skipcxxcomments  {
             }
setskipexpression s n n void set save comments bool comments save comments comments bool save comments return save comments append to vector ranges  {
	                ranges :: -1000
                     }
the comments found in the byte range start end inclusive of the input data only comments that were extracted entirely  {
	           entirely :: -1000
                  }
within that range are returned no range splitting  {
	splitting :: -1000
      }
of atomically  {
	atomically :: -1000
 }
extracted comments is performed void getcomments  {
    }
int start int end std vector stringpiece ranges append to vector ranges the comments added since the last time this was called this functionality is provided for efficiency  {
	                 efficiency :: -1000
                          }
when interleaving  {
	interleaving :: -1000
 }
scanning with parsing void getnextcomments  {
   }
std vector stringpiece ranges private std string data all the input data stringpiece input unprocessed  {
	   unprocessed :: -1000
             }
input re skip if non null re for skipping input bool should skip if true use skip bool skip repeat if true repeat skip as long as it works bool save comments if true aggregate  {
	                         aggregate :: -1000
                                 }
the skip expression the skipped comments todo later consider requiring that the stringpieces  {
	stringpieces :: -1000
           }
be added in order by their start position std vector stringpiece comments the offset into comments that has been returned by getnextcomments int comments offset helper function to consume skip and honour  {
	                         honour :: -1000
                              }
save comments void consumeskip  {
	consumers :: 14
	consumerist :: 14
	consumes :: 16
	consumership :: 15
  }
namespace pcrecpp endif pcre scanner h copyright c google inc all rights reserved redistribution and use in source and binary forms with or without modification are permitted provided that the following conditions are met redistributions of source code must retain the above copyright notice this list of conditions and the following disclaimer redistributions in binary form must reproduce the above copyright notice this list of conditions and the following disclaimer in the documentation and or other materials provided with the distribution neither the name of google inc nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission this software is provided by the copyright holders and contributors as is and any express or implied warranties including but not limited to the implied warranties of merchantability and fitness for a particular purpose are disclaimed in no event shall the copyright owner or contributors be liable for any direct indirect incidental special exemplary or consequential damages including but not limited to procurement of substitute goods or services loss of use data or profits or business interruption however caused and on any theory of liability whether in contract strict liability or tort including negligence or otherwise arising in any way out of the use of this software even if advised of the possibility of such damage author sanjay ghemawat a string like object that points into another piece of memory useful for providing an interface that allows clients to easily pass in either a const char or a string arghh  {
                                                                                                                                                                                                                                                                  }
i wish c literals  {
	literals :: -1000
  }
were automatically of type string ifndef pcre stringpiece h define pcre stringpiece h include cstring  {
	      cutlings :: 9
	      citrines :: 9
	      citrange :: 9
	       casting :: 9
	       carting :: 9
	      astringe :: 10
	      tracings :: 9
	       costing :: 9
	       storing :: 9
	       scoring :: 9
	       crating :: 9
	       sacring :: 9
	        citrin :: 9
	     astringed :: 9
	       staring :: 9
	      catlings :: 9
	       citrons :: 9
	       citrins :: 10
	       scaring :: 9
	       cursing :: 9
	     citranges :: 10
	      outrings :: 9
             }
include string include iosfwd  {
	sowfed :: 7
  }
for ostream forward declaration if define have type traits  {
	  traits :: -1000
       }
include type traits h elif define have type traits include bits type traits h endif include pcre h using std memcmp using std strlen using std string namespace pcrecpp class pcrecpp exp defn stringpiece private const char ptr int length public we provide non explicit singleton  {
	                                    singleton :: -1000
                                            }
constructors so users can pass in a const char or a string wherever a stringpiece is expected stringpiece ptr null length stringpiece const char str ptr str length static cast int strlen ptr stringpiece const unsigned char str ptr reinterpret cast const char str length static cast int strlen ptr stringpiece const string str ptr str data length static cast int str size stringpiece const char offset int len ptr offset length len data may return a pointer to a buffer with embedded nuls  {
	                                                                            hypnums :: -1000
                                                                                  }
and the returned buffer may or may not be null terminated therefore it is typically a mistake to pass data to a routine that expects a nul terminated string use as string c str if you really need to do this or better yet change your routine so it does not rely  {
	                                               rely :: -1000
                                                  }
on nul termination const char data const return ptr int size const return length bool empty const return length void clear ptr null length void set const char buffer int len ptr buffer length len void set const char str ptr str length static cast int strlen str void set const void buffer int len ptr reinterpret cast const char buffer length len char operator int i const return ptr i void remove prefix int n ptr n length n void remove suffix int n length n bool operator const stringpiece x const return length x length memcmp ptr x ptr length bool operator const stringpiece x const return this x define stringpiece binary predicate cmp auxcmp  {
	                                                                                                              mudcap :: 7
                                                                                                                   }
bool operator cmp const stringpiece x const int r memcmp ptr x ptr length x length length x length return r auxcmp r length cmp x length stringpiece binary predicate stringpiece binary predicate stringpiece binary predicate stringpiece binary predicate undef stringpiece binary predicate int compare const stringpiece x const int r memcmp ptr x ptr length x length length x length if r if length x length r else if length x length r return r string as string const return string data size void copytostring  {
                                                                                    }
string target const target assign ptr length does this start with x bool starts with const stringpiece x const return length x length memcmp ptr x ptr x length namespace pcrecpp functions used to create stl  {
	                              atlas :: 3
	                              stylo :: 3
	                              styli :: 3
	                              style :: 3
	                              stulm :: 3
	                              stull :: 3
	                              stool :: 3
	                              stole :: 3
	                              stola :: 3
	                              still :: 3
	                              stile :: 3
	                              stilb :: 3
	                              stell :: 3
	                              stele :: 3
	                              stela :: 3
	                              steil :: 3
	                              steel :: 3
	                              steal :: 3
	                              stall :: 3
	                              stalk :: 3
	                              stale :: 3
	                               tils :: 3
	                               tels :: 3
	                               slut :: 3
	                               slot :: 3
	                               slit :: 3
	                               slat :: 3
	                               silt :: 4
	                               salt :: 4
	                              split :: 3
	                              splat :: 3
	                              silty :: 3
	                              salty :: 3
	                              salto :: 3
	                              salet :: 3
	                                sol :: 3
	                                sel :: 3
	                                sal :: 3
	                                 st :: 4
	                                 sl :: 3
                                  }
containers  {
	containers :: -1000
 }
that use stringpiece remember that a stringpiece s lifetime had better be less than that of the underlying string or char if it is not then you cannot safely store a stringpiece into an stl container ifdef have type traits this makes vector stringpiece really fast for some stl implementations template struct type traits pcrecpp stringpiece typedef true type has trivial  {
	                                                     trivial :: -1000
                                                           }
default constructor typedef true type has trivial copy constructor typedef true type has trivial assignment operator typedef true type has trivial destructor typedef true type is pod  {
	                       pod :: -1000
                         }
type endif allow stringpiece to be logged  {
	logged :: -1000
     }
std ostream operator std ostream o const pcrecpp stringpiece piece endif pcre stringpiece h pngconf  {
             }
h machine configurable  {
	unforgivable :: 15
	configured :: 16
	configures :: 16
	configurative :: 15
	configure :: 17
	considerable :: 15
 }
file for libpng libpng version july copyright c glenn randers pehrson version copyright c andreas  {
	       aspread :: 9
	       anadems :: 9
	        snared :: 9
             }
dilger  {
	beemasters :: -1000
 }
version copyright c guy  {
	hey :: -1000
  }
eric  {
	eric :: -1000
 }
schalnat  {
	shallot :: -1000
 }
group inc this code is released under the libpng license for conditions of distribution and use see the disclaimer and license in png h any machine specific code is near the front of this file so if you are configuring  {
	                            configuring :: -1000
                                      }
libpng for a machine you may want to read the section starting here down to where it starts to typedef png color png text and png info ifndef pngconf h define pngconf h define png x png user config has to be defined on the compiler command line this includes the resource compiler for windows dll configurations  {
	                                          configurations :: -1000
                                                       }
ifdef png user config ifndef png user privatebuild  {
      }
define png user privatebuild endif include pngusr  {
	perusing :: 7
	sprung :: 7
	 pungs :: 7
     }
h endif png configure libpng is set by the configure script ifdef png configure libpng ifdef have config h include config h endif endif added at libpng if you create a private dll you need to define in pngusr h the followings  {
	                               followings :: -1000
                                        }
define png user privatebuild describes by whom and why this version of the dll was built e g define png user privatebuild build by mycompany  {
	               pyromancy :: 11
	               accompany :: 12
                       }
for xyz reasons define png user dllfname  {
     }
postfix two letter postfix that serve to distinguish your dll from those of the official release these correspond to the trailing letters that come after the version number and must match your private dll name e g private dll libpng gx dll define png user dllfname postfix gx the following macros are also at your disposal  {
	                                               disposal :: -1000
                                                      }
if you want to complete the dll versioninfo  {
      }
structure png user versioninfo comments png user versioninfo companyname  {
       }
png user versioninfo legaltrademarks  {
  }
ifdef stdc ifdef specialbuild  {
  }
pragma message png libpng specialbuild and deprecated specialbuild are now libpng reserved macros use png user privatebuild instead endif ifdef privatebuild pragma message privatebuild is deprecated use png user privatebuild instead define png user privatebuild privatebuild endif endif stdc ifndef png version info only end of material added to libpng added at libpng removed at libpng because it caused trouble restored  {
	                                                    restored :: -1000
                                                           }
at libpng if defined png no warn uninitialized row defined png warn uninitialized row define png warn uninitialized row endif end of material added at libpng this is the size of the compression buffer and thus the size of an idat chunk make this whatever size you feel  {
	                                           feel :: -1000
                                              }
is best for your machine one of these will be allocated per png struct when this is full it writes the data to the disk and does some other calculations making this an extremely small size will slow the library down but you may want to experiment to determine where it becomes  {
	                                            becomes :: -1000
                                                  }
significant if you are concerned with memory usage note that zlib allocates at least kb  {
	          kbar :: 2
	           kob :: 2
	           kab :: 2
	             k :: 2
             }
also for readers  {
	sudden :: -1000
 }
this describes the size of the buffer available to read the data in unless this gets smaller than the size of a row compressed it should not make much difference how big this is ifndef png zbuf  {
                                   }
size define png zbuf size endif enable if you want a write only libpng ifndef png no read supported define png read supported endif enable if you want a read only libpng ifndef png no write supported define png write supported endif enabled in ifdef png allow benign  {
	                                         benign :: -1000
                                              }
errors define png benign error png warning define png chunk benign error png chunk warning else ifndef png benign errors supported define png benign error png error define png chunk benign error png chunk error endif endif added in libpng if defined png no warnings defined png warnings supported define png warnings supported endif if defined png no error text defined png error text supported define png error text supported endif if defined png no check chrm defined png check chrm supported define png check chrm supported endif enabled by default in you can disable this if you don t need to support pngs  {
	                                                                                                   pugs :: 5
	                                                                                                   pigs :: 5
	                                                                                                   pegs :: 5
	                                                                                                   engs :: 5
                                                                                                      }
that are embedded in mng datastreams if defined png x defined png no mng features ifndef png mng features supported define png mng features supported endif endif ifndef png no floating point supported ifndef png floating point supported define png floating point supported endif endif if you are running on a machine where you cannot allocate more than k of memory at once uncomment this while libpng will not normally need that much memory in a chunk unless you load up a very large file zlib needs to know how big of a chunk it can use and libpng thus makes sure to check any memory allocation to verify it will fit into memory define png max malloc k if defined maxseg  {
	                                                                                                            confiscatable :: -1000
                                                                                                                        }
k defined png max malloc k define png max malloc k endif special munging  {
	      munting :: 11
	      minging :: 11
	      gurning :: 9
	       muntin :: 9
	      mugging :: 11
	      muggins :: 9
	      dunging :: 11
	      mudging :: 11
	     muntings :: 10
	      numbing :: 9
	      manging :: 11
	     muggings :: 10
	      bunging :: 11
	      nudging :: 10
	      menging :: 11
	      unaging :: 9
            }
to support doing things the cygwin way normal png on win defines defaults png build dll building dll png use dll building an application linking to dll no define building static library or building an application and linking to the static lib cygwin defines defaults png build dll ignored building the dll no define ignored building an application linking to the dll png static ignored building the static lib or building an application that links to the static lib all static ignored building various static libs or building an application that links to the static libs thus a cygwin user should define either png build dll or png static and this bit of ifdefs  {
                                                                                                                }
will define the correct config variables based on that if a cygwin user wants to define png use dll that s okay but unnecessary also the precedence  {
	                precedence :: -1000
                         }
order is all static since we can t undef something outside our namespace png build dll png static nothing png use dll cygwin the preceding is now obsolete with the advent  {
	                        advent :: -1000
                             }
of auto import in binutils  {
	binits :: 10
	botulins :: 10
   }
we no longer need to worry about declspec dllexport declspec dllimport and friends  {
	     friends :: -1000
           }
therefore we don t need to worry about png static or all static when it comes to declspec stuff however we do need to worry about png build dll and png static because those change some defaults such as console io and whether global arrays are allowed ifdef cygwin ifdef all static ifdef png build dll undef png build dll endif ifdef png use dll undef png use dll endif ifdef png dll undef png dll endif ifndef png static define png static endif else ifdef png build dll ifdef png static undef png static endif ifdef png use dll undef png use dll endif ifndef png dll define png dll endif else ifdef png static ifdef png use dll undef png use dll endif ifdef png dll undef png dll endif else ifndef png use dll define png use dll endif ifndef png dll define png dll endif endif endif endif endif this protects  {
	                                                                                                                                                  protects :: -1000
                                                                                                                                                         }
us against compilers that run on a windowing  {
	windowing :: -1000
      }
system and thus don t have or would rather us not use the stdio types stdin stdout and stderr the only one currently used is stderr in png error and png warning defining png no console io will prevent these from being compiled and used defining png no stdio will also prevent these plus will prevent the entire set of stdio macros and functions file printf etc from being compiled and used unless png debug has been defined define png no console io define png no stdio if defined png no stdio defined png stdio supported define png stdio supported endif ifdef win wce  {
	                                                                                                  wreck :: 3
	                                                                                                   wice :: 3
	                                                                                                   crew :: 3
	                                                                                                   clew :: 3
	                                                                                                   chew :: 3
	                                                                                                    wye :: 3
	                                                                                                    woe :: 3
	                                                                                                    wee :: 3
	                                                                                                    wae :: 3
	                                                                                                    ice :: 3
	                                                                                                    ace :: 3
	                                                                                                     we :: 3
                                                                                                      }
include windows h console i o functions are not supported on windowsce define png no console io abort may not be supported on some all windows ce platforms define png abort exit ifdef png debug undef png debug endif endif ifdef png build dll ifndef png console io supported ifndef png no console io define png no console io endif endif endif ifdef png no stdio ifndef png no console io define png no console io endif ifdef png debug if png debug include stdio h endif endif else ifndef win wce stdio h functions are not supported on windowsce include stdio h endif endif if defined png no console io defined png console io supported define png console io supported endif this macro protects us against machines that don t have function prototypes ie k r style headers if your compiler does not handle function prototypes define this macro and use the included ansi knr  {
	                                                                                                                                                        kob :: -1000
                                                                                                                                                          }
i ve always been able  {
	able :: -1000
   }
to use no proto as the indicator but you may need to drag  {
	        drag :: -1000
           }
the empty declaration out in front of here or change the ifdef to suit your own needs ifndef pngarg  {
	            upgang :: 7
	            parang :: 7
	            paging :: 7
	           pygargs :: 8
	            pygarg :: 9
                 }
ifdef of zlib prototype munger  {
	murgeon :: 9
	mugger :: 9
	gunters :: 7
	hunger :: 9
	muggers :: 8
	morgen :: 7
	monger :: 9
	muckering :: 7
	mangers :: 8
	hungers :: 8
	mustering :: 7
	mongery :: 8
	mongers :: 8
	lunger :: 9
	nudgers :: 7
	gunter :: 8
	gunner :: 7
	manger :: 9
	hungerly :: 7
	number :: 7
	lungers :: 8
	nudger :: 8
	rung :: 7
	mung :: 8
	meng :: 7
	mungo :: 7
	mudge :: 7
	minge :: 7
	menge :: 7
	murdering :: 7
   }
define pngarg arglist of arglist else ifdef no proto define pngarg arglist ifndef png typecast  {
	      typecast :: -1000
             }
null define png typecast null endif else define pngarg arglist arglist endif no proto endif of endif pngarg try to determine if we are compiling on a mac note that testing for just mwerks is not good enough because the codewarrior is now used on non mac platforms ifndef macos  {
	                                           mucose :: 6
	                                           mucosa :: 8
	                                            comas :: 6
	                                          masonic :: 6
	                                           mochas :: 6
	                                          mucosas :: 6
	                                          mucosal :: 7
	                                          mucosae :: 7
	                                           mascot :: 6
	                                           mascon :: 6
	                                          macrons :: 6
	                                           macros :: 7
	                                           macons :: 8
	                                           machos :: 7
	                                            tacos :: 7
	                                             mocs :: 6
	                                             macs :: 7
	                                           caroms :: 6
	                                            pacos :: 7
	                                            mocks :: 6
	                                            micos :: 7
	                                            micas :: 6
	                                            mayos :: 7
	                                            mason :: 6
	                                            marcs :: 6
	                                            manos :: 7
	                                            makos :: 7
	                                            macro :: 6
	                                            macon :: 7
	                                            macks :: 7
	                                            machs :: 7
	                                            macho :: 6
	                                              mac :: 6
                                                }
if defined mwerks defined macintosh defined applec  {
	applecart :: 8
	 apply :: 7
	 appel :: 8
	 ample :: 7
	apples :: 9
	appels :: 7
	applied :: 7
	applies :: 7
	applier :: 7
	applecarts :: 7
	 pepla :: 7
	caplet :: 7
	applicate :: 7
     }
defined think c defined sc defined target os mac define macos endif endif enough people need this for various reasons to include it here if defined macos defined riscos  {
	                      sirocs :: 8
	                      sickos :: 7
	                      piscos :: 9
	                      rosins :: 7
	                      discos :: 9
	                   discovers :: 7
	                   discourse :: 7
	                      micros :: 7
	                     rissole :: 7
	                      ciscos :: 9
	                      visors :: 7
	                     viscose :: 8
	                     viscous :: 7
	                     ciscoes :: 7
	                    discords :: 8
                           }
defined win wce include sys types h endif if defined png setjmp not supported defined png no setjmp supported define png setjmp supported endif ifdef png setjmp supported this is an attempt to force a single setjmp behaviour on linux if the x config stuff didn t define bsd source we wouldn  {
	                                             woundy :: 8
	                                             wounds :: 8
	                                              could :: 7
	                                            wounder :: 7
	                                            wouldst :: 8
	                                              wound :: 9
	                                              would :: 10
	                                              world :: 7
	                                              woald :: 7
	                                           woundily :: 8
	                                             louden :: 7
	                                          woundless :: 7
	                                           wouldest :: 7
	                                          woundable :: 7
	                                              nould :: 9
	                                              mould :: 7
	                                              lownd :: 7
                                                  }
t need this you can bypass  {
	bypass :: -1000
    }
this test if you know that your application uses exactly the same setjmp h that was included when libpng was built only define png skip setjmp check while building your application prior to the application s include png h don t define png skip setjmp check while building a separate libpng library for general use ifndef png skip setjmp check ifdef linux ifdef bsd source define png save bsd source undef bsd source endif ifdef setjmp h if you encounter a compiler error here see the explanation  {
	                                                                           explanation :: -1000
                                                                                     }
near the end of install pngconf h in libpng already includes setjmp h dont include it again endif endif linux endif png skip setjmp check include setjmp h for error handling include setjmp h ifdef linux ifdef png save bsd source ifndef bsd source define bsd source endif undef png save bsd source endif endif linux endif png setjmp supported ifdef bsd include strings h else include string h endif other defines for things like memory and the like can go here ifdef png internal include stdlib h the functions exported by png extern are png internal functions which aren t usually used outside the library as far as i know so it is debatable  {
	                                                                                                         debatable :: -1000
                                                                                                                 }
if they should be exported at all in the future when it is possible to have run time registry  {
	          registry :: -1000
                 }
of chunk handling functions some of these will be made available again define png extern extern define png extern other defines specific to compilers can go here try to keep them inside an appropriate ifdef endif pair for portability ifdef png floating point supported ifdef macos we need to check that math h hasn  {
	                                                harns :: 6
	                                                hants :: 5
	                                                hanks :: 5
	                                                hangs :: 5
	                                                hands :: 5
	                                                 shan :: 5
	                                               haunts :: 5
	                                               hasten :: 5
	                                                 hast :: 5
	                                                 hasp :: 5
	                                                 hask :: 5
	                                                 harn :: 5
	                                                 hain :: 5
	                                                 haen :: 5
	                                                  nas :: 5
	                                                  has :: 6
	                                                  han :: 5
                                                    }
t already been included earlier as it seems it doesn t agree with fp h yet we should really use fp h if possible if defined math h defined math h defined cmath include fp h endif else include math h endif if defined amiga  {
	                                       amiga :: -1000
                                           }
defined sasc  {
	sars :: -1000
 }
defined m amiga sas c we must include builtin fpu functions when compiling using math include m h endif endif codewarrior on nt has linking problems without this if defined mwerks defined win defined stdc define png always extern endif this provides the non ansi far memory allocation routines if defined turboc  {
	                                           turbocar :: 9
	                                           turbofan :: 7
	                                            turbots :: 7
	                                             turbot :: 8
	                                             turbos :: 9
	                                             turaco :: 7
	                                            burdock :: 7
	                                            burbots :: 7
	                                          turbocars :: 8
	                                              turbo :: 10
	                                             burton :: 7
	                                             burbot :: 8
	                                               curb :: 7
                                                  }
defined msdos  {
	osmosed :: 6
	sodoms :: 6
	musos :: 6
	modus :: 6
	modes :: 6
	misos :: 6
 }
include mem h include alloc h endif i have no idea why is this necessary if defined msc ver defined win defined windows defined windows defined win defined win include malloc h endif this controls how fine the dithering gets as this allocates a largish  {
	                                     largish :: -1000
                                           }
chunk of memory k those who are not as concerned with dithering quality can decrease  {
	      decrease :: -1000
             }
some or all of these ifndef png dither red bits define png dither red bits endif ifndef png dither green bits define png dither green bits endif ifndef png dither blue bits define png dither blue bits endif this controls how fine the gamma correction  {
	                                  correction :: -1000
                                           }
becomes when you are only interested  {
	interested :: -1000
    }
in bits anyway increasing this value results in more memory being used and more pow functions being called to fill in the gamma tables don t set this value less then and even that may not work i haven  {
	                                 haven :: -1000
                                     }
t tested it ifndef png max gamma define png max gamma endif this controls how much a difference in gamma we can tolerate  {
	              tolerate :: -1000
                     }
before we actually start doing gamma conversion ifndef png gamma threshold define png gamma threshold endif endif png internal the following uses const char instead of char for error and warning message functions so some compilers won t complain if you do not want to use const define png no const here ifndef png no const define png const const else define png const endif the following defines give you the ability to remove code from the library that you will not be using i wish i could figure out how to automate  {
	                                                                                    automate :: -1000
                                                                                           }
this but i can t do that without making it seriously hard on the users so if you are not using an ability change the define to and undef and that part of the library will not be compiled if your linker can t find a function you may want to make sure the ability is defined here some of these depend upon some others being defined i haven t figured out all the interactions  {
	                                                              interactions :: -1000
                                                                         }
here so you may have to experiment awhile  {
	 awhile :: -1000
      }
to get everything to compile if you are creating or using a shared library you probably shouldn t touch this as it will affect the size of the structures and this will cause bad things to happen if the library and or application ever change any features you will not be using can be undef ed here gr p a set transforms supported as default but allow user to turn it off with transforms not supported or png no transforms on the compile line then pick and choose which ones to define without having to edit this file it is safe to use the transforms not supported if you only want to have a png compliant reader writer but don t need any of the extra transformations  {
	                                                                                                               transformations :: -1000
                                                                                                                             }
this saves about kbytes  {
	keyset :: 7
	kythes :: 7
  }
in a typical installation of the library png no form added in version c for consistency the size of the png text structure changed in libpng when itxt support was added itxt support was turned off by default through libpng x to support old apps that malloc the png text structure instead of calling png set text and letting  {
	                                                   letting :: -1000
                                                         }
libpng malloc it it will be turned on by default in libpng if defined png x defined png x ifndef png no itxt supported define png no itxt supported endif ifndef png no read itxt define png no read itxt endif ifndef png no write itxt define png no write itxt endif endif if defined png no itxt supported if defined png read itxt supported defined png no read itxt define png read itxt endif if defined png write itxt supported defined png no write itxt define png write itxt endif endif the following support added after version can be turned off here en masse  {
	                                                                                                   masse :: -1000
                                                                                                       }
by defining png legacy supported in case you need binary compatibility with old applications that require the length of png struct and png info to remain unchanged ifdef png legacy supported define png no free me define png no read unknown chunks define png no write unknown chunks define png no handle as unknown define png no read user chunks define png no read iccp define png no write iccp define png no read itxt define png no write itxt define png no read scal define png no write scal define png no read splt define png no write splt define png no info image define png no read rgb to gray define png no read user transform define png no write user transform define png no user mem define png no read empty plte define png no mng features define png no fixed point supported endif ignore attempt to turn off both floating and fixed point support if defined png floating point supported defined png no fixed point supported define png fixed point supported endif ifndef png no free me define png free me supported endif ifdef png read supported if defined png read transforms not supported defined png no read transforms define png read transforms supported endif ifdef png read transforms supported ifndef png no read expand define png read expand supported endif ifndef png no read shift define png read shift supported endif ifndef png no read pack define png read pack supported endif ifndef png no read bgr define png read bgr supported endif ifndef png no read swap define png read swap supported endif ifndef png no read packswap  {
	                                                                                                                                                                                                                                                                        backwraps :: 10
	                                                                                                                                                                                                                                                                         backslap :: 10
                                                                                                                                                                                                                                                                                }
define png read packswap supported endif ifndef png no read invert  {
	    invert :: -1000
         }
define png read invert supported endif ifndef png no read dither define png read dither supported endif ifndef png no read background define png read background supported endif ifndef png no read to define png read to supported endif ifndef png no read filler define png read filler supported endif ifndef png no read gamma define png read gamma supported endif ifndef png no read gray to rgb define png read gray to rgb supported endif ifndef png no read swap alpha define png read swap alpha supported endif ifndef png no read invert alpha define png read invert alpha supported endif ifndef png no read strip alpha define png read strip alpha supported endif ifndef png no read user transform define png read user transform supported endif ifndef png no read rgb to gray define png read rgb to gray supported endif endif png read transforms supported png progressive read not supported is deprecated if defined png no progressive read defined png progressive read not supported if you don t do progressive define png progressive read supported reading this is not talking endif about interlacing  {
	                                                                                                                                                                              interlacing :: -1000
                                                                                                                                                                                        }
capability you ll still have interlacing unless you change the following define define png read interlacing supported required for png compliant decoders png no sequential read supported is deprecated if defined png no sequential read defined png sequential read supported defined png no sequential read supported define png sequential read supported endif define png read interlacing supported required in png compliant decoders ifndef png no read composite nodiv  {
	                                                              iodin :: 6
	                                                               nodi :: 8
	                                                                nod :: 6
                                                                  }
ifndef png no read composited  {
	composited :: -1000
   }
nodiv libpng x misspelling  {
	misspelling :: -1000
  }
define png read composite nodiv supported well tested on intel sgi endif endif if defined png x defined png x deprecated will be removed from version use png mng features supported instead ifndef png no read empty plte define png read empty plte supported endif endif endif png read supported ifdef png write supported if defined png write transforms not supported defined png no write transforms define png write transforms supported endif ifdef png write transforms supported ifndef png no write shift define png write shift supported endif ifndef png no write pack define png write pack supported endif ifndef png no write bgr define png write bgr supported endif ifndef png no write swap define png write swap supported endif ifndef png no write packswap define png write packswap supported endif ifndef png no write invert define png write invert supported endif ifndef png no write filler define png write filler supported same as write strip alpha endif ifndef png no write swap alpha define png write swap alpha supported endif ifndef png x ifndef png no write invert alpha define png write invert alpha supported endif endif ifndef png no write user transform define png write user transform supported endif endif png write transforms supported if defined png no write interlacing supported defined png write interlacing supported define png write interlacing supported not required for png compliant encoders  {
	                                                                                                                                                                                                                             encoders :: -1000
                                                                                                                                                                                                                                    }
but can cause trouble if left undefined endif if defined png no write weighted  {
	     weighted :: -1000
            }
filter defined png write weighted filter defined png floating point supported define png write weighted filter supported endif ifndef png no write flush define png write flush supported endif if defined png x defined png x deprecated see png mng features supported above ifndef png no write empty plte define png write empty plte supported endif endif endif png write supported ifndef png x ifndef png no error numbers define png error numbers supported endif endif png x if defined png read user transform supported defined png write user transform supported ifndef png no user transform ptr define png user transform ptr supported endif endif ifndef png no stdio define png time rfc supported endif this adds extra functions in pngget  {
	                                                                                                                 nuggety :: 7
	                                                                                                                 nuggets :: 7
	                                                                                                                  nugget :: 8
	                                                                                                                   pogge :: 7
                                                                                                                       }
c for accessing data from the info pointer added in version png get image width png get image height png get bit depth png get color type png get compression type png get filter type png get interlace type png get pixel aspect ratio png get pixels per meter png get x offset pixels png get y offset pixels png get x offset microns  {
	                                                        microns :: -1000
                                                              }
png get y offset microns if defined png no easy access defined png easy access supported define png easy access supported endif png assembler code was enabled by default in version and removed from version the following will be removed from libpng if defined png read supported defined png no optimized code ifndef png optimized code supported define png optimized code supported endif endif if defined png read supported defined png no assembler code ifndef png assembler code supported define png assembler code supported endif if defined gnuc defined x gnuc work around bit gcc compiler bugs in gcc x if defined png mmx  {
	                                                                                                  maxim :: 3
	                                                                                                     mm :: 4
                                                                                                      }
code supported defined png no mmx code define png no mmx code endif endif ifdef apple if defined png mmx code supported defined png no mmx code define png no mmx code endif endif if defined mwerks mwerks x macintosh if defined png mmx code supported defined png no mmx code define png no mmx code endif endif if defined png mmx code supported defined png no mmx code define png mmx code supported endif endif end of obsolete code to be removed from libpng added at libpng ifndef png x if defined png no user mem defined png user mem supported define png user mem supported endif endif png x added at libpng ifndef png x ifndef png set user limits supported ifndef png no set user limits define png set user limits supported endif endif endif png x added at libpng and ifndef png user limits supported ifndef png no user limits define png user limits supported endif endif added at libpng and to accept all valid pngs no matter how large set these limits to x fffffffl  {
                                                                                                                                                                                  }
ifndef png user width max define png user width max l endif ifndef png user height max define png user height max l endif added at libpng to accept all valid pngs no matter how large set these two limits to ifndef png user chunk cache max define png user chunk cache max endif added at libpng ifndef png user chunk malloc max define png user chunk malloc max endif ifndef png literal sharp  {
	                                                                    sharp :: -1000
                                                                        }
define png literal sharp x endif ifndef png literal left square bracket  {
	    bracket :: -1000
          }
define png literal left square bracket x b endif ifndef png literal right square bracket define png literal right square bracket x d endif added at libpng ifndef png string newline define png string newline n endif these are currently experimental features define them if you want very little testing ifdef png read supported ifndef png read to accurate scale supported define png read to accurate scale supported endif endif this is only for powerpc big endian and x systems some testing ifndef png read big endian supported define png read big endian supported endif buggy  {
	                                                                                          buggy :: -1000
                                                                                              }
compilers e g gcc need this define png no pointer indexing  {
	  indexing :: -1000
         }
if defined png no pointer indexing defined png pointer indexing supported define png pointer indexing supported endif these functions are turned off by default as they will be phased  {
	                      phased :: -1000
                           }
out define png useless tests  {
	tests :: -1000
   }
supported define png correct palette supported any chunks you are not interested in you can undef here the ones that allocate memory may be expecially  {
	                especial :: 12
	              especially :: 17
	              explicable :: 13
	              explicably :: 13
                       }
important hist text ztxt trns pcal others will just save time and make png info a bit smaller if defined png read supported defined png read ancillary chunks not supported defined png no read ancillary chunks define png read ancillary chunks supported endif if defined png write supported defined png write ancillary chunks not supported defined png no write ancillary chunks define png write ancillary chunks supported endif ifdef png read ancillary chunks supported ifdef png no read text define png no read itxt define png no read text define png no read ztxt endif ifndef png no read bkgd define png read bkgd supported define png bkgd supported endif ifndef png no read chrm define png read chrm supported define png chrm supported endif ifndef png no read gama define png read gama supported define png gama supported endif ifndef png no read hist define png read hist supported define png hist supported endif ifndef png no read iccp define png read iccp supported define png iccp supported endif ifndef png no read itxt ifndef png read itxt supported define png read itxt supported endif ifndef png itxt supported define png itxt supported endif endif ifndef png no read offs define png read offs supported define png offs supported endif ifndef png no read pcal define png read pcal supported define png pcal supported endif ifndef png no read scal define png read scal supported define png scal supported endif ifndef png no read phys define png read phys supported define png phys supported endif ifndef png no read sbit define png read sbit supported define png sbit supported endif ifndef png no read splt define png read splt supported define png splt supported endif ifndef png no read srgb define png read srgb supported define png srgb supported endif ifndef png no read text define png read text supported define png text supported endif ifndef png no read time define png read time supported define png time supported endif ifndef png no read trns define png read trns supported define png trns supported endif ifndef png no read ztxt define png read ztxt supported define png ztxt supported endif ifndef png no read opt plte define png read opt plte supported only affects support of the endif optional plte chunk in rgb and rgba images if defined png read itxt supported defined png read text supported defined png read ztxt supported define png read text supported define png text supported endif endif png read ancillary chunks supported ifndef png no read unknown chunks define png read unknown chunks supported ifndef png unknown chunks supported define png unknown chunks supported endif endif if defined png no read user chunks defined png read unknown chunks supported define png read user chunks supported define png user chunks supported ifdef png no read unknown chunks undef png no read unknown chunks endif ifdef png no handle as unknown undef png no handle as unknown endif endif ifndef png no handle as unknown ifndef png handle as unknown supported define png handle as unknown supported endif endif ifdef png write supported ifdef png write ancillary chunks supported ifdef png no write text define png no write itxt define png no write text define png no write ztxt endif ifndef png no write bkgd define png write bkgd supported ifndef png bkgd supported define png bkgd supported endif endif ifndef png no write chrm define png write chrm supported ifndef png chrm supported define png chrm supported endif endif ifndef png no write gama define png write gama supported ifndef png gama supported define png gama supported endif endif ifndef png no write hist define png write hist supported ifndef png hist supported define png hist supported endif endif ifndef png no write iccp define png write iccp supported ifndef png iccp supported define png iccp supported endif endif ifndef png no write itxt ifndef png write itxt supported define png write itxt supported endif ifndef png itxt supported define png itxt supported endif endif ifndef png no write offs define png write offs supported ifndef png offs supported define png offs supported endif endif ifndef png no write pcal define png write pcal supported ifndef png pcal supported define png pcal supported endif endif ifndef png no write scal define png write scal supported ifndef png scal supported define png scal supported endif endif ifndef png no write phys define png write phys supported ifndef png phys supported define png phys supported endif endif ifndef png no write sbit define png write sbit supported ifndef png sbit supported define png sbit supported endif endif ifndef png no write splt define png write splt supported ifndef png splt supported define png splt supported endif endif ifndef png no write srgb define png write srgb supported ifndef png srgb supported define png srgb supported endif endif ifndef png no write text define png write text supported ifndef png text supported define png text supported endif endif ifndef png no write time define png write time supported ifndef png time supported define png time supported endif endif ifndef png no write trns define png write trns supported ifndef png trns supported define png trns supported endif endif ifndef png no write ztxt define png write ztxt supported ifndef png ztxt supported define png ztxt supported endif endif if defined png write itxt supported defined png write text supported defined png write ztxt supported define png write text supported ifndef png text supported define png text supported endif endif ifdef png write time supported ifndef png no convert time ifndef win wce the tm structure is not supported on windowsce ifndef png convert time supported define png convert time supported endif endif endif endif endif png write ancillary chunks supported if defined png no write filter defined png write filter supported define png write filter supported endif ifndef png no write unknown chunks define png write unknown chunks supported ifndef png unknown chunks supported define png unknown chunks supported endif endif ifndef png no handle as unknown ifndef png handle as unknown supported define png handle as unknown supported endif endif endif png write supported turn this off to disable png read png and png write png and leave the row pointers member out of the info structure ifndef png no info image define png info image supported endif need the time information for converting time chunks ifdef png convert time supported time h functions are not supported on windowsce include time h endif some typedefs to get us started these should be safe on most of the common platforms the typedefs should be at least as large as the numbers suggest  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   suggest :: -1000
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         }
a png uint must be at least bits long but they don t have to be exactly that size some compilers dislike  {
	              dislike :: -1000
                    }
passing unsigned shorts as function parameters so you may be better off using unsigned int for png uint likewise for bit systems you may want to have unsigned int for png uint instead of unsigned long typedef unsigned long png uint typedef long png int typedef unsigned short png uint typedef short png int typedef unsigned char png byte this is usually size t it is typedef ed just in case you need it to change i m not sure if you will or not so i thought i d be safe ifdef png size t typedef png size t png size t define png sizeof x png convert size sizeof x else typedef size t png size t define png sizeof x sizeof x endif the following is needed for medium model support it cannot be in the png internal section needs modification for other compilers besides  {
	                                                                                                                                            besides :: -1000
                                                                                                                                                  }
msc model independent support declares  {
	declares :: -1000
   }
all arrays and pointers to be large using the far keyword the zlib version used must also support model independent data as of version zlib the necessary changes have been made in zlib the use far keyword define triggers  {
	                              triggers :: -1000
                                     }
other changes that are needed tim wegner  {
	lenger :: 7
	weiners :: 8
	gender :: 7
	 genre :: 7
	weaners :: 8
	winger :: 7
	wiener :: 8
	weltering :: 7
	weiner :: 9
	weaner :: 9
	wieners :: 7
	regrew :: 7
	westering :: 7
	western :: 7
	  ween :: 7
	venger :: 7
     }
separate compiler dependencies problem here is that zlib h always defines far sjt  {
	        jots :: 3
	        jets :: 3
	         sot :: 3
	         sit :: 3
	         set :: 3
	         sat :: 3
	          st :: 3
           }
ifdef borlandc if defined large defined huge defined compact define ldata  {
	     adyta :: 6
         }
else define ldata endif grr  {
	girr :: 3
	 gor :: 3
	 ger :: 3
	 gar :: 3
	 err :: 3
	 brr :: 3
	 arr :: 3
	  gr :: 3
   }
why is cygwin in here cygwin is not borland c if defined win defined flat defined cygwin define png max malloc k if ldata ifndef far define far far endif define use far keyword endif ldata possibly useful for moving data out of default segment uncomment it if you want could also define fardata  {
	                                              radiata :: 9
                                                    }
as const if your compiler supports it sjt define fardata far endif win flat cygwin endif borlandc suggest testing for specific compiler first before testing for far the watcom  {
	                    watchmen :: 7
	                     catworm :: 8
	                    catworms :: 7
	                      matlow :: 7
	                      mascot :: 7
	                       watch :: 7
                           }
compiler defines both medium and m i mm making reliance  {
	 reliance :: -1000
        }
oncertain  {
	incoronate :: 11
	cineration :: 11
	uncertainly :: 13
	uncurtained :: 12
	uncertainty :: 12
	incarnate :: 11
	ancestoring :: 11
	incretion :: 11
	uncertain :: 15
	incertain :: 15
	uncurtains :: 11
	ascertains :: 11
	entertains :: 11
	crenation :: 11
	uncurtain :: 12
	entertain :: 12
	interclan :: 11
 }
keywords suspect  {
	suspect :: -1000
 }
sjt msc medium model ifdef far ifdef m i mm define use far keyword define fardata far include dos h endif endif sjt default case ifndef far define far endif at this point far is always defined ifndef fardata define fardata endif typedef for floating point numbers that are converted to fixed point with a multiple of e g int gamma typedef png int png fixed point add typedefs for pointers typedef void far png voidp  {
	                                                                     voider :: 6
	                                                                     voidee :: 6
	                                                                      voids :: 7
	                                                                       void :: 8
                                                                          }
typedef png byte far png bytep  {
	 type :: 6
    }
typedef png uint far png uint p typedef png int far png int p typedef png uint far png uint p typedef png int far png int p typedef png const char far png const charp  {
	                             sharpy :: 6
	                             sharps :: 6
	                             scarph :: 7
	                              cramp :: 6
	                              chirp :: 7
	                              cheap :: 6
	                              chary :: 7
	                              chart :: 7
	                              charr :: 6
	                              charm :: 7
	                              chark :: 7
	                              chare :: 7
	                              chard :: 7
	                              chara :: 6
	                              chapt :: 6
	                              chaps :: 6
	                              chape :: 6
	                              champ :: 7
	                              chair :: 6
	                             coprah :: 6
	                            cheaper :: 6
	                             eparch :: 6
	                             chirpy :: 6
	                             chirps :: 6
	                             charts :: 6
	                             charms :: 6
	                             charks :: 6
	                             charge :: 6
	                             charet :: 6
	                             chares :: 6
	                             chared :: 6
	                             chards :: 6
	                             chappy :: 6
	                             champs :: 6
	                            charpoy :: 8
	                            charpie :: 8
	                            charpai :: 7
	                            chapter :: 6
	                            champer :: 7
	                           charpies :: 7
	                           charpais :: 6
	                              sharp :: 7
	                              scarp :: 6
	                               crap :: 6
	                               char :: 8
	                               chap :: 7
	                            scarphs :: 6
	                              phare :: 6
	                           champers :: 6
	                                cha :: 6
                                  }
typedef char far png charp typedef png fixed point far png fixed point p ifndef png no stdio ifdef win wce typedef handle png file p else typedef file png file p endif endif ifdef png floating point supported typedef double far png doublep  {
	                                   doublers :: 10
	                                   doublets :: 10
	                                     doubly :: 9
	                                     doable :: 9
	                                     rouble :: 9
	                                    coupled :: 9
	                                    soupled :: 9
	                                    doubled :: 10
	                                    doublet :: 11
	                                    doubles :: 11
	                                    doubler :: 11
                                          }
endif pointers to pointers i e arrays typedef png byte far far png bytepp  {
            }
typedef png uint far far png uint pp typedef png int far far png int pp typedef png uint far far png uint pp typedef png int far far png int pp typedef png const char far far png const charpp  {
	                                   chary :: 7
	                                   chart :: 7
	                                   charm :: 7
	                                   chark :: 7
	                                   chare :: 7
	                                   chard :: 7
	                                  chappy :: 7
	                                 charpoy :: 7
	                                 charpie :: 7
	                                    char :: 8
	                                    chap :: 7
                                       }
typedef char far far png charpp typedef png fixed point far far png fixed point pp ifdef png floating point supported typedef double far far png doublepp  {
	                  doublers :: 10
	                  doublets :: 10
	                   doubled :: 10
	                   doublet :: 11
	                   doubles :: 11
	                   doubler :: 11
                         }
endif pointers to pointers to pointers i e pointer to array typedef char far far far png charppp  {
                }
if defined png x defined png x spc is this stuff deprecated it ll be removed as of libpng gr p libpng typedefs for types in zlib if zlib changes or another compression library is used then change these eliminates  {
	                             eliminates :: -1000
                                      }
need to change all the source files typedef charf  {
	chaffron :: 6
	chaffers :: 6
	chaffier :: 6
	   chary :: 7
	   chart :: 7
	   charr :: 6
	   charm :: 7
	   chark :: 7
	   chare :: 7
	   chard :: 7
	   chara :: 6
	   chair :: 6
	   chaft :: 6
	   chaff :: 7
	   chafe :: 6
	  wharfs :: 6
	   wharf :: 7
	chaufers :: 6
	  charts :: 6
	  charms :: 6
	  charks :: 6
	  charge :: 6
	  charet :: 6
	  chares :: 6
	  chared :: 6
	  chards :: 6
	  chaffy :: 6
	  chaffs :: 6
	  chafer :: 7
	 chaufer :: 7
	 chamfer :: 7
	 chafers :: 6
	 chaffer :: 7
	charmful :: 6
	   scarf :: 6
	    char :: 8
	chanfron :: 6
	chamfron :: 6
	     cha :: 6
       }
png zcharp  {
 }
typedef charf far png zcharpp  {
   }
typedef z stream far png zstreamp  {
    }
endif png x defined png x define png build dll if the module being built is a windows libpng dll define png use dll if you want to link to the windows libpng dll it is equivalent to microsoft predefined macro dll that is automatically defined when you compile using the share version of the crt c run time library the cygwin mods make this behavior a little different define png build dll if you are building a dll for use with cygwin define png static if you are building a static library for use with cygwin or if you are building an application that you want to link to the static library png use dll is defined by default no user action needed unless one of the other flags is defined if defined png dll defined png build dll defined png use dll define png dll endif if cygwin then disallow global arrays unless building a static lib when building a static lib default to no global arrays but allow command line override ifdef cygwin ifndef png static ifdef png use global arrays undef png use global arrays endif ifndef png use local arrays define png use local arrays endif else if defined png use local arrays defined png no global arrays ifdef png use global arrays undef png use global arrays endif endif endif if defined png use local arrays defined png use global arrays define png use local arrays endif endif do not use global arrays helps with building dll s they are no longer used in libpng itself since version c but might be required for some pre c applications if defined png use local arrays defined png use global arrays if defined png no global arrays defined gnuc defined png dll defined msc ver define png use local arrays else define png use global arrays endif endif ifdef cygwin undef pngapi  {
                                                                                                                                                                                                                                                                                                                          }
define pngapi cdecl undef png impexp  {
    }
define png impexp endif if you define pngapi e g with compiler option dpngapi  {
            }
stdcall you may get warnings regarding  {
	regarding :: -1000
    }
the linkage of png zalloc  {
	hallo :: 7
	ballocks :: 7
	callose :: 7
	callous :: 7
	callows :: 7
	call :: 7
	callow :: 8
	callop :: 8
   }
and png zfree  {
	afreet :: 6
 }
don t ignore those warnings you must also reset the default calling convention in your compiler to match your pngapi and you must build zlib and your applications the same way you build libpng if defined mingw defined png moduledef  {
	                             enamorados :: -1000
                                      }
ifndef png no moduledef define png no moduledef endif endif if defined png impexp defined png build dll defined png no moduledef define png impexp endif if defined png dll defined dll defined dll defined windows defined windows defined win defined win defined win ifndef pngapi if defined gnuc defined msc ver msc ver define pngapi cdecl else define pngapi cdecl endif endif if defined png impexp defined png dll wincompiler  {
	                                                           personifier :: -1000
                                                                     }
with no support for declimpexp  {
	decomplex :: 12
   }
define png impexp endif ifndef png impexp define png export type type symbol png impexp type pngapi symbol define png export type type symbol type png impexp pngapi symbol borland microsoft if defined msc ver defined borlandc if msc ver borlandc x define png export png export type else define png export png export type ifdef png build dll define png impexp export else define png impexp import doesn t exist afaik  {
	                                                                 alfaki :: 6
                                                                      }
in vc endif exists in borland c for c classes huge endif endif ifndef png impexp ifdef png build dll define png impexp declspec dllexport else define png impexp declspec dllimport endif endif endif png impexp else dll non cygwin windows if defined ibmc  {
                                          }
defined ibmcpp  {
 }
defined os ifndef pngapi define pngapi system endif else if other platforms with other meanings  {
	      meanings :: -1000
             }
endif endif endif ifndef pngapi define pngapi endif ifndef png impexp define png impexp endif ifdef png buildsyms  {
	           builds :: 11
                }
ifndef png export define png export type symbol png function export symbol end endif ifdef png use global arrays ifndef png export var define png export var type png data export endif endif endif ifndef png export define png export type symbol png impexp type pngapi symbol endif ifdef png use global arrays ifndef png export var define png export var type extern png impexp type endif endif ifdef png pedantic warnings ifndef png pedantic warnings supported define png pedantic warnings supported endif endif ifdef png pedantic warnings supported support for compiler specific function attributes these are used so that where compiler support is available incorrect use of api functions in png h will generate compiler warnings added at libpng version ifdef gnuc ifndef png use result define png use result attribute warn unused result endif ifndef png noreturn define png noreturn attribute noreturn endif ifndef png allocated define png allocated attribute malloc endif this specifically protects structure members that should only be accessed from within the library therefore should be empty during a library build ifndef png deprecated define png deprecated attribute deprecated endif ifndef png depstruct  {
	                                                                                                                                                                                constructed :: 11
                                                                                                                                                                                          }
define png depstruct attribute deprecated endif ifndef png private if doesn t work so we use deprecated instead define png private attribute warning this function is not exported by libpng else define png private attribute deprecated endif endif png private endif gnuc endif png pedantic warnings ifndef png deprecated define png deprecated use of this function is deprecated endif ifndef png use result define png use result the result of this function must be checked endif ifndef png noreturn define png noreturn this function does not return endif ifndef png allocated define png allocated the result of the function is new memory endif ifndef png depstruct define png depstruct access to this struct member is deprecated endif ifndef png private define png private this is a private libpng function endif user may want to use these so they are not in png internal any library functions that are passed far data must be model independent ifndef png abort define png abort abort endif ifdef png setjmp supported define png jmpbuf  {
                                                                                                                                                                        }
png ptr png ptr jmpbuf else define png jmpbuf png ptr libpng was compiled with png setjmp not supported endif ifdef use far keyword memory model independent fns use this to make far to near assignments define check define nocheck define cvt ptr ptr png far to near png ptr ptr check define cvt ptr nocheck ptr png far to near png ptr ptr nocheck define png snprintf fsnprintf  {
	                                                            offprint :: 11
	                                                           offprints :: 12
                                                                   }
added to v define png strlen fstrlen  {
     }
define png memcmp fmemcmp  {
  }
sjt added define png memcpy fmemcpy  {
    }
define png memset fmemset  {
  }
else use the usual functions define cvt ptr ptr ptr define cvt ptr nocheck ptr ptr ifndef png no snprintf ifdef msc ver define png snprintf snprintf added to v define png snprintf snprintf define png snprintf snprintf else define png snprintf snprintf added to v define png snprintf snprintf define png snprintf snprintf endif else you don t have or don t want to use snprintf caution using sprintf  {
	                                                              forints :: 9
	                                                             sprinter :: 9
	                                                             sprinted :: 10
	                                                                sprit :: 9
	                                                               sprint :: 12
	                                                               spring :: 9
	                                                               sprent :: 9
	                                                               splint :: 9
	                                                             splinter :: 9
	                                                              sprints :: 10
                                                                    }
instead of snprintf exposes  {
	exposes :: -1000
  }
your application to accidental  {
	accidental :: -1000
  }
or malevolent  {
	malevolent :: -1000
 }
buffer overflows if you don t have snprintf as a general rule you should provide one you can get one from portable  {
	             portable :: -1000
                    }
openssh  {
	opens :: 9
 }
define png snprintf s n fmt x sprintf s fmt x define png snprintf s n fmt x x sprintf s fmt x x define png snprintf s n fmt x x x x x x sprintf s fmt x x x x x x endif define png strlen strlen define png memcmp memcmp sjt added define png memcpy memcpy define png memset memset endif end of memory model independent support just a little check that someone  {
	                                                                     someone :: -1000
                                                                           }
hasn t tried to define something contradictory  {
	contradictory :: -1000
     }
if png zbuf size l defined png max malloc k undef png zbuf size define png zbuf size l endif added at libpng endif png version info only endif pngconf h png h header file for png reference library libpng version july copyright c glenn randers pehrson version copyright c andreas dilger version copyright c guy eric schalnat group inc this code is released under the libpng license see license below authors and maintainers  {
	                                                              maintainers :: -1000
                                                                        }
libpng versions may through january guy schalnat libpng versions c june through may andreas dilger libpng versions january through july glenn see also contributing authors below note about libpng version numbers due to various miscommunications  {
	                 miscommunications :: -1000
                                 }
unforeseen  {
	unforeseen :: -1000
 }
code incompatibilities  {
	incompatibilities :: -1000
 }
and occasional  {
	occasional :: -1000
 }
factors outside the authors control version numbering on the library has not always been consistent and straightforward  {
	 straightforward :: -1000
               }
the following table summarizes  {
	summarizes :: -1000
  }
matters since version c which was the first widely used release source png h png h shared lib version string int version c beta beta should have been beta should have been beta should have been b beta should have been c a m should be from here on the should be png h string is a e identical  {
	                                                 identical :: -1000
                                                         }
to the from here on the shared library source version is v where v is the source code a b version except as noted a d a f patches  {
	                     patches :: -1000
                           }
a d e r not source compatible s v not binary compatible patches still binary incompatible d f still binary incompatible g h h testing xy z so numbering i i j j incompatible with beta dllnum  {
                                   }
beta binary compatible beta beta binary compatible rc rc binary compatible still compatible beta beta rc rc beta beta rc rc beta beta rc rc beta beta rc rc beta beta rc rc beta beta rc rc a f a f branch abandoned  {
	                                 abandoned :: -1000
                                         }
beta beta beta beta rc rc beta beta rc rc beta so beta beta so beta rc so rc rc so rc so so rc so rc so beta so beta rc so rc rc so rc so so beta so beta rc so rc rc so rc so so beta so beta so so beta so beta rc so rc rc so rc so so beta so beta rc so rc rc so rc so so beta so beta beta so rc so so beta so rc so so beta so rc so rc so so so so so beta so so so beta so rc so rc so so so beta so rc so rc so so so beta so rc so so so beta so rc so rc so so so so so beta so rc so rc so so so beta so rc so rc so so so beta so rc so so so beta so rc so rc so so so beta so rc so so beta so rc so so beta so rc so so so beta so rc so so so beta so rc so so so so so beta so rc so so so so beta so rc so rc so so so rc so rc so so so beta so rc so rc so so so beta so rc so rc so so so beta so rc so rc so so so beta so rc so rc so so so beta so rc so so so beta so rc so so so so beta so rc so so so beta so rc so so so beta so rc so so so beta so rc so rc so so so beta so rc so so so beta so rc so rc so so so beta so rc so so beta so rc so rc so so so rc so so so henceforth  {
	                                                                                                                                                                                                                                                                                                                     henceforth :: -1000
                                                                                                                                                                                                                                                                                                                              }
the source version will match the shared library major and minor numbers the shared library major version number will be used for changes in backward compatibility as it is intended the png libpng ver macro which is not used within libpng but is available for applications is an unsigned integer of the form xyyzz  {
                                                    }
corresponding to the source version x y z leading zeros  {
	    zeros :: -1000
        }
in y and z beta versions were given the previous public release number plus a letter until version j from then on they were given the upcoming public release number plus betann  {
	                        banteng :: 7
	                         bezant :: 7
	                        bethank :: 7
	                        betaine :: 7
	                         bejant :: 7
	                          betas :: 7
	                         batmen :: 7
	                         bannet :: 7
	                        bepaint :: 7
	                       butanone :: 8
	                      butanones :: 7
	                           beta :: 8
                              }
or rcnn  {
 }
binary incompatibility  {
	incompatibility :: -1000
 }
exists only when applications make direct access to the info ptr or png ptr members through png h and the compiled application is loaded with a different version of the library dllnum will change each time there are forward or backward changes in binary compatibility e g when a new feature is added see libpng txt or libpng for more information the png specification is available as a w c recommendation  {
	                                                        recommendation :: -1000
                                                                     }
and as an iso specification http www w org tr rec png copyright notice disclaimer and license if you modify libpng you may insert additional notices immediately following this sentence this code is released under the libpng license libpng versions august  {
	                                  behest :: -1000
                                       }
through july are copyright c glenn randers pehrson and are distributed according to the same disclaimer and license as libpng with the following individual added to the list of contributing authors cosmin  {
	                        cummins :: 7
	                       coamings :: 9
	                     comminutes :: 7
	                      combiners :: 7
	                     commingles :: 7
	                     comminates :: 7
	                          coins :: 7
	                      communise :: 7
	                      communist :: 7
	                        cousins :: 7
	                        souming :: 7
	                      criminous :: 7
	                       mockings :: 7
	                        cosying :: 8
	                        costing :: 8
	                         mosaic :: 7
	                        cosmist :: 7
	                        crimson :: 7
	                        coshing :: 8
	                        camions :: 7
	                        cortins :: 7
	                       combines :: 8
	                       combings :: 8
	                        copsing :: 7
	                        coppins :: 7
	                         tocsin :: 7
	                        cooming :: 7
	                        moshing :: 7
	                        coniums :: 7
	                        comping :: 7
	                        commits :: 7
	                        commies :: 7
	                        comings :: 7
	                         cousin :: 8
	                         cosmic :: 8
	                         cosing :: 7
	                         cosine :: 7
	                         cosign :: 8
	                        combing :: 7
	                         commis :: 8
	                        collins :: 7
	                        dormins :: 7
	                        coffins :: 7
	                        clonism :: 7
	                        codlins :: 7
	                        codeins :: 7
	                        coaming :: 8
	                       confirms :: 7
	                         socmen :: 7
	                         socman :: 7
                              }
truta  {
	prutah :: 6
	truthy :: 6
	truths :: 6
	truant :: 7
	truants :: 6
	tuart :: 6
	truth :: 7
	trust :: 6
	trats :: 6
	tauter :: 7
	trat :: 7
	tauts :: 6
	taut :: 7
	tart :: 6
	brutal :: 6
	pruta :: 7
 }
libpng versions july through october  {
	scooter :: 9
   }
are copyright c glenn randers pehrson and are distributed according to the same disclaimer and license as libpng with the following individuals added to the list of contributing authors simon pierre  {
	                    disposable :: -1000
                             }
cadieux  {
	cadeaux :: 9
	caudex :: 9
	cadies :: 9
 }
eric s raymond  {
	septennially :: -1000
 }
gilles  {
	siller :: 8
	gimels :: 7
	gilled :: 9
	gilets :: 7
	gibels :: 7
	sillers :: 7
	ingles :: 7
	bilges :: 7
	gilly :: 7
	gills :: 9
	fille :: 7
	millers :: 7
	millets :: 7
	gallizes :: 7
	gallised :: 8
	galleins :: 8
	jillets :: 7
	gimlets :: 7
	gullies :: 8
	gulleys :: 7
	gullets :: 7
	gillies :: 8
	willeys :: 7
	gillers :: 10
	willers :: 7
	willets :: 7
	tillers :: 7
	rilles :: 9
	filles :: 9
	milles :: 9
	killers :: 7
	giblets :: 7
	hillers :: 7
	gallise :: 9
	gallies :: 8
	galleys :: 7
	gallets :: 7
	gallein :: 7
	gillnets :: 8
	millages :: 7
	tillages :: 7
	villages :: 7
	guiles :: 8
	selling :: 7
	billers :: 7
	billets :: 7
	gollies :: 8
	sill :: 7
	lingels :: 7
	gill :: 8
	rille :: 7
	lisles :: 8
	lieges :: 7
	glimes :: 7
	glides :: 7
	mille :: 7
	villose :: 7
	fillers :: 7
	fillets :: 7
	lisle :: 8
 }
vollant  {
	pollan :: 9
	villan :: 9
 }
and with the following additions to the disclaimer there is no warranty against interference  {
	 interference :: -1000
            }
with your enjoyment  {
	enjoyment :: -1000
 }
of the library or against infringement there is no warranty that our efforts  {
	     efforts :: -1000
           }
or the library will fulfill any of your particular purposes or needs this library is provided with all faults and the entire risk of satisfactory  {
	            satisfactory :: -1000
                       }
quality performance accuracy  {
	accuracy :: -1000
 }
and effort is with the user libpng versions january through march  {
	     march :: -1000
         }
are copyright c glenn randers pehrson and are distributed according to the same disclaimer and license as libpng with the following individuals added to the list of contributing authors tom lane glenn randers pehrson willem  {
	                             fille :: 7
	                           millers :: 7
	                           millets :: 7
	                           willeys :: 8
	                           willers :: 8
	                           willets :: 8
	                            willey :: 9
	                            willet :: 9
	                            willer :: 9
	                            willed :: 9
	                            wellie :: 7
	                            millet :: 8
	                            milles :: 8
	                            miller :: 8
	                            milled :: 8
	                            wallie :: 7
	                             willy :: 7
	                             wills :: 7
	                            mallei :: 7
	                         willemite :: 7
	                              will :: 8
	                              well :: 7
	                              mill :: 7
	                             rille :: 7
	                             mille :: 9
                                 }
van schaik  {
	schtik :: 9
	schrik :: 9
	scraigh :: 7
	chiacks :: 7
	schtiks :: 7
	schriks :: 7
	hijacks :: 7
	schav :: 7
 }
libpng versions june through may are copyright c andreas dilger distributed according to the same disclaimer and license as libpng with the following individuals added to the list of contributing authors john bowler  {
	                          bowler :: -1000
                               }
kevin  {
	levin :: 7
	knive :: 6
	kevil :: 7
	keying :: 6
	kevils :: 6
	kelvin :: 6
	venin :: 6
	nevi :: 7
	pekin :: 6
 }
bracey  {
	grace :: 7
	scarey :: 7
	beachy :: 8
	braze :: 7
	brave :: 7
	brame :: 7
	brake :: 7
	bract :: 7
	brack :: 7
	brach :: 7
	brace :: 10
	bravely :: 7
	barye :: 7
	bracken :: 7
	bracket :: 7
	brachet :: 7
	bracers :: 7
	bracero :: 7
	brachydome :: 7
	barney :: 7
	barley :: 7
	crabby :: 7
	trace :: 7
	bray :: 7
	brae :: 7
	bready :: 7
	brayer :: 7
	braces :: 9
	bracer :: 8
 }
sam bushell  {
	bushelling :: 11
	subcell :: 9
	unshell :: 10
	bushels :: 9
	burhels :: 9
	bushveld :: 9
	bushelled :: 11
	busher :: 9
	bushel :: 11
	bushed :: 9
 }
magnus  {
	musang :: 7
	magnesic :: 7
	magnesium :: 7
	magnums :: 9
	magnets :: 7
	maungy :: 7
	maunds :: 8
	manuls :: 7
	mangos :: 7
	manges :: 7
	mancus :: 8
	magnum :: 8
	magnes :: 9
	maun :: 7
	mags :: 7
	sagum :: 7
	manus :: 7
	mangs :: 7
	magus :: 8
 }
holmgren  {
 }
greg  {
	gurge :: 5
	grego :: 7
	gregos :: 6
	grog :: 5
	grig :: 5
	gleg :: 5
	areg :: 5
 }
roelofs  {
	reflows :: 9
	foetors :: 9
 }
tom tanner  {
	tanner :: -1000
 }
libpng versions may through january are copyright c guy eric schalnat group inc for the purposes of this copyright and license contributing authors is defined as the following set of individuals andreas dilger dave  {
	                            laved :: 6
	                            eaved :: 6
	                            daven :: 7
	                            caved :: 6
	                            advew :: 5
	                           davies :: 5
	                           davens :: 6
	                            waved :: 6
	                            vaned :: 5
	                             wave :: 5
	                             vade :: 6
	                             save :: 5
	                             rave :: 5
	                             pave :: 5
	                             nave :: 5
	                             lave :: 5
	                             have :: 5
	                             gave :: 5
	                             fave :: 5
	                             eave :: 5
	                             dove :: 5
	                             dive :: 5
	                            saved :: 6
	                             deva :: 6
	                             davy :: 5
	                             date :: 5
	                             dare :: 5
	                             dame :: 5
	                             dale :: 5
	                             dace :: 5
	                             cave :: 5
	                            raved :: 6
	                            paved :: 6
	                              dev :: 5
	                              dae :: 5
                                }
martindale  {
	marginated :: 13
	martian :: 12
	martial :: 12
	martingale :: 17
	marginate :: 12
	marinated :: 12
	marinade :: 12
 }
guy eric schalnat paul  {
	paul :: -1000
  }
schmidt  {
 }
tim wegner the png reference library is supplied as is the contributing authors and group inc disclaim all warranties expressed or implied including without limitation the warranties of merchantability and of fitness for any purpose the contributing authors and group inc assume no liability for direct indirect incidental special exemplary or consequential damages which may result from the use of the png reference library even if advised of the possibility of such damage permission is hereby granted to use copy modify and distribute this source code or portions hereof for any purpose without fee subject to the following restrictions the origin of this source code must not be misrepresented altered versions must be plainly marked as such and must not be misrepresented as being the original source this copyright notice may not be removed or altered from any source or altered source distribution the contributing authors and group inc specifically permit without fee and encourage the use of this source code as a component to supporting the png file format in commercial products if you use this source code in a product acknowledgment is not required but would be appreciated a png get copyright function is available for convenient use in about boxes  {
	                                                                                                                                                                                                     boxes :: -1000
                                                                                                                                                                                                         }
and the like printf s png get copyright null also the png logo in png format of course is supplied in the files pngbar  {
	                probang :: 8
	               probangs :: 7
                      }
png and pngbar jpg x and pngnow  {
	ungrown :: 7
	ingrown :: 7
     }
png x libpng is osi  {
	osiery :: 3
	soil :: 3
	pois :: 3
	oils :: 3
	obis :: 4
	psion :: 3
	oxims :: 3
	oxids :: 3
	ovist :: 3
	ostia :: 3
	osmic :: 3
	osier :: 4
	omits :: 3
	ohias :: 3
	odist :: 3
	odism :: 3
	obits :: 3
	obias :: 3
	 psi :: 3
	 ose :: 3
	 oli :: 3
	 ois :: 4
	 obi :: 3
	 ios :: 3
	  os :: 4
	  oi :: 3
	  is :: 3
   }
certified  {
	certified :: -1000
 }
open source software osi certified is a certification  {
	certification :: -1000
      }
mark of the open source initiative  {
	initiative :: -1000
    }
the contributing authors would like to thank all those who helped  {
	    helped :: -1000
         }
with testing bug fixes and patience  {
	patience :: -1000
    }
this wouldn t have been possible without all of you thanks to frank j t wojcik  {
              }
for helping with the documentation y k compliance in libpng july since the png development group is an ad hoc  {
	                hoc :: -1000
                  }
body  {
	body :: -1000
 }
we can t make an official declaration this is your unofficial assurance  {
	  assurance :: -1000
          }
that libpng from version and upward through are y k compliant it is my belief  {
	        belief :: -1000
             }
that earlier versions were also y k compliant libpng only has three year fields one is a byte unsigned integer that will hold years  {
	                  years :: -1000
                      }
up to the other two hold the date in text format and will hold years up to the integer is png uint year in png time struct the strings are png charp time buffer in png struct and near time buffer which is a local character string in png c there are seven time related functions png c png convert to rfc in png c formerly  {
	                                                         formerly :: -1000
                                                                }
png convert to rfc in error png convert from struct tm in pngwrite  {
	  prewriting :: 10
           }
c called in pngwrite c png convert from time t in pngwrite c png get time in pngget c png handle time in pngrutil  {
	                 pignut :: 10
                      }
c called in pngread  {
	pranged :: 9
  }
c png set time in pngset  {
	signet :: 7
	posseting :: 7
	posnet :: 7
	piglets :: 7
	pigments :: 7
	 pegs :: 7
	 engs :: 7
    }
c png write time in pngwutil  {
	pignut :: 10
    }
c called in pngwrite c all handle dates  {
	  dates :: -1000
      }
properly in a y k environment the png convert from time t function calls gmtime  {
	      grimmest :: 7
             }
to convert from system clock  {
	clock :: -1000
   }
time which returns year which we properly convert to the full digit year there is a possibility that applications using libpng are not passing digit years into the png convert to rfc function or that they are incorrectly  {
	                          incorrectly :: -1000
                                    }
passing only a digit year instead of year into the png convert from struct tm function but this is not under our control the libpng documentation has always stated  {
	                      stated :: -1000
                           }
that it works with digit years and the apis  {
	   apsis :: 5
	   apism :: 7
	   apish :: 7
	   aphis :: 5
	  apices :: 5
	 apishly :: 5
	   spina :: 5
	   spica :: 5
	   spial :: 5
	    pias :: 5
	    pais :: 6
	    axis :: 5
	    apes :: 5
	    anis :: 5
	   paisa :: 5
       }
have been documented as such the time chunk itself is also y k compliant it uses a byte unsigned integer to hold the year and can hold years as large as zlib upon which libpng depends is also y k compliant it contains no date related code glenn randers pehrson libpng maintainer png development group ifndef png h define png h this is not the place to learn  {
	                                                              learn :: -1000
                                                                  }
how to use libpng the file libpng txt describes how to use libpng and the file example c summarizes it with some code on which to build this file is useful for looking at the actual function definitions and structure components version information for png h this should match the version in png c define png libpng ver string define png header version string libpng version july n define png libpng ver sonum  {
	                                                                   conus :: 6
	                                                                   bonus :: 6
	                                                                 columns :: 6
	                                                                   tonus :: 6
	                                                                    soum :: 6
	                                                                   solum :: 7
	                                                                    mons :: 6
	                                                                   novum :: 6
	                                                                   notum :: 6
	                                                                     son :: 6
                                                                       }
define png libpng ver dllnum these should match the first components of png libpng ver string define png libpng ver major define png libpng ver minor define png libpng ver release this should match the numeric part of the final component of png libpng ver string omitting  {
	                                      omitting :: -1000
                                             }
any leading zero define png libpng ver build release status define png libpng build alpha define png libpng build beta define png libpng build rc define png libpng build stable define png libpng build release status mask release specific flags define png libpng build patch can be or ed with png libpng build stable only define png libpng build private cannot be or ed with png libpng build special define png libpng build special cannot be or ed with png libpng build private define png libpng build base type png libpng build stable careful  {
	                                                                                      careful :: -1000
                                                                                            }
here at one time guy wanted to use but that would be octal we must not include leading zeros versions through were in the range to here only version was mis numbered instead of from version it s xxyyzz  {
                                     }
where x major y minor z release define png libpng ver ifndef png version info only include the compression library s header include zlib h endif include all user configurable info including optional assembler routines include pngconf h added at libpng ref msdn  {
                                         }
private as priority over special vs ff privatebuild file was not built using standard release procedures if this value is given the stringfileinfo  {
                     }
block must contain a privatebuild string vs ff specialbuild file was built by the original company using standard release procedures but is a variation  {
	              variation :: -1000
                      }
of the standard file of the same version number if this value is given the stringfileinfo block must contain a specialbuild string ifdef png user privatebuild define png libpng build type png libpng build base type png libpng build private else ifdef png libpng specialbuild define png libpng build type png libpng build base type png libpng build special else define png libpng build type png libpng build base type endif endif ifndef png version info only inhibit c name mangling  {
	                                                                        mangling :: -1000
                                                                               }
for libpng functions but not for system calls ifdef cplusplus extern c endif cplusplus this file is arranged  {
	         calidity :: -1000
                }
in several sections the first section contains structure and type definitions the second section contains the external library functions while the third has the internal library functions which applications aren t expected to use directly ifndef png no typecast null define int p null int null define png bytep null png bytep null define png bytepp null png bytepp null define png doublep null png doublep null define png error ptr null png error ptr null define png flush ptr null png flush ptr null define png free ptr null png free ptr null define png infopp  {
	                                                                                           ippon :: 7
	                                                                                           infos :: 7
	                                                                                            info :: 8
                                                                                               }
null png infopp null define png malloc ptr null png malloc ptr null define png read status ptr null png read status ptr null define png rw ptr null png rw ptr null define png structp  {
	                             strunt :: 9
	                             strict :: 9
	                              strut :: 9
                                  }
null png structp null define png uint p null png uint p null define png voidp null png voidp null define png write status ptr null png write status ptr null else define int p null null define png bytep null null define png bytepp null null define png doublep null null define png error ptr null null define png flush ptr null null define png free ptr null null define png infopp null null define png malloc ptr null null define png read status ptr null null define png rw ptr null null define png structp null null define png uint p null null define png voidp null null define png write status ptr null null endif variables declared in png c only it needs to define png no extern if defined png no extern defined png always extern version information for c files stored in png c this had better match the version above ifdef png use global arrays png export var png const char png libpng ver need room for beta z else define png libpng ver png get header ver null endif ifdef png use global arrays this was removed in version c structures to facilitate easy interlacing see png c for more details png export var png const int fardata png pass start png export var png const int fardata png pass inc png export var png const int fardata png pass ystart  {
	                                                                                                                                                                                                                                   shorewards :: -1000
                                                                                                                                                                                                                                            }
png export var png const int fardata png pass yinc  {
	   zincky :: 5
	   wincey :: 5
	    zincy :: 6
	    yonic :: 5
	    yince :: 7
	     zinc :: 5
	     yins :: 5
	    mincy :: 6
	      yin :: 6
        }
png export var png const int fardata png pass mask png export var png const int fardata png pass dsp mask this isn t currently used if you need it see png c for more details png export var png const int fardata png pass height endif endif png no extern three color definitions the order of the red green and blue and the exact size is not important although the size of the fields need to be png byte or png uint as defined below typedef struct png color struct png byte red png byte green png byte blue png color typedef png color far png colorp  {
	                                                                                                      dolor :: 7
	                                                                                                      color :: 10
	                                                                                                      colon :: 7
	                                                                                                      colog :: 7
	                                                                                                      cloop :: 7
	                                                                                                   colorize :: 7
	                                                                                                   colorism :: 7
	                                                                                                   colorist :: 7
	                                                                                                   colorman :: 7
	                                                                                                   colormen :: 7
	                                                                                                   coloreds :: 7
	                                                                                                   coloring :: 7
	                                                                                                   colorant :: 7
	                                                                                                    coloury :: 7
	                                                                                                    colours :: 7
	                                                                                                    colored :: 8
	                                                                                                    colorer :: 7
	                                                                                                     colour :: 8
	                                                                                                     colory :: 9
	                                                                                                     colors :: 9
	                                                                                                     collop :: 7
	                                                                                                       polo :: 7
	                                                                                                      orlop :: 7
                                                                                                          }
typedef png color far far png colorpp  {
	 color :: 10
	colory :: 9
	colors :: 9
     }
typedef struct png color struct png byte index used for palette files png uint red for use in red green blue files png uint green png uint blue png uint gray for use in grayscale files png color typedef png color far png color p typedef png color far far png color pp typedef struct png color struct png byte red for use in red green blue files png byte green png byte blue png byte gray for use in grayscale files png byte alpha for alpha channel files png color typedef png color far png color p typedef png color far far png color pp the following two structures are used for the in core representation of splt chunks typedef struct png splt entry struct png uint red png uint green png uint blue png uint alpha png uint frequency png splt entry typedef png splt entry far png splt entryp  {
	                                                                                                                                                entropy :: 10
	                                                                                                                                                entraps :: 8
	                                                                                                                                               entryism :: 7
	                                                                                                                                                 entrap :: 9
	                                                                                                                                               entropic :: 7
	                                                                                                                                                encrypt :: 10
	                                                                                                                                              encrypted :: 7
                                                                                                                                                      }
typedef png splt entry far far png splt entrypp  {
	 entropy :: 9
	 encrypt :: 9
       }
when the depth of the splt palette is bits the color and alpha samples occupy  {
	        occupy :: -1000
             }
the lsb of their respective members and the msb of each member is zero filled the frequency member always occupies the full bits typedef struct png splt struct png charp name palette name png byte depth depth of palette samples png splt entryp entries palette entries png int nentries number of palette entries png splt t typedef png splt t far png splt tp typedef png splt t far far png splt tpp  {
	                                                                    typp :: 3
	                                                                     twp :: 3
	                                                                     tup :: 3
	                                                                     top :: 3
	                                                                     tip :: 3
	                                                                     tap :: 3
                                                                       }
ifdef png text supported png text holds the contents of a text ztxt itxt chunk in a png file and whether that contents is compressed or not the key field points to a regular zero terminated c string the text lang and lang key fields can be regular c strings empty strings or null pointers however the structure returned by png get text will always contain regular zero terminated c strings possibly empty never null pointers so they can be safely used in printf and other string handling functions typedef struct png text struct int compression compression value text none ztxt deflate itxt none itxt deflate png charp key keyword character description of text png charp text comment may be an empty string ie or a null pointer png size t text length length of the text string ifdef png itxt supported png size t itxt length length of the itxt string png charp lang language code characters or a null pointer png charp lang key keyword translated utf string or more chars or a null pointer endif png text typedef png text far png textp  {
	                                                                                                                                                                                    texts :: 7
	                                                                                                                                                                                     text :: 8
                                                                                                                                                                                        }
typedef png text far far png textpp  {
	 texts :: 7
	  text :: 8
     }
endif supported compression types for text in png files text and ztxt the values of the png text compression defines should not be changed define png text compression none wr define png text compression ztxt wr define png text compression none define png text compression ztxt define png itxt compression none define png itxt compression ztxt define png text compression last not a valid value png time is a way to hold the time in an machine independent way two conversions are provided both from time t and struct tm there is no portable way to convert to either of these structures as far as i know if you know of a portable way send it to me as a side note png has always been year compliant typedef struct png time struct png uint year full year as in png byte month month of year png byte day day of month png byte hour hour of day png byte minute minute of hour png byte second second of minute for leap  {
	                                                                                                                                                                       leap :: -1000
                                                                                                                                                                          }
seconds png time typedef png time far png timep  {
	 pimento :: 6
	  timers :: 6
	  timely :: 6
	   timps :: 6
	   times :: 7
	   timer :: 7
	   timed :: 7
	   tempi :: 7
	    time :: 8
	    temp :: 6
	    mite :: 6
	  limpet :: 6
       }
typedef png time far far png timepp  {
	 times :: 7
	 timer :: 7
	 timed :: 7
	 tempi :: 7
	  time :: 8
	 pipet :: 7
     }
if defined png unknown chunks supported defined png handle as unknown supported png unknown chunk is a structure to hold queued  {
	              refeed :: -1000
                   }
chunks for which there is no specific support the idea is that we can use this to queue up private chunks for output even though the library doesn t actually know about their semantics define png chunk name length typedef struct png unknown chunk t png byte name png chunk name length png byte data png size t size libpng using applications should not directly modify this byte png byte location mode of operation at read time png unknown chunk typedef png unknown chunk far png unknown chunkp typedef png unknown chunk far far png unknown chunkpp  {
	                                                                                           chunk :: 10
	                                                                                          chunky :: 9
	                                                                                          chunks :: 9
                                                                                               }
endif png info is a structure that holds the information in a png file so that the application can find out the characteristics of the image if you are reading the file this structure will tell you what is in the png file if you are writing the file fill in the information you want to put into the png file then call png write info the names chosen should be very close to the png specification so consult  {
	                                                                       consult :: -1000
                                                                             }
that document for information about the meaning of each field with libpng it was only possible to directly set and read the the values in the png info struct which meant that the contents and order of the values had to remain fixed with libpng and later however there are now functions that abstract the contents of png info struct from the application so this makes it easier to use libpng with dynamic libraries and even makes it possible to use libraries that don t have all of the libpng ancillary chunk handing  {
	                                                                                     handing :: -1000
                                                                                           }
functionality in any case the order of the parameters in png info struct should not be changed for as long as possible to keep compatibility with applications that use the old direct access method with png info struct the following members may have allocated storage attached  {
	                                     attached :: -1000
                                            }
that should be cleaned  {
	conspiracies :: -1000
  }
up before the structure is discarded palette trans text pcal purpose pcal units pcal params hist iccp name iccp profile splt palettes  {
	             palettes :: -1000
                    }
scal unit row pointers and unknowns  {
	unknowns :: -1000
    }
by default these are automatically freed when the info structure is deallocated if they were allocated internally by libpng this behavior can be changed by means of the png data freer function more allocation details all the chunk reading functions that change these members go through the corresponding png set functions a function to clear these members is available see png free data the png set functions do not depend on being able to point info structure members to any of the storage they are passed they make their own copies except that the png set text functions use the same storage passed to them in the text ptr or itxt ptr structure argument and the png set rows and png set unknowns functions do not make their own copies typedef struct png info struct the following are necessary for every png file png uint width png depstruct width of image in pixels from ihdr png uint height png depstruct height of image in pixels from ihdr png uint valid png depstruct valid chunk data see png info below png uint rowbytes  {
                                                                                                                                                                                    }
png depstruct bytes needed to hold an untransformed  {
	untransformed :: -1000
      }
row png colorp palette png depstruct array of color values valid png info plte png uint num palette png depstruct number of color entries in palette plte png uint num trans png depstruct number of transparent palette color trns png byte bit depth png depstruct or bits channel from ihdr png byte color type png depstruct see png color type below from ihdr the following three should have been named method not type png byte compression type png depstruct must be png compression type base ihdr png byte filter type png depstruct must be png filter type base from ihdr png byte interlace type png depstruct one of png interlace none png interlace adam the following is informational only on read and not used on writes png byte channels png depstruct number of data channels per pixel png byte pixel depth png depstruct number of bits per pixel png byte spare  {
	                                                                                                                                                 spare :: -1000
                                                                                                                                                     }
byte png depstruct to align the data and for future use png byte signature png depstruct magic bytes read by libpng from start of file the rest of the data is optional if you are reading check the valid field to see if the information in these are valid if you are writing set the valid field to those chunks you want written and initialize the appropriate fields below if defined png gama supported defined png floating point supported the gama chunk describes the gamma characteristics of the system on which the image was created normally in the range data is valid if valid png info gama is non zero float gamma png depstruct gamma value of image if valid png info gama endif ifdef png srgb supported gr p a data valid if valid png info srgb non zero png byte srgb intent png depstruct srgb rendering intent or endif ifdef png text supported the text and ztxt chunks contain human  {
	                                                                                                                                                            human :: -1000
                                                                                                                                                                }
readable textual data in uncompressed compressed and optionally compressed forms respectively the data in text is an array of pointers to uncompressed null terminated c strings each chunk has a keyword that describes the textual data contained in that chunk keywords are not required to be unique and the text string may be empty any number of text chunks may be in an image int num text png depstruct number of comments read to write int max text png depstruct current size of text array png textp text png depstruct array of comments read to write endif png text supported ifdef png time supported the time chunk holds the last time the displayed image data was modified see the png time struct for the contents of this struct png time mod time png depstruct endif ifdef png sbit supported the sbit chunk specifies the number of significant high order bits in the pixel data values are in the range bit depth and are only specified for the channels in the pixel data the contents of the low order bits is not specified data is valid if valid png info sbit is non zero png color sig bit png depstruct significant bits in color channels endif if defined png trns supported defined png read expand supported defined png read background supported the trns chunk supplies transparency data for paletted  {
	                                                                                                                                                                                                                           patented :: 12
	                                                                                                                                                                                                                           facetted :: 10
	                                                                                                                                                                                                                            pileate :: 10
	                                                                                                                                                                                                                           splatted :: 11
	                                                                                                                                                                                                                           palleted :: 11
	                                                                                                                                                                                                                           palettes :: 13
	                                                                                                                                                                                                                           galettes :: 10
	                                                                                                                                                                                                                           talented :: 12
	                                                                                                                                                                                                                           tableted :: 10
	                                                                                                                                                                                                                           unletted :: 10
	                                                                                                                                                                                                                           lappeted :: 10
	                                                                                                                                                                                                                            ailette :: 10
	                                                                                                                                                                                                                            palette :: 14
	                                                                                                                                                                                                                           gazetted :: 10
	                                                                                                                                                                                                                           pattered :: 10
	                                                                                                                                                                                                                           pattened :: 10
	                                                                                                                                                                                                                            galette :: 11
	                                                                                                                                                                                                                            peltate :: 11
	                                                                                                                                                                                                                           parented :: 10
	                                                                                                                                                                                                                           pileated :: 12
	                                                                                                                                                                                                                            layette :: 10
	                                                                                                                                                                                                                           paltered :: 11
                                                                                                                                                                                                                                  }
images and other image types that don t need a full alpha channel there are num trans transparency values for a paletted image stored in the same order as the palette colors starting from index values for the data are in the range ranging  {
	                                    ranging :: -1000
                                          }
from fully transparent to fully opaque respectively for non paletted images there is a single color specified that should be treated as fully transparent data is valid if valid png info trns is non zero png bytep trans png depstruct transparent values for paletted image png color trans values png depstruct transparent color for non palette image endif if defined png bkgd supported defined png read background supported the bkgd chunk gives the suggested  {
	                                                                suggested :: -1000
                                                                        }
image background color if the display program does not have its own background color and the image is needs to composited onto a background before display the colors in background are normally in the same color space depth as the pixel data data is valid if valid png info bkgd is non zero png color background png depstruct endif ifdef png offs supported the offs chunk gives the offset in offset unit type units rightwards  {
	                                                                rightwards :: -1000
                                                                         }
and downwards  {
	downwards :: -1000
 }
from the top left corner  {
	corner :: -1000
   }
of the display page or other application specific co ordinate  {
	 patinate :: -1000
        }
space see the png offset defines below for the unit types valid if valid png info offs non zero png int x offset png depstruct x offset on page png int y offset png depstruct y offset on page png byte offset unit type png depstruct offset units type endif ifdef png phys supported the phys chunk gives the physical pixel density of the image for display or printing in phys unit type units see png resolution defines below data is valid if valid png info phys is non zero png uint x pixels per unit png depstruct horizontal pixel density png uint y pixels per unit png depstruct vertical pixel density png byte phys unit type png depstruct resolution type see png resolution below endif ifdef png hist supported the hist chunk contains the relative frequency or importance  {
	                                                                                                                                importance :: -1000
                                                                                                                                         }
of the various palette entries so that a viewer  {
	  viewer :: -1000
       }
can intelligently  {
	intelligently :: -1000
 }
select a reduced  {
	reduced :: -1000
 }
color palette if required data is an array of num palette values in the range data valid if valid png info hist is non zero png uint p hist png depstruct endif ifdef png chrm supported the chrm chunk describes the cie color characteristics of the monitor on which the png was created this data allows the viewer to do gamut mapping of the input image to ensure that the viewer sees  {
	                                                                   sees :: -1000
                                                                      }
the same colors in the image as the creator values are in the range data valid if valid png info chrm non zero ifdef png floating point supported float x white png depstruct float y white png depstruct float x red png depstruct float y red png depstruct float x green png depstruct float y green png depstruct float x blue png depstruct float y blue png depstruct endif endif ifdef png pcal supported the pcal chunk describes a transformation between the stored pixel values and original physical data values used to create the image the integer range bit depth maps to the floating point range given by pcal x pcal x and are further transformed  {
	                                                                                                        transformed :: -1000
                                                                                                                  }
by a possibly non linear transformation function given by pcal type and pcal params into pcal units please see the png equation  {
	             equation :: -1000
                    }
defines below and the png group s png extensions document for a complete description of the transformations and how they should be implemented and for a description of the ascii parameter strings data values are valid if valid png info pcal non zero png charp pcal purpose png depstruct pcal chunk description string png int pcal x png depstruct minimum value png int pcal x png depstruct maximum value png charp pcal units png depstruct latin  {
	                                                                      lawin :: 7
	                                                                      lathi :: 6
	                                                                      laten :: 7
	                                                                      lapin :: 7
	                                                                      lakin :: 7
	                                                                     eating :: 6
	                                                                     lazing :: 6
	                                                                     laying :: 6
	                                                                     lawins :: 6
	                                                                     lawing :: 6
	                                                                     lawine :: 6
	                                                                     laving :: 6
	                                                                     lattin :: 6
	                                                                     latish :: 6
	                                                                     latino :: 9
	                                                                     latigo :: 6
	                                                                     latens :: 6
	                                                                     lasing :: 6
	                                                                     larine :: 6
	                                                                     lapins :: 6
	                                                                     laming :: 6
	                                                                     laking :: 6
	                                                                     ladino :: 6
	                                                                     lading :: 6
	                                                                     lacing :: 6
	                                                                     plaint :: 6
	                                                                    retinal :: 6
	                                                                     satiny :: 6
	                                                                     satins :: 6
	                                                                     sating :: 6
	                                                                     gating :: 6
	                                                                      actin :: 6
	                                                                    matinal :: 6
	                                                                     bating :: 6
	                                                                     patins :: 6
	                                                                     patine :: 6
	                                                                     dating :: 6
	                                                                     ratlin :: 6
	                                                                     rating :: 6
	                                                                     ratine :: 6
	                                                                     fating :: 6
	                                                                     matins :: 6
	                                                                     mating :: 6
	                                                                    actinal :: 6
	                                                                      tatin :: 7
	                                                                       tali :: 6
	                                                                      takin :: 6
	                                                                     talion :: 6
	                                                                     hating :: 6
	                                                                       lati :: 8
	                                                                       lant :: 6
	                                                                       lain :: 6
	                                                                      satin :: 7
	                                                                       anti :: 6
	                                                                     catlin :: 6
	                                                                   latinize :: 6
	                                                                      patin :: 7
	                                                                     litany :: 7
	                                                                     libant :: 6
	                                                                    latrine :: 6
	                                                                      matin :: 7
	                                                                        lat :: 6
	                                                                    latinos :: 8
	                                                                    lathing :: 6
                                                                          }
string giving physical units png charpp pcal params png depstruct ascii strings containing parameter values png byte pcal type png depstruct equation type see png equation below png byte pcal nparams  {
                             }
png depstruct number of parameters given in pcal params endif new members added in libpng ifdef png free me supported png uint free me png depstruct flags items libpng is responsible for freeing endif if defined png unknown chunks supported defined png handle as unknown supported storage for unknown chunks that the library doesn t recognize png unknown chunkp unknown chunks png depstruct png size t unknown chunks num png depstruct endif ifdef png iccp supported iccp chunk data png charp iccp name png depstruct profile name png charp iccp profile png depstruct international color consortium profile data note to maintainer should be png bytep png uint iccp proflen  {
	                                                                                                 muttonchops :: -1000
                                                                                                           }
png depstruct icc profile data length png byte iccp compression png depstruct always zero endif ifdef png splt supported data on splt chunks there may be more than one png splt tp splt palettes png depstruct png uint splt palettes num png depstruct endif ifdef png scal supported the scal chunk describes the actual physical dimensions of the subject matter of the graphic the chunk contains a unit specification a byte value and two ascii strings representing floating point values the values are width and height corresponsing  {
	                                                                         corresponding :: 22
	                                                                      correspondencies :: 16
	                                                                         corresponsive :: 18
	                                                                       correspondingly :: 20
	                                                                           corresponds :: 17
	                                                                         processioning :: 16
	                                                                        correspondents :: 17
                                                                                     }
to one pixel in the image this external representation is converted to double here data values are valid if valid png info scal is non zero png byte scal unit png depstruct unit of physical scale ifdef png floating point supported double scal pixel width png depstruct width of one pixel double scal pixel height png depstruct height of one pixel endif ifdef png fixed point supported png charp scal s width png depstruct string containing height png charp scal s height png depstruct string containing width endif endif ifdef png info image supported memory has been allocated if valid png allocated info rows non zero data valid if valid png info idat non zero png bytepp row pointers png depstruct the image bits endif if defined png fixed point supported defined png gama supported png fixed point int gamma png depstruct gamma of image if valid png info gama endif if defined png chrm supported defined png fixed point supported png fixed point int x white png depstruct png fixed point int y white png depstruct png fixed point int x red png depstruct png fixed point int y red png depstruct png fixed point int x green png depstruct png fixed point int y green png depstruct png fixed point int x blue png depstruct png fixed point int y blue png depstruct endif png info typedef png info far png infop typedef png info far far png infopp maximum positive integer used in png is define png uint max png uint x fffffffl define png uint max png uint define png size max png size t if defined png x defined png x png max uint is deprecated use png uint max instead define png max uint png uint max endif these describe the color type field in png info color type masks define png color mask palette define png color mask color define png color mask alpha color types note that not all combinations are legal define png color type gray define png color type palette png color mask color png color mask palette define png color type rgb png color mask color define png color type rgb alpha png color mask color png color mask alpha define png color type gray alpha png color mask alpha aliases define png color type rgba png color type rgb alpha define png color type ga png color type gray alpha this is for compression type png only define the single type define png compression type base deflate method k window define png compression type default png compression type base this is for filter type png only define the single type define png filter type base single row per byte filtering  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                          filtering :: -1000
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  }
define png intrapixel  {
	intrepidly :: 12
	intrepid :: 12
 }
differencing  {
	tribulations :: -1000
 }
used only in mng datastreams define png filter type default png filter type base these are for the interlacing type these values should not be changed define png interlace none non interlaced image define png interlace adam adam interlacing define png interlace last not a valid value these are for the offs chunk these values should not be changed define png offset pixel offset in pixels define png offset micrometer  {
	                                                           micrometer :: -1000
                                                                    }
offset in micrometers  {
	micrometers :: -1000
 }
meter define png offset last not a valid value these are for the pcal chunk these values should not be changed define png equation linear linear transformation define png equation base e exponential  {
	                     exponential :: -1000
                               }
base e transform define png equation arbitrary arbitrary base exponential transform define png equation hyperbolic  {
	    hyperbolic :: -1000
             }
hyperbolic sine  {
	sine :: -1000
 }
transformation define png equation last not a valid value these are for the scal chunk these values should not be changed define png scale unknown unknown unit image scale define png scale meter meters  {
	                           meters :: -1000
                                }
per pixel define png scale radian  {
	radian :: -1000
    }
radians  {
	radians :: -1000
 }
per pixel define png scale last not a valid value these are for the phys chunk these values should not be changed define png resolution unknown pixels unknown unit aspect ratio define png resolution meter pixels meter define png resolution last not a valid value these are for the srgb chunk these values should not be changed define png srgb intent perceptual define png srgb intent relative define png srgb intent saturation define png srgb intent absolute define png srgb intent last not a valid value this is for text chunks define png keyword max length maximum number of entries in plte splt trns arrays define png max palette length these determine if an ancillary chunk s data has been successfully read from the png header or if the application has filled in the corresponding data in the info struct to be written into the output file the values of the png info chunk defines should not be changed define png info gama x define png info sbit x define png info chrm x define png info plte x define png info trns x define png info bkgd x define png info hist x define png info phys x define png info offs x define png info time x define png info pcal x define png info srgb x gr p a define png info iccp x esr define png info splt x esr define png info scal x esr define png info idat x l esr this is used for the transformation routines as some of them change these values for the row it also should enable using the routines for other purposes typedef struct png row info struct png uint width width of row png uint rowbytes number of bytes in row png byte color type color type of row png byte bit depth bit depth of row png byte channels number of channels or png byte pixel depth bits per pixel depth channels png row info typedef png row info far png row infop typedef png row info far far png row infopp these are the function types for the i o functions and for the functions that allow the user to override the default i o functions with his or her own the png error ptr type should match that of user supplied warning and error functions while the png rw ptr type should match that of the user read write data functions typedef struct png struct def png struct typedef png struct far png structp typedef void pngapi png error ptr pngarg png structp png const charp typedef void pngapi png rw ptr pngarg png structp png bytep png size t typedef void pngapi png flush ptr pngarg png structp typedef void pngapi png read status ptr pngarg png structp png uint int typedef void pngapi png write status ptr pngarg png structp png uint int ifdef png progressive read supported typedef void pngapi png progressive info ptr pngarg png structp png infop typedef void pngapi png progressive end ptr pngarg png structp png infop typedef void pngapi png progressive row ptr pngarg png structp png bytep png uint int endif if defined png read user transform supported defined png write user transform supported defined png legacy supported typedef void pngapi png user transform ptr pngarg png structp png row infop png bytep endif ifdef png user chunks supported typedef int pngapi png user chunk ptr pngarg png structp png unknown chunkp endif ifdef png unknown chunks supported typedef void pngapi png unknown chunk ptr pngarg png structp endif transform masks for the high level interface define png transform identity x read and write define png transform strip x read only define png transform strip alpha x read only define png transform packing x read and write define png transform packswap x read and write define png transform expand x read only define png transform invert mono x read and write define png transform shift x read and write define png transform bgr x read and write define png transform swap alpha x read and write define png transform swap endian x read and write define png transform invert alpha x read and write define png transform strip filler x write only deprecated added to libpng define png transform strip filler before x write only define png transform strip filler after x write only added to libpng define png transform gray to rgb x read only flags for mng supported features define png flag mng empty plte x define png flag mng filter x define png all mng features x typedef png voidp png malloc ptr pngarg png structp png size t typedef void png free ptr pngarg png structp png voidp the structure that holds the information to read and write png files the only people who need to care about what is inside of this are the people who will be modifying the library for their own special needs it should not be accessed directly by an application except to store the jmp buf struct png struct def ifdef png setjmp supported jmp buf jmpbuf used in png error endif png error ptr error fn png depstruct function for printing errors and aborting png error ptr warning fn png depstruct function for printing warnings png voidp error ptr png depstruct user supplied struct for error functions png rw ptr write data fn png depstruct function for writing output data png rw ptr read data fn png depstruct function for reading input data png voidp io ptr png depstruct ptr to application struct for i o functions ifdef png read user transform supported png user transform ptr read user transform fn png depstruct user read transform endif ifdef png write user transform supported png user transform ptr write user transform fn png depstruct user write transform endif these were added in libpng ifdef png user transform ptr supported if defined png read user transform supported defined png write user transform supported png voidp user transform ptr png depstruct user supplied struct for user transform png byte user transform depth png depstruct bit depth of user transformed pixels png byte user transform channels png depstruct channels in user transformed pixels endif endif png uint mode png depstruct tells us where we are in the png file png uint flags png depstruct flags indicating various things to libpng png uint transformations png depstruct which transformations to perform z stream zstream png depstruct pointer to decompression structure below png bytep zbuf png depstruct buffer for zlib png size t zbuf size png depstruct size of zbuf int zlib level png depstruct holds zlib compression level int zlib method png depstruct holds zlib compression method int zlib window bits png depstruct holds zlib compression window bits int zlib mem level png depstruct holds zlib compression memory level int zlib strategy png depstruct holds zlib compression strategy png uint width png depstruct width of image in pixels png uint height png depstruct height of image in pixels png uint num rows png depstruct number of rows in current pass png uint usr width png depstruct width of row at start of write png uint rowbytes png depstruct size of row in bytes if replaced with the following in libpng png size t irowbytes  {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
png depstruct endif added in libpng ifdef png user limits supported added in libpng total number of splt text and unknown chunks that can be stored means unlimited  {
	                  unlimited :: -1000
                          }
png uint user chunk cache max png depstruct endif png uint iwidth png depstruct width of current interlaced row in pixels png uint row number png depstruct current row in interlace pass png bytep prev row png depstruct buffer to save previous unfiltered  {
	                                unfiltered :: -1000
                                         }
row png bytep row buf png depstruct buffer to save current unfiltered row ifndef png no write filter png bytep sub row png depstruct buffer to save sub row when filtering png bytep up row png depstruct buffer to save up row when filtering png bytep avg row png depstruct buffer to save avg row when filtering png bytep paeth row png depstruct buffer to save paeth row when filtering endif png row info row info png depstruct used for transformation routines png uint idat size png depstruct current idat size for read png uint crc png depstruct current chunk crc value png colorp palette png depstruct palette from the input file png uint num palette png depstruct number of color entries in palette png uint num trans png depstruct number of transparency values png byte chunk name png depstruct null terminated name of current chunk png byte compression png depstruct file compression type always png byte filter png depstruct file filter type always png byte interlaced png depstruct png interlace none png interlace adam png byte pass png depstruct current interlace pass png byte do filter png depstruct row filter flags see png filter below png byte color type png depstruct color type of file png byte bit depth png depstruct bit depth of file png byte usr bit depth png depstruct bit depth of users row png byte pixel depth png depstruct number of bits per pixel png byte channels png depstruct number of channels in file png byte usr channels png depstruct channels at start of write png byte sig bytes png depstruct magic bytes read written from start of file if defined png read filler supported defined png write filler supported ifdef png legacy supported png byte filler png depstruct filler byte for pixel expansion else png uint filler png depstruct filler bytes for pixel expansion endif endif ifdef png bkgd supported png byte background gamma type png depstruct ifdef png floating point supported float background gamma png depstruct endif png color background png depstruct background color in screen gamma space ifdef png read gamma supported png color background png depstruct background normalized to gamma endif endif png bkgd supported ifdef png write flush supported png flush ptr output flush fn png depstruct function for flushing  {
	                                                                                                                                                                                                                                                                                                                                                                                   flushing :: -1000
                                                                                                                                                                                                                                                                                                                                                                                          }
output png uint flush dist png depstruct how many rows apart  {
	     apart :: -1000
         }
to flush no flush png uint flush rows png depstruct number of rows written since last flush endif if defined png read gamma supported defined png read background supported int gamma shift png depstruct number of insignificant  {
	                       insignificant :: -1000
                                   }
bits bit gamma ifdef png floating point supported float gamma png depstruct file gamma value float screen gamma png depstruct screen gamma value display exponent endif endif if defined png read gamma supported defined png read background supported png bytep gamma table png depstruct gamma table for bit depth files png bytep gamma from png depstruct converts from to screen png bytep gamma to png depstruct converts from file to png uint pp gamma table png depstruct gamma table for bit depth files png uint pp gamma from png depstruct converts from to screen png uint pp gamma to png depstruct converts from file to endif if defined png read gamma supported defined png sbit supported png color sig bit png depstruct significant bits in each available channel endif if defined png read shift supported defined png write shift supported png color shift png depstruct shift for significant bit tranformation  {
	                                                                                                                                       transformation :: 16
	                                                                                                                                        transpiration :: 16
	                                                                                                                                        reaffirmation :: 16
                                                                                                                                                    }
endif if defined png trns supported defined png read background supported defined png read expand supported defined png read background supported png bytep trans png depstruct transparency values for paletted files png color trans values png depstruct transparency values for non paletted files endif png read status ptr read row fn png depstruct called after each row is decoded  {
	                                                   decoded :: -1000
                                                         }
png write status ptr write row fn png depstruct called after each row is encoded ifdef png progressive read supported png progressive info ptr info fn png depstruct called after header data fully read png progressive row ptr row fn png depstruct called after each prog row is decoded png progressive end ptr end fn png depstruct called after image is complete png bytep save buffer ptr png depstruct current location in save buffer png bytep save buffer png depstruct buffer for previously read data png bytep current buffer ptr png depstruct current location in current buffer png bytep current buffer png depstruct buffer for recently used data png uint push length png depstruct size of current input chunk png uint skip length png depstruct bytes to skip in input data png size t save buffer size png depstruct amount of data now in save buffer png size t save buffer max png depstruct total size of save buffer png size t buffer size png depstruct total amount of available input data png size t current buffer size png depstruct amount of data now in current buffer int process mode png depstruct what push library is currently doing int cur palette png depstruct current push library palette index ifdef png text supported png size t current text size png depstruct current size of text input data png size t current text left png depstruct how much text left to read in input png charp current text png depstruct current text chunk buffer png charp current text ptr png depstruct current location in current text endif png text supported endif png progressive read supported if defined turboc defined windows defined flat for the borland special k segment handler png bytepp offset table ptr png depstruct png bytep offset table png depstruct png uint offset table number png depstruct png uint offset table count png depstruct png uint offset table count free png depstruct endif ifdef png read dither supported png bytep palette lookup png depstruct lookup table for dithering png bytep dither index png depstruct index translation for palette files endif if defined png read dither supported defined png hist supported png uint p hist png depstruct histogram  {
	                                                                                                                                                                                                                                                                                                                                                                     histogram :: -1000
                                                                                                                                                                                                                                                                                                                                                                             }
endif ifdef png write weighted filter supported png byte heuristic  {
	heuristic :: -1000
        }
method png depstruct heuristic for row filter selection png byte num prev filters png depstruct number of weights  {
	          weights :: -1000
                }
for previous rows png bytep prev filters png depstruct filter type s of previous row s png uint p filter weights png depstruct weight s for previous line s png uint p inv filter weights png depstruct weight s for previous line s png uint p filter costs png depstruct relative filter calculation cost png uint p inv filter costs png depstruct relative filter calculation cost endif ifdef png time rfc supported png charp time buffer png depstruct string to hold rfc time text endif new members added in libpng ifdef png free me supported png uint free me png depstruct flags items libpng is responsible for freeing endif ifdef png user chunks supported png voidp user chunk ptr png depstruct png user chunk ptr read user chunk fn png depstruct user read chunk handler endif ifdef png handle as unknown supported int num chunk list png depstruct png bytep chunk list png depstruct endif new members added in libpng ifdef png read rgb to gray supported png byte rgb to gray status png depstruct these were changed from png byte in libpng png uint rgb to gray red coeff png depstruct png uint rgb to gray green coeff png depstruct png uint rgb to gray blue coeff png depstruct endif new member added in libpng renamed in if defined png mng features supported defined png read empty plte supported defined png write empty plte supported changed from png byte to png uint at version ifdef png x png byte mng features permitted png depstruct else png uint mng features permitted png depstruct endif png x endif new member added in libpng if defined png read gamma supported defined png read background supported png fixed point int gamma png depstruct endif new member added in libpng ifdef ed out in enabled in ifdef png mng features supported png byte filter type png depstruct endif ifdef png x new member added in libpng ifdef ed out in png uint row buf size png depstruct endif new members added in libpng ifdef png assembler code supported ifndef png x ifdef png mmx code supported png byte mmx bitdepth threshold png depstruct png uint mmx rowbytes threshold png depstruct endif png uint asm flags png depstruct endif endif new members added in libpng but first enabled by default in ifdef png user mem supported png voidp mem ptr png depstruct user supplied struct for mem functions png malloc ptr malloc fn png depstruct function for allocating memory png free ptr free fn png depstruct function for freeing memory endif new member added in libpng and png bytep big row buf png depstruct buffer to save current unfiltered row ifdef png read dither supported the following three members were added at version and png bytep dither sort png depstruct working sort array png bytep index to palette png depstruct where the original index currently is in the palette png bytep palette to index png depstruct which original index points to this palette color endif new members added in libpng and png byte compression type png depstruct ifdef png user limits supported png uint user width max png depstruct png uint user height max png depstruct endif new member added in libpng and ifdef png unknown chunks supported storage for unknown chunk that the library doesn t recognize png unknown chunk unknown chunk png depstruct endif new members added in libpng png uint old big row buf size png depstruct png uint old prev row size png depstruct new member added in libpng png charp chunkdata  {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }
png depstruct buffer for reading chunk data this triggers a compiler error in png c if png c and png h do not agree upon the version number typedef png structp version typedef png struct far far png structpp  {
                                     }
here are the function definitions most commonly used this is not the place to find out how to use libpng see libpng txt for the full explanation see example c for the summary this just provides a simple one line description of the use of each function returns the version number of the library extern png export png uint png access version number pngarg void tell lib we have already handled the first num bytes magic bytes handling more than bytes from the beginning of the file is an error extern png export void png set sig bytes pngarg png structp png ptr int num bytes check sig start through sig start num to check to see if it s a png file returns zero if the supplied bytes match the byte png signature and non zero otherwise having num to check or start will always fail ie return non zero extern png export int png sig cmp pngarg png bytep sig png size t start png size t num to check simple signature checking function this is the same as calling png check sig sig n png sig cmp sig n extern png export int png check sig pngarg png bytep sig int num png deprecated allocate and initialize png ptr struct for reading and any other memory extern png export png structp png create read struct pngarg png const charp user png ver png voidp error ptr png error ptr error fn png error ptr warn fn png allocated allocate and initialize png ptr struct for writing and any other memory extern png export png structp png create write struct pngarg png const charp user png ver png voidp error ptr png error ptr error fn png error ptr warn fn png allocated ifdef png write supported extern png export png uint png get compression buffer size pngarg png structp png ptr endif ifdef png write supported extern png export void png set compression buffer size pngarg png structp png ptr png uint size endif reset the compression stream extern png export int png reset zstream pngarg png structp png ptr new functions added in libpng not enabled by default until ifdef png user mem supported extern png export png structp png create read struct pngarg png const charp user png ver png voidp error ptr png error ptr error fn png error ptr warn fn png voidp mem ptr png malloc ptr malloc fn png free ptr free fn png allocated extern png export png structp png create write struct pngarg png const charp user png ver png voidp error ptr png error ptr error fn png error ptr warn fn png voidp mem ptr png malloc ptr malloc fn png free ptr free fn png allocated endif write a png chunk size type optional data crc extern png export void png write chunk pngarg png structp png ptr png bytep chunk name png bytep data png size t length write the start of a png chunk length and chunk name extern png export void png write chunk start pngarg png structp png ptr png bytep chunk name png uint length write the data of a png chunk started with png write chunk start extern png export void png write chunk data pngarg png structp png ptr png bytep data png size t length finish a chunk started with png write chunk start includes crc extern png export void png write chunk end pngarg png structp png ptr allocate and initialize the info structure extern png export png infop png create info struct pngarg png structp png ptr png allocated if defined png x defined png x initialize the info structure old interface deprecated extern png export void png info init pngarg png infop info ptr png deprecated undef png info init define png info init info ptr png info init info ptr png sizeof png info endif extern png export void png info init pngarg png infopp info ptr png size t png info struct size writes all the png information before the image extern png export void png write info before plte pngarg png structp png ptr png infop info ptr extern png export void png write info pngarg png structp png ptr png infop info ptr ifdef png sequential read supported read the information before the actual image data extern png export void png read info pngarg png structp png ptr png infop info ptr endif ifdef png time rfc supported extern png export png charp png convert to rfc pngarg png structp png ptr png timep ptime  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     primes :: 6
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     primer :: 6
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     primed :: 6
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    pigment :: 6
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    pigmeat :: 6
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     pitmen :: 7
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     permit :: 6
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    primate :: 6
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     stimes :: 6
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     stimed :: 6
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      stipe :: 6
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      stime :: 7
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       item :: 6
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      prime :: 7
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          }
endif ifdef png convert time supported convert from a struct tm to png time extern png export void png convert from struct tm pngarg png timep ptime struct tm far ttime  {
	                        titmen :: 7
	                        stimes :: 6
	                        stimed :: 6
	                         twite :: 6
	                         trite :: 6
	                         thite :: 6
	                         stime :: 7
	                          item :: 6
                             }
convert from time t to png time uses gmtime extern png export void png convert from time t pngarg png timep ptime time t ttime endif png convert time supported ifdef png read expand supported expand data to bit rgb or bit grayscale with alpha if available extern png export void png set expand pngarg png structp png ptr ifndef png x extern png export void png set expand gray to pngarg png structp png ptr endif extern png export void png set palette to rgb pngarg png structp png ptr extern png export void png set trns to alpha pngarg png structp png ptr if defined png x defined png x deprecated extern png export void png set gray to pngarg png structp png ptr png deprecated endif endif if defined png read bgr supported defined png write bgr supported use blue green red order for pixels extern png export void png set bgr pngarg png structp png ptr endif ifdef png read gray to rgb supported expand the grayscale to bit rgb if necessary extern png export void png set gray to rgb pngarg png structp png ptr endif ifdef png read rgb to gray supported reduce rgb to grayscale ifdef png floating point supported extern png export void png set rgb to gray pngarg png structp png ptr int error action double red double green endif extern png export void png set rgb to gray fixed pngarg png structp png ptr int error action png fixed point red png fixed point green extern png export png byte png get rgb to gray status pngarg png structp png ptr endif extern png export void png build grayscale palette pngarg int bit depth png colorp palette ifdef png read strip alpha supported extern png export void png set strip alpha pngarg png structp png ptr endif if defined png read swap alpha supported defined png write swap alpha supported extern png export void png set swap alpha pngarg png structp png ptr endif if defined png read invert alpha supported defined png write invert alpha supported extern png export void png set invert alpha pngarg png structp png ptr endif if defined png read filler supported defined png write filler supported add a filler byte to bit gray or bit rgb images extern png export void png set filler pngarg png structp png ptr png uint filler int flags the values of the png filler defines should not be changed define png filler before define png filler after add an alpha byte to bit gray or bit rgb images ifndef png x extern png export void png set add alpha pngarg png structp png ptr png uint filler int flags endif endif png read filler supported png write filler supported if defined png read swap supported defined png write swap supported swap bytes in bit depth files extern png export void png set swap pngarg png structp png ptr endif if defined png read pack supported defined png write pack supported use byte per pixel in or bit depth files extern png export void png set packing pngarg png structp png ptr endif if defined png read packswap supported defined png write packswap supported swap packing order of pixels in bytes extern png export void png set packswap pngarg png structp png ptr endif if defined png read shift supported defined png write shift supported converts files to legal bit depths  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     depths :: -1000
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          }
extern png export void png set shift pngarg png structp png ptr png color p true bits endif if defined png read interlacing supported defined png write interlacing supported have the code handle the interlacing returns the number of passes extern png export int png set interlace handling pngarg png structp png ptr endif if defined png read invert supported defined png write invert supported invert monochrome files extern png export void png set invert mono pngarg png structp png ptr endif ifdef png read background supported handle alpha and trns by replacing with a background color ifdef png floating point supported extern png export void png set background pngarg png structp png ptr png color p background color int background gamma code int need expand double background gamma endif define png background gamma unknown define png background gamma screen define png background gamma file define png background gamma unique endif ifdef png read to supported strip the second byte of information from a bit depth file extern png export void png set strip pngarg png structp png ptr endif ifdef png read dither supported turn on dithering and reduce the palette to the number of colors available extern png export void png set dither pngarg png structp png ptr png colorp palette int num palette int maximum colors png uint p histogram int full dither endif ifdef png read gamma supported handle gamma correction screen gamma display exponent ifdef png floating point supported extern png export void png set gamma pngarg png structp png ptr double screen gamma double default file gamma endif endif if defined png x defined png x if defined png read empty plte supported defined png write empty plte supported permit or disallow empty plte not permitted permitted deprecated and will be removed use png permit mng features instead extern png export void png permit empty plte pngarg png structp png ptr int empty plte permitted png deprecated endif endif ifdef png write flush supported set how many lines between output flushes  {
	                                                                                                                                                                                                                                                                                                                                         flushes :: -1000
                                                                                                                                                                                                                                                                                                                                               }
for no flushing extern png export void png set flush pngarg png structp png ptr int nrows  {
	         cupolar :: -1000
               }
flush the current png output buffer extern png export void png write flush pngarg png structp png ptr endif optional update palette with requested transformations extern png export void png start read image pngarg png structp png ptr optional call to update the users info structure extern png export void png read update info pngarg png structp png ptr png infop info ptr ifndef png no sequential read supported read one or more rows of image data extern png export void png read rows pngarg png structp png ptr png bytepp row png bytepp display row png uint num rows endif ifndef png no sequential read supported read a row of data extern png export void png read row pngarg png structp png ptr png bytep row png bytep display row endif ifndef png no sequential read supported read the whole image into memory at once extern png export void png read image pngarg png structp png ptr png bytepp image endif write a row of image data extern png export void png write row pngarg png structp png ptr png bytep row write a few rows of image data extern png export void png write rows pngarg png structp png ptr png bytepp row png uint num rows write the image data extern png export void png write image pngarg png structp png ptr png bytepp image writes the end of the png file extern png export void png write end pngarg png structp png ptr png infop info ptr ifndef png no sequential read supported read the end of the png file extern png export void png read end pngarg png structp png ptr png infop info ptr endif free any memory associated with the png info struct extern png export void png destroy info struct pngarg png structp png ptr png infopp info ptr ptr free any memory associated with the png struct and the png info structs extern png export void png destroy read struct pngarg png structpp png ptr ptr png infopp info ptr ptr png infopp end info ptr ptr free all memory used by the read old method not dll exported debian  {
	                                                                                                                                                                                                                                                                                                                                                               mediant :: 7
	                                                                                                                                                                                                                                                                                                                                                               medians :: 7
	                                                                                                                                                                                                                                                                                                                                                               defiant :: 8
	                                                                                                                                                                                                                                                                                                                                                                 debit :: 7
	                                                                                                                                                                                                                                                                                                                                                                bedpan :: 7
	                                                                                                                                                                                                                                                                                                                                                              deviants :: 7
	                                                                                                                                                                                                                                                                                                                                                              deviancy :: 7
	                                                                                                                                                                                                                                                                                                                                                                detain :: 7
	                                                                                                                                                                                                                                                                                                                                                                denial :: 8
	                                                                                                                                                                                                                                                                                                                                                                demain :: 7
	                                                                                                                                                                                                                                                                                                                                                              gabioned :: 7
	                                                                                                                                                                                                                                                                                                                                                              unbiased :: 7
	                                                                                                                                                                                                                                                                                                                                                              debonair :: 7
	                                                                                                                                                                                                                                                                                                                                                                rebind :: 7
	                                                                                                                                                                                                                                                                                                                                                                median :: 8
	                                                                                                                                                                                                                                                                                                                                                               cabined :: 7
	                                                                                                                                                                                                                                                                                                                                                              deniably :: 8
	                                                                                                                                                                                                                                                                                                                                                              deniable :: 7
	                                                                                                                                                                                                                                                                                                                                                               beading :: 7
	                                                                                                                                                                                                                                                                                                                                                               deviant :: 8
	                                                                                                                                                                                                                                                                                                                                                              debating :: 7
	                                                                                                                                                                                                                                                                                                                                                              debasing :: 7
	                                                                                                                                                                                                                                                                                                                                                               denials :: 7
                                                                                                                                                                                                                                                                                                                                                                     }
note exporting as it is required by legacy applications extern png export void png read destroy pngarg png structp png ptr png infop info ptr png infop end info ptr free any memory associated with the png struct and the png info structs extern png export void png destroy write struct pngarg png structpp png ptr ptr png infopp info ptr ptr free any memory used in png ptr struct old method not dll exported debian note exporting as it is required by legacy applications extern png export void png write destroy pngarg png structp png ptr set the libpng method of handling chunk crc errors extern png export void png set crc action pngarg png structp png ptr int crit action int ancil action values for png set crc action to say how to handle crc errors in ancillary and critical chunks and whether to use the data contained therein  {
	                                                                                                                                               therein :: -1000
                                                                                                                                                     }
note that it is impossible to discard data in a critical chunk for versions prior to the action was always error quit whereas  {
	               whereas :: -1000
                     }
in version and later the action for crc errors in ancillary chunks is warn discard these values should not be changed value action critical action ancillary define png crc default error quit warn discard data define png crc error quit error quit error quit define png crc warn discard invalid warn discard data define png crc warn use warn use data warn use data define png crc quiet use quiet use data quiet use data define png crc no change use current value use current value these functions give the user control over the scan line filtering in libpng and the compression methods used by zlib these functions are mainly useful for testing as the defaults should work with most users those users who are tight  {
	                                                                                                                        tight :: -1000
                                                                                                                            }
on memory or want faster performance at the expense  {
	 expense :: -1000
       }
of compression can modify them see the compression library header file zlib h for an explination  {
	    prelibation :: 14
	    examination :: 16
	    declination :: 15
	   replications :: 14
	    expatiation :: 15
	    explication :: 19
	    pollination :: 15
	   pollinations :: 14
	    pectination :: 14
	    explanation :: 19
	    epoxidation :: 14
	   explorations :: 15
	   eliminations :: 14
	   declinations :: 14
	    exfoliation :: 14
	   explanations :: 18
	    exculpation :: 14
	   examinations :: 15
	    replication :: 15
	   explications :: 18
	    exploration :: 16
              }
of the compression functions set the filtering method s used by libpng currently the only valid value for method is extern png export void png set filter pngarg png structp png ptr int method int filters flags for png set filter to say which filters to use the flags are chosen so that they don t conflict with real filter types below in case they are supplied instead of the defined constants these values should not be changed define png no filters x define png filter none x define png filter sub x define png filter up x define png filter avg x define png filter paeth x define png all filters png filter none png filter sub png filter up png filter avg png filter paeth filter values not flags used in pngwrite c pngwutil c for now these defines should not be changed define png filter value none define png filter value sub define png filter value up define png filter value avg define png filter value paeth define png filter value last if defined png write weighted filter supported experimental the heuristic method is given by one of the png filter heuristic defines either the default minimum sum of absolute differences or the experimental method weighted minimum sum of absolute differences weights are factors indicating how important it is to keep the filter type consistent between rows larger numbers mean the current filter is that many times as likely to be the same as the num weights previous filters this is cumulative  {
	                                                                                                                                                                                                                                                    cumulative :: -1000
                                                                                                                                                                                                                                                             }
for each previous row with a weight there needs to be num weights values in filter weights or it can be null if the weights aren t being specified weights have no influence on the selection of the first row filter well chosen weights can in theory improve the compression for a given image costs are factors indicating the relative decoding costs of a filter type higher costs indicate more decoding expense and are therefore less likely to be selected over a filter with lower computational  {
	                                                                        computational :: -1000
                                                                                    }
costs there needs to be a value in filter costs for each valid filter type given by png filter value last or it can be null if you aren t setting the costs costs try to improve the speed of decompression without unduly  {
	                                    unduly :: -1000
                                         }
increasing the compressed image size a negative weight or cost indicates the default value is to be used and values in the range indicate the value is to remain unchanged the default values for both weights and costs are currently but may change if good general weighting  {
	                                     weighting :: -1000
                                             }
cost heuristics  {
	heuristics :: -1000
 }
can be found if both the weights and costs are set to this degenerates  {
	  degenerates :: -1000
            }
the weighted method to the unweighted  {
	unweighted :: -1000
    }
method but with added encoding time computation ifdef png floating point supported extern png export void png set filter heuristics pngarg png structp png ptr int heuristic method int num weights png doublep filter weights png doublep filter costs endif endif png write weighted filter supported heuristic used for row filter selection these defines should not be changed define png filter heuristic default currently unweighted define png filter heuristic unweighted used by libpng define png filter heuristic weighted experimental feature define png filter heuristic last not a valid value set the library compression level currently valid values range from corresponding directly to the zlib compression levels no compression maximal compression note that tests have shown  {
	                                                                                                             shown :: -1000
                                                                                                                 }
that zlib compression levels usually perform as well as level for png images and do considerably  {
	   considerably :: -1000
              }
fewer caclulations  {
	coagulations :: 16
	circulation :: 15
	calculation :: 20
	calculating :: 16
	cancelation :: 15
	calculational :: 15
	pullulations :: 15
	calcinations :: 16
	circulations :: 17
	acclamations :: 15
	acclimations :: 15
	cupellations :: 15
	ejaculations :: 16
	collocations :: 15
	vacuolations :: 17
	vacillations :: 17
	occultations :: 15
	sacculation :: 19
	vacuolation :: 15
	vacillation :: 15
	calculations :: 22
	cancelations :: 17
	sacculations :: 19
 }
in the future these values may not correspond directly to the zlib compression levels extern png export void png set compression level pngarg png structp png ptr int level extern png export void png set compression mem level pngarg png structp png ptr int mem level extern png export void png set compression strategy pngarg png structp png ptr int strategy extern png export void png set compression window bits pngarg png structp png ptr int window bits extern png export void png set compression method pngarg png structp png ptr int method these next functions are called for input output memory and error handling they are in the file pngrio  {
	                                                                                                       sporing :: 7
	                                                                                                        poring :: 7
	                                                                                                      ingroups :: 7
	                                                                                                       pignora :: 7
	                                                                                                       proving :: 7
	                                                                                                       prosing :: 7
	                                                                                                       proking :: 7
	                                                                                                       probing :: 7
	                                                                                                       pouring :: 8
	                                                                                                       porting :: 7
	                                                                                                       porging :: 7
	                                                                                                      pourings :: 7
	                                                                                                       perigon :: 7
	                                                                                                       pterion :: 7
	                                                                                                         pagri :: 7
	                                                                                                       ingroup :: 8
                                                                                                             }
c pngwio  {
	plowing :: 8
 }
c and pngerror  {
 }
c and call standard c i o routines such as fread fwrite and fprintf these functions can be made to use other i o routines at run time for those applications that need to handle i o in a different manner by calling png set fn see libpng txt for more information ifdef png stdio supported initialize the input output for the png file to the default functions extern png export void png init io pngarg png structp png ptr png file p fp endif replace the error and abort and warning functions with user supplied functions if no messages are to be printed you must still write and use replacement functions the replacement error fn should still do a longjmp  {
                                                                                                                       }
to the last setjmp location if you are using this method of error handling if error fn or warning fn is null the default function will be used extern png export void png set error fn pngarg png structp png ptr png voidp error ptr png error ptr error fn png error ptr warning fn return the user pointer associated with the error functions extern png export png voidp png get error ptr pngarg png structp png ptr replace the default data output functions with a user supplied one s if buffered output is not used then output flush fn can be set to null if png write flush supported is not defined at libpng compile time output flush fn will be ignored and thus can be null it is probably a mistake to use null for output flush fn if write data fn is not also null unless you have built libpng with png write flush supported undefined because in this case libpng s default flush function which uses the standard file structure will be used extern png export void png set write fn pngarg png structp png ptr png voidp io ptr png rw ptr write data fn png flush ptr output flush fn replace the default data input function with a user supplied one extern png export void png set read fn pngarg png structp png ptr png voidp io ptr png rw ptr read data fn return the user pointer associated with the i o functions extern png export png voidp png get io ptr pngarg png structp png ptr extern png export void png set read status fn pngarg png structp png ptr png read status ptr read row fn extern png export void png set write status fn pngarg png structp png ptr png write status ptr write row fn ifdef png user mem supported replace the default memory allocation functions with user supplied one s extern png export void png set mem fn pngarg png structp png ptr png voidp mem ptr png malloc ptr malloc fn png free ptr free fn return the user pointer associated with the memory functions extern png export png voidp png get mem ptr pngarg png structp png ptr endif if defined png read user transform supported defined png legacy supported extern png export void png set read user transform fn pngarg png structp png ptr png user transform ptr read user transform fn endif if defined png write user transform supported defined png legacy supported extern png export void png set write user transform fn pngarg png structp png ptr png user transform ptr write user transform fn endif if defined png read user transform supported defined png write user transform supported defined png legacy supported extern png export void png set user transform info pngarg png structp png ptr png voidp user transform ptr int user transform depth int user transform channels return the user pointer associated with the user transform functions extern png export png voidp png get user transform ptr pngarg png structp png ptr endif ifdef png user chunks supported extern png export void png set read user chunk fn pngarg png structp png ptr png voidp user chunk ptr png user chunk ptr read user chunk fn extern png export png voidp png get user chunk ptr pngarg png structp png ptr endif ifdef png progressive read supported sets the function callbacks for the push reader and a pointer to a user defined structure available to the callback functions extern png export void png set progressive read fn pngarg png structp png ptr png voidp progressive ptr png progressive info ptr info fn png progressive row ptr row fn png progressive end ptr end fn returns the user pointer associated with the push read functions extern png export png voidp png get progressive ptr pngarg png structp png ptr function to be called when data becomes available extern png export void png process data pngarg png structp png ptr png infop info ptr png bytep buffer png size t buffer size function that combines  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  combines :: -1000
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         }
rows not very much different than the png combine row call is this even used extern png export void png progressive combine row pngarg png structp png ptr png bytep old row png bytep new row endif png progressive read supported extern png export png voidp png malloc pngarg png structp png ptr png uint size png allocated ifdef png x define png malloc warn png malloc else added at libpng version extern png export png voidp png malloc warn pngarg png structp png ptr png uint size png allocated endif frees a pointer allocated by png malloc extern png export void png free pngarg png structp png ptr png voidp ptr ifdef png x function to allocate memory for zlib extern png export voidpf  {
	                                                                                                                antielectron :: -1000
                                                                                                                           }
png zalloc pngarg voidpf png ptr uint items uint size function to free memory for zlib extern png export void png zfree pngarg voidpf png ptr voidpf ptr endif free data that was allocated internally extern png export void png free data pngarg png structp png ptr png infop info ptr png uint free me int num ifdef png free me supported reassign  {
	                                                      reassign :: -1000
                                                             }
responsibility for freeing existing data whether allocated by libpng or by the application extern png export void png data freer pngarg png structp png ptr png infop info ptr int freer png uint mask endif assignments for png data freer define png destroy will free data define png set will free data define png user will free data flags for png ptr free me and info ptr free me define png free hist x define png free iccp x define png free splt x define png free rows x define png free pcal x define png free scal x define png free unkn x define png free list x define png free plte x define png free trns x define png free text x define png free all x fff define png free mul x png free splt png free text png free unkn ifdef png user mem supported extern png export png voidp png malloc default pngarg png structp png ptr png uint size png allocated extern png export void png free default pngarg png structp png ptr png voidp ptr endif extern png export png voidp png memcpy check pngarg png structp png ptr png voidp s png voidp s png uint size png deprecated extern png export png voidp png memset check pngarg png structp png ptr png voidp s int value png uint size png deprecated if defined use far keyword memory model conversion function extern void png far to near pngarg png structp png ptr png voidp ptr int check endif use far keyword ifndef png no error text fatal error in png image of libpng can t continue extern png export void png error pngarg png structp png ptr png const charp error message png noreturn the same but the chunk name is prepended to the error string extern png export void png chunk error pngarg png structp png ptr png const charp error message png noreturn else fatal error in png image of libpng can t continue extern png export void png err pngarg png structp png ptr png noreturn endif ifndef png no warnings non fatal error in libpng can continue but may have a problem extern png export void png warning pngarg png structp png ptr png const charp warning message ifdef png read supported non fatal error in libpng chunk name is prepended to message extern png export void png chunk warning pngarg png structp png ptr png const charp warning message endif png read supported endif png no warnings the png set chunk functions are for storing  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                    storing :: -1000
                                                                                                                                                                                                                                                                                                                                                                                                                                          }
values in the png info struct similarly the png get chunk calls are used to read values from the png info struct either storing the parameters in the passed variables or setting pointers into the png info struct where the data is stored the png get chunk functions return a non zero value if the data was available in info ptr or return zero and do not change any of the parameters if the data was not available these functions should be used instead of directly accessing png info to avoid problems with future changes in the size and internal layout  {
	                                                                                              layout :: -1000
                                                                                                   }
of png info struct returns flag if chunk data is valid in info ptr extern png export png uint png get valid pngarg png structp png ptr png infop info ptr png uint flag returns number of bytes needed to hold a transformed row extern png export png uint png get rowbytes pngarg png structp png ptr png infop info ptr ifdef png info image supported returns row pointers which is an array of pointers to scanlines that was returned from png read png extern png export png bytepp png get rows pngarg png structp png ptr png infop info ptr set row pointers which is an array of pointers to scanlines for use by png write png extern png export void png set rows pngarg png structp png ptr png infop info ptr png bytepp row pointers endif returns number of color channels in image extern png export png byte png get channels pngarg png structp png ptr png infop info ptr ifdef png easy access supported returns image width in pixels extern png export png uint png get image width pngarg png structp png ptr png infop info ptr returns image height in pixels extern png export png uint png get image height pngarg png structp png ptr png infop info ptr returns image bit depth extern png export png byte png get bit depth pngarg png structp png ptr png infop info ptr returns image color type extern png export png byte png get color type pngarg png structp png ptr png infop info ptr returns image filter type extern png export png byte png get filter type pngarg png structp png ptr png infop info ptr returns image interlace type extern png export png byte png get interlace type pngarg png structp png ptr png infop info ptr returns image compression type extern png export png byte png get compression type pngarg png structp png ptr png infop info ptr returns image resolution in pixels per meter from phys chunk data extern png export png uint png get pixels per meter pngarg png structp png ptr png infop info ptr extern png export png uint png get x pixels per meter pngarg png structp png ptr png infop info ptr extern png export png uint png get y pixels per meter pngarg png structp png ptr png infop info ptr returns pixel aspect ratio computed from phys chunk data ifdef png floating point supported extern png export float png get pixel aspect ratio pngarg png structp png ptr png infop info ptr endif returns image x y offset in pixels or microns from offs chunk data extern png export png int png get x offset pixels pngarg png structp png ptr png infop info ptr extern png export png int png get y offset pixels pngarg png structp png ptr png infop info ptr extern png export png int png get x offset microns pngarg png structp png ptr png infop info ptr extern png export png int png get y offset microns pngarg png structp png ptr png infop info ptr endif png easy access supported returns pointer to signature string read from png header extern png export png bytep png get signature pngarg png structp png ptr png infop info ptr ifdef png bkgd supported extern png export png uint png get bkgd pngarg png structp png ptr png infop info ptr png color p background endif ifdef png bkgd supported extern png export void png set bkgd pngarg png structp png ptr png infop info ptr png color p background endif ifdef png chrm supported ifdef png floating point supported extern png export png uint png get chrm pngarg png structp png ptr png infop info ptr double white x double white y double red x double red y double green x double green y double blue x double blue y endif ifdef png fixed point supported extern png export png uint png get chrm fixed pngarg png structp png ptr png infop info ptr png fixed point int white x png fixed point int white y png fixed point int red x png fixed point int red y png fixed point int green x png fixed point int green y png fixed point int blue x png fixed point int blue y endif endif ifdef png chrm supported ifdef png floating point supported extern png export void png set chrm pngarg png structp png ptr png infop info ptr double white x double white y double red x double red y double green x double green y double blue x double blue y endif ifdef png fixed point supported extern png export void png set chrm fixed pngarg png structp png ptr png infop info ptr png fixed point int white x png fixed point int white y png fixed point int red x png fixed point int red y png fixed point int green x png fixed point int green y png fixed point int blue x png fixed point int blue y endif endif ifdef png gama supported ifdef png floating point supported extern png export png uint png get gama pngarg png structp png ptr png infop info ptr double file gamma endif extern png export png uint png get gama fixed pngarg png structp png ptr png infop info ptr png fixed point int file gamma endif ifdef png gama supported ifdef png floating point supported extern png export void png set gama pngarg png structp png ptr png infop info ptr double file gamma endif extern png export void png set gama fixed pngarg png structp png ptr png infop info ptr png fixed point int file gamma endif ifdef png hist supported extern png export png uint png get hist pngarg png structp png ptr png infop info ptr png uint p hist endif ifdef png hist supported extern png export void png set hist pngarg png structp png ptr png infop info ptr png uint p hist endif extern png export png uint png get ihdr pngarg png structp png ptr png infop info ptr png uint width png uint height int bit depth int color type int interlace method int compression method int filter method extern png export void png set ihdr pngarg png structp png ptr png infop info ptr png uint width png uint height int bit depth int color type int interlace method int compression method int filter method ifdef png offs supported extern png export png uint png get offs pngarg png structp png ptr png infop info ptr png int offset x png int offset y int unit type endif ifdef png offs supported extern png export void png set offs pngarg png structp png ptr png infop info ptr png int offset x png int offset y int unit type endif ifdef png pcal supported extern png export png uint png get pcal pngarg png structp png ptr png infop info ptr png charp purpose png int x png int x int type int nparams png charp units png charpp params endif ifdef png pcal supported extern png export void png set pcal pngarg png structp png ptr png infop info ptr png charp purpose png int x png int x int type int nparams png charp units png charpp params endif ifdef png phys supported extern png export png uint png get phys pngarg png structp png ptr png infop info ptr png uint res x png uint res y int unit type endif ifdef png phys supported extern png export void png set phys pngarg png structp png ptr png infop info ptr png uint res x png uint res y int unit type endif extern png export png uint png get plte pngarg png structp png ptr png infop info ptr png colorp palette int num palette extern png export void png set plte pngarg png structp png ptr png infop info ptr png colorp palette int num palette ifdef png sbit supported extern png export png uint png get sbit pngarg png structp png ptr png infop info ptr png color p sig bit endif ifdef png sbit supported extern png export void png set sbit pngarg png structp png ptr png infop info ptr png color p sig bit endif ifdef png srgb supported extern png export png uint png get srgb pngarg png structp png ptr png infop info ptr int intent endif ifdef png srgb supported extern png export void png set srgb pngarg png structp png ptr png infop info ptr int intent extern png export void png set srgb gama and chrm pngarg png structp png ptr png infop info ptr int intent endif ifdef png iccp supported extern png export png uint png get iccp pngarg png structp png ptr png infop info ptr png charpp name int compression type png charpp profile png uint proflen note to maintainer profile should be png bytepp endif ifdef png iccp supported extern png export void png set iccp pngarg png structp png ptr png infop info ptr png charp name int compression type png charp profile png uint proflen note to maintainer profile should be png bytep endif ifdef png splt supported extern png export png uint png get splt pngarg png structp png ptr png infop info ptr png splt tpp entries endif ifdef png splt supported extern png export void png set splt pngarg png structp png ptr png infop info ptr png splt tp entries int nentries endif ifdef png text supported png get text also returns the number of text chunks in num text extern png export png uint png get text pngarg png structp png ptr png infop info ptr png textp text ptr int num text endif note while png set text will accept a structure whose text language and translated keywords are null pointers the structure returned by png get text will always contain regular zero terminated c strings they might be empty strings but they will never be null pointers ifdef png text supported extern png export void png set text pngarg png structp png ptr png infop info ptr png textp text ptr int num text endif ifdef png time supported extern png export png uint png get time pngarg png structp png ptr png infop info ptr png timep mod time endif ifdef png time supported extern png export void png set time pngarg png structp png ptr png infop info ptr png timep mod time endif ifdef png trns supported extern png export png uint png get trns pngarg png structp png ptr png infop info ptr png bytep trans int num trans png color p trans values endif ifdef png trns supported extern png export void png set trns pngarg png structp png ptr png infop info ptr png bytep trans int num trans png color p trans values endif ifdef png trns supported endif ifdef png scal supported ifdef png floating point supported extern png export png uint png get scal pngarg png structp png ptr png infop info ptr int unit double width double height else ifdef png fixed point supported extern png export png uint png get scal s pngarg png structp png ptr png infop info ptr int unit png charpp swidth  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       switched :: 8
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        switchy :: 7
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        swifted :: 7
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         swithe :: 7
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         switch :: 8
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          whist :: 7
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          whids :: 7
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          swith :: 8
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          swift :: 7
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        whisted :: 7
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              }
png charpp sheight  {
	aheight :: 11
	sheugh :: 9
	sheikh :: 9
	resight :: 9
	freights :: 9
	behight :: 9
	sleights :: 9
	sheathing :: 9
	sleigh :: 9
	skeigh :: 9
	sleight :: 11
 }
endif endif endif png scal supported ifdef png scal supported ifdef png floating point supported extern png export void png set scal pngarg png structp png ptr png infop info ptr int unit double width double height else ifdef png fixed point supported extern png export void png set scal s pngarg png structp png ptr png infop info ptr int unit png charp swidth png charp sheight endif endif endif png scal supported png write scal supported ifdef png handle as unknown supported provide a list of chunks and how they are to be handled if the built in handling or default unknown chunk handling is not desired any chunks not listed will be handled in the default manner the ihdr and iend chunks must not be listed keep follow default behaviour do not keep keep only if safe to copy keep even if unsafe  {
	                                                                                                                                           unsafe :: -1000
                                                                                                                                                }
to copy extern png export void png set keep unknown chunks pngarg png structp png ptr int keep png bytep chunk list int num chunks png export int png handle as unknown pngarg png structp png ptr png bytep chunk name endif ifdef png unknown chunks supported extern png export void png set unknown chunks pngarg png structp png ptr png infop info ptr png unknown chunkp unknowns int num unknowns extern png export void png set unknown chunk location pngarg png structp png ptr png infop info ptr int chunk int location extern png export png uint png get unknown chunks pngarg png structp png ptr png infop info ptr png unknown chunkpp entries endif png free data will turn off the valid flag for anything it frees if you need to turn it off for a chunk that your application has freed you can use png set invalid png ptr info ptr png info chnk  {
	                                                                                                                                                       chunk :: 5
	                                                                                                                                                       chink :: 5
	                                                                                                                                                       chank :: 5
	                                                                                                                                                        conk :: 5
                                                                                                                                                           }
extern png export void png set invalid pngarg png structp png ptr png infop info ptr int mask ifdef png info image supported the params pointer is currently not used and is for future expansion extern png export void png read png pngarg png structp png ptr png infop info ptr int transforms png voidp params extern png export void png write png pngarg png structp png ptr png infop info ptr int transforms png voidp params endif define png debug at compile time for debugging information higher numbers for png debug mean more debugging information this has only been added since version so it is not implemented throughout libpng yet but more support will be added as needed ifdef png debug if png debug if defined png debug file defined msc ver include crtdbg  {
                                                                                                                                     }
h if png debug ifndef debug define debug endif ifndef png debug define png debug l m rpt  {
	              sad :: -1000
                }
crt warn m png string newline endif ifndef png debug define png debug l m p rpt crt warn m png string newline p endif ifndef png debug define png debug l m p p rpt crt warn m png string newline p p endif endif else png debug file msc ver ifndef png debug file define png debug file stderr endif png debug file if png debug note s m png string newline probably does not work on non iso compilers ifdef stdc ifndef png debug define png debug l m int num tabs l fprintf png debug file s m png string newline num tabs t num tabs t t num tabs t t t endif ifndef png debug define png debug l m p int num tabs l fprintf png debug file s m png string newline num tabs t num tabs t t num tabs t t t p endif ifndef png debug define png debug l m p p int num tabs l fprintf png debug file s m png string newline num tabs t num tabs t t num tabs t t t p p endif else stdc ifndef png debug define png debug l m int num tabs l char format snprintf format s s s num tabs t num tabs t t num tabs t t t m png string newline fprintf png debug file format endif ifndef png debug define png debug l m p int num tabs l char format snprintf format s s s num tabs t num tabs t t num tabs t t t m png string newline fprintf png debug file format p endif ifndef png debug define png debug l m p p int num tabs l char format snprintf format s s s num tabs t num tabs t t num tabs t t t m png string newline fprintf png debug file format p p endif endif stdc endif png debug endif msc ver endif png debug endif png debug ifndef png debug define png debug l m endif ifndef png debug define png debug l m p endif ifndef png debug define png debug l m p p endif extern png export png charp png get copyright pngarg png structp png ptr extern png export png charp png get header ver pngarg png structp png ptr extern png export png charp png get header version pngarg png structp png ptr extern png export png charp png get libpng ver pngarg png structp png ptr ifdef png mng features supported extern png export png uint png permit mng features pngarg png structp png ptr png uint mng features permitted endif for use in png set keep unknown added to version define png handle chunk as default define png handle chunk never define png handle chunk if safe define png handle chunk always added to version ifdef png assembler code supported ifdef png mmx code supported define png asm flag mmx support compiled x not user settable define png asm flag mmx support in cpu x not user settable define png asm flag mmx read combine row x define png asm flag mmx read interlace x define png asm flag mmx read filter sub x define png asm flag mmx read filter up x define png asm flag mmx read filter avg x define png asm flag mmx read filter paeth x define png asm flags initialized x not user settable define png mmx read flags png asm flag mmx read combine row png asm flag mmx read interlace png asm flag mmx read filter sub png asm flag mmx read filter up png asm flag mmx read filter avg png asm flag mmx read filter paeth define png mmx write flags define png mmx flags png asm flag mmx support compiled png asm flag mmx support in cpu png mmx read flags png mmx write flags define png select read define png select write endif png mmx code supported ifndef png x pngget c extern png export png uint png get mmx flagmask  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                flagman :: 11
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      }
pngarg int flag select int compilerid  {
	complier :: 14
	complied :: 13
	compiler :: 15
	compiled :: 14
	dimplier :: 12
	compilers :: 14
	compile :: 13
    }
pngget c extern png export png uint png get asm flagmask pngarg int flag select pngget c extern png export png uint png get asm flags pngarg png structp png ptr pngget c extern png export png byte png get mmx bitdepth threshold pngarg png structp png ptr pngget c extern png export png uint png get mmx rowbytes threshold pngarg png structp png ptr pngset c extern png export void png set asm flags pngarg png structp png ptr png uint asm flags pngset c extern png export void png set mmx thresholds  {
	                                                                                   thresholds :: -1000
                                                                                            }
pngarg png structp png ptr png byte mmx bitdepth threshold png uint mmx rowbytes threshold endif png x ifndef png x png c pnggccrd  {
                      }
c or pngvcrd  {
 }
c extern png export int png mmx support pngarg void endif png x endif png assembler code supported strip the prepended error numbers nnn  {
	                    inn :: 3
	                    ann :: 3
                      }
from error and warning messages before passing them to the error or warning handler ifdef png error numbers supported extern png export void png set strip error numbers pngarg png structp png ptr png uint strip mode endif added at libpng ifdef png set user limits supported extern png export void png set user limits pngarg png structp png ptr png uint user width max png uint user height max extern png export png uint png get user width max pngarg png structp png ptr extern png export png uint png get user height max pngarg png structp png ptr endif maintainer put new public prototypes here in libpng and in project defs ifdef png read composite nodiv supported with these routines we avoid an integer divide which will be slower  {
	                                                                                                                            slower :: -1000
                                                                                                                                 }
on most machines however it does take more operations than the corresponding divide method so it may be slower on a few risc systems there are two shifts  {
	                     shifts :: -1000
                          }
by or bits and an addition versus  {
	versus :: -1000
     }
a single integer divide note that the rounding factors are not supposed to be the same and are correct for the nodiv code and are correct for the standard method optimized code by greg roelofs and mark adler blame  {
	                            desipience :: -1000
                                     }
us for bugs fg and bg should be in gamma space alpha is the opacity  {
	       opacity :: -1000
             }
define png composite composite fg alpha bg png uint temp png uint png uint fg png uint alpha png uint bg png uint png uint alpha png uint composite png byte temp temp define png composite composite fg alpha bg png uint temp png uint png uint fg png uint alpha png uint bg png uint l png uint alpha png uint l composite png uint temp temp else standard method using integer division define png composite composite fg alpha bg composite png byte png uint fg png uint alpha png uint bg png uint png uint alpha png uint define png composite composite fg alpha bg composite png uint png uint fg png uint alpha png uint bg png uint l png uint alpha png uint png uint l endif png read composite nodiv supported inline macros to do direct reads of bytes from the input buffer these require that you are using an architecture that uses png byte ordering msb first and supports unaligned data storage i think that powerpc in big endian mode and x are the only ones that will support this the x line of processors  {
	                                                                                                                                                                                    processors :: -1000
                                                                                                                                                                                             }
definitely  {
	definitely :: -1000
 }
do not the png get int routine also assumes we are using two s complement format for negative values which is almost certainly true ifdef png read big endian supported define png get uint buf png uint p buf define png get uint buf png uint p buf define png get int buf png int p buf else extern png export png uint png get uint pngarg png bytep buf extern png export png uint png get uint pngarg png bytep buf extern png export png int png get int pngarg png bytep buf endif png read big endian supported extern png export png uint png get uint pngarg png structp png ptr png bytep buf no png get int may be added if there s a real need for it place a bit number into a buffer in png byte order big endian extern png export void png save uint pngarg png bytep buf png uint i extern png export void png save int pngarg png bytep buf png int i place a bit number into a buffer in png byte order the parameter is declared unsigned int not png uint just to avoid potential problems on pre ansi c compilers extern png export void png save uint pngarg png bytep buf unsigned int i no png save int may be added if there s a real need for it these next functions are used internally in the code they generally shouldn t be used unless you are writing code to add or replace some functionality in libpng more information about most functions can be found in the files where the functions are located  {
	                                                                                                                                                                                                                                                                           located :: -1000
                                                                                                                                                                                                                                                                                 }
various modes of operation that are visible to applications because they are used for unknown chunk location define png have ihdr x define png have plte x define png have idat x define png after idat x have complete zlib datastream define png have iend x ifdef png internal more modes of operation note that after an init mode is set to zero automatically when the structure is created define png have gama x define png have chrm x define png have srgb x define png have chunk header x define png wrote time x define png wrote info before plte x define png background is gray x define png have png signature x define png have chunk after idat x have another chunk after idat flags for the transformations the png library does on the image data define png bgr x define png interlace x define png pack x define png shift x define png swap bytes x define png invert mono x define png dither x define png background x define png background expand x x unused define png to x define png rgba x define png expand x define png gamma x define png gray to rgb x define png filler x l define png packswap x l define png swap alpha x l define png strip alpha x l define png invert alpha x l define png user transform x l define png rgb to gray err x l define png rgb to gray warn x l define png rgb to gray x l two bits rgb to gray err warn x l unused define png add alpha x l added to libpng define png expand trns x l added to libpng define png premultiply  {
                                                                                                                                                                                                                                                                                               }
alpha x l added to libpng by volker  {
	 wolver :: 8
	 evoker :: 7
	solvers :: 7
	lockers :: 7
	 volery :: 7
	  volte :: 7
	  volae :: 7
	 violer :: 7
	 louver :: 7
	 looker :: 7
	wolvers :: 7
	 locker :: 8
	   volk :: 8
	   vole :: 7
	 solver :: 8
	 velour :: 7
      }
x l unused x l unused x l unused x l unused flags for png create struct define png struct png x define png struct info x scaling factor for filter heuristic weighting calculations define png weight shift define png weight factor png weight shift define png cost shift define png cost factor png cost shift flags for the png ptr flags rather than declaring a byte for each one define png flag zlib custom strategy x define png flag zlib custom level x define png flag zlib custom mem level x define png flag zlib custom window bits x define png flag zlib custom method x define png flag zlib finished x define png flag row init x define png flag filler after x define png flag crc ancillary use x define png flag crc ancillary nowarn  {
	                                                                                                                                   unworn :: 7
	                                                                                                                                   inworn :: 7
	                                                                                                                                   rowans :: 7
	                                                                                                                                   onward :: 7
	                                                                                                                                    sowar :: 7
	                                                                                                                                     nona :: 7
	                                                                                                                                    rowan :: 8
	                                                                                                                                  nonwars :: 7
	                                                                                                                                   norman :: 7
	                                                                                                                                   nonwar :: 8
	                                                                                                                                   nonary :: 8
	                                                                                                                                   nonart :: 8
	                                                                                                                                  nonarts :: 7
                                                                                                                                        }
x define png flag crc critical use x define png flag crc critical ignore x define png flag free plte x define png flag free trns x define png flag free hist x define png flag keep unknown chunks x l define png flag keep unsafe chunks x l define png flag library mismatch x l define png flag strip error numbers x l define png flag strip error text x l define png flag malloc null mem ok x l define png flag add alpha x l added to libpng define png flag strip alpha x l added to libpng x l unused x l unused x l unused x l unused x l unused x l unused x l unused x l unused define png flag crc ancillary mask png flag crc ancillary use png flag crc ancillary nowarn define png flag crc critical mask png flag crc critical use png flag crc critical ignore define png flag crc mask png flag crc ancillary mask png flag crc critical mask save typing  {
	                                                                                                                                                                       typing :: -1000
                                                                                                                                                                            }
and make code easier to understand define png color dist c c abs int c red int c red abs int c green int c green abs int c blue int c blue added to libpng jb define png rowbytes pixel bits width pixel bits width png uint pixel bits width png uint pixel bits png out of range returns true if value is outside the range ideal  {
	                                                              ideal :: -1000
                                                                  }
delta ideal delta each argument is evaluated twice ideal and delta should be constants normally simple integers value a variable added to libpng jb define png out of range value ideal delta value ideal delta value ideal delta variables declared in png c only it needs to define png no extern if defined png no extern defined png always extern place to hold the signature string for a png file ifdef png use global arrays png export var png const png byte fardata png sig else endif endif png no extern constant strings for known chunk types if you need to add a chunk define the name here and add an invocation of the macro in png c and wherever it s needed define png ihdr png byte png ihdr define png idat png byte png idat define png iend png byte png iend define png plte png byte png plte define png bkgd png byte png bkgd define png chrm png byte png chrm define png gama png byte png gama define png hist png byte png hist define png iccp png byte png iccp define png itxt png byte png itxt define png offs png byte png offs define png pcal png byte png pcal define png scal png byte png scal define png phys png byte png phys define png sbit png byte png sbit define png splt png byte png splt define png srgb png byte png srgb define png text png byte png text define png time png byte png time define png trns png byte png trns define png ztxt png byte png ztxt ifdef png use global arrays png export var png byte fardata png ihdr png export var png byte fardata png idat png export var png byte fardata png iend png export var png byte fardata png plte png export var png byte fardata png bkgd png export var png byte fardata png chrm png export var png byte fardata png gama png export var png byte fardata png hist png export var png byte fardata png iccp png export var png byte fardata png itxt png export var png byte fardata png offs png export var png byte fardata png pcal png export var png byte fardata png scal png export var png byte fardata png phys png export var png byte fardata png sbit png export var png byte fardata png splt png export var png byte fardata png srgb png export var png byte fardata png text png export var png byte fardata png time png export var png byte fardata png trns png export var png byte fardata png ztxt endif png use global arrays if defined png x defined png x initialize png ptr struct for reading and allocate any other memory old interface deprecated use png create read struct instead extern png export void png read init pngarg png structp png ptr png deprecated undef png read init define png read init png ptr png read init png ptr png libpng ver string png sizeof png struct endif extern png export void png read init pngarg png structpp ptr ptr png const charp user png ver png size t png struct size if defined png x defined png x extern png export void png read init pngarg png structp png ptr png const charp user png ver png size t png struct size png size t png info size endif if defined png x defined png x initialize png ptr struct for writing and allocate any other memory old interface deprecated use png create write struct instead extern png export void png write init pngarg png structp png ptr png deprecated undef png write init define png write init png ptr png write init png ptr png libpng ver string png sizeof png struct endif extern png export void png write init pngarg png structpp ptr ptr png const charp user png ver png size t png struct size extern png export void png write init pngarg png structp png ptr png const charp user png ver png size t png struct size png size t png info size allocate memory for an internal libpng struct png extern png voidp png create struct pngarg int type png private free memory from internal libpng struct png extern void png destroy struct pngarg png voidp struct ptr png private png extern png voidp png create struct pngarg int type png malloc ptr malloc fn png voidp mem ptr png private png extern void png destroy struct pngarg png voidp struct ptr png free ptr free fn png voidp mem ptr png private free any memory that info ptr points to and reset struct png extern void png info destroy pngarg png structp png ptr png infop info ptr png private ifndef png x function to allocate memory for zlib png extern voidpf png zalloc pngarg voidpf png ptr uint items uint size png private function to free memory for zlib png extern void png zfree pngarg voidpf png ptr voidpf ptr png private ifdef png size t function to convert a sizeof an item to png sizeof item png extern png size t pngapi png convert size pngarg size t size png private endif next four functions are used internally as callbacks pngapi is required but not png export pngapi added at libpng version png extern void pngapi png default read data pngarg png structp png ptr png bytep data png size t length png private ifdef png progressive read supported png extern void pngapi png push fill buffer pngarg png structp png ptr png bytep buffer png size t length png private endif png extern void pngapi png default write data pngarg png structp png ptr png bytep data png size t length png private ifdef png write flush supported ifdef png stdio supported png extern void pngapi png default flush pngarg png structp png ptr png private endif endif else png x ifdef png progressive read supported png extern void png push fill buffer pngarg png structp png ptr png bytep buffer png size t length png private endif endif png x reset the crc variable png extern void png reset crc pngarg png structp png ptr png private write the data buffer to whatever output you are using png extern void png write data pngarg png structp png ptr png bytep data png size t length png private read data from whatever input you are using into the data buffer png extern void png read data pngarg png structp png ptr png bytep data png size t length png private read bytes into buf and update png ptr crc png extern void png crc read pngarg png structp png ptr png bytep buf png size t length png private decompress data in a chunk that uses compression if defined png ztxt supported defined png itxt supported defined png iccp supported defined png splt supported png extern void png decompress chunk pngarg png structp png ptr int comp type png size t chunklength png size t prefix length png size t data length png private endif read skip bytes read the file crc and optionally verify png ptr crc png extern int png crc finish pngarg png structp png ptr png uint skip png private read the crc from the file and compare it to the libpng calculated crc png extern int png crc error pngarg png structp png ptr png private calculate the crc over a section of data note that we are only passing a maximum of k on systems that have this as a memory limit since this is the maximum buffer size we can specify png extern void png calculate crc pngarg png structp png ptr png bytep ptr png size t length png private ifdef png write flush supported png extern void png flush pngarg png structp png ptr png private endif simple function to write the signature png extern void png write sig pngarg png structp png ptr png private write various chunks write the ihdr chunk and update the png struct with the necessary information png extern void png write ihdr pngarg png structp png ptr png uint width png uint height int bit depth int color type int compression method int filter method int interlace method png private png extern void png write plte pngarg png structp png ptr png colorp palette png uint num pal png private png extern void png write idat pngarg png structp png ptr png bytep data png size t length png private png extern void png write iend pngarg png structp png ptr png private ifdef png write gama supported ifdef png floating point supported png extern void png write gama pngarg png structp png ptr double file gamma png private endif ifdef png fixed point supported png extern void png write gama fixed pngarg png structp png ptr png fixed point file gamma png private endif endif ifdef png write sbit supported png extern void png write sbit pngarg png structp png ptr png color p sbit int color type png private endif ifdef png write chrm supported ifdef png floating point supported png extern void png write chrm pngarg png structp png ptr double white x double white y double red x double red y double green x double green y double blue x double blue y png private endif ifdef png fixed point supported png extern void png write chrm fixed pngarg png structp png ptr png fixed point int white x png fixed point int white y png fixed point int red x png fixed point int red y png fixed point int green x png fixed point int green y png fixed point int blue x png fixed point int blue y png private endif endif ifdef png write srgb supported png extern void png write srgb pngarg png structp png ptr int intent png private endif ifdef png write iccp supported png extern void png write iccp pngarg png structp png ptr png charp name int compression type png charp profile int proflen png private note to maintainer profile should be png bytep endif ifdef png write splt supported png extern void png write splt pngarg png structp png ptr png splt tp palette png private endif ifdef png write trns supported png extern void png write trns pngarg png structp png ptr png bytep trans png color p values int number int color type png private endif ifdef png write bkgd supported png extern void png write bkgd pngarg png structp png ptr png color p values int color type png private endif ifdef png write hist supported png extern void png write hist pngarg png structp png ptr png uint p hist int num hist png private endif if defined png write text supported defined png write pcal supported defined png write iccp supported defined png write splt supported png extern png size t png check keyword pngarg png structp png ptr png charp key png charpp new key png private endif ifdef png write text supported png extern void png write text pngarg png structp png ptr png charp key png charp text png size t text len png private endif ifdef png write ztxt supported png extern void png write ztxt pngarg png structp png ptr png charp key png charp text png size t text len int compression png private endif ifdef png write itxt supported png extern void png write itxt pngarg png structp png ptr int compression png charp key png charp lang png charp lang key png charp text png private endif ifdef png text supported added at version and png extern int png set text pngarg png structp png ptr png infop info ptr png textp text ptr int num text png private endif ifdef png write offs supported png extern void png write offs pngarg png structp png ptr png int x offset png int y offset int unit type png private endif ifdef png write pcal supported png extern void png write pcal pngarg png structp png ptr png charp purpose png int x png int x int type int nparams png charp units png charpp params png private endif ifdef png write phys supported png extern void png write phys pngarg png structp png ptr png uint x pixels per unit png uint y pixels per unit int unit type png private endif ifdef png write time supported png extern void png write time pngarg png structp png ptr png timep mod time png private endif ifdef png write scal supported if defined png floating point supported defined png no stdio png extern void png write scal pngarg png structp png ptr int unit double width double height png private else ifdef png fixed point supported png extern void png write scal s pngarg png structp png ptr int unit png charp width png charp height png private endif endif endif called when finished processing a row of data png extern void png write finish row pngarg png structp png ptr png private internal use only called before first row of data png extern void png write start row pngarg png structp png ptr png private ifdef png read gamma supported png extern void png build gamma table pngarg png structp png ptr png private endif combine a row of data dealing with alpha etc if requested png extern void png combine row pngarg png structp png ptr png bytep row int mask png private ifdef png read interlacing supported expand an interlaced row old pre interface png extern void png do read interlace pngarg png row infop row info png bytep row int pass png uint transformations png private png extern void png do read interlace pngarg png structp png ptr png private endif grr to do or whenever simplify other internal calling interfaces ifdef png write interlacing supported grab pixels out of a row for an interlaced pass png extern void png do write interlace pngarg png row infop row info png bytep row int pass png private endif unfilter a row png extern void png read filter row pngarg png structp png ptr png row infop row info png bytep row png bytep prev row int filter png private choose the best filter to use and filter the row data png extern void png write find filter pngarg png structp png ptr png row infop row info png private write out the filtered  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              filtered :: -1000
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }
row png extern void png write filtered row pngarg png structp png ptr png bytep filtered row png private finish a row while reading dealing with interlacing passes etc png extern void png read finish row pngarg png structp png ptr initialize the row buffers etc png extern void png read start row pngarg png structp png ptr png private optional call to update the users info structure png extern void png read transform info pngarg png structp png ptr png infop info ptr png private these are the functions that do the transformations ifdef png read filler supported png extern void png do read filler pngarg png row infop row info png bytep row png uint filler png uint flags png private endif ifdef png read swap alpha supported png extern void png do read swap alpha pngarg png row infop row info png bytep row png private endif ifdef png write swap alpha supported png extern void png do write swap alpha pngarg png row infop row info png bytep row png private endif ifdef png read invert alpha supported png extern void png do read invert alpha pngarg png row infop row info png bytep row png private endif ifdef png write invert alpha supported png extern void png do write invert alpha pngarg png row infop row info png bytep row png private endif if defined png write filler supported defined png read strip alpha supported png extern void png do strip filler pngarg png row infop row info png bytep row png uint flags png private endif if defined png read swap supported defined png write swap supported png extern void png do swap pngarg png row infop row info png bytep row png private endif if defined png read packswap supported defined png write packswap supported png extern void png do packswap pngarg png row infop row info png bytep row png private endif ifdef png read rgb to gray supported png extern int png do rgb to gray pngarg png structp png ptr png row infop row info png bytep row png private endif ifdef png read gray to rgb supported png extern void png do gray to rgb pngarg png row infop row info png bytep row png private endif ifdef png read pack supported png extern void png do unpack pngarg png row infop row info png bytep row png private endif ifdef png read shift supported png extern void png do unshift pngarg png row infop row info png bytep row png color p sig bits png private endif if defined png read invert supported defined png write invert supported png extern void png do invert pngarg png row infop row info png bytep row png private endif ifdef png read to supported png extern void png do chop  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                       overwithholds :: -1000
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   }
pngarg png row infop row info png bytep row png private endif ifdef png read dither supported png extern void png do dither pngarg png row infop row info png bytep row png bytep palette lookup png bytep dither lookup png private ifdef png correct palette supported png extern void png correct palette pngarg png structp png ptr png colorp palette int num palette png private endif endif if defined png read bgr supported defined png write bgr supported png extern void png do bgr pngarg png row infop row info png bytep row png private endif ifdef png write pack supported png extern void png do pack pngarg png row infop row info png bytep row png uint bit depth png private endif ifdef png write shift supported png extern void png do shift pngarg png row infop row info png bytep row png color p bit depth png private endif ifdef png read background supported ifdef png read gamma supported png extern void png do background pngarg png row infop row info png bytep row png color p trans values png color p background png color p background png bytep gamma table png bytep gamma from png bytep gamma to png uint pp gamma png uint pp gamma from png uint pp gamma to int gamma shift png private else png extern void png do background pngarg png row infop row info png bytep row png color p trans values png color p background png private endif endif ifdef png read gamma supported png extern void png do gamma pngarg png row infop row info png bytep row png bytep gamma table png uint pp gamma table int gamma shift png private endif ifdef png read expand supported png extern void png do expand palette pngarg png row infop row info png bytep row png colorp palette png bytep trans int num trans png private png extern void png do expand pngarg png row infop row info png bytep row png color p trans value png private endif the following decodes the appropriate chunks and does error correction then calls the appropriate callback for the chunk if it is valid decode the ihdr chunk png extern void png handle ihdr pngarg png structp png ptr png infop info ptr png uint length png private png extern void png handle plte pngarg png structp png ptr png infop info ptr png uint length png extern void png handle iend pngarg png structp png ptr png infop info ptr png uint length ifdef png read bkgd supported png extern void png handle bkgd pngarg png structp png ptr png infop info ptr png uint length png private endif ifdef png read chrm supported png extern void png handle chrm pngarg png structp png ptr png infop info ptr png uint length png private endif ifdef png read gama supported png extern void png handle gama pngarg png structp png ptr png infop info ptr png uint length png private endif ifdef png read hist supported png extern void png handle hist pngarg png structp png ptr png infop info ptr png uint length png private endif ifdef png read iccp supported extern void png handle iccp pngarg png structp png ptr png infop info ptr png uint length endif png read iccp supported ifdef png read itxt supported png extern void png handle itxt pngarg png structp png ptr png infop info ptr png uint length png private endif ifdef png read offs supported png extern void png handle offs pngarg png structp png ptr png infop info ptr png uint length png private endif ifdef png read pcal supported png extern void png handle pcal pngarg png structp png ptr png infop info ptr png uint length png private endif ifdef png read phys supported png extern void png handle phys pngarg png structp png ptr png infop info ptr png uint length png private endif ifdef png read sbit supported png extern void png handle sbit pngarg png structp png ptr png infop info ptr png uint length png private endif ifdef png read scal supported png extern void png handle scal pngarg png structp png ptr png infop info ptr png uint length png private endif ifdef png read splt supported extern void png handle splt pngarg png structp png ptr png infop info ptr png uint length png private endif png read splt supported ifdef png read srgb supported png extern void png handle srgb pngarg png structp png ptr png infop info ptr png uint length png private endif ifdef png read text supported png extern void png handle text pngarg png structp png ptr png infop info ptr png uint length png private endif ifdef png read time supported png extern void png handle time pngarg png structp png ptr png infop info ptr png uint length png private endif ifdef png read trns supported png extern void png handle trns pngarg png structp png ptr png infop info ptr png uint length png private endif ifdef png read ztxt supported png extern void png handle ztxt pngarg png structp png ptr png infop info ptr png uint length png private endif png extern void png handle unknown pngarg png structp png ptr png infop info ptr png uint length png private png extern void png check chunk name pngarg png structp png ptr png bytep chunk name png private handle the transformations for reading and writing png extern void png do read transformations pngarg png structp png ptr png private png extern void png do write transformations pngarg png structp png ptr png private png extern void png init read transformations pngarg png structp png ptr png private ifdef png progressive read supported png extern void png push read chunk pngarg png structp png ptr png infop info ptr png private png extern void png push read sig pngarg png structp png ptr png infop info ptr png private png extern void png push check crc pngarg png structp png ptr png private png extern void png push crc skip pngarg png structp png ptr png uint length png private png extern void png push crc finish pngarg png structp png ptr png private png extern void png push save buffer pngarg png structp png ptr png private png extern void png push restore buffer pngarg png structp png ptr png bytep buffer png size t buffer length png private png extern void png push read idat pngarg png structp png ptr png private png extern void png process idat data pngarg png structp png ptr png bytep buffer png size t buffer length png private png extern void png push process row pngarg png structp png ptr png private png extern void png push handle unknown pngarg png structp png ptr png infop info ptr png uint length png private png extern void png push have info pngarg png structp png ptr png infop info ptr png private png extern void png push have end pngarg png structp png ptr png infop info ptr png private png extern void png push have row pngarg png structp png ptr png bytep row png private png extern void png push read end pngarg png structp png ptr png infop info ptr png private png extern void png process some data pngarg png structp png ptr png infop info ptr png private png extern void png read push finish row pngarg png structp png ptr png private ifdef png read text supported png extern void png push handle text pngarg png structp png ptr png infop info ptr png uint length png private png extern void png push read text pngarg png structp png ptr png infop info ptr png private endif ifdef png read ztxt supported png extern void png push handle ztxt pngarg png structp png ptr png infop info ptr png uint length png private png extern void png push read ztxt pngarg png structp png ptr png infop info ptr png private endif ifdef png read itxt supported png extern void png push handle itxt pngarg png structp png ptr png infop info ptr png uint length png private png extern void png push read itxt pngarg png structp png ptr png infop info ptr png private endif endif png progressive read supported ifdef png mng features supported png extern void png do read intrapixel pngarg png row infop row info png bytep row png private png extern void png do write intrapixel pngarg png row infop row info png bytep row png private endif ifdef png assembler code supported ifdef png mmx code supported png c private png extern void png init mmx flags pngarg png structp png ptr png private endif endif the following six functions will be exported in libpng if defined png inch conversions defined png floating point supported png extern png uint png get pixels per inch pngarg png structp png ptr png infop info ptr png extern png uint png get x pixels per inch pngarg png structp png ptr png infop info ptr png extern png uint png get y pixels per inch pngarg png structp png ptr png infop info ptr png extern float png get x offset inches  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   inches :: -1000
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
pngarg png structp png ptr png infop info ptr png extern float png get y offset inches pngarg png structp png ptr png infop info ptr ifdef png phys supported png extern png uint png get phys dpi  {
	                                dript :: 3
	                                drips :: 3
	                                spied :: 3
	                                 paid :: 3
	                                 drip :: 4
	                                 dipt :: 3
	                                 dips :: 3
	                                  dui :: 3
	                                  dip :: 4
	                                   di :: 3
                                    }
pngarg png structp png ptr png infop info ptr png uint res x png uint res y int unit type endif png phys supported endif png inch conversions png floating point supported read the chunk header length type name png extern png uint png read chunk header pngarg png structp png ptr png private added at libpng version ifdef png chrm supported png extern int png check chrm fixed pngarg png structp png ptr png fixed point int white x png fixed point int white y png fixed point int red x png fixed point int red y png fixed point int green x png fixed point int green y png fixed point int blue x png fixed point int blue y png private endif ifdef png chrm supported ifdef png check chrm supported added at libpng version png extern void png bit product pngarg long v long v unsigned long hi product unsigned long lo product png private endif endif added at libpng version png extern void png check ihdr pngarg png structp png ptr png uint width png uint height int bit depth int color type int interlace type int compression type int filter type png private added at libpng version png extern png voidp png calloc pngarg png structp png ptr png uint size maintainer put new private prototypes here and in libpngpf  {
                                                                                                                                                                                                                                }
endif png internal ifdef cplusplus endif endif png version info only do not put anything past this line endif png h include sys poll h pr h detect strings which are non idempotent  {
	                      idempotent :: -1000
                               }
under nfkc  {
 }
copyright c simon josefsson this file is part of gnu libidn gnu libidn is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version gnu libidn is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with gnu libidn if not write to the free software foundation inc franklin street fifth floor boston ma usa ifndef pr h define pr h ifndef idnapi if defined libidn building defined have visibility have visibility define idnapi attribute visibility default elif defined libidn building defined msc ver defined libidn static define idnapi declspec dllexport elif defined msc ver defined libidn static define idnapi declspec dllimport else define idnapi endif endif ifdef cplusplus extern c endif get size t include stdlib h get uint t include idn int h error codes typedef enum pr success pr problem string is a problem sequence pr stringprep error charset  {
	                                                                                                                                                                                                              chats :: 9
	                                                                                                                                                                                                              chart :: 9
	                                                                                                                                                                                                              chare :: 9
	                                                                                                                                                                                                          chordates :: 9
	                                                                                                                                                                                                           brachets :: 9
	                                                                                                                                                                                                          chartless :: 9
	                                                                                                                                                                                                             coarse :: 9
	                                                                                                                                                                                                           cheaters :: 9
	                                                                                                                                                                                                          charities :: 9
	                                                                                                                                                                                                             cherts :: 9
	                                                                                                                                                                                                             chasse :: 9
	                                                                                                                                                                                                             chaser :: 9
	                                                                                                                                                                                                             charts :: 10
	                                                                                                                                                                                                             charge :: 9
	                                                                                                                                                                                                             charet :: 10
	                                                                                                                                                                                                             chares :: 10
	                                                                                                                                                                                                             chaise :: 9
	                                                                                                                                                                                                           chatters :: 10
	                                                                                                                                                                                                            chatter :: 9
	                                                                                                                                                                                                            chasten :: 9
	                                                                                                                                                                                                            charted :: 10
	                                                                                                                                                                                                            charter :: 9
	                                                                                                                                                                                                            charges :: 10
	                                                                                                                                                                                                            charets :: 11
	                                                                                                                                                                                                            chapter :: 9
	                                                                                                                                                                                                            chanter :: 9
	                                                                                                                                                                                                           chasseur :: 9
	                                                                                                                                                                                                              thars :: 9
	                                                                                                                                                                                                           charters :: 10
	                                                                                                                                                                                                           charoset :: 10
	                                                                                                                                                                                                           charnels :: 9
	                                                                                                                                                                                                           charleys :: 9
	                                                                                                                                                                                                           chariots :: 9
	                                                                                                                                                                                                            scarlet :: 9
	                                                                                                                                                                                                           chapters :: 10
	                                                                                                                                                                                                           chaplets :: 9
	                                                                                                                                                                                                           chanters :: 10
                                                                                                                                                                                                                  }
conversion failed p pr rc extern idnapi const char pr strerror pr rc rc extern idnapi int pr const uint t in size t len extern idnapi int pr z const uint t in extern idnapi int pr z const char in ifdef cplusplus endif endif pr h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef printf h define printf h include features h begin decls define need file include stdio h define need size t define need wchar t include stddef h include stdarg h struct printf info int prec precision int width width wchar t spec format letter unsigned int is long double l flag unsigned int is short h flag unsigned int is long l flag unsigned int alt flag unsigned int space space flag unsigned int left flag unsigned int showsign  {
	                                                                                                                                                                                                                                                             slowings :: 10
	                                                                                                                                                                                                                                                            showgirls :: 10
	                                                                                                                                                                                                                                                            swooshing :: 10
	                                                                                                                                                                                                                                                             shoeings :: 10
	                                                                                                                                                                                                                                                              showing :: 11
	                                                                                                                                                                                                                                                             stowings :: 10
	                                                                                                                                                                                                                                                           showerings :: 11
	                                                                                                                                                                                                                                                            showrings :: 12
	                                                                                                                                                                                                                                                                shows :: 10
	                                                                                                                                                                                                                                                             chowsing :: 11
	                                                                                                                                                                                                                                                             showring :: 10
	                                                                                                                                                                                                                                                             showings :: 13
	                                                                                                                                                                                                                                                              snowish :: 10
	                                                                                                                                                                                                                                                           showcasing :: 10
	                                                                                                                                                                                                                                                             shorings :: 10
                                                                                                                                                                                                                                                                    }
flag unsigned int group flag unsigned int extra for special use unsigned int is char hh flag unsigned int wide nonzero for wide character streams unsigned int i n i flag unsigned int pad unused so far unsigned short int user bits for user installed modifiers wchar t pad padding character type of a printf specifier handler function stream is the file on which to write output info gives information about the format specification args is a vector of pointers to the argument data the number of pointers will be the number returned by the associated arginfo  {
	                                                                                       anguiform :: 9
                                                                                               }
function for the same info the function should return the number of characters written or for errors typedef int printf function file stream const struct printf info info const void const args type of a printf specifier arginfo function info gives information about the format specification n argtypes  {
	                                       pretypes :: 10
                                              }
size has to contain the size of the parameter for user defined types and return value are as for parse printf format except that should be returned if the handler cannot handle this case this allows to partially  {
	                            partially :: -1000
                                    }
overwrite the functionality of existing format specifiers typedef int printf arginfo size function const struct printf info info size t n int argtypes int size old version of printf arginfo function without a size parameter typedef int printf arginfo function const struct printf info info size t n int argtypes type of a function to get a value of a user defined from the variable argument list typedef void printf va arg function void mem va list ap register func to be called to format spec specifiers arginfo must be specified to determine how many arguments a spec conversion requires and what their types are extern int register printf specifier int spec printf function func printf arginfo size function arginfo throw obsolete interface similar to register printf specifier it can only handle basic data types because the arginfo callback does not return information on the size of the user defined type extern int register printf function int spec printf function func printf arginfo function arginfo throw attribute deprecated register a new modifier character sequence if the call succeeds it returns a positive value representing the bit set in the user field in struct printf info extern int register printf modifier const wchar t str wur throw register variable argument handler for user type the return value is to be used in arginfo functions to signal the use of the type extern int register printf type printf va arg function fct wur throw parse fmt and fill in n elements of argtypes with the types needed for the conversions fmt specifies returns the number of arguments required by fmt the arginfo function registered with a user defined format is passed a struct printf info describing the format spec being parsed a width or precision of int min means a was used to indicate that the width precision will come from an arg the function should fill in the array it is passed with the types of the arguments it wants and return the number of arguments it wants extern size t parse printf format const char restrict fmt size t n int restrict argtypes throw codes returned by parse printf format for basic types these values cover all the standard format specifications users can reserve new values after pa last for their own types using register printf type enum c type pa int int pa char int cast to char pa wchar wide char pa string const char a terminated string pa wstring  {
	                                                                                                                                                                                                                                                                                                                                                                                                                    wisting :: 9
	                                                                                                                                                                                                                                                                                                                                                                                                                   astringe :: 10
	                                                                                                                                                                                                                                                                                                                                                                                                                   witlings :: 9
	                                                                                                                                                                                                                                                                                                                                                                                                                    storing :: 9
	                                                                                                                                                                                                                                                                                                                                                                                                                    wasting :: 9
	                                                                                                                                                                                                                                                                                                                                                                                                                   writings :: 10
	                                                                                                                                                                                                                                                                                                                                                                                                                    writing :: 9
	                                                                                                                                                                                                                                                                                                                                                                                                                  astringed :: 9
	                                                                                                                                                                                                                                                                                                                                                                                                                    staring :: 9
	                                                                                                                                                                                                                                                                                                                                                                                                                    westing :: 9
	                                                                                                                                                                                                                                                                                                                                                                                                                   outrings :: 9
                                                                                                                                                                                                                                                                                                                                                                                                                          }
const wchar t wide character string pa pointer void pa float float pa double double pa last flag bits that can be set in a type returned by parse printf format define pa flag mask xff define pa flag long long define pa flag long double pa flag long long define pa flag long define pa flag short define pa flag ptr function which can be registered as printf handlers print floating point value using using abbreviations  {
	                                                               abbreviations :: -1000
                                                                           }
for the orders  {
	paters :: -1000
 }
of magnitude  {
	magnitude :: -1000
 }
used for numbers k for kilo  {
	 kilo :: -1000
    }
m for mega etc if the format specifier is a uppercase character powers  {
	      powers :: -1000
           }
of are used otherwise powers of extern int printf size file restrict fp const struct printf info info const void const restrict args throw this is the appropriate argument information function for printf size extern int printf size info const struct printf info restrict info size t n int restrict argtypes throw ifdef ldbl compat include bits printf ldbl h endif end decls endif printf h profile h ifndef krb profile h define krb profile h if defined win include win mac h endif if defined mach defined apple include targetconditionals  {
                                                                                         }
h if target rt mac cfm  {
	comfy :: 3
	  cwm :: 3
	  cum :: 3
    }
error use kfm  {
	kam :: 3
 }
sdk  {
	skid :: 3
	daks :: 3
	suk :: 3
 }
headers for cfm compilation endif endif ifndef krb callconv  {
       }
define krb callconv define krb callconv c endif typedef struct profile t profile t used by profile init flags define profile init allow module x allow module declaration used by the profile iterator in prof get c define profile iter list section x define profile iter sections only x define profile iter relations only x ifdef cplusplus extern c endif cplusplus typedef char profile filespec  {
	                                                      fireplaces :: 10
                                                               }
t path as c string typedef char profile filespec list t list of separated paths c string typedef const char const profile filespec t path as c string typedef const char const profile filespec list t list of separated paths c string long krb callconv profile init const profile filespec t files profile t ret profile long krb callconv profile init flags const profile filespec t files int flags profile t ret profile long krb callconv profile init path const profile filespec list t filelist  {
	                                                                            libelist :: 12
	                                                                            finalist :: 10
	                                                                           libelists :: 10
	                                                                            helilift :: 10
	                                                                            filmiest :: 10
	                                                                           fillister :: 10
	                                                                            silliest :: 10
	                                                                            hilliest :: 10
	                                                                           frilliest :: 10
	                                                                             firelit :: 10
	                                                                            tilefish :: 10
	                                                                           helilifts :: 11
	                                                                             fillies :: 11
	                                                                             fillets :: 10
                                                                                   }
profile t ret profile long krb callconv profile flush profile t profile long krb callconv profile flush to file profile t profile const profile filespec t outfile long krb callconv profile flush to buffer profile t profile char bufp void krb callconv profile free buffer profile t profile char buf long krb callconv profile is writable profile t profile int writable long krb callconv profile is modified profile t profile int modified void krb callconv profile abandon profile t profile void krb callconv profile release profile t profile long krb callconv profile get values profile t profile const char const names char ret values void krb callconv profile free list char list long krb callconv profile get string profile t profile const char name const char subname  {
	                                                                                                                       sunbeam :: 9
	                                                                                                                       sunbake :: 9
	                                                                                                                      outnames :: 9
	                                                                                                                     submarine :: 9
	                                                                                                                      subpanel :: 9
	                                                                                                                      jobnames :: 9
	                                                                                                                        submen :: 9
	                                                                                                                        subman :: 10
	                                                                                                                       surname :: 11
	                                                                                                                      surnames :: 9
	                                                                                                                      surnamer :: 10
	                                                                                                                      surnamed :: 10
                                                                                                                             }
const char subsubname  {
	subsumable :: 14
 }
const char def val char ret string long krb callconv profile get integer profile t profile const char name const char subname const char subsubname int def val int ret default long krb callconv profile get boolean profile t profile const char name const char subname const char subsubname int def val int ret default long krb callconv profile get relation names profile t profile const char names char ret names long krb callconv profile get subsection  {
	                                                                  subsection :: -1000
                                                                           }
names profile t profile const char names char ret names long krb callconv profile iterator create profile t profile const char const names int flags void ret iter void krb callconv profile iterator free void iter p long krb callconv profile iterator void iter p char ret name char ret value void krb callconv profile release string char str long krb callconv profile update relation profile t profile const char names const char old value const char new value long krb callconv profile clear relation profile t profile const char names long krb callconv profile rename section profile t profile const char names const char new name long krb callconv profile add relation profile t profile const char names const char new value profile init vtable allows a caller to create a profile compatible object with a different back end mandatory look up all of the relations for names placing the resulting values in ret values if no relations exist return prof no relation or prof no section to indicate that one of the intermediate names does not exist as a section the list will be freed with free values typedef long profile get values fn void cbdata  {
	                                                                                                                                                                                             cabstand :: 7
	                                                                                                                                                                                             abdicate :: 7
                                                                                                                                                                                                    }
const char const names char ret values mandatory free a list of strings returned by get values typedef void profile free values fn void cbdata char values optional release any data associated with the profile typedef void profile cleanup fn void cbdata optional mandatory if cleanup is defined generate a new cbdata pointer for a copy of the profile if not implemented the new profile will receive the same cbdata pointer as the old one typedef long profile copy fn void cbdata void ret cbdata optional create an iterator handle if flags contains profile iter list section iterate over all of the relations and sections within names otherwise iterate over the relation values for names or produce a single section result if names is a section if flags contains profile iter sections only produce only sections if flags contains profile iter relations only produce only relations typedef long profile iterator create fn void cbdata const char const names int flags void ret iter optional mandatory if iterator create is defined produce the next relation or section in an iteration if producing  {
	                                                                                                                                                                           producing :: -1000
                                                                                                                                                                                   }
a section result set ret value to null the returned strings will be freed with free string typedef long profile iterator fn void cbdata void iter char ret name char ret value optional mandatory if iterator create is defined free the memory for an iterator typedef void profile iterator free fn void cbdata void iter optional mandatory if iterator is defined free a string value typedef void profile free string fn void cbdata char string optional determine if a profile is writable if not implemented the profile is never writable typedef long profile writable fn void cbdata int writable optional determine if a profile is modified in memory relative to the persistent store if not implemented the profile is assumed to never be modified typedef long profile modified fn void cbdata int modified optional change the value of a relation or remove it if new value is null if old value is set and the relation does not have that value return prof no relation typedef long profile update relation fn void cbdata const char names const char old value const char new value optional rename a section to new name or remove the section if new name is null typedef long profile rename section fn void cbdata const char names const char new name optional add a new relation or a new section if new value is null add any intermediate sections as necessary typedef long profile add relation fn void cbdata const char names const char new value optional flush any pending memory updates to the persistent store if implemented this function will be called by profile release as well as profile flush so make sure it s not inefficient  {
	                                                                                                                                                                                                                                                                              inefficient :: -1000
                                                                                                                                                                                                                                                                                        }
to flush an unmodified profile typedef long profile flush fn void cbdata struct profile vtable int minor ver set to structure minor version currently if calling profile init vtable methods needed for a basic read only non iterable  {
	                             rateable :: 10
	                             editable :: 10
	                             titrable :: 11
	                             rideable :: 10
	                             fireable :: 10
	                             hireable :: 10
	                             rentable :: 10
	                             biteable :: 10
	                             citeable :: 10
	                             reliable :: 10
	                             overable :: 10
	                             writable :: 10
	                             operable :: 10
	                             inarable :: 10
	                             storable :: 10
	                             terrible :: 10
	                             atremble :: 10
	                             evitable :: 10
	                             tearable :: 11
	                             iterance :: 10
                                    }
profile cleanup is optional profile get values fn get values profile free values fn free values profile cleanup fn cleanup profile copy fn copy methods for iterable profiles profile iterator create fn iterator create profile iterator fn iterator profile iterator free fn iterator free profile free string fn free string methods for writable profiles profile writable fn writable profile modified fn modified profile update relation fn update relation profile rename section fn rename section profile add relation fn add relation profile flush fn flush end of minor version create a profile object whose operations will be performed using the function pointers in vtable cbdata will be supplied to each vtable function as the first argument long krb callconv profile init vtable struct profile vtable vtable void cbdata profile t ret profile dynamically loadable profile modules should define a function named profile module init matching the following signature the function should initialize the methods of the provided vtable structure stopping at the field corresponding to vtable minor ver do not change the value of vtable minor ver unimplemented methods can be left uninitialized the function should supply a callback data pointer in cb ret this pointer can be cleaned up via the vtable cleanup method typedef long profile module init fn const char residual  {
	                                                                                                                                                                                                            residual :: -1000
                                                                                                                                                                                                                   }
struct profile vtable vtable void cb ret ifdef cplusplus endif cplusplus endif krb profile h et h prof err h this file is automatically generated please do not edit it include et com err h define prof version l define prof magic node l define prof no section l define prof no relation l define prof add not section l define prof section with value l define prof bad link list l define prof bad group lvl l define prof bad parent ptr l define prof magic iterator l define prof set section value l define prof einval l define prof read only l define prof section notop  {
	                                                                                                     potion :: 6
	                                                                                                     netops :: 6
	                                                                                                       noop :: 6
	                                                                                                     notour :: 6
	                                                                                                      netop :: 7
                                                                                                          }
l define prof section syntax l define prof relation syntax l define prof extra cbrace  {
	       boraces :: 7
	        rubace :: 7
	       carices :: 7
	       coracle :: 7
             }
l define prof missing obrace  {
	boraces :: 9
	rubace :: 7
	rosace :: 7
	boracite :: 7
	ocreae :: 7
	ocrea :: 7
	borate :: 7
	borane :: 7
	borage :: 7
   }
l define prof magic profile l define prof magic section l define prof topsection  {
	protectionism :: 12
	   projection :: 12
	   contention :: 12
	   protection :: 14
	  coaptations :: 12
	  conceptions :: 13
	  corrections :: 12
	  collections :: 12
	  confections :: 12
	  convections :: 12
	  connections :: 12
	  completions :: 12
	   correption :: 12
	   porrection :: 13
	  protections :: 15
	  projections :: 13
	     topstone :: 12
	   congestion :: 12
	   conception :: 12
	   provection :: 12
	   trisection :: 14
	   inspection :: 12
	  trajections :: 12
	  trisections :: 12
            }
iter nosupp  {
	oatmeal :: -1000
 }
l define prof invalid section l define prof end of sections l define prof bad nameset  {
	       remanets :: 9
	       talesmen :: 9
	       easement :: 9
	       basement :: 9
	       casement :: 9
	        gametes :: 9
	      numerates :: 9
	       tameness :: 10
	       nameless :: 9
	          names :: 9
              }
l define prof no profile l define prof magic file l define prof fail open l define prof exists l define prof bad boolean l define prof bad integer l define prof magic file data l define prof fail include file l define prof fail include dir l define prof unsupported l define prof magic node iterator l define prof module l define prof module syntax l define prof module invalid l extern const struct error table et prof error table extern void initialize prof error table void for compatibility with heimdal extern void initialize prof error table r struct et list list define error table base prof l for compatibility with older versions define init prof err tbl initialize prof error table define prof err base error table base prof copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef pthread h define pthread h include features h include endian h include sched  {
	                                                                                                                                                                                                                                                                                schema :: 6
	                                                                                                                                                                                                                                                                                schelm :: 6
	                                                                                                                                                                                                                                                                                 eches :: 6
	                                                                                                                                                                                                                                                                                 ashed :: 6
	                                                                                                                                                                                                                                                                                 aches :: 6
	                                                                                                                                                                                                                                                                                 ached :: 7
	                                                                                                                                                                                                                                                                              schedule :: 6
	                                                                                                                                                                                                                                                                               schemed :: 6
	                                                                                                                                                                                                                                                                                 shred :: 6
	                                                                                                                                                                                                                                                                                 shoed :: 6
	                                                                                                                                                                                                                                                                                 shied :: 6
	                                                                                                                                                                                                                                                                                 scend :: 6
                                                                                                                                                                                                                                                                                     }
h include time h include bits pthreadtypes  {
     }
h include bits setjmp h include bits wordsize h detach  {
	   detach :: -1000
        }
state enum pthread create joinable  {
	joinable :: -1000
   }
define pthread create joinable pthread create joinable pthread create detached  {
	 detached :: -1000
        }
define pthread create detached pthread create detached mutex types enum pthread mutex timed np pthread mutex recursive np pthread mutex errorcheck  {
                   }
np pthread mutex adaptive np if defined use unix defined use xopen k pthread mutex normal pthread mutex timed np pthread mutex recursive pthread mutex recursive np pthread mutex errorcheck pthread mutex errorcheck np pthread mutex default pthread mutex normal endif ifdef use gnu for compatibility pthread mutex fast np pthread mutex timed np endif ifdef use xopen k robust  {
	                                                     robust :: -1000
                                                          }
mutex or not flags enum pthread mutex stalled  {
	stalled :: -1000
      }
pthread mutex stalled np pthread mutex stalled pthread mutex robust pthread mutex robust np pthread mutex robust endif ifdef use unix mutex protocols enum pthread prio none pthread prio inherit pthread prio protect endif mutex initializers  {
	               contradistinguishing :: -1000
                                  }
if wordsize define pthread mutex initializer ifdef use gnu define pthread recursive mutex initializer np pthread mutex recursive np define pthread errorcheck mutex initializer np pthread mutex errorcheck np define pthread adaptive mutex initializer np pthread mutex adaptive np endif else define pthread mutex initializer ifdef use gnu define pthread recursive mutex initializer np pthread mutex recursive np define pthread errorcheck mutex initializer np pthread mutex errorcheck np define pthread adaptive mutex initializer np pthread mutex adaptive np endif endif read write lock types if defined use unix defined use xopen k enum pthread rwlock prefer reader np pthread rwlock prefer writer np pthread rwlock prefer writer nonrecursive  {
	                                                                                                  nonsecure :: 16
	                                                                                               nonexclusive :: 16
                                                                                                          }
np pthread rwlock default np pthread rwlock prefer reader np read write lock initializers define pthread rwlock initializer ifdef use gnu if wordsize define pthread rwlock writer nonrecursive initializer np pthread rwlock prefer writer nonrecursive np else if byte order little endian define pthread rwlock writer nonrecursive initializer np pthread rwlock prefer writer nonrecursive np else define pthread rwlock writer nonrecursive initializer np pthread rwlock prefer writer nonrecursive np endif endif endif endif unix or xopen k scheduler  {
	                                                                    scheduler :: -1000
                                                                            }
inheritance  {
	inheritance :: -1000
 }
enum pthread inherit sched define pthread inherit sched pthread inherit sched pthread explicit sched define pthread explicit sched pthread explicit sched scope handling enum pthread scope system define pthread scope system pthread scope system pthread scope process define pthread scope process pthread scope process process shared or private flag enum pthread process private define pthread process private pthread process private pthread process shared define pthread process shared pthread process shared conditional variable handling define pthread cond initializer void cleanup buffers struct pthread cleanup buffer void routine void function to call void arg its argument int canceltype  {
	                                                                                       canceler :: 12
                                                                                              }
saved cancellation type struct pthread cleanup buffer prev chaining of cleanup functions cancellation enum pthread cancel enable define pthread cancel enable pthread cancel enable pthread cancel disable define pthread cancel disable pthread cancel disable enum pthread cancel deferred  {
	                             deferred :: -1000
                                    }
define pthread cancel deferred pthread cancel deferred pthread cancel asynchronous define pthread cancel asynchronous pthread cancel asynchronous define pthread canceled void single execution handling define pthread once init ifdef use xopen k value returned by pthread barrier  {
	                             barrier :: -1000
                                   }
wait for one of the threads after the required number of threads have called this function is distinct from and all errno constants define pthread barrier serial thread endif begin decls create a new thread starting with execution of start routine getting passed arg creation attributed  {
	                                   attributed :: -1000
                                            }
come from attr the new handle is stored in newthread  {
	 neatherd :: 12
	 nectared :: 11
	netherward :: 11
        }
extern int pthread create pthread t restrict newthread const pthread attr t restrict attr void start routine void void restrict arg thrownl  {
	             thrawnly :: 10
	               throws :: 9
	               thrown :: 12
	               thrawn :: 9
	             throwing :: 9
	                throw :: 10
                    }
nonnull terminate calling thread the registered cleanup handlers are called via exception handling so we cannot mark this function with throw extern void pthread exit void retval attribute noreturn make calling thread wait for termination of the thread th the exit status of the thread is stored in thread return if thread return is not null this function is a cancellation point and therefore not marked with throw extern int pthread join pthread t th void thread return ifdef use gnu check whether thread th has terminated if yes return the status of the thread in thread return if thread return is not null extern int pthread tryjoin  {
	                                                                                                   drypoint :: 9
                                                                                                          }
np pthread t th void thread return throw make calling thread wait for termination of the thread th but only until timeout the exit status of the thread is stored in thread return if thread return is not null this function is a cancellation point and therefore not marked with throw extern int pthread timedjoin  {
	                                                kulans :: -1000
                                                     }
np pthread t th void thread return const struct timespec abstime  {
	tediousness :: -1000
         }
endif indicate that the thread th is never to be joined  {
	    joined :: -1000
         }
with pthread join the resources of th will therefore be freed immediately when it terminates instead of waiting for another thread to perform pthread join on it extern int pthread detach pthread t th throw obtain the identifier of the current thread extern pthread t pthread self void throw attribute const compare two thread identifiers extern int pthread equal pthread t thread pthread t thread throw thread attribute handling initialize thread attribute attr with default attributes detachstate  {
                                                                           }
is pthread joinable scheduling  {
	scheduling :: -1000
  }
policy is sched other no user provided stack extern int pthread attr init pthread attr t attr throw nonnull destroy thread attribute attr extern int pthread attr destroy pthread attr t attr throw nonnull get detach state attribute extern int pthread attr getdetachstate  {
                                         }
const pthread attr t attr int detachstate throw nonnull set detach state attribute extern int pthread attr setdetachstate  {
                }
pthread attr t attr int detachstate throw nonnull get the size of the guard area created for stack overflow protection extern int pthread attr getguardsize  {
                       }
const pthread attr t attr size t guardsize  {
	grandsire :: 11
	 guards :: 12
	guardsmen :: 11
	guardees :: 11
      }
throw nonnull set the size of the guard area created for stack overflow protection extern int pthread attr setguardsize  {
                 }
pthread attr t attr size t guardsize throw nonnull return in param the scheduling parameters of attr extern int pthread attr getschedparam  {
                    }
const pthread attr t restrict attr struct sched param restrict param throw nonnull set scheduling parameters priority etc in attr according to param extern int pthread attr setschedparam  {
                          }
pthread attr t restrict attr const struct sched param restrict param throw nonnull return in policy the scheduling policy of attr extern int pthread attr getschedpolicy  {
                        }
const pthread attr t restrict attr int restrict policy throw nonnull set scheduling policy in attr according to policy extern int pthread attr setschedpolicy  {
                      }
pthread attr t attr int policy throw nonnull return in inherit the scheduling inheritance mode of attr extern int pthread attr getinheritsched  {
                    }
const pthread attr t restrict attr int restrict inherit throw nonnull set scheduling inheritance mode in attr according to inherit extern int pthread attr setinheritsched  {
                       }
pthread attr t attr int inherit throw nonnull return in scope the scheduling contention  {
	   contention :: -1000
            }
scope of attr extern int pthread attr getscope  {
      }
const pthread attr t restrict attr int restrict scope throw nonnull set scheduling contention scope in attr according to scope extern int pthread attr setscope  {
	                seascape :: 10
                       }
pthread attr t attr int scope throw nonnull return the previously set address for the stack extern int pthread attr getstackaddr  {
                   }
const pthread attr t restrict attr void restrict stackaddr  {
	stockaded :: 11
	standard :: 11
	stackyard :: 12
       }
throw nonnull attribute deprecated set the starting address of the stack of the thread to be created depending on whether the stack grows  {
	                 grows :: -1000
                     }
up or down the value must either be higher or lower than all the address in the memory block the minimal size of the block must be pthread stack min extern int pthread attr setstackaddr  {
                                 }
pthread attr t attr void stackaddr throw nonnull attribute deprecated return the currently used minimal stack size extern int pthread attr getstacksize  {
                    }
const pthread attr t restrict attr size t restrict stacksize  {
	ecstasize :: 11
	   sticks :: 11
	   stacks :: 12
	tracksides :: 11
	trackside :: 11
	 stackers :: 11
        }
throw nonnull add information about the minimum stack size needed for the thread to be started this size must never be less than pthread stack min and must also not exceed the system limits extern int pthread attr setstacksize  {
                                     }
pthread attr t attr size t stacksize throw nonnull ifdef use xopen k return the previously set address for the stack extern int pthread attr getstack const pthread attr t restrict attr void restrict stackaddr size t restrict stacksize throw nonnull the following two interfaces are intended to replace the last two they require setting the address as well as the size since only setting the address will make the implementation on some architectures  {
	                                                            architectures :: -1000
                                                                        }
impossible extern int pthread attr setstack pthread attr t attr void stackaddr size t stacksize throw nonnull endif ifdef use gnu thread created with attribute attr will be limited to run only on the processors represented in cpuset  {
	                              crusets :: 7
	                                cruse :: 7
	                                chuse :: 7
	                                cause :: 7
	                               cruset :: 9
	                               coupes :: 7
	                               chutes :: 7
	                                stupe :: 7
	                                scute :: 7
	                              cuspate :: 7
                                    }
extern int pthread attr setaffinity  {
   }
np pthread attr t attr size t cpusetsize  {
      }
const cpu set t cpuset throw nonnull get bit set in cpuset representing the processors threads created with attr can run on extern int pthread attr getaffinity  {
                         }
np const pthread attr t attr size t cpusetsize cpu set t cpuset throw nonnull initialize thread attribute attr with attributes corresponding to the already running thread th it shall be called on uninitialized attr and destroyed with pthread attr destroy when no longer needed extern int pthread getattr np pthread t th pthread attr t attr throw nonnull endif functions for scheduling control set the scheduling parameters for target thread according to policy and param extern int pthread setschedparam pthread t target thread int policy const struct sched param param throw nonnull return in policy and param the scheduling parameters for target thread extern int pthread getschedparam pthread t target thread int restrict policy struct sched param restrict param throw nonnull set the scheduling priority for target thread extern int pthread setschedprio  {
                                                                                                                                   }
pthread t target thread int prio throw ifdef use gnu get thread name visible in the kernel and its interfaces extern int pthread getname np pthread t target thread char buf size t buflen throw nonnull set thread name visible in the kernel and its interfaces extern int pthread setname np pthread t target thread const char name throw nonnull endif ifdef use unix determine level of concurrency  {
	                                                        concurrency :: -1000
                                                                  }
extern int pthread getconcurrency  {
  }
void throw set new concurrency level to level extern int pthread setconcurrency  {
	nonconcurrences :: 18
          }
int level throw endif ifdef use gnu yield the processor to another thread or process this function is similar to the posix sched yield function but might be differently implemented in the case of a m on n thread implementation extern int pthread yield void throw limit specified thread th to run only on the processors represented in cpuset extern int pthread setaffinity np pthread t th size t cpusetsize const cpu set t cpuset throw nonnull get bit set in cpuset representing the processors th can run on extern int pthread getaffinity np pthread t th size t cpusetsize cpu set t cpuset throw nonnull endif functions for handling initialization guarantee that the initialization function init routine will be called only once even if pthread once is executed several times with the same once control argument once control must point to a static or extern variable initialized to pthread once init the initialization functions might throw exception which is why this function is not marked with throw extern int pthread once pthread once t once control void init routine void nonnull functions for handling cancellation note that these functions are explicitly not marked to not throw an exception in c code if cancellation is implemented by unwinding  {
	                                                                                                                                                                                                      unwinding :: -1000
                                                                                                                                                                                                              }
this is necessary to have the compiler generate the unwind information set cancelability  {
	recallability :: 17
	acceptability :: 16
	changeability :: 16
           }
state of current thread to state returning old state in oldstate  {
	 constated :: 10
	 outskated :: 10
	 outlasted :: 10
	 oscitated :: 10
	  outstate :: 10
	 outstated :: 11
         }
if oldstate is not null extern int pthread setcancelstate  {
       }
int state int oldstate set cancellation state of current thread to type returning the old type in oldtype  {
                }
if oldtype is not null extern int pthread setcanceltype  {
       }
int type int oldtype cancel thread immediately or at the next possibility extern int pthread cancel pthread t th test for pending cancellation for the current thread and terminate the thread as per pthread exit pthread canceled if it has been cancelled extern void pthread testcancel  {
	                                    tentacles :: 12
                                            }
void cancellation handling with integration  {
	integration :: -1000
   }
into exception handling typedef struct struct jmp buf cancel jmp buf int mask was saved cancel jmp buf void pad pthread unwind buf t attribute aligned no special attributes by default ifndef cleanup fct attribute define cleanup fct attribute endif structure to hold the cleanup handler information struct pthread cleanup frame void cancel routine void void cancel arg int do it int cancel type if defined gnuc defined exceptions ifdef cplusplus class to handle cancellation handler invocation class pthread cleanup class void cancel routine void void cancel arg int do it int cancel type public pthread cleanup class void fct void void arg cancel routine fct cancel arg arg do it pthread cleanup class if do it cancel routine cancel arg void setdoit  {
	                                                                                                                   dotiest :: 9
                                                                                                                         }
int newval  {
	unweal :: 7
	nerval :: 9
	vernal :: 7
	venial :: 7
	veinal :: 7
 }
do it newval void defer pthread setcanceltype pthread cancel deferred cancel type void restore const pthread setcanceltype cancel type install a cleanup handler routine will be called with arguments arg when the thread is canceled or calls pthread exit routine will also be called with arguments arg when the matching pthread cleanup pop is executed with non zero execute argument pthread cleanup push and pthread cleanup pop are macros and must always be used in matching pairs at the same nesting level of braces  {
	                                                                             braces :: -1000
                                                                                  }
define pthread cleanup push routine arg do pthread cleanup class clframe  {
         }
routine arg remove a cleanup handler installed by the matching pthread cleanup push if execute is non zero the handler function is called define pthread cleanup pop execute clframe setdoit execute while ifdef use gnu install a cleanup handler as pthread cleanup push does but also saves the current cancellation type and sets it to deferred cancellation define pthread cleanup push defer np routine arg do pthread cleanup class clframe routine arg clframe defer remove a cleanup handler as pthread cleanup pop does but also restores  {
	                                                                             restores :: -1000
                                                                                    }
the cancellation type that was in effect when the matching pthread cleanup push defer was called define pthread cleanup pop restore np execute clframe restore clframe setdoit execute while endif else function called to call the cleanup handler as an extern inline function the compiler is free to decide inlining  {
	                                         unlining :: 13
	                                         engining :: 10
	                                         relining :: 10
	                                         bylining :: 10
	                                         splining :: 10
                                                }
the change when needed or fall back on the copy which must exist somewhere  {
	    somewhere :: -1000
            }
else extern inline void pthread cleanup routine struct pthread cleanup frame frame if frame do it frame cancel routine frame cancel arg install a cleanup handler routine will be called with arguments arg when the thread is canceled or calls pthread exit routine will also be called with arguments arg when the matching pthread cleanup pop is executed with non zero execute argument pthread cleanup push and pthread cleanup pop are macros and must always be used in matching pairs at the same nesting level of braces define pthread cleanup push routine arg do struct pthread cleanup frame clframe attribute cleanup pthread cleanup routine cancel routine routine cancel arg arg do it remove a cleanup handler installed by the matching pthread cleanup push if execute is non zero the handler function is called define pthread cleanup pop execute clframe do it execute while ifdef use gnu install a cleanup handler as pthread cleanup push does but also saves the current cancellation type and sets it to deferred cancellation define pthread cleanup push defer np routine arg do struct pthread cleanup frame clframe attribute cleanup pthread cleanup routine cancel routine routine cancel arg arg do it void pthread setcanceltype pthread cancel deferred clframe cancel type remove a cleanup handler as pthread cleanup pop does but also restores the cancellation type that was in effect when the matching pthread cleanup push defer was called define pthread cleanup pop restore np execute void pthread setcanceltype clframe cancel type null clframe do it execute while endif endif else install a cleanup handler routine will be called with arguments arg when the thread is canceled or calls pthread exit routine will also be called with arguments arg when the matching pthread cleanup pop is executed with non zero execute argument pthread cleanup push and pthread cleanup pop are macros and must always be used in matching pairs at the same nesting level of braces define pthread cleanup push routine arg do pthread unwind buf t cancel buf void cancel routine void routine void cancel arg arg int not first call sigsetjmp  {
	                                                                                                                                                                                                                                                                                                                                                    adays :: -1000
                                                                                                                                                                                                                                                                                                                                                        }
struct jmp buf tag void cancel buf cancel jmp buf if builtin expect not first call cancel routine cancel arg pthread unwind next cancel buf notreached  {
	               intrenched :: 13
	               untrenched :: 13
	               retrenched :: 13
	               entrenched :: 13
	               inwreathed :: 12
	               inbreathed :: 12
	               unwreathed :: 12
	               unbreathed :: 12
	               enwreathed :: 12
	               encroached :: 14
	               reproached :: 12
	               outreaches :: 13
	               outreached :: 16
	               unpreached :: 13
	               unbreached :: 13
                        }
pthread register cancel cancel buf do extern void pthread register cancel pthread unwind buf t buf cleanup fct attribute remove a cleanup handler installed by the matching pthread cleanup push if execute is non zero the handler function is called define pthread cleanup pop execute do while empty to allow label before pthread cleanup pop while pthread unregister cancel cancel buf if execute cancel routine cancel arg while extern void pthread unregister cancel pthread unwind buf t buf cleanup fct attribute ifdef use gnu install a cleanup handler as pthread cleanup push does but also saves the current cancellation type and sets it to deferred cancellation define pthread cleanup push defer np routine arg do pthread unwind buf t cancel buf void cancel routine void routine void cancel arg arg int not first call sigsetjmp struct jmp buf tag void cancel buf cancel jmp buf if builtin expect not first call cancel routine cancel arg pthread unwind next cancel buf notreached pthread register cancel defer cancel buf do extern void pthread register cancel defer pthread unwind buf t buf cleanup fct attribute remove a cleanup handler as pthread cleanup pop does but also restores the cancellation type that was in effect when the matching pthread cleanup push defer was called define pthread cleanup pop restore np execute do while empty to allow label before pthread cleanup pop while pthread unregister cancel restore cancel buf if execute cancel routine cancel arg while extern void pthread unregister cancel restore pthread unwind buf t buf cleanup fct attribute endif internal interface to initiate cleanup extern void pthread unwind next pthread unwind buf t buf cleanup fct attribute attribute noreturn ifndef shared attribute weak endif endif function used in the macros struct jmp buf tag extern int sigsetjmp struct jmp buf tag env int savemask  {
                                                                                                                                                                                                                                                                                                           }
throw mutex handling initialize a mutex extern int pthread mutex init pthread mutex t mutex const pthread mutexattr  {
                }
t mutexattr throw nonnull destroy a mutex extern int pthread mutex destroy pthread mutex t mutex throw nonnull try locking a mutex extern int pthread mutex trylock  {
                         }
pthread mutex t mutex thrownl nonnull lock a mutex extern int pthread mutex lock pthread mutex t mutex thrownl nonnull ifdef use xopen k wait until lock becomes available or specified time passes extern int pthread mutex timedlock  {
                                    }
pthread mutex t restrict mutex const struct timespec restrict abstime thrownl nonnull endif unlock a mutex extern int pthread mutex unlock pthread mutex t mutex thrownl nonnull get the priority ceiling  {
	                       ceiling :: -1000
                             }
of mutex extern int pthread mutex getprioceiling  {
     }
const pthread mutex t restrict mutex int restrict prioceiling  {
	recompiling :: 15
       }
throw nonnull set the priority ceiling of mutex to prioceiling return old priority ceiling value in old ceiling extern int pthread mutex setprioceiling  {
                     }
pthread mutex t restrict mutex int prioceiling int restrict old ceiling throw nonnull ifdef use xopen k declare the state protected by mutex as consistent extern int pthread mutex consistent pthread mutex t mutex throw nonnull ifdef use gnu extern int pthread mutex consistent np pthread mutex t mutex throw nonnull endif endif functions for handling mutex attributes initialize mutex attribute object attr with default attributes kind is pthread mutex timed np extern int pthread mutexattr init pthread mutexattr t attr throw nonnull destroy mutex attribute object attr extern int pthread mutexattr destroy pthread mutexattr t attr throw nonnull get the process shared flag of the mutex attribute attr extern int pthread mutexattr getpshared  {
	                                                                                                       upgathered :: 12
                                                                                                                }
const pthread mutexattr t restrict attr int restrict pshared  {
	 pshawed :: 11
	 aspired :: 9
	 sphered :: 9
	  phrase :: 9
	 speared :: 9
	 phrased :: 11
	 sheared :: 9
	 sharped :: 9
       }
throw nonnull set the process shared flag of the mutex attribute attr extern int pthread mutexattr setpshared  {
	      hotpressed :: 12
               }
pthread mutexattr t attr int pshared throw nonnull if defined use unix defined use xopen k return in kind the mutex kind attribute in attr extern int pthread mutexattr gettype  {
                            }
const pthread mutexattr t restrict attr int restrict kind throw nonnull set the mutex kind attribute in attr to kind either pthread mutex normal pthread mutex recursive pthread mutex errorcheck or pthread mutex default extern int pthread mutexattr settype  {
	                              neotypes :: 9
                                     }
pthread mutexattr t attr int kind throw nonnull endif return in protocol the mutex protocol attribute in attr extern int pthread mutexattr getprotocol  {
                     }
const pthread mutexattr t restrict attr int restrict protocol throw nonnull set the mutex protocol attribute in attr to protocol either pthread prio none pthread prio inherit or pthread prio protect extern int pthread mutexattr setprotocol  {
                                  }
pthread mutexattr t attr int protocol throw nonnull return in prioceiling the mutex prioceiling attribute in attr extern int pthread mutexattr getprioceiling const pthread mutexattr t restrict attr int restrict prioceiling throw nonnull set the mutex prioceiling attribute in attr to prioceiling extern int pthread mutexattr setprioceiling pthread mutexattr t attr int prioceiling throw nonnull ifdef use xopen k get the robustness  {
	                                                   robustness :: -1000
                                                            }
flag of the mutex attribute attr extern int pthread mutexattr getrobust  {
	  betroths :: 11
         }
const pthread mutexattr t attr int robustness throw nonnull ifdef use gnu extern int pthread mutexattr getrobust np const pthread mutexattr t attr int robustness throw nonnull endif set the robustness flag of the mutex attribute attr extern int pthread mutexattr setrobust  {
	                                robustest :: 11
	                                 betroths :: 11
                                        }
pthread mutexattr t attr int robustness throw nonnull ifdef use gnu extern int pthread mutexattr setrobust np pthread mutexattr t attr int robustness throw nonnull endif endif if defined use unix defined use xopen k functions for handling read write locks initialize read write lock rwlock using attributes attr or use the default values if later is null extern int pthread rwlock init pthread rwlock t restrict rwlock const pthread rwlockattr  {
                                                                     }
t restrict attr throw nonnull destroy read write lock rwlock extern int pthread rwlock destroy pthread rwlock t rwlock throw nonnull acquire read lock for rwlock extern int pthread rwlock rdlock pthread rwlock t rwlock thrownl nonnull try to acquire read lock for rwlock extern int pthread rwlock tryrdlock  {
                                               }
pthread rwlock t rwlock thrownl nonnull ifdef use xopen k try to acquire read lock for rwlock or return after specfied  {
	            speckled :: 10
	           specified :: 11
	            casefied :: 10
	            precised :: 10
	              specie :: 10
                   }
time extern int pthread rwlock timedrdlock  {
    }
pthread rwlock t restrict rwlock const struct timespec restrict abstime thrownl nonnull endif acquire write lock for rwlock extern int pthread rwlock wrlock pthread rwlock t rwlock thrownl nonnull try to acquire write lock for rwlock extern int pthread rwlock trywrlock  {
                                       }
pthread rwlock t rwlock thrownl nonnull ifdef use xopen k try to acquire write lock for rwlock or return after specfied time extern int pthread rwlock timedwrlock  {
                         }
pthread rwlock t restrict rwlock const struct timespec restrict abstime thrownl nonnull endif unlock rwlock extern int pthread rwlock unlock pthread rwlock t rwlock thrownl nonnull functions for handling read write lock attributes initialize attribute object attr with default values extern int pthread rwlockattr init pthread rwlockattr t attr throw nonnull destroy attribute object attr extern int pthread rwlockattr destroy pthread rwlockattr t attr throw nonnull return current setting of process shared attribute of attr in pshared extern int pthread rwlockattr getpshared const pthread rwlockattr t restrict attr int restrict pshared throw nonnull set process shared attribute of attr to pshared extern int pthread rwlockattr setpshared pthread rwlockattr t attr int pshared throw nonnull return current setting of reader writer preference extern int pthread rwlockattr getkind  {
	                                                                                                                      decking :: 9
                                                                                                                            }
np const pthread rwlockattr t restrict attr int restrict pref throw nonnull set reader write preference extern int pthread rwlockattr setkind  {
	             detains :: 9
                   }
np pthread rwlockattr t attr int pref throw nonnull endif functions for handling conditional variables initialize condition variable cond using attributes attr or use the default values if later is null extern int pthread cond init pthread cond t restrict cond const pthread condattr  {
	                                   contrate :: 10
                                          }
t restrict cond attr throw nonnull destroy condition variable cond extern int pthread cond destroy pthread cond t cond throw nonnull wake up one thread waiting for condition variable cond extern int pthread cond signal pthread cond t cond thrownl nonnull wake up all threads waiting for condition variables cond extern int pthread cond broadcast pthread cond t cond thrownl nonnull wait for condition variable cond to be signaled or broadcast mutex is assumed to be locked before this function is a cancellation point and therefore not marked with throw extern int pthread cond wait pthread cond t restrict cond pthread mutex t restrict mutex nonnull wait for condition variable cond to be signaled or broadcast until abstime mutex is assumed to be locked before abstime is an absolute time specification zero is the beginning of the epoch gmt january this function is a cancellation point and therefore not marked with throw extern int pthread cond timedwait  {
	                                                                                                                                                      lemony :: -1000
                                                                                                                                                           }
pthread cond t restrict cond pthread mutex t restrict mutex const struct timespec restrict abstime nonnull functions for handling condition variable attributes initialize condition variable attribute attr extern int pthread condattr init pthread condattr t attr throw nonnull destroy condition variable attribute attr extern int pthread condattr destroy pthread condattr t attr throw nonnull get the process shared flag of the condition variable attribute attr extern int pthread condattr getpshared const pthread condattr t restrict attr int restrict pshared throw nonnull set the process shared flag of the condition variable attribute attr extern int pthread condattr setpshared pthread condattr t attr int pshared throw nonnull ifdef use xopen k get the clock selected for the conditon  {
	                                                                                                         conditions :: 11
	                                                                                                          contadino :: 11
	                                                                                                            rondino :: 10
	                                                                                                          condoling :: 10
	                                                                                                           continuo :: 10
	                                                                                                          conations :: 10
	                                                                                                          condition :: 12
	                                                                                                          condiment :: 10
	                                                                                                           connoted :: 10
	                                                                                                           coeditor :: 10
	                                                                                                            tondino :: 12
	                                                                                                        conditional :: 10
	                                                                                                        conditioner :: 10
	                                                                                                           tondinos :: 11
	                                                                                                           conation :: 11
	                                                                                                           donation :: 10
                                                                                                                  }
variable attribute attr extern int pthread condattr getclock  {
      }
const pthread condattr t restrict attr clockid  {
	 clock :: 10
	 click :: 9
	clocking :: 10
	clocks :: 9
	clocked :: 11
	clicked :: 10
     }
t restrict clock id throw nonnull set the clock selected for the conditon variable attribute attr extern int pthread condattr setclock  {
                   }
pthread condattr t attr clockid t clock id throw nonnull endif ifdef use xopen k functions to handle spinlocks  {
	         princocks :: 11
	         sunblocks :: 11
                 }
initialize the spinlock lock if pshared is nonzero the spinlock can be shared between different processes extern int pthread spin init pthread spinlock t lock int pshared throw nonnull destroy the spinlock lock extern int pthread spin destroy pthread spinlock t lock throw nonnull wait until spinlock lock is retrieved extern int pthread spin lock pthread spinlock t lock thrownl nonnull try to lock spinlock lock extern int pthread spin trylock pthread spinlock t lock thrownl nonnull release spinlock lock extern int pthread spin unlock pthread spinlock t lock thrownl nonnull functions to handle barriers  {
	                                                                                      barriers :: -1000
                                                                                             }
initialize barrier with the attributes in attr the barrier is opened when count waiters  {
	      waiters :: -1000
            }
arrived  {
	arrived :: -1000
 }
extern int pthread barrier init pthread barrier t restrict barrier const pthread barrierattr  {
           }
t restrict attr unsigned int count throw nonnull destroy a previously dynamically initialized barrier barrier extern int pthread barrier destroy pthread barrier t barrier throw nonnull wait on barrier barrier extern int pthread barrier wait pthread barrier t barrier thrownl nonnull initialize barrier attribute attr extern int pthread barrierattr init pthread barrierattr t attr throw nonnull destroy previously dynamically initialized barrier attribute attr extern int pthread barrierattr destroy pthread barrierattr t attr throw nonnull get the process shared flag of the barrier attribute attr extern int pthread barrierattr getpshared const pthread barrierattr t restrict attr int restrict pshared throw nonnull set the process shared flag of the barrier attribute attr extern int pthread barrierattr setpshared pthread barrierattr t attr int pshared throw nonnull endif functions for handling thread specific data create a key value identifying a location in the thread specific data area each thread maintains  {
	                                                                                                                                        maintains :: -1000
                                                                                                                                                }
a distinct thread specific data area destr function if non null is called with the value associated to that key when the key is destroyed destr function is not called if the value associated is null when the key is destroyed extern int pthread key create pthread key t key void destr function void throw nonnull destroy key extern int pthread key delete pthread key t key throw return current value of the thread specific data slot identified by key extern void pthread getspecific  {
                                                                                  }
pthread key t key throw store pointer in the thread specific data slot identified by key extern int pthread setspecific  {
	        subspecific :: 16
                  }
pthread key t key const void pointer throw ifdef use xopen k get id of cpu time clock for thread thread id extern int pthread getcpuclockid  {
                        }
pthread t thread id clockid t clock id throw nonnull endif install handlers to be called when a new process is created with fork  {
	                   fork :: -1000
                      }
the prepare handler is called in the parent process just before performing fork the parent handler is called in the parent process just after fork the child handler is called in the child process each of the three handlers can be null meaning that no handler needs to be called at that point pthread atfork  {
                                                     }
can be called several times in which case the prepare handlers are called in lifo  {
	        bifold :: 5
	         filos :: 5
	          lino :: 5
	          lift :: 5
	          life :: 5
	          filo :: 6
             }
order last added with pthread atfork first called before fork and the parent and child handlers are called in fifo first added first called extern int pthread atfork void prepare void void parent void void child void throw ifdef use extern inlines optimizations extern inline int nth pthread equal pthread t thread pthread t thread return thread thread endif end decls endif pthread h functions for pseudo tty handling copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef pty  {
	                                                                                                                                                                                                  ampliative :: -1000
                                                                                                                                                                                                           }
h define pty h include features h include termios  {
	wormiest :: 10
	roomiest :: 9
	tiresome :: 9
	 mortise :: 9
	 permits :: 10
	 mersion :: 9
	  tercio :: 9
	 merinos :: 9
	 tremies :: 9
	   terms :: 9
	 tommies :: 9
	 tersion :: 10
	ternions :: 9
	 termors :: 9
	 tercios :: 11
	fermions :: 9
	terminus :: 9
       }
h include sys ioctl h begin decls create pseudo tty master slave pair with name and set terminal  {
	         terminal :: -1000
                }
attributes according to termp  {
	teraphim :: 6
	trompe :: 7
	permit :: 7
	trumped :: 6
	tromped :: 6
	trompes :: 6
	thumper :: 6
	permits :: 6
	termly :: 6
	teraph :: 6
	trump :: 6
	tromp :: 6
	tramp :: 6
	terms :: 7
	term :: 8
	temp :: 6
	pert :: 6
	perm :: 7
	trample :: 6
	tramped :: 6
	tramper :: 6
	perms :: 6
	mpret :: 6
  }
and winp  {
	wippen :: 5
	windup :: 5
	wisp :: 5
	winy :: 5
	wins :: 5
	wino :: 5
	wink :: 5
	wing :: 5
	wine :: 5
	wind :: 5
	wimp :: 5
	win :: 6
	pin :: 5
 }
and return handles for both ends in amaster  {
	amateur :: 9
	amasser :: 10
	lamster :: 9
	smatters :: 9
	amassers :: 9
	 amates :: 9
	maister :: 9
	adapters :: 9
	smatter :: 10
	smarten :: 9
	smarted :: 9
	smarter :: 10
	awaiters :: 9
	hamster :: 9
      }
and aslave  {
	sclave :: 8
	salame :: 7
	salade :: 7
	anlases :: 7
	anlages :: 7
	anlaces :: 7
	ablates :: 7
	palavers :: 8
	palaver :: 7
	asea :: 7
	atlases :: 7
	caravels :: 7
	sleave :: 7
	lavages :: 7
 }
extern int openpty  {
 }
int amaster int aslave char name const struct termios termp const struct winsize  {
           }
winp throw create child process and establish the slave pseudo terminal as the child s controlling terminal extern int forkpty  {
	              forky :: 9
                  }
int amaster char name const struct termios termp const struct winsize winp throw end decls endif pty h punycode h declarations for punycode functions copyright c simon josefsson this file is part of gnu libidn gnu libidn is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version gnu libidn is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with gnu libidn if not write to the free software foundation inc franklin street fifth floor boston ma usa this file is derived from rfc bis written by adam m costello  {
	                                                                                                                                                         coolest :: 10
                                                                                                                                                               }
disclaimer and license regarding this entire document or any portion of it including the pseudocode  {
	    pseudocode :: -1000
             }
and c code the author makes no guarantees and is not responsible for any damage resulting from its use the author grants  {
	               grants :: -1000
                    }
irrevocable  {
	irrevocable :: -1000
 }
permission to anyone  {
	anyone :: -1000
 }
to use modify and distribute it in any way that does not diminish  {
	    diminish :: -1000
           }
the rights of anyone else to use modify and distribute it provided that redistributed  {
	redistributed :: -1000
            }
derivative  {
	derivative :: -1000
 }
works do not contain misleading  {
	misleading :: -1000
   }
author or version information derivative works need not be licensed  {
	 licensed :: -1000
        }
under similar terms copyright c the internet society  {
	society :: -1000
      }
all rights reserved this document and translations  {
	translations :: -1000
     }
of it may be copied and furnished to others and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared copied published and distributed in whole or in part without restriction of any kind provided that the above copyright notice and this paragraph  {
	                                        paragraph :: -1000
                                                }
are included on all such copies and derivative works however this document itself may not be modified in any way such as by removing  {
	               removing :: -1000
                      }
the copyright notice or references to the internet society or other internet organizations  {
	organizations :: -1000
           }
except as needed for the purpose of developing  {
	spiffiness :: -1000
      }
internet standards  {
	standards :: -1000
 }
in which case the procedures for copyrights  {
	copyrights :: -1000
     }
defined in the internet standards process must be followed or as required to translate it into languages  {
	       languages :: -1000
               }
other than english the limited permissions  {
	permissions :: -1000
    }
granted above are perpetual  {
	perpetual :: -1000
  }
and will not be revoked by the internet society or its successors  {
	 successors :: -1000
          }
or assigns  {
	assigns :: -1000
 }
this document and the information contained herein  {
	herein :: -1000
     }
is provided on an as is basis  {
	 basis :: -1000
     }
and the internet society and the internet engineering  {
	engineering :: -1000
      }
task force disclaims  {
	disclaims :: -1000
 }
all warranties express or implied including but not limited to any warranty that the use of the information herein will not infringe any rights or any implied warranties of merchantability or fitness for a particular purpose ifndef punycode h define punycode h ifndef idnapi if defined libidn building defined have visibility have visibility define idnapi attribute visibility default elif defined libidn building defined msc ver defined libidn static define idnapi declspec dllexport elif defined msc ver defined libidn static define idnapi declspec dllimport else define idnapi endif endif ifdef cplusplus extern c endif include stddef h size t include idn int h uint t enum punycode status punycode success punycode bad input input is invalid punycode big output output would exceed the space provided punycode overflow wider integers needed to process input typedef enum punycode success punycode success punycode bad input punycode bad input punycode big output punycode big output punycode overflow punycode overflow punycode status extern idnapi const char punycode strerror punycode status rc punycode uint needs to be unsigned and needs to be at least bits wide typedef uint t punycode uint extern idnapi int punycode encode size t input length const punycode uint input const unsigned char case flags size t output length char output punycode encode converts a sequence of code points presumed  {
	                                                                                                                                                                                                                presumed :: -1000
                                                                                                                                                                                                                       }
to be unicode code points to punycode input arguments to be supplied by the caller input length the number of code points in the input array and the number of flags in the case flags array input an array of code points they are presumed to be unicode code points but that is not strictly  {
	                                              strictly :: -1000
                                                     }
required the array contains code points not code units utf uses code units d through dfff  {
	           duff :: 5
	           doff :: 5
	           daff :: 5
              }
to refer to code points ffff the code points d dfff do not occur in any valid unicode string the code points that can occur in unicode strings d ff and e ffff are also called unicode scalar values case flags a null pointer or an array of boolean values parallel to the input array nonzero true flagged suggests  {
	                                                  suggests :: -1000
                                                         }
that the corresponding unicode character be forced  {
	forced :: -1000
     }
to uppercase after being decoded if possible and zero false unflagged  {
	 beflagged :: 12
	 reflagged :: 12
	 unplugged :: 11
	 unclogged :: 12
	  unflawed :: 11
	 unfledged :: 12
         }
suggests that it be forced to lowercase if possible ascii code points f are encoded literally  {
	      literally :: -1000
              }
except that ascii letters are forced to uppercase or lowercase according to the corresponding case flags if case flags is a null pointer then ascii letters are left as they are and other code points are treated as unflagged output arguments to be filled in by the function output an array of ascii code points it is not null terminated it will contain zeros if and only if the input contains zeros of course the caller can leave room for a terminator and add one if needed input output arguments to be supplied by the caller and overwritten by the function output length the caller passes in the maximum number of ascii code points that it can receive on successful return it will contain the number of ascii code points actually output return value can be any of the punycode status values defined above except punycode bad input if not punycode success then output size and output might contain garbage extern idnapi int punycode decode size t input length const char input size t output length punycode uint output unsigned char case flags punycode decode converts punycode to a sequence of code points presumed to be unicode code points input arguments to be supplied by the caller input length the number of ascii code points in the input array input an array of ascii code points f output arguments to be filled in by the function output an array of code points like the input argument of punycode encode see above case flags a null pointer if the flags are not needed by the caller or an array of boolean values parallel to the output array nonzero true flagged suggests that the corresponding unicode character be forced to uppercase by the caller if possible and zero false unflagged suggests that it be forced to lowercase if possible ascii code points f are output already in the proper case but their flags will be set appropriately so that applying  {
	                                                                                                                                                                                                                                                                                                                               applying :: -1000
                                                                                                                                                                                                                                                                                                                                      }
the flags would be harmless  {
	harmless :: -1000
   }
input output arguments to be supplied by the caller and overwritten by the function output length the caller passes in the maximum number of code points that it can receive into the output array which is also the maximum number of flags that it can receive into the case flags array if case flags is not a null pointer on successful return it will contain the number of code points actually output which is also the number of flags actually output if case flags is not a null pointer the decoder will never need to output more code points than the number of ascii code points in the input because of the way the encoding is defined the number of code points output cannot exceed the maximum possible value of a punycode uint even if the supplied output length is greater than that return value can be any of the punycode status values defined above if not punycode success then output length output and case flags might contain garbage ifdef cplusplus endif endif punycode h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa posix standard user database access pwd h ifndef pwd h define pwd h include features h begin decls include bits types h define need size t include stddef h if defined use xopen defined use xopen k the single unix specification says that some more types are available here ifndef gid t defined typedef gid t gid t define gid t defined endif ifndef uid t defined typedef uid t uid t define uid t defined endif endif the passwd structure struct passwd char pw name username char pw passwd password uid t pw uid user id gid t pw gid group id char pw gecos  {
	                                                                                                                                                                                                                                                                                                                                                                                                                         gecks :: 7
	                                                                                                                                                                                                                                                                                                                                                                                                                         gecko :: 6
	                                                                                                                                                                                                                                                                                                                                                                                                                        geckos :: 7
	                                                                                                                                                                                                                                                                                                                                                                                                                         ceros :: 6
	                                                                                                                                                                                                                                                                                                                                                                                                                         segos :: 6
	                                                                                                                                                                                                                                                                                                                                                                                                                          geos :: 6
                                                                                                                                                                                                                                                                                                                                                                                                                             }
real name char pw dir home directory char pw shell shell program if defined use svid defined use gnu define need file include stdio h endif if defined use svid defined use misc defined use xopen extended rewind the password file stream this function is a possible cancellation point and therefore not marked with throw extern void setpwent  {
	                                                 strepent :: 10
                                                        }
void close the password file stream this function is a possible cancellation point and therefore not marked with throw extern void endpwent  {
                    }
void read an entry from the password file stream opening it if necessary this function is a possible cancellation point and therefore not marked with throw extern struct passwd getpwent  {
                            }
void endif ifdef use svid read an entry from stream this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern struct passwd fgetpwent  {
                                                 }
file stream write the given entry onto the given stream this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int putpwent  {
                                                }
const struct passwd restrict p file restrict f endif search for an entry with a matching user id this function is a possible cancellation point and therefore not marked with throw extern struct passwd getpwuid  {
	                        fantoccini :: -1000
                                 }
uid t uid search for an entry with a matching username this function is a possible cancellation point and therefore not marked with throw extern struct passwd getpwnam  {
                          }
const char name if defined use posix defined use misc ifdef use misc reasonable value for the buffer sized used in the reentrant functions below but better use sysconf define nss buflen passwd endif reentrant versions of some of the functions above please note the getpwent r function is not yet standardized the interface may change in later versions of this library but the interface is designed following the principals used for the other reentrant functions so the chances are good this is what the posix people would choose if defined use svid defined use misc this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int getpwent r struct passwd restrict resultbuf char restrict buffer size t buflen struct passwd restrict result endif extern int getpwuid r uid t uid struct passwd restrict resultbuf char restrict buffer size t buflen struct passwd restrict result extern int getpwnam r const char restrict name struct passwd restrict resultbuf char restrict buffer size t buflen struct passwd restrict result ifdef use svid read an entry from stream this function is not standardized and probably never will this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int fgetpwent r file restrict stream struct passwd restrict resultbuf char restrict buffer size t buflen struct passwd restrict result endif endif posix or reentrant ifdef use gnu re construct the password file line for the given uid in the given buffer this knows  {
	                                                                                                                                                                                                                                                                                                knows :: -1000
                                                                                                                                                                                                                                                                                                    }
the format that the caller will expect but this need not be the format of the password file this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int getpw uid t uid char buffer endif end decls endif pwd h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef re comp h define re comp h this is only a wrapper around the regex h file xpg mentions  {
	                                                                                                                                                                                                                      mentions :: -1000
                                                                                                                                                                                                                             }
this name include regex h endif re comp h definitions for data structures and routines for the regular expression library copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef regex h define regex h include sys types h include gnu option groups h allow the use in c code ifdef cplusplus extern c endif the following two types have to be signed and unsigned integer type wide enough to hold a value of a pointer for most ansi compilers ptrdiff t and size t should be likely ok still size of these two types is for microsoft c ugh typedef long int s reg t typedef unsigned long int active reg t the following bits are used to determine the regexp syntax we recognize the set not set meanings are chosen so that emacs syntax remains  {
	                                                                                                                                                                                                                                                              remains :: -1000
                                                                                                                                                                                                                                                                    }
the value the bits are given in alphabetical order and the definitions shifted by one from the previous bit thus when we add or remove a bit only one other definition need change typedef unsigned long int reg syntax t ifdef use gnu if this bit is not set then inside a bracket expression is literal if set then such a quotes the following character define re backslash escape in lists unsigned long int if this bit is not set then and are operators and and are literals if set then and are operators and and are literals define re bk plus qm re backslash escape in lists if this bit is set then character classes are supported they are alpha upper lower digit alnum xdigit space print punct graph and cntrl if not set then character classes are not supported define re char classes re bk plus qm if this bit is set then and are always anchors  {
	                                                                                                                                                     homophile :: -1000
                                                                                                                                                             }
outside bracket expressions of course if this bit is not set then it depends is an anchor if it is at the beginning of a regular expression or after an open group or an alternation  {
	                       alternation :: -1000
                                 }
operator is an anchor if it is at the end of a regular expression or before a close group or an alternation operator this bit could be re combined with re context indep ops because posix draft says that etc in leading positions is undefined we already implemented a previous draft which made those constructs invalid though so we haven t changed the code back define re context indep anchors re char classes if this bit is set then special characters are always special regardless of where they are in the pattern if this bit is not set then special characters are special only in some contexts otherwise they are ordinary specifically and intervals  {
	                                                                                                        intervals :: -1000
                                                                                                                }
are only special when not after the beginning open group or alternation operator define re context indep ops re context indep anchors if this bit is set then and cannot be first in an re or immediately after an alternation or begin group operator define re context invalid ops re context indep ops if this bit is set then matches newline if not set then it doesn t define re dot newline re context invalid ops if this bit is set then doesn t match nul if not set then it does define re dot not null re dot newline if this bit is set nonmatching  {
	                                                                                              nonteaching :: 17
	                                                                                              nonmagnetic :: 14
	                                                                                              outmatching :: 15
	                                                                                              outmarching :: 14
                                                                                                        }
lists do not match newline if not set they do define re hat  {
	         hat :: -1000
           }
lists not newline re dot not null if this bit is set either or defines an interval depending on re no bk braces if not set and are literals define re intervals re hat lists not newline if this bit is set and aren t recognized as operators if not set they are define re limited ops re intervals if this bit is set newline is an alternation operator if not set newline is literal define re newline alt re limited ops if this bit is set then defines an interval and and are literals if not set then defines an interval define re no bk braces re newline alt if this bit is set defines a group and and are literals if not set defines a group and and are literals define re no bk parens re no bk braces if this bit is set then digit matches digit if not set then digit is a back reference define re no bk refs re no bk parens if this bit is set then is an alternation operator and is literal if not set then is an alternation operator and is literal define re no bk vbar  {
	                                                                                                                                                                                                voar :: 5
	                                                                                                                                                                                                kbar :: 5
                                                                                                                                                                                                   }
re no bk refs if this bit is set then an ending range point collating  {
	     collating :: -1000
             }
higher than the starting range point as in z a is invalid if not set then when ending range point collates  {
	            collates :: -1000
                   }
higher than the starting range point the range is ignored define re no empty ranges re no bk vbar if this bit is set then an unmatched is ordinary if not set then an unmatched is invalid define re unmatched right paren ord re no empty ranges if this bit is set succeed as soon as we match the whole pattern without further backtracking  {
	                                                     mysterious :: -1000
                                                              }
define re no posix backtracking re unmatched right paren ord if this bit is set do not process the gnu regex operators if not set then the gnu regex operators are recognized define re no gnu ops re no posix backtracking if this bit is set turn on internal regex debugging if not set and debugging was on turn it off this only works if regex c is compiled ddebug  {
	                                                               bedbug :: 7
	                                                               redbug :: 7
                                                                    }
we define this bit always so that all that s needed to turn on debugging is to recompile regex c the calling code can always have this bit set and it won t affect anything in the normal case define re debug re no gnu ops if this bit is set a syntactically  {
	                                       syntactically :: -1000
                                                   }
invalid interval is treated as a string of ordinary characters for example the ere a is treated as a define re invalid interval ord re debug eglibc  {
                         }
old regex implementation does not support these ifdef option posix regexp glibc if this bit is set then ignore case when matching if not set then case is significant define re icase re invalid interval ord this bit is used internally like re context indep anchors but only for because it is difficult  {
	                                           difficult :: -1000
                                                   }
to scan the regex backwards to find whether should be special define re caret  {
	        caret :: -1000
            }
anchors here re icase if this bit is set then cannot be first in an bre or immediately after an alternation or begin group operator define re context invalid dup re caret anchors here if this bit is set then no sub will be set to during re compile pattern define re no sub re context invalid dup endif option posix regexp glibc endif this global variable defines the particular regexp syntax to use for some interfaces when a regexp is compiled the syntax used is stored in the pattern buffer so changing this does not affect already compiled regexps  {
	                                                                                             repegs :: 9
	                                                                                              reges :: 9
                                                                                                  }
extern reg syntax t re syntax options ifdef use gnu define combinations of the above bits for the standard possibilities the comments delimit what gets put into the texinfo  {
	                      toxine :: 10
	                     toxines :: 9
	                       toxin :: 9
                           }
file so don t delete them begin syntaxes  {
	syntaxes :: -1000
      }
define re syntax emacs define re syntax awk re backslash escape in lists re dot not null re no bk parens re no bk refs re no bk vbar re no empty ranges re dot newline re context indep anchors re char classes re unmatched right paren ord re no gnu ops define re syntax gnu awk re syntax posix extended re backslash escape in lists re invalid interval ord re dot not null re context indep ops re context invalid ops define re syntax posix awk re syntax posix extended re backslash escape in lists re intervals re no gnu ops re invalid interval ord define re syntax grep  {
	                                                                                                        grope :: 6
	                                                                                                        gripe :: 6
	                                                                                                        grape :: 6
	                                                                                                       gropes :: 5
	                                                                                                       groped :: 5
	                                                                                                       gripey :: 5
	                                                                                                       gripes :: 5
	                                                                                                       griped :: 5
	                                                                                                         prep :: 5
	                                                                                                       grapey :: 5
	                                                                                                       grapes :: 5
	                                                                                                       graped :: 5
	                                                                                                         grey :: 5
	                                                                                                         grew :: 5
	                                                                                                         geep :: 5
	                                                                                                          pre :: 5
                                                                                                            }
re bk plus qm re char classes re hat lists not newline re intervals re newline alt define re syntax egrep  {
	                gere :: 6
	                eger :: 6
	               repeg :: 6
	              egrets :: 6
                   }
re char classes re context indep anchors re context indep ops re hat lists not newline re newline alt re no bk parens re no bk vbar define re syntax posix egrep re syntax egrep re intervals re no bk braces re invalid interval ord p d section lines ff define re syntax ed re syntax posix basic define re syntax sed re syntax posix basic syntax bits common to both basic and extended posix regex syntax define re syntax posix common re char classes re dot newline re dot not null re intervals re no empty ranges ifdef option posix regexp glibc define re syntax posix basic re syntax posix common re bk plus qm re context invalid dup else define re syntax posix basic re syntax posix common re bk plus qm endif differs  {
	                                                                                                                                differs :: -1000
                                                                                                                                      }
from posix basic only in that re bk plus qm becomes re limited ops i e are not recognized actually this isn t minimal since other operators such as aren t disabled define re syntax posix minimal basic re syntax posix common re limited ops define re syntax posix extended re syntax posix common re context indep anchors re context indep ops re no bk braces re no bk parens re no bk vbar re context invalid ops re unmatched right paren ord differs from posix extended in that re context indep ops is removed and re no bk refs is added define re syntax posix minimal extended re syntax posix common re context indep anchors re context invalid ops re no bk braces re no bk parens re no bk refs re no bk vbar re unmatched right paren ord end syntaxes maximum number of duplicates  {
	                                                                                                                                   interventionism :: -1000
                                                                                                                                                 }
an interval can allow some systems erroneously  {
	erroneously :: -1000
     }
define this in other header files but we want our value so remove any previous define ifdef re dup max undef re dup max endif if sizeof int then overflows define re dup max x fff endif posix cflags bits i e information for regcomp if this bit is set then use extended regular expression syntax if not set then use basic regular expression syntax define reg extended if this bit is set then ignore case when matching if not set then case is significant define reg icase reg extended if this bit is set then anchors do not match at newline characters in the string if not set then anchors do match at newlines define reg newline reg icase if this bit is set then report only success or fail in regexec if not set then returns differ between not matching and errors define reg nosub reg newline posix eflags  {
	                                                                                                                                            stentorian :: -1000
                                                                                                                                                     }
bits i e information for regexec if this bit is set then the beginning of line operator doesn t match the beginning of the string presumably  {
	               presumably :: -1000
                        }
because it s not the beginning of a line if not set then the beginning of line operator does match the beginning of the string define reg notbol like reg notbol except for the end of line define reg noteol ifdef option posix regexp glibc use pmatch  {
	                                        phatic :: 7
	                                      smatches :: 7
	                                      smatched :: 7
	                                          phat :: 7
	                                        smatch :: 9
                                             }
to delimit the start and end of the search in the buffer define reg startend endif if any error codes are removed changed or added update the re error msg table in regex c typedef enum if defined xopen source defined use xopen k reg enosys this will never happen for this implementation endif reg noerror success reg nomatch didn t find a match for regexec posix regcomp return error codes in the order listed in the standard reg badpat invalid pattern reg ecollate inalid  {
	                                                                              sialid :: 8
	                                                                              unlaid :: 7
	                                                                            dialings :: 7
	                                                                            sialidan :: 7
	                                                                             sialids :: 7
	                                                                             dialing :: 8
	                                                                              dualin :: 7
                                                                                   }
collating element reg ectype invalid character class name reg eescape trailing backslash reg esubreg invalid back reference reg ebrack unmatched left bracket reg eparen parenthesis  {
	             parenthesis :: -1000
                       }
imbalance  {
	imbalance :: -1000
 }
reg ebrace unmatched reg badbr invalid contents of reg erange invalid range end reg espace ran out of memory reg badrpt no preceding re for repetition op error codes we ve added reg eend  {
	                            erned :: 5
	                             wend :: 5
	                             vend :: 5
	                             tend :: 5
	                             send :: 5
	                             pend :: 5
	                             need :: 5
	                             mend :: 5
	                             lend :: 5
	                             hend :: 5
	                             fend :: 5
	                             dene :: 5
	                             bend :: 5
	                              een :: 6
	                              den :: 5
                                }
premature end reg esize compiled pattern bigger than bytes reg erparen  {
         }
unmatched or not returned from regcomp reg errcode t this data structure represents a compiled pattern before calling the pattern compiler the fields buffer allocated fastmap  {
                        }
and translate can be set after the pattern has been compiled the fields re nsub not bol  {
	           bowls :: 3
	           bowel :: 3
	           boult :: 3
	           boule :: 3
	           botel :: 3
	           borel :: 3
	           boral :: 3
	           bolus :: 4
	           bolts :: 4
	           bolos :: 3
	           bolls :: 3
	           boles :: 4
	           bolds :: 4
	           bolas :: 4
	           bolar :: 4
	           boils :: 3
	           bogle :: 3
	           bodle :: 3
	           baloo :: 3
	            lobs :: 3
	            lobi :: 3
	            lobe :: 3
	            bowl :: 4
	            bolt :: 5
	            bolo :: 4
	            boll :: 4
	            bole :: 5
	            bold :: 5
	            bola :: 5
	            boil :: 4
	            blow :: 3
	            blot :: 3
	            bloc :: 3
	          bolter :: 3
	          bolted :: 3
	          bolshy :: 3
	          bolide :: 3
	          boleti :: 3
	          bolete :: 3
	          bolder :: 3
	             vol :: 3
	             sol :: 3
	             pol :: 3
	             mol :: 3
	             lob :: 4
	             dol :: 3
	             col :: 3
	             boy :: 3
	             box :: 3
	             bow :: 3
	             bot :: 3
	             bos :: 3
	             bor :: 3
	             bop :: 3
	             bok :: 3
	             boh :: 3
	             bog :: 3
	             bod :: 3
	             boa :: 3
	             bel :: 3
	             bal :: 3
	              lo :: 3
	              bo :: 4
               }
and not eol  {
	joles :: 3
	joled :: 3
	holey :: 3
	holes :: 3
	holed :: 3
	golpe :: 3
	golem :: 3
	folie :: 3
	eorls :: 3
	doles :: 3
	doled :: 3
	dolce :: 3
	coley :: 3
	coles :: 3
	coled :: 3
	boles :: 3
	wolve :: 3
	eolith :: 3
	eolian :: 3
	volte :: 3
	volet :: 3
	voles :: 3
	voled :: 3
	volae :: 3
	toles :: 3
	toled :: 3
	vole :: 4
	tole :: 4
	sole :: 4
	role :: 4
	solve :: 3
	soles :: 3
	soler :: 3
	solen :: 3
	solei :: 3
	soled :: 3
	pole :: 4
	orle :: 3
	ogle :: 3
	nole :: 4
	noel :: 3
	mole :: 4
	lowe :: 3
	love :: 3
	lote :: 3
	lose :: 3
	lore :: 3
	lope :: 3
	lone :: 3
	lome :: 3
	loke :: 3
	loge :: 3
	lode :: 3
	lobe :: 3
	koel :: 3
	jole :: 4
	hole :: 4
	helo :: 3
	goel :: 3
	eorl :: 4
	enol :: 3
	dole :: 4
	cole :: 4
	bole :: 4
	roles :: 3
	poley :: 3
	poles :: 3
	poler :: 3
	poled :: 3
	moles :: 3
	vol :: 3
	sol :: 3
	pol :: 3
	ole :: 3
	mol :: 3
	eon :: 3
	ell :: 3
	dol :: 3
	col :: 3
	lo :: 3
	el :: 3
 }
are available all other fields are private to the regex routines ifndef re translate type define re translate type unsigned char ifdef use gnu define re translate type re translate type endif endif ifdef use gnu define repb  {
	                                 reps :: 5
	                                rebop :: 5
	                                  rep :: 6
	                                  reb :: 5
                                    }
prefix name name else define repb prefix name name endif struct re pattern buffer space that holds the compiled pattern it is declared as unsigned char because its elements are sometimes used as array indexes unsigned char repb prefix buffer number of bytes to which buffer points unsigned long int repb prefix allocated number of bytes actually used in buffer unsigned long int repb prefix used syntax setting with which the pattern was compiled reg syntax t repb prefix syntax pointer to a fastmap if any otherwise zero re search uses the fastmap if there is one to skip over impossible starting points for matches char repb prefix fastmap either a translate table to apply to all characters before comparing  {
	                                                                                                              comparing :: -1000
                                                                                                                      }
them or zero for no translation the translation is applied to a pattern when it is compiled and to a string when it is matched re translate type repb prefix translate number of subexpressions  {
                                }
found by the compiler size t re nsub zero if this pattern cannot match the empty string one else well in truth  {
	                truth :: -1000
                    }
it s used only in re search to see whether or not we should use the fastmap so we don t set this absolutely perfectly  {
	               perfectly :: -1000
                       }
see re compile fastmap the duplicate case unsigned repb prefix can be null if regs  {
	 semiporcelain :: -1000
             }
unallocated  {
	unallocated :: -1000
 }
allocate space in the regs structure for max re nregs  {
	    greys :: 6
	   krengs :: 6
	    dregs :: 7
	    brens :: 6
	    wrens :: 6
        }
re nsub groups if regs reallocate reallocate space if necessary if regs fixed use what s there ifdef use gnu define regs unallocated define regs reallocate define regs fixed endif unsigned repb prefix regs allocated set to zero when regex compile compiles  {
	                               encephalon :: -1000
                                        }
a pattern set to one by re compile fastmap if it updates the fastmap unsigned repb prefix fastmap accurate if set re match does not return information about subexpressions unsigned repb prefix no sub if set a beginning of line anchor doesn t match at the beginning of the string unsigned repb prefix not bol similarly for an end of line anchor unsigned repb prefix not eol if true an anchor at a newline matches unsigned repb prefix newline anchor typedef struct re pattern buffer regex t type for byte offsets within the string posix mandates  {
	                                                                                       mandates :: -1000
                                                                                              }
this typedef int regoff t ifdef use gnu this is the structure we store register match data in see regex texinfo for a full description of what registers match struct re registers unsigned num regs regoff t start regoff t end if regs allocated is regs unallocated in the pattern buffer re match returns information about at least this many registers the first time a regs structure is passed ifndef re nregs define re nregs endif endif posix specification for registers aside from the different names than re registers posix uses an array of structures instead of a structure of arrays typedef struct regoff t rm so byte offset from string s start to substring s start regoff t rm eo byte offset from string s start to substring s end regmatch t declarations for routines ifdef use gnu sets the current default syntax to syntax and return the old syntax you can also simply assign to the re syntax options variable extern reg syntax t re set syntax reg syntax t syntax compile the regular expression pattern with length length and syntax given by the global re syntax options into the buffer buffer return null if successful and an error string if not to free the allocated storage you must call regfree on buffer note that the translate table must either have been initialised  {
	                                                                                                                                                                                                                     trivialised :: 15
	                                                                                                                                                                                                                     initiatives :: 14
	                                                                                                                                                                                                                     italianised :: 15
	                                                                                                                                                                                                                     initializes :: 18
	                                                                                                                                                                                                                     initialized :: 19
	                                                                                                                                                                                                                     initialisms :: 15
	                                                                                                                                                                                                                      initialize :: 17
	                                                                                                                                                                                                                      initialism :: 17
	                                                                                                                                                                                                                      initialise :: 20
                                                                                                                                                                                                                               }
by regcomp with a malloc ed value or set to null before calling regfree extern const char re compile pattern const char pattern size t length struct re pattern buffer buffer compile a fastmap for the compiled pattern in buffer used to accelerate  {
	                                accelerate :: -1000
                                         }
searches  {
	searches :: -1000
 }
return if successful and if was an internal error extern int re compile fastmap struct re pattern buffer buffer search in the string string with length length for the pattern compiled into buffer start searching at position start for range characters return the starting position of the match for no match or for an internal error also return register information in regs if regs and buffer no sub are nonzero extern int re search struct re pattern buffer buffer const char string int length int start int range struct re registers regs like re search but search in the concatenation of string and string also stop searching at index start stop extern int re search struct re pattern buffer buffer const char string int length const char string int length int start int range struct re registers regs int stop like re search but return how many characters in string the regexp in buffer matched starting at position start extern int re match struct re pattern buffer buffer const char string int length int start struct re registers regs relates  {
	                                                                                                                                                                            relates :: -1000
                                                                                                                                                                                  }
to re match as re search relates to re search extern int re match struct re pattern buffer buffer const char string int length const char string int length int start struct re registers regs int stop set regs to hold num regs registers storing them in starts and ends subsequent matches using buffer and regs will use this memory for recording  {
	                                                    recording :: -1000
                                                            }
register information starts and ends must be allocated with malloc and must each be at least num regs sizeof regoff t bytes long if num regs then subsequent matches should allocate their own register data unless this function is called the first search or match using pattern buffer will allocate its own register data without freeing the old data extern void re set registers struct re pattern buffer buffer struct re registers regs unsigned int num regs regoff t starts regoff t ends endif use gnu if defined regex re comp defined libc defined use bsd ifndef cray  {
	                                                                                             dari :: -1000
                                                                                                }
bsd compatibility extern char re comp const char extern int re exec const char endif endif gcc and later have restrict c compilers have restrict and configure may have defined restrict ifndef restrict if gnuc gnuc gnuc minor if defined restrict l stdc version define restrict restrict else define restrict endif endif endif gcc and up support the restrict syntax ifndef restrict arr if gnuc gnuc gnuc minor defined gnug define restrict arr restrict else define restrict arr endif endif posix compatibility extern int regcomp regex t restrict preg  {
	                                                                                    prog :: 5
	                                                                                    prig :: 5
	                                                                                    prez :: 5
	                                                                                    prey :: 5
	                                                                                    prex :: 5
	                                                                                    areg :: 5
	                                                                                   purge :: 5
	                                                                                   porge :: 5
	                                                                                   parge :: 5
	                                                                                     pre :: 6
                                                                                       }
const char restrict pattern int cflags extern int regexec const regex t restrict preg const char restrict string size t nmatch  {
	           smatching :: 8
	             snatchy :: 7
	              nautch :: 8
	            smatches :: 7
	            smatched :: 7
	              stanch :: 7
	              snatch :: 8
	              smatch :: 9
                   }
regmatch t pmatch restrict arr int eflags extern size t regerror int errcode const regex t restrict preg char restrict errbuf  {
                   }
size t errbuf size extern void regfree regex t preg ifdef cplusplus endif c endif regex h copyright c free software foundation inc this file is part of the gnu c library contributed by ulrich  {
	                           utricle :: 7
                                 }
drepper  {
	droppers :: 10
	dropper :: 11
	prepped :: 9
	drippers :: 10
	dripper :: 11
 }
drepper cygnus com the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef regexp h define regexp h the contents of this header file was first standardized in x open system interface and headers issue originally coming  {
	                                                                                                                                            coming :: -1000
                                                                                                                                                 }
from sysv in issue version it is marked as to be witdrawn  {
	    windrow :: 10
	   outdrawn :: 10
	   misdrawn :: 10
	  withdrawn :: 10
          }
and it has been withdrawn  {
	withdrawn :: -1000
   }
in susv  {
 }
this code shouldn t be used in any newly written code it is included only for compatibility reasons use the posix definition in regex h for portable applications and a reasonable interface include features h include alloca h include regex h include stdlib h include string h the implementation provided here emulates  {
	                                           emulates :: -1000
                                                  }
the needed functionality by mapping to the posix regular expression matcher  {
	   matcher :: -1000
         }
the interface for the here included function is weird this really is a harmless word the user has to provide six macros before this header file can be included init declarations vor  {
	                        dabbled :: -1000
                              }
variables which can be used by the other macros getc return the value of the next character in the regular expression pattern successive calls should return successive characters peekc return the value of the next character in the regular expression pattern immediately successive calls to peekc should return the same character which should also be the next character returned by getc ungetc  {
	                                                       ungets :: 9
	                                                       uncate :: 7
	                                                      urgency :: 7
	                                                      unteach :: 7
	                                                        unwet :: 7
	                                                        unset :: 7
	                                                        unmet :: 7
	                                                        unlet :: 7
	                                                        unket :: 7
	                                                        ungot :: 7
	                                                        unget :: 10
	                                                         unce :: 7
	                                                       urgent :: 7
                                                            }
c cause c to be returned by the next call to getc and peekc return ptr used for normal exit of the compile function ptr is a pointer to the character after the last character of the compiled regular expression error val used for abnormal  {
	                                    abnormal :: -1000
                                           }
return from compile val is the error number the error codes are range endpoint  {
	     endpoint :: -1000
            }
too large bad number digit out of range illegal or missing delimiter no remembered  {
	   remembered :: -1000
            }
search string imbalance too many more tan two numbers given in expected after first number exceeds second in imbalance regular expression overflow begin decls interface variables they contain the results of the successful calls to setp and advance extern char loc extern char loc the use of this variable in the advance function is not supported extern char locs ifndef do not define compile get and compile the user supplied pattern up to end of line or string or until eof is seen whatever happens first the result is placed in the buffer starting at expbuf  {
                                                                                              }
and delimited  {
	saiga :: -1000
 }
by endbuf  {
	undeaf :: 7
 }
this function cannot be defined in the libc itself since it depends on the macros char compile char restrict instring  {
	           insuring :: 13
	           inhering :: 10
	           unstrung :: 10
	           unstring :: 13
	           ingrains :: 10
	           stirring :: 10
	           restring :: 10
	           lustring :: 10
	          unstrings :: 11
	          trainings :: 10
	           inshrine :: 10
	         instarring :: 10
	            gastrin :: 10
	          inserting :: 11
	           resiting :: 10
	           resining :: 10
	           snifting :: 10
	          printings :: 10
	          centrings :: 10
	           snorting :: 10
	           injuring :: 10
	         unstringed :: 11
	          enterings :: 10
	           untiring :: 11
                  }
char restrict expbuf const char restrict endbuf int eof char input buffer null size t input size size t current size int ch int error init align the expression buffer according to the needs for an object of type regex t then check for minimum size of the buffer for the compiled regular expression regex t expr ptr if defined gnuc gnuc const size t req alignof  {
	                                                             align :: 10
                                                                 }
regex t else how shall we find out we simply guess it and can change it is this really proofs  {
	             proofs :: -1000
                  }
to be wrong const size t req endif expbuf req expbuf expbuf char req if endbuf expbuf sizeof regex t error expr ptr regex t expbuf the remaining space in the buffer can be used for the compiled pattern expr ptr repb prefix buffer expbuf sizeof regex t expr ptr repb prefix allocated endbuf char expr ptr repb prefix buffer while ch getc eof if ch ch n ungetc ch break if current size input size size t new size input size input size char new room char alloca new size see whether we can use the old buffer if new room new size input buffer input size new size input buffer char memcpy new room input buffer current size else if input buffer input size new room input size new size else input size new size input buffer char memcpy new room input buffer current size input buffer current size ch if current size input buffer current size else input buffer now compile the pattern error regcomp expr ptr input buffer reg newline if error oh well we have to translate posix error codes switch error case reg badpat case reg ecollate case reg ectype case reg eescape case reg badrpt case reg eend case reg erparen default there is no matching error code return case reg esubreg return case reg ebrack return case reg eparen return case reg ebrace return case reg badbr return case reg erange return case reg espace case reg esize error everything is ok return char expr ptr repb prefix buffer expr ptr repb prefix used endif find the next match in string the compiled regular expression is found in the buffer starting at expbuf loc will return the first character matched and loc points to the next unmatched character extern int step const char restrict string const char restrict expbuf throw match the beginning of string with the compiled regular expression in expbuf if the match is successful loc will contain the position of the first unmatched character extern int advance const char restrict string const char restrict expbuf throw end decls endif regexp h copyright c the regents of the university of california all rights reserved redistribution and use in source and binary forms with or without modification are permitted provided that the following conditions are met redistributions of source code must retain the above copyright notice this list of conditions and the following disclaimer redistributions in binary form must reproduce the above copyright notice this list of conditions and the following disclaimer in the documentation and or other materials provided with the distribution neither the name of the university nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission this software is provided by the regents and contributors as is and any express or implied warranties including but not limited to the implied warranties of merchantability and fitness for a particular purpose are disclaimed in no event shall the regents or contributors be liable for any direct indirect incidental special exemplary or consequential damages including but not limited to procurement of substitute goods or services loss of use data or profits or business interruption however caused and on any theory of liability whether in contract strict liability or tort including negligence or otherwise arising in any way out of the use of this software even if advised of the possibility of such damage portions copyright c by internet software consortium permission to use copy modify and distribute this software for any purpose with or without fee is hereby granted provided that the above copyright notice and this permission notice appear in all copies the software is provided as is and internet software consortium disclaims all warranties with regard to this software including all implied warranties of merchantability and fitness in no event shall internet software consortium be liable for any special direct indirect or consequential damages or any damages whatsoever  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           whatsoever :: -1000
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
resulting from loss of use data or profits whether in an action of contract negligence or other tortious  {
	         tortious :: -1000
                }
action arising out of or in connection with the use or performance of this software resolv h berkeley bindid  {
	           bandied :: 7
	            bindis :: 8
	          biddings :: 7
	             bindi :: 9
	           birdied :: 7
	           bidding :: 8
                 }
resolv h v vixie  {
	nixies :: 6
	dixie :: 7
	civie :: 6
	pixies :: 6
	dixies :: 6
	fixive :: 7
	visie :: 7
	vizier :: 6
	vexil :: 6
	visies :: 6
	vinier :: 6
	pixie :: 7
	nixie :: 7
  }
exp ifndef resolv h these headers are needed for types used in the struct res state declaration include sys types h include netinet in h ifndef need res state define resolv h include sys param h include sys cdefs h include stdio h include arpa  {
	                                        para :: 5
	                                        arna :: 5
	                                        aria :: 5
	                                        area :: 5
	                                        arba :: 5
	                                       praam :: 5
                                           }
nameser  {
	namers :: 9
	ramees :: 9
	lameters :: 9
	nameless :: 9
	names :: 9
 }
h endif ifndef res state defined define res state defined typedef enum res goahead  {
	     godheads :: 10
	      godhead :: 11
            }
res nextns  {
	xenons :: 7
	sexton :: 7
	sextan :: 7
	nextness :: 8
	tenons :: 7
	sext :: 7
	next :: 7
	ntgens :: 7
 }
res modified res done res error res sendhookact  {
	backpacker :: -1000
      }
typedef res sendhookact res send qhook  {
	shooks :: 6
	chook :: 7
	quooke :: 6
	chooks :: 6
	shook :: 7
    }
struct sockaddr in const ns const u char query int querylen  {
	   queerly :: 11
	   queenly :: 11
         }
u char ans int anssiz  {
	anis :: 7
   }
int resplen  {
	repanels :: 9
	respell :: 9
	respelt :: 9
	besprent :: 9
	resplend :: 13
	resplice :: 9
	resole :: 9
	resile :: 9
	resale :: 9
	repels :: 9
	nestler :: 9
	resplended :: 9
 }
typedef res sendhookact res send rhook  {
	shooks :: 6
	drook :: 6
	crook :: 6
	chook :: 7
	brook :: 6
	chooks :: 6
	shook :: 7
    }
const struct sockaddr in ns const u char query int querylen u char ans int anssiz int resplen global defines and variables for resolver  {
	              snaillike :: -1000
                      }
stub define maxns  {
	damns :: 6
	mans :: 6
	moxas :: 6
	moans :: 6
	means :: 6
	maxis :: 7
	maxes :: 7
	manus :: 6
	manos :: 6
	mangs :: 6
	manes :: 6
	mains :: 7
	max :: 6
 }
max name servers we ll track define maxdflsrch  {
      }
default domain levels to try define maxdnsrch  {
     }
max domains in search path define localdomainparts  {
	caprices :: -1000
     }
min levels in name that is local define res timeout min seconds between retries  {
	      retries :: -1000
            }
define maxresolvsort  {
 }
number of net to sort on define res maxndots  {
       }
should reflect bit field size define res maxretrans  {
	untaught :: -1000
      }
only for resolv conf res options define res maxretry  {
	barretry :: 10
       }
only for resolv conf res options define res dflretry  {
       }
default tries define res maxtime  {
	maximite :: 9
   }
infinity in milliseconds struct res state int retrans  {
	ranters :: 9
	 serran :: 10
	retransmit :: 10
	returns :: 10
	retrain :: 10
	retears :: 9
	retards :: 9
	retains :: 9
	entraps :: 9
	regrants :: 11
	 retral :: 9
	regrant :: 10
	serrano :: 9
	serrans :: 10
	 terras :: 9
	terranes :: 9
	terrains :: 9
	retracks :: 9
	retrains :: 11
      }
retransmition  {
	retranslations :: 17
	retransmit :: 18
	reimportations :: 16
	recrimination :: 16
	retransmitting :: 19
	retransmission :: 17
	retransmissions :: 16
	retransmits :: 16
	retranslation :: 19
	recriminations :: 17
	remonstrations :: 16
	remonstration :: 17
	reorientations :: 16
 }
time interval int retry  {
	retry :: -1000
  }
number of times to retransmit u long options option flags see below int nscount  {
	     nocturns :: 9
	     recounts :: 9
	     accounts :: 9
	   encounters :: 9
            }
number of name servers struct sockaddr in nsaddr  {
	 readds :: 7
      }
list maxns address of name server define nsaddr nsaddr list for backward compatibility u short id current message id byte hole  {
	                hole :: -1000
                   }
here char dnsrch  {
	cuckoldom :: -1000
 }
maxdnsrch components of domain to search char defdname  {
	defamed :: 10
	defanged :: 10
	 defend :: 10
      }
default domain deprecated u long pfcode  {
	amplification :: -1000
    }
res prf flags see below unsigned ndots  {
	meretriciously :: -1000
     }
threshold for initial abs query unsigned nsort  {
	nitros :: 6
	fronts :: 6
	shorten :: 6
	thorns :: 6
	 trons :: 6
	 sport :: 6
	 snort :: 8
	 short :: 6
	snorted :: 6
	snorty :: 7
	snorts :: 7
     }
number of elements in sort list unsigned ipv unavail connecting to ipv server failed unsigned unused struct struct in addr addr u int t mask sort list maxresolvsort byte hole here on bit architectures res send qhook qhook query hook res send rhook rhook response hook int res h errno last one set for this context int vcsock  {
                                                        }
private for res send vc i o u int flags private see below byte hole here on bit architectures union char pad on an i this means b total struct u int t nscount u int t nsmap  {
	                                 nams :: 6
	                                nomas :: 6
                                    }
maxns int nssocks  {
 }
maxns u int t nscount u int t nsinit  {
	  sennit :: 7
	 tinnies :: 7
	tinnitus :: 7
	ninjitsu :: 7
	 kainits :: 7
       }
struct sockaddr in nsaddrs  {
  }
maxns ifdef libc unsigned long long int initstamp  {
	imitants :: 11
      }
attribute packed  {
	pathological :: -1000
 }
else unsigned int initstamp endif ext u typedef struct res state res state undef need res state endif ifdef resolv h revision information this is the release date in yyyymmdd  {
                            }
format it can change every day so the right thing to do with it is use it in preprocessor commands such as if res do not compare for equality rather use it to determine whether your resolver is new enough to contain a certain feature define res resolver configuration file normally not present but may contain the address of the inital  {
	                                                      instil :: 8
	                                                      instal :: 8
	                                                     pintail :: 7
	                                                      unital :: 9
	                                                       intil :: 7
	                                                    intaglio :: 7
	                                                      trinal :: 7
	                                                     invital :: 7
	                                                     inutile :: 7
	                                                     nautili :: 7
	                                                     intimal :: 7
	                                                     instils :: 7
	                                                     instals :: 7
	                                                     intagli :: 8
	                                                        inia :: 7
	                                                     initial :: 7
                                                           }
name server s to query and the domain search list ifndef path resconf  {
	     reckons :: 9
           }
define path resconf etc resolv conf endif struct res sym int number identifying number like t mx char name its symbolic name like mx char humanname  {
                        }
its fun name like mail exchanger  {
	exchanger :: -1000
    }
resolver flags used to be discrete  {
	discrete :: -1000
    }
per module statics  {
	statics :: -1000
 }
ints define res f vc x socket is tcp define res f conn x socket is connected  {
	       connected :: -1000
               }
define res f edns  {
	dense :: 5
	send :: 5
	neds :: 5
	erns :: 5
	ends :: 6
	edhs :: 5
	dens :: 6
  }
err x edns caused errors res findzonecut  {
     }
options define res exhaustive  {
	exhaustive :: -1000
  }
x always do all queries  {
	queries :: -1000
   }
resolver options keep these in synch with res debug c please define res init x address initialized define res debug x print debug messages define res aaonly  {
	                    azonal :: 7
	                    axonal :: 7
	                    atonal :: 7
	                   anomaly :: 7
	                    anally :: 7
	                    agonal :: 7
	                  atonally :: 7
                         }
x authoritative answers  {
	answers :: -1000
 }
only impl define res usevc  {
	 use :: 6
   }
x use virtual circuit  {
	circuit :: -1000
  }
define res primary x query primary server only impl define res igntc  {
	  monachist :: -1000
          }
x ignore trucation  {
	curvations :: 11
	urination :: 11
	truncation :: 11
	educations :: 11
	furcations :: 12
	neuration :: 11
	traction :: 11
	arcuation :: 13
	curtation :: 14
	luctations :: 11
	education :: 12
	curtations :: 13
	furcation :: 13
	tradition :: 11
	curvation :: 12
	eructation :: 11
	actuation :: 12
	sulcation :: 11
	luctation :: 12
	ructation :: 14
	causation :: 11
	actuations :: 11
	arcuations :: 12
	crenation :: 11
	tarnation :: 11
 }
errors define res recurse x recursion desired define res defnames  {
	  demeans :: 10
	 maenades :: 10
	  defames :: 10
	 defamers :: 10
	 pennames :: 10
	 enframed :: 10
	 enframes :: 11
	 endgames :: 10
	 enflamed :: 10
	 enflames :: 11
	defoamers :: 11
	 reframes :: 10
	 defoamer :: 10
	defeatism :: 10
	 deflates :: 10
        }
x use default domain name define res stayopen  {
	unshutting :: -1000
      }
x keep tcp socket open define res dnsrch x search up local domain tree define res insecure  {
	        pulingly :: -1000
               }
x type security disabled define res insecure x type security disabled define res noaliases  {
	    nasalises :: 11
	    collinses :: 11
	    nodalises :: 12
            }
x shuts  {
	shuts :: -1000
 }
off hostaliases  {
 }
feature define res use inet x use map ipv in gethostbyname define res rotate  {
	       rotate :: -1000
            }
x rotate ns list after each query define res nocheckname  {
        }
x do not check names for sanity  {
	sanity :: -1000
     }
define res keeptsig  {
	keepings :: 10
 }
x do not strip tsig  {
	trigos :: 5
	thighs :: 5
	twigs :: 6
	trigs :: 6
	tings :: 5
	thigs :: 6
	twig :: 5
	trig :: 5
	tigs :: 5
	thig :: 5
	taig :: 5
	taigs :: 6
	taigas :: 5
   }
records define res blast  {
	blast :: -1000
  }
x blast all recursive servers define res usebstring  {
	treasuring :: 12
	lutestring :: 12
	shoestring :: 12
	pressuring :: 12
	blustering :: 12
	lutestrings :: 12
      }
x ipv reverse lookup with byte strings define res noip  {
	     noup :: 5
	     noil :: 5
	    point :: 5
	    poind :: 5
	      poi :: 5
        }
dotint  {
	doting :: 8
	dotant :: 9
	doitit :: 7
	ditto :: 7
	toting :: 7
	dotting :: 8
	dotings :: 7
	dotiest :: 7
 }
x do not use ip int in ipv reverse lookup define res use edns x use edns define res snglkup  {
                  }
x one outstanding request at a time define res snglkupreop  {
        }
x but open new socket for each request define res use dnssec  {
	    dissent :: 7
	    dissect :: 8
	      desse :: 7
	     cussed :: 7
	   descents :: 7
	     cessed :: 7
	 dissection :: 7
	 dissecting :: 7
	   discerns :: 7
          }
x use dnssec using ok bit in opt define res notldquery  {
         }
x do not look up unqualified  {
	unqualified :: -1000
    }
name as a tld  {
	tidal :: 3
	told :: 3
	teld :: 3
	tod :: 3
	tid :: 3
	ted :: 3
	tad :: 3
	old :: 3
	eld :: 3
  }
define res default res recurse res defnames res dnsrch res noip dotint resolver pfcode values used by dig define res prf stats x define res prf update x define res prf class x define res prf cmd x define res prf ques  {
	                                     rees :: -1000
                                        }
x define res prf ans x define res prf auth x define res prf add x define res prf head x define res prf head x define res prf ttlid  {
	               antepenultimas :: -1000
                            }
x define res prf headx  {
	hexad :: 7
	heard :: 6
	heald :: 6
	heady :: 7
	heads :: 7
	hoaxed :: 6
	hexads :: 6
	head :: 8
	haed :: 6
   }
x define res prf query x define res prf reply x define res prf init x x things involving an internal static resolver context begin decls extern struct res state res state void attribute const end decls define res res state ifndef bind nostatic  {
	                                   unshaven :: -1000
                                          }
define fp nquery  {
 }
fp nquery define fp query fp query define hostalias hostalias define p query p query define res close res close define res init res init define res isourserver  {
                          }
res isourserver define res mkquery  {
   }
res mkquery define res query res query define res querydomain  {
	querimony :: 14
        }
res querydomain define res search res search define res send res send begin decls void fp nquery const u char int file throw void fp query const u char file throw const char hostalias const char throw void p query const u char throw void res close void throw int res init void throw int res isourserver const struct sockaddr in throw int res mkquery int const char int int const u char int const u char u char int throw int res query const char int int u char int throw int res querydomain const char const char int int u char int throw int res search const char int int u char int throw int res send const u char int u char int throw end decls endif define b ntop  {
	                                                                                                                                stop :: 5
	                                                                                                                                noop :: 5
	                                                                                                                                atop :: 5
                                                                                                                                   }
b ntop define b pton  {
	poon :: 5
	pion :: 5
	phon :: 5
	peon :: 5
	point :: 5
   }
b pton define dn comp dn comp define dn count labels dn count labels define dn expand dn expand define dn skipname  {
	            skiplanes :: 10
	             skiplane :: 12
	            spinnaker :: 10
                    }
dn skipname define fp resstat  {
	restarts :: 9
	hesitators :: 9
	misstate :: 9
   }
fp resstat define loc aton  {
	atonic :: 6
	atones :: 6
	atoner :: 6
	atoned :: 6
	atonal :: 5
	atony :: 7
	atone :: 7
	atonics :: 5
	atonies :: 5
	atoners :: 5
	trona :: 5
	azon :: 5
	axon :: 5
	atop :: 5
	atom :: 5
	atok :: 5
	atoc :: 5
	anon :: 5
	agon :: 5
	aeon :: 5
   }
loc aton define loc ntoa  {
	atony :: 5
	atone :: 5
	stoa :: 5
	notal :: 5
   }
loc ntoa define p cdname  {
	agnamed :: 7
	caned :: 7
	canaled :: 7
	benamed :: 7
	renamed :: 7
	creamed :: 7
	comade :: 7
	unnamed :: 7
	menace :: 7
	cinema :: 7
	menaced :: 8
	candle :: 7
	menad :: 7
   }
p cdname define p cdnname  {
	canned :: 9
   }
p cdnname define p class p class define p fqname  {
	   infame :: 7
	  foramen :: 7
        }
p fqname define p fqnname  {
	fenman :: 9
   }
p fqnname define p option p option define p secstodate  {
        }
p secstodate define p section p section define p time p time define p type p type define p rcode  {
	             scored :: 7
	              erode :: 6
	             rocked :: 6
	             crowed :: 6
	             conder :: 6
	             colder :: 6
	             codder :: 6
	             chored :: 6
	              trode :: 6
	               roed :: 6
	              score :: 6
	               ecod :: 7
	              ronde :: 6
	             ochred :: 6
                  }
p rcode define putlong  {
	siderates :: -1000
  }
putlong define putshort  {
	wordiness :: -1000
 }
putshort define res dnok  {
	dook :: 5
	snoked :: 5
  }
res dnok define res hnok  {
	teratology :: -1000
   }
res hnok define res hostalias res hostalias define res mailok  {
	  maplike :: 7
	  manlike :: 7
	  mailbox :: 7
	     moil :: 7
	     mail :: 8
	     maik :: 7
	     kail :: 7
	    milko :: 7
	    matlo :: 7
	    malik :: 7
	    mails :: 7
	    maile :: 7
        }
res mailok define res nameinquery  {
   }
res nameinquery define res nclose  {
	lenos :: 7
	lanose :: 7
	coles :: 7
	counsel :: 7
	colones :: 8
	colone :: 7
	eclosion :: 7
	nolos :: 7
	noels :: 7
   }
res nclose define res ninit  {
	binits :: 6
	binit :: 7
	pinite :: 6
	nitinol :: 6
	finite :: 6
	tining :: 6
	nicotin :: 6
	nineties :: 6
   }
res ninit define res nmkquery  {
   }
res nmkquery define res npquery  {
	enquiry :: 9
   }
res npquery define res nquery res nquery define res nquerydomain  {
        }
res nquerydomain define res nsearch  {
	navarchs :: 9
	nomarchs :: 9
	mesarch :: 9
	menarches :: 9
	nomarchies :: 9
	navarchies :: 9
	endarch :: 9
   }
res nsearch define res nsend  {
	stend :: 6
	spend :: 6
	shend :: 6
	scend :: 6
   }
res nsend define res nisourserver  {
   }
res nisourserver define res ownok  {
   }
res ownok define res queriesmatch  {
	requiescat :: 15
   }
res queriesmatch define res randomid  {
	randoms :: 10
	ransomed :: 10
	randomize :: 11
	randomise :: 11
	radiomen :: 10
	random :: 11
	randomized :: 13
	randomizes :: 10
	randomised :: 13
	randomises :: 10
	bondmaid :: 10
   }
res randomid define sym ntop sym ntop define sym ntos  {
	    stown :: 5
	    stoun :: 5
	    stony :: 5
	    stonk :: 5
	    stong :: 5
	    stone :: 5
	    stond :: 5
	     tons :: 5
	     snot :: 5
	     naos :: 5
        }
sym ntos define sym ston  {
	atones :: 5
	stonked :: 5
	stonker :: 5
	stonily :: 5
	stonied :: 5
	stonier :: 5
	stound :: 5
	stonks :: 5
	stoney :: 6
	stones :: 5
	stoner :: 6
	stonen :: 5
	stoned :: 6
	stolen :: 5
	stinko :: 5
	stingo :: 5
	trons :: 5
	toons :: 5
	stown :: 6
	stoun :: 6
	stony :: 7
	stonk :: 7
	stong :: 7
	stone :: 7
	stond :: 7
	steno :: 6
	stow :: 5
	stop :: 5
	stob :: 5
	stoa :: 5
	sten :: 5
	soon :: 5
	snot :: 6
	snout :: 5
	snort :: 5
   }
sym ston begin decls int res hnok const char throw int res ownok const char throw int res mailok const char throw int res dnok const char throw int sym ston const struct res sym const char int throw const char sym ntos const struct res sym int int throw const char sym ntop const struct res sym int int throw int b ntop u char const size t char size t throw int b pton char const u char size t throw int loc aton const char ascii u char binary throw const char loc ntoa const u char binary char ascii throw int dn skipname const u char const u char throw void putlong u int t u char throw void putshort u int t u char throw const char p class int throw const char p time u int t throw const char p type int throw const char p rcode int throw const u char p cdnname const u char const u char int file throw const u char p cdname const u char const u char file throw const u char p fqnname const u char cp const u char msg int char int throw const u char p fqname const u char const u char file throw const char p option u long option throw char p secstodate u long throw int dn count labels const char throw int dn comp const char u char int u char u char throw int dn expand const u char const u char const u char char int throw u int res randomid void throw int res nameinquery const char int int const u char const u char throw int res queriesmatch const u char const u char const u char const u char throw const char p section int section int opcode throw things involving a resolver context int res ninit res state throw int res nisourserver const res state const struct sockaddr in throw void fp resstat const res state file throw void res npquery const res state const u char int file throw const char res hostalias const res state const char char size t throw int res nquery res state const char int int u char int throw int res nsearch res state const char int int u char int throw int res nquerydomain res state const char const char int int u char int throw int res nmkquery res state int const char int int const u char int const u char u char int throw int res nsend res state const u char int u char int throw void res nclose res state throw end decls endif endif resolv h definitions for posix b aka  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                awake :: 3
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                araks :: 3
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                alack :: 3
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                aback :: 3
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                 kaas :: 3
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                 arak :: 4
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ska :: 3
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                  oka :: 3
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                  awa :: 3
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ava :: 3
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ata :: 3
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ana :: 3
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ama :: 3
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ala :: 3
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                  aia :: 3
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                  aha :: 3
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                  aga :: 3
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ada :: 3
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                  aba :: 3
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                   aa :: 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
posix scheduling interface copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef sched h define sched h include features h get type definitions include bits types h define need size t include stddef h define need time t define need timespec include time h ifndef pid t defined typedef pid t pid t define pid t defined endif get system specific constant and data structure definitions include bits sched h define the real names for the elements of struct sched param define sched priority sched priority begin decls set scheduling parameters for a process extern int sched setparam pid t pid const struct sched param param throw retrieve scheduling parameters for a particular process extern int sched getparam  {
	                                                                                                                                                                                                                                            regmata :: 10
                                                                                                                                                                                                                                                  }
pid t pid struct sched param param throw set scheduling algorithm and or parameters for a process extern int sched setscheduler  {
	          organzines :: -1000
                   }
pid t pid int policy const struct sched param param throw retrieve scheduling algorithm for a particular purpose extern int sched getscheduler  {
	         preschedules :: 15
	         prescheduled :: 15
	          preschedule :: 17
                    }
pid t pid throw yield the processor extern int sched yield void throw get maximum priority value for a scheduler extern int sched get priority max int algorithm throw get minimum priority value for a scheduler extern int sched get priority min int algorithm throw get the sched rr interval for the named process extern int sched rr get interval pid t pid struct timespec t throw ifdef use gnu access macros for cpu set define cpu setsize  {
	                                                                     setlines :: 9
	                                                                      sestine :: 9
                                                                            }
cpu setsize define cpu set cpu cpusetp  {
	cruset :: 9
     }
cpu set s cpu sizeof cpu set t cpusetp define cpu clr cpu cpusetp cpu clr s cpu sizeof cpu set t cpusetp define cpu isset  {
	                   undrew :: -1000
                        }
cpu cpusetp cpu isset s cpu sizeof cpu set t cpusetp define cpu zero cpusetp cpu zero s sizeof cpu set t cpusetp define cpu count cpusetp cpu count s sizeof cpu set t cpusetp define cpu set s cpu setsize cpusetp cpu set s cpu setsize cpusetp define cpu clr s cpu setsize cpusetp cpu clr s cpu setsize cpusetp define cpu isset s cpu setsize cpusetp cpu isset s cpu setsize cpusetp define cpu zero s setsize cpusetp cpu zero s setsize cpusetp define cpu count s setsize cpusetp cpu count s setsize cpusetp define cpu equal cpusetp cpusetp cpu equal s sizeof cpu set t cpusetp cpusetp define cpu equal s setsize cpusetp cpusetp cpu equal s setsize cpusetp cpusetp define cpu and destset  {
	                                                                                                                       deftest :: 9
	                                                                                                                        detest :: 9
	                                                                                                                       detests :: 9
	                                                                                                                       dessert :: 9
                                                                                                                             }
srcset  {
	tasset :: -1000
 }
srcset cpu op s sizeof cpu set t destset srcset srcset define cpu or destset srcset srcset cpu op s sizeof cpu set t destset srcset srcset define cpu xor  {
	                        borax :: 3
	                         roux :: 3
	                        sorex :: 3
	                          tor :: 3
	                          nor :: 3
	                          mor :: 3
	                          lor :: 3
	                          kor :: 3
	                          jor :: 3
	                          gor :: 3
	                          for :: 3
	                          dor :: 3
	                          cor :: 3
	                          bor :: 3
                            }
destset srcset srcset cpu op s sizeof cpu set t destset srcset srcset define cpu and s setsize destset srcset srcset cpu op s setsize destset srcset srcset define cpu or s setsize destset srcset srcset cpu op s setsize destset srcset srcset define cpu xor s setsize destset srcset srcset cpu op s setsize destset srcset srcset define cpu alloc size count cpu alloc size count define cpu alloc count cpu alloc count define cpu free cpuset cpu free cpuset set the cpu affinity  {
	                                                                            affinity :: -1000
                                                                                   }
for a task extern int sched setaffinity pid t pid size t cpusetsize const cpu set t cpuset throw get the cpu affinity for a task extern int sched getaffinity pid t pid size t cpusetsize cpu set t cpuset throw endif end decls endif sched h declarations for system v style searching functions copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef search h define search h include features h define need size t include stddef h begin decls if defined use svid defined use xopen extended prototype structure for a linked list data structure this is the type used by the insque  {
	                                                                                                                                                                                                                               intuse :: 7
	                                                                                                                                                                                                                               insure :: 8
	                                                                                                                                                                                                                               unique :: 8
	                                                                                                                                                                                                                               infuse :: 7
	                                                                                                                                                                                                                               incuse :: 7
	                                                                                                                                                                                                                             basquine :: 7
	                                                                                                                                                                                                                               bisque :: 8
	                                                                                                                                                                                                                               saique :: 7
	                                                                                                                                                                                                                             uniquest :: 8
	                                                                                                                                                                                                                             mesquine :: 7
	                                                                                                                                                                                                                               risque :: 8
	                                                                                                                                                                                                                              insurer :: 7
	                                                                                                                                                                                                                              mesquin :: 8
	                                                                                                                                                                                                                              uniques :: 9
	                                                                                                                                                                                                                              uniquer :: 7
	                                                                                                                                                                                                                              inquest :: 7
	                                                                                                                                                                                                                               cinque :: 7
	                                                                                                                                                                                                                              cinques :: 8
                                                                                                                                                                                                                                    }
and remque  {
	requiems :: 7
	requiem :: 8
	marquee :: 7
	demure :: 7
	resume :: 7
	relume :: 7
	reequip :: 7
	marque :: 7
	jerques :: 7
	jerquer :: 7
 }
functions ifdef use gnu struct qelem  {
	 leme :: 6
    }
struct qelem q forw struct qelem q back char q data endif insert elem into a doubly  {
	          doubly :: -1000
               }
linked list after prev extern void insque void elem void prev throw unlink elem from the doubly linked list that it is in extern void remque void elem throw endif for use with hsearch  {
	                         thearchy :: 9
	                          mesarch :: 9
	                         hexarchy :: 9
	                       hexarchies :: 9
	                          hexarch :: 10
                                }
ifndef compar fn t define compar fn t typedef int compar fn t const void const void ifdef use gnu typedef compar fn t comparison fn t endif endif action which shall be performed in the call the hsearch typedef enum find enter action typedef struct entry char key void data entry opaque type for internal use struct entry family of hash table handling functions the functions also have reentrant counterparts  {
	                                                          counterparts :: -1000
                                                                     }
ending with r the non reentrant functions all work on a signle  {
	     singly :: 7
	     single :: 10
	    singled :: 9
	    singlet :: 9
	    singles :: 8
	     simnel :: 7
	     silene :: 7
	     silane :: 7
	     silage :: 7
	     signet :: 8
	     signer :: 8
	     signee :: 9
	     signed :: 8
	     signal :: 8
	     gingle :: 7
	     ingles :: 7
	    pingles :: 8
	     niggle :: 7
	     bingle :: 7
	     senile :: 7
	    mingles :: 8
	    signore :: 7
	    signeur :: 7
	    signees :: 7
	    jingles :: 8
	   sidelong :: 7
	    spignel :: 7
	    ginnels :: 7
	     pingle :: 7
	    gingles :: 8
	     dingle :: 7
	    swingle :: 7
	    tingles :: 8
	    dingles :: 8
	  singleton :: 7
	   gainless :: 7
	  signalled :: 7
	  signaller :: 7
	     mingle :: 7
	    shingle :: 7
	     tingle :: 7
	    niggles :: 8
	     swinge :: 7
	    bingles :: 8
	   signless :: 9
	    engilds :: 7
	   ligneous :: 7
	   signaler :: 8
	   signaled :: 8
	     jingle :: 7
	       sign :: 8
	      sling :: 7
	    lingoes :: 7
	      singe :: 7
	      silen :: 7
	      segni :: 8
	    linages :: 7
	   lightens :: 7
	    slinger :: 8
	   nigglers :: 7
	     ligase :: 7
	   pinglers :: 7
	   minglers :: 7
	   jinglets :: 7
	   kinglets :: 7
	   kingless :: 7
	   winglets :: 7
	   wingless :: 7
	   ringless :: 7
	   tinglers :: 7
	   singlets :: 7
	    ligules :: 7
	    lignose :: 8
	      ligne :: 8
	      liens :: 7
          }
internal hashing table search for entry matching item key in internal hash table if action is find return found entry or signal error by returning null if action is enter replace existing data if any with item data extern entry hsearch entry item action action throw create a new hashing table which will at most contain nel  {
	                                                   felon :: 3
	                                                    nole :: 4
	                                                    noel :: 3
	                                                    neal :: 4
	                                                    lent :: 3
	                                                    lens :: 3
	                                                    leno :: 3
	                                                    leng :: 3
	                                                    lend :: 3
	                                                    lean :: 3
	                                                   pelon :: 3
	                                                   newly :: 3
	                                                   nerol :: 3
	                                                   nelly :: 3
	                                                   neals :: 3
	                                                   ndler :: 3
	                                                   naled :: 3
	                                                   melon :: 3
	                                                     zel :: 3
	                                                     tel :: 3
	                                                     sel :: 3
	                                                     nil :: 3
	                                                     new :: 3
	                                                     net :: 3
	                                                     nep :: 3
	                                                     nek :: 3
	                                                     nef :: 3
	                                                     ned :: 3
	                                                     neb :: 3
	                                                     mel :: 3
	                                                     gel :: 3
	                                                     eel :: 3
	                                                     del :: 3
	                                                     cel :: 3
	                                                     bel :: 3
	                                                      ne :: 4
	                                                      le :: 3
                                                       }
elements extern int hcreate  {
	threaten :: 9
	threated :: 9
	acerate :: 9
	ocreate :: 11
	rechates :: 9
	rechated :: 9
	hectare :: 10
	rechate :: 10
	hereat :: 10
	hectares :: 9
  }
size t nel throw destroy current internal hashing table extern void hdestroy  {
	  hysteroid :: 10
	   herstory :: 10
          }
void throw ifdef use gnu data type for reentrant functions struct hsearch data struct entry table unsigned int size unsigned int filled reentrant versions which can handle multiple hashing tables at the same time extern int hsearch r entry item action action entry retval struct hsearch data htab  {
	                                           stab :: 5
                                              }
throw extern int hcreate r size t nel struct hsearch data htab throw extern void hdestroy r struct hsearch data htab throw endif the tsearch  {
	                toparchs :: 9
	                thearchy :: 10
	                 mesarch :: 9
	              toparchies :: 9
	              triarchies :: 9
	              thearchies :: 9
                       }
routines are very interesting they make many assumptions  {
	assumptions :: -1000
      }
about the compiler it assumes that the first field in node must be the key field which points to the datum everything depends on that for tsearch typedef enum preorder postorder endorder  {
	                       dehorner :: 10
	                     underdoers :: 10
	                       endorsed :: 11
	                       endorser :: 12
	                       endoderm :: 10
	                       enforcer :: 10
	                       enfolder :: 10
	                      endorsers :: 11
	                      underdoer :: 11
                              }
leaf visit search for an entry matching the given key in the tree pointed to by rootp and insert a new element if not found extern void tsearch const void key void rootp compar fn t compar search for an entry matching the given key in the tree pointed to by rootp if no matching entry is available return null extern void tfind  {
	                                                        teinds :: 6
                                                             }
const void key void const rootp compar fn t compar remove the element matching key from the tree pointed to by rootp extern void tdelete  {
	                tableted :: 9
	                toileted :: 9
	                 deplete :: 9
                       }
const void restrict key void restrict rootp compar fn t compar ifndef action fn t define action fn t typedef void action fn t const void nodep  {
	                     coden :: 6
	                  notepads :: 6
	                   notepad :: 7
	                      pone :: 6
	                      nope :: 7
	                      node :: 8
	                   tonepad :: 6
	                      dope :: 6
	                      done :: 6
	                     podex :: 6
	                     nowed :: 6
	                     noted :: 6
	                     nosed :: 6
	                     nopes :: 6
	                     nodes :: 7
	                     loden :: 6
	                       nod :: 6
                         }
visit value int level endif walk through the whole tree and call the action callback for every node or leaf extern void twalk  {
	                twanky :: 6
	                twanks :: 6
	                 tweak :: 6
	                 twank :: 7
	                 twals :: 7
	                 stalk :: 6
	                  twal :: 8
	                   twa :: 6
                     }
const void root action fn t action ifdef use gnu callback type for function to free a tree node if the keys are atomic data this function should do nothing typedef void free fn t void nodep destroy the whole tree call freefct  {
	                                   prefect :: 9
                                         }
for each node or leaf extern void tdestroy  {
	pockpit :: -1000
      }
void root free fn t freefct endif perform linear search for key by comparing by compar in an array base base nmemb size extern void lfind  {
	                    blind :: 6
	                  flinder :: 6
                        }
const void key const void base size t nmemb size t size compar fn t compar perform linear search for key by comparing by compar function in array base base nmemb size and insert entry if not found extern void lsearch  {
	                                  clears :: 9
	                                 mesarch :: 9
                                       }
const void key void base size t nmemb size t size compar fn t compar end decls endif search h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef semaphore  {
	                                                                                                                                                  semaphore :: -1000
                                                                                                                                                          }
h define semaphore h include features h include sys types h ifdef use xopen k define need timespec include time h endif get the definition for sem t include bits semaphore h begin decls initialize semaphore object sem to value if pshared then share it with other processes extern int sem init sem t sem int pshared unsigned int value throw free resources associated with semaphore object sem extern int sem destroy sem t sem throw open a named semaphore name with open flags oflag extern sem t sem open const char name int oflag throw close descriptor for named semaphore sem extern int sem close sem t sem throw remove named semaphore name extern int sem unlink const char name throw wait for sem being posted  {
	                                                                                                                        posted :: -1000
                                                                                                                             }
this function is a cancellation point and therefore not marked with throw extern int sem wait sem t sem ifdef use xopen k similar to sem wait but wait only until abstime this function is a cancellation point and therefore not marked with throw extern int sem timedwait sem t restrict sem const struct timespec restrict abstime endif test whether sem is posted extern int sem trywait  {
                                                                 }
sem t sem thrownl post sem extern int sem post sem t sem thrownl get current value of sem and store it in sval  {
	                  targe :: -1000
                      }
extern int sem getvalue sem t restrict sem int restrict sval throw end decls endif semaphore h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa iso c standard nonlocal  {
	                                                                                                                                                  nonlocal :: -1000
                                                                                                                                                         }
jumps  {
	kemps :: -1000
 }
setjmp h ifndef setjmp h define setjmp h include features h begin decls include bits setjmp h get jmp buf include bits sigset h get sigset t calling environment plus possibly a saved signal mask struct jmp buf tag note the machine dependent definitions of sigsetjmp assume that a jmp buf begins with a jmp buf and that mask was saved follows it do not move these members or add others before it jmp buf jmpbuf calling environment int mask was saved saved the signal mask sigset t saved mask saved signal mask begin namespace std typedef struct jmp buf tag jmp buf store the calling environment in env also saving the signal mask return extern int setjmp jmp buf env thrownl end namespace std store the calling environment in env also saving the signal mask if savemask is nonzero return this is the internal name for sigsetjmp extern int sigsetjmp struct jmp buf tag env int savemask thrownl ifndef favor bsd store the calling environment in env not saving the signal mask return extern int setjmp struct jmp buf tag env thrownl do not save the signal mask this is equivalent to the setjmp bsd function define setjmp env setjmp env else we are in bsd compatibility mode in which setjmp saves the signal mask like sigsetjmp env we have to define a macro since iso c says setjmp is one define setjmp env setjmp env endif favor bsd begin namespace std jump to the environment saved in env making the setjmp call there return val or if val is extern void longjmp struct jmp buf tag env int val thrownl attribute noreturn end namespace std if defined use bsd defined use xopen same usually longjmp is used with setjmp which does not save the signal mask but it is how env was saved that determines whether longjmp restores the mask longjmp is just an alias extern void longjmp struct jmp buf tag env int val thrownl attribute noreturn endif ifdef use posix use the same type for jmp buf and sigjmp  {
                                                                                                                                                                                                                                                                                                                                                     }
buf the mask was saved flag determines whether or not longjmp will restore the signal mask typedef struct jmp buf tag sigjmp buf store the calling environment in env also saving the signal mask if savemask is nonzero return define sigsetjmp env savemask sigsetjmp env savemask jump to the environment saved in env making the sigsetjmp call there return val or if val is restore the signal mask if that sigsetjmp call saved it this is just an alias longjmp extern void siglongjmp  {
                                                                                 }
sigjmp buf env int val thrownl attribute noreturn endif use posix define helper functions to catch unsafe code if use fortify level include bits setjmp h endif end decls endif setjmp h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef sgtty  {
	                                                                                                                                                                  gutty :: 6
                                                                                                                                                                      }
h define sgtty h include features h include sys ioctl h on some systems this type is not defined by bits ioctl types h in that case the functions are just stubs that return enosys struct sgttyb  {
                                   }
begin decls fill in params with terminal parameters associated with fd extern int gtty  {
            }
int fd struct sgttyb params throw set the terminal parameters associated with fd to params extern int stty  {
                }
int fd const struct sgttyb params throw end decls endif sgtty h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa declaration of types and functions for shadow password suite ifndef shadow h define shadow h include features h include paths h define need file include stdio h define need size t include stddef h paths to the user database files define shadow path shadow begin decls structure of the password file struct spwd  {
	                                                                                                                                                                                                  spud :: 5
	                                                                                                                                                                                                  sped :: 5
                                                                                                                                                                                                     }
char sp namp login name char sp pwdp  {
      }
encrypted password long int sp lstchg  {
	letch :: 7
	latches :: 7
	latch :: 7
	letches :: 7
	litchis :: 7
    }
date of last change long int sp min minimum number of days between changes long int sp max maximum number of days between changes long int sp warn number of days to warn user to change the password long int sp inact  {
	                                   intact :: 6
	                                 inactive :: 6
	                                 unactive :: 6
	                                 enactive :: 6
	                                    incut :: 6
	                                    inapt :: 7
	                                    idant :: 6
	                                    enact :: 7
	                                    diact :: 6
	                                    antic :: 6
	                                   anicut :: 6
	                                   enatic :: 6
	                                   enacts :: 6
                                        }
number of days the account may be inactive  {
	inactive :: -1000
      }
long int sp expire number of days since until account expires unsigned long int sp flag reserved open database for reading this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern void setspent  {
	                                                   setenants :: 10
	                                                   sepiments :: 10
	                                                    steepens :: 10
	                                                    steepest :: 10
	                                                    strepent :: 10
	                                                    outspent :: 10
	                                                   sentients :: 10
                                                           }
void close database this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern void endspent  {
	                                   foozler :: -1000
                                         }
void get next entry from database perhaps after opening the file this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern struct spwd getspent  {
	                                           gentlest :: 10
	                                           strepent :: 10
	                                           outspent :: 10
                                                  }
void get shadow entry matching name this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern struct spwd getspnam  {
                                             }
const char name read shadow entry from string this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern struct spwd sgetspent  {
                                               }
const char string read next shadow entry from stream this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern struct spwd fgetspent  {
	                                        forespent :: 11
                                                }
file stream write line containing shadow password entry to stream this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int putspent  {
	                                         outspend :: -1000
                                                }
const struct spwd p file stream ifdef use misc reentrant versions of some of the functions above these functions are not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation they are cancellation points and therefore not marked with throw extern int getspent r struct spwd result buf char buffer size t buflen struct spwd result extern int getspnam r const char name struct spwd result buf char buffer size t buflen struct spwd result extern int sgetspent r const char string struct spwd result buf char buffer size t buflen struct spwd result extern int fgetspent r file stream struct spwd result buf char buffer size t buflen struct spwd result endif misc the simple locking functionality provided here is not suitable for multi threaded  {
	                                                                                                                                  threaded :: -1000
                                                                                                                                         }
applications protect password file against multi writers  {
	writers :: -1000
     }
extern int lckpwdf  {
 }
void throw unlock password file extern int ulckpwdf  {
      }
void throw end decls endif shadow h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa iso c standard signal handling signal h ifndef signal h if defined need sig atomic t defined need sigset t define signal h endif include features h begin decls include bits sigset h sigset t sig atomic t an integral  {
	                                                                                                                                                                            integral :: -1000
                                                                                                                                                                                   }
type that can be modified atomically without the possibility of a signal arriving  {
	    arriving :: -1000
           }
in the middle of the operation if defined need sig atomic t defined signal h ifndef sig atomic t defined define sig atomic t defined begin namespace std typedef sig atomic t sig atomic t end namespace std endif undef need sig atomic t endif if defined need sigset t defined signal h defined use posix ifndef sigset t defined define sigset t defined typedef sigset t sigset t endif undef need sigset t endif ifdef signal h include bits types h include bits signum  {
	                                                                              siglum :: 9
	                                                                              ingrum :: 7
	                                                                             signeur :: 7
	                                                                             pignuts :: 7
	                                                                              pignus :: 8
	                                                                             magnums :: 7
	                                                                               suing :: 7
	                                                                                sign :: 8
	                                                                              lignum :: 9
                                                                                   }
h if defined use xopen defined use xopen k ifndef pid t defined typedef pid t pid t define pid t defined endif ifdef use xopen endif ifndef uid t defined typedef uid t uid t define uid t defined endif endif unix ifdef use posix we need struct timespec later on define need timespec include time h get the siginfo t type plus the needed symbols include bits siginfo h endif type of a signal handler typedef void sighandler  {
	                                                                     dismantler :: 12
	                                                                    highlanders :: 14
	                                                                     reshingled :: 12
	                                                                       signaler :: 12
	                                                                       signaled :: 12
	                                                                      mishandle :: 14
	                                                                     highlander :: 13
	                                                                    panhandlers :: 12
	                                                                     mishandles :: 13
	                                                                     mishandled :: 12
                                                                              }
t int the x open definition of signal specifies the svid semantic use the additional function sysv signal when x open compatibility is requested extern sighandler t sysv signal int sig sighandler t handler throw ifdef use gnu extern sighandler t sysv signal int sig sighandler t handler throw endif set the handler for the signal sig to handler returning the old handler or sig err on error by default signal has the bsd semantic begin namespace std ifdef use bsd extern sighandler t signal int sig sighandler t handler throw else make sure the used signal implementation is the svid version ifdef redirect nth extern sighandler t redirect nth signal int sig sighandler t handler sysv signal else define signal sysv signal endif endif end namespace std ifdef use xopen the x open definition of signal conflicts with the bsd version so they defined another function bsd signal extern sighandler t bsd signal int sig sighandler t handler throw endif send signal sig to process number pid if pid is zero send sig to all processes in the current process s process group if pid is send sig to all processes in process group pid ifdef use posix extern int kill  {
	                                                                                                                                                                                                     kill :: -1000
                                                                                                                                                                                                        }
pid t pid int sig throw endif use posix if defined use bsd defined use xopen extended send sig to all processes in process group pgrp  {
	              transducers :: -1000
                        }
if pgrp is zero send sig to all processes in the current process s process group extern int killpg  {
	             kills :: 7
	           pillage :: 7
	              pill :: 7
	              kill :: 8
	              gill :: 7
                 }
pid t pgrp int sig throw endif use bsd x open unix begin namespace std raise signal sig i e send sig to yourself  {
	               yourself :: -1000
                      }
extern int raise int sig throw end namespace std ifdef use svid svid names for the same things extern sighandler t ssignal  {
	             spignels :: 9
                    }
int sig sighandler t handler throw extern int gsignal  {
	 gingals :: 9
       }
int sig throw endif use svid if defined use misc defined use xopen k print a message describing the meaning of the given signal number extern void psignal int sig const char s endif use misc or posix ifdef use xopen k print a message describing the meaning of the given signal information extern void psiginfo  {
	                                                poising :: 11
                                                      }
const siginfo t pinfo  {
	pinfold :: 8
	pintos :: 6
	pinkos :: 6
	pingos :: 6
	pinfolded :: 6
	pion :: 6
	fino :: 6
	pinot :: 6
	pinko :: 7
	pingo :: 7
	piano :: 6
	pinfolds :: 7
	pin :: 6
  }
const char s endif posix the sigpause  {
	diapause :: 10
	pegasus :: 10
     }
function has two different interfaces the original bsd definition defines the argument as a mask of the signal while the more modern  {
	               modern :: -1000
                    }
interface in x open defines it as the signal number we go with the bsd version unless the user explicitly selects  {
	             selects :: -1000
                   }
the x open version this function is a cancellation point and therefore not marked with throw extern int sigpause int sig or mask int is sig ifdef favor bsd set the mask of blocked signals  {
	                           signals :: -1000
                                 }
to mask wait for a signal to arrive and then restore the mask extern int sigpause int mask throw attribute deprecated else ifdef use xopen ifdef gnuc extern int sigpause int sig asm xpg sigpause else remove a signal from the signal mask and suspend the process define sigpause sig sigpause sig endif endif endif ifdef use bsd none of the following functions should be used anymore they are here only for compatibility a single word int is not guaranteed to be enough to hold a complete signal mask and therefore these functions simply do not work in many situations use sigprocmask  {
                                                                                                    }
instead compute mask for signal sig define sigmask  {
	 sigmas :: 12
	dismask :: 10
	sigmates :: 9
	  sigma :: 9
      }
sig sigmask sig block signals in mask returning the old mask extern int sigblock  {
	     sunblock :: 10
	     subblock :: 10
            }
int mask throw attribute deprecated set the mask of blocked signals to mask returning the old mask extern int sigsetmask  {
                  }
int mask throw attribute deprecated return currently selected signal mask extern int siggetmask  {
           }
void throw attribute deprecated endif use bsd ifdef use misc define nsig nsig endif ifdef use gnu typedef sighandler t sighandler t endif bsd uses the name sig t for this ifdef use bsd typedef sighandler t sig t endif ifdef use posix clear all signals from set extern int sigemptyset  {
                                                 }
sigset t set throw nonnull set all signals in set extern int sigfillset  {
           }
sigset t set throw nonnull add signo  {
	signor :: 9
	signet :: 6
	signer :: 6
	signee :: 6
	signed :: 6
	signal :: 6
	gibson :: 6
	bingos :: 6
	signori :: 7
	signore :: 8
	signora :: 8
	signory :: 8
	signors :: 7
	signior :: 6
	sagoin :: 6
	pigeons :: 6
	pingos :: 6
	wigeons :: 6
	tiglons :: 6
	tigons :: 6
	signoria :: 6
	signoras :: 6
	stingo :: 6
	  sing :: 6
	  sign :: 8
	 signs :: 6
	 segno :: 7
	 segni :: 6
	lignose :: 7
     }
to set extern int sigaddset  {
   }
sigset t set int signo throw nonnull remove signo from set extern int sigdelset  {
	      seidels :: 11
            }
sigset t set int signo throw nonnull return if signo is in set if not extern int sigismember  {
                }
const sigset t set int signo throw nonnull ifdef use gnu return non empty value is set is not empty extern int sigisemptyset  {
                     }
const sigset t set throw nonnull build new signal set by combining the two inputs set using logical and extern int sigandset  {
	              ligands :: 11
	              signets :: 11
	              tisanes :: 11
	            steadings :: 11
	            saginates :: 11
	            sagenites :: 11
                    }
sigset t set const sigset t left const sigset t right throw nonnull build new signal set by combining the two inputs set using logical or extern int sigorset  {
	                      tigers :: 10
	                 somerseting :: 10
	                      sogers :: 10
                           }
sigset t set const sigset t left const sigset t right throw nonnull endif gnu get the system specific definitions of struct sigaction  {
	              gigantic :: 11
	            incautions :: 11
	            cognitions :: 11
	            sigmations :: 12
	             sociation :: 12
	            dictations :: 11
	            sonicating :: 11
	            cognations :: 11
	             situation :: 11
	            impactions :: 12
	             impaction :: 11
	             sinuation :: 11
	              sigmatic :: 11
	             digestion :: 11
	            migrations :: 12
	             migration :: 11
	             sigmation :: 14
	           bisectional :: 11
	             bisection :: 11
                     }
and the sa and sig constants include bits sigaction h get and or change the set of blocked signals extern int sigprocmask int how const sigset t restrict set sigset t restrict oset  {
	                            toes :: 5
	                           poets :: 5
	                             ose :: 6
                               }
throw change the set of blocked signals to set wait until a signal arrives  {
	      arrives :: -1000
            }
and restore the set of blocked signals this function is a cancellation point and therefore not marked with throw extern int sigsuspend  {
	            dispunges :: 12
                    }
const sigset t set nonnull get and or set the action for signal sig extern int sigaction int sig const struct sigaction restrict act struct sigaction restrict oact  {
	                      canto :: 5
	                     factor :: 5
	                       tact :: 5
	                       taco :: 6
	                      tacos :: 5
	                      tacho :: 5
	                       pact :: 5
	                       octa :: 5
	                       oast :: 5
	                       fact :: 5
	                       coat :: 5
	                        oat :: 5
                          }
throw put in set all signals that are blocked and waiting to be delivered  {
	    delivered :: -1000
            }
extern int sigpending  {
	mistending :: 13
	springeing :: 12
	distending :: 13
	dispunging :: 14
	digressing :: 12
	pigeonwing :: 12
	dispersing :: 12
	responding :: 12
	disponging :: 14
	desponding :: 12
	missending :: 13
	dispelling :: 12
	dissenting :: 12
	regrinding :: 12
	pigeonwings :: 13
	mispenning :: 12
	dispensing :: 15
	suspending :: 13
	dispending :: 16
	pigmenting :: 13
 }
sigset t set throw nonnull select any of pending signals from set or wait for any to arrive this function is a cancellation point and therefore not marked with throw extern int sigwait  {
                               }
const sigset t restrict set int restrict sig nonnull ifdef use posix select any of pending signals from set and place information in info this function is a cancellation point and therefore not marked with throw extern int sigwaitinfo  {
                                     }
const sigset t restrict set siginfo t restrict info nonnull select any of pending signals from set and place information in info wait the time specified by timeout if no signal is pending this function is a cancellation point and therefore not marked with throw extern int sigtimedwait  {
                                              }
const sigset t restrict set siginfo t restrict info const struct timespec restrict timeout nonnull send signal sig to the process pid associate data in val with the signal extern int sigqueue  {
                              }
pid t pid int sig const union sigval val throw endif use posix endif use posix ifdef use bsd names of the signals this variable exists only for compatibility use strsignal  {
	                     strangles :: 11
	                       strings :: 11
	                       strains :: 11
	                   springtails :: 11
	                      starings :: 11
	                     torsional :: 11
	                     starlings :: 12
	                    straylings :: 11
	                     strayings :: 11
	                   stringhalts :: 12
                             }
instead see string h extern const char const sys siglist  {
	   sigils :: 10
        }
nsig extern const char const sys siglist nsig structure passed to sigvec  {
	cumbersomeness :: -1000
          }
struct sigvec sighandler t sv handler signal handler int sv mask mask of signals to be blocked int sv flags flags see below define sv onstack  {
	                 unstacks :: 9
	                  unstock :: 10
	                  unstack :: 11
	                unstacked :: 9
                        }
sv flags bsd compatibility bits in sv flags define sv onstack take the signal on the signal stack define sv interrupt do not restart system calls define sv resethand  {
	                   resinated :: 11
	                   resonated :: 11
                           }
reset handler to sig dfl on receipt  {
	receipt :: -1000
     }
if vec is non null set the handler for sig to the sv handler member of vec the signals in sv mask will be blocked while the handler runs if the sv resethand bit is set in sv flags the handler for sig will be reset to sig dfl before sv handler is entered  {
	                                              entered :: -1000
                                                    }
if ovec  {
	pets :: -1000
 }
is non null it is filled in with the old information for sig extern int sigvec int sig const struct sigvec vec struct sigvec ovec throw get machine dependent struct sigcontext  {
	                    discontent :: 12
	                    miscontent :: 12
                             }
and signal subcodes  {
	subcodes :: -1000
 }
include bits sigcontext h restore the state saved in scp  {
	     spic :: 3
	     spec :: 3
	     scup :: 4
	     scop :: 4
	    sepic :: 3
	    sculp :: 3
	    scrip :: 3
	    scrap :: 3
	    scoup :: 3
	    scope :: 3
	    scopa :: 3
	    scoop :: 3
	    scaup :: 3
	    scarp :: 3
	    scapi :: 3
	    scape :: 3
	    scapa :: 3
	    scamp :: 3
	    scalp :: 3
	     cups :: 3
	     cops :: 3
	     ceps :: 3
	     caps :: 3
	      sup :: 3
	      sop :: 3
	      sip :: 3
	      sap :: 3
        }
extern int sigreturn  {
	signet :: 11
	signeur :: 11
	garnitures :: 11
	signature :: 13
	signatures :: 11
	ringster :: 11
 }
struct sigcontext scp throw endif use bsd if defined use bsd defined use xopen extended defined use xopen k define need size t include stddef h if interrupt is nonzero make signal sig interrupt system calls causing them to fail with eintr if interrupt is zero make system calls be restarted after signal sig extern int siginterrupt  {
                                                       }
int sig int interrupt throw include bits sigstack  {
      }
h if defined use xopen defined use xopen k this will define ucontext  {
           }
t and mcontext  {
 }
t include sys ucontext h endif run signals handlers on the stack specified by ss if not null if oss  {
	              assot :: 3
	             ossify :: 3
	             ossein :: 3
	               ossa :: 5
	               oses :: 4
	               dsos :: 3
	              ossia :: 4
	                sos :: 4
	                ows :: 3
	                ors :: 3
	                ons :: 3
	                oms :: 3
	                ois :: 3
	                ohs :: 3
	                oes :: 3
	                ods :: 3
	                obs :: 3
	                oas :: 3
	                ess :: 3
	                ass :: 3
	                 os :: 3
                  }
is not null it is filled in with the old signal stack status this interface is obsolete and on many platform not implemented extern int sigstack struct sigstack ss struct sigstack oss throw attribute deprecated alternate signal handler stack interface this interface should always be preferred over sigstack extern int sigaltstack  {
                                                 }
const struct sigaltstack restrict ss struct sigaltstack restrict oss throw endif use bsd or x open unix ifdef use xopen extended simplified  {
	           simplified :: -1000
                    }
interface for signal management add sig to the calling process signal mask extern int sighold  {
             }
int sig throw remove sig from the calling process signal mask extern int sigrelse  {
	      signees :: 10
	      siegers :: 10
	    tigresses :: 10
	    digressed :: 11
	    digresses :: 10
	      sirrees :: 10
            }
int sig throw set the disposition  {
	disposition :: -1000
    }
of sig to sig ign extern int sigignore  {
	seignior :: 11
      }
int sig throw set the disposition of sig extern sighandler t sigset int sig sighandler t disp throw endif if defined use posix defined use unix some of the functions for handling signals in threaded programs must be defined here include bits pthreadtypes h include bits sigthread  {
	                                     stairhead :: 11
                                             }
h endif use unix the following functions are used internally in the c library and in other code which need deep insights  {
	             insights :: -1000
                    }
return number of available real time signal with highest priority extern int libc current sigrtmin  {
	     maistring :: 10
	     misrating :: 11
	     mistering :: 10
	    migrations :: 10
	     snirtling :: 10
             }
void throw return number of available real time signal with lowest priority extern int libc current sigrtmax  {
               }
void throw endif signal h end decls endif not signal h definitions for posix spawn  {
	         spawn :: -1000
             }
interface copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef spawn h define spawn h include features h include sched h include signal h include sys types h data structure to contain attributes for thread creation typedef struct short int flags pid t pgrp sigset t sd sigset t ss struct sched param sp int policy int pad posix spawnattr  {
	                                                                                                                                                                                  spartan :: 11
                                                                                                                                                                                        }
t data structure to contain information about the actions  {
	 actions :: -1000
       }
to be performed in the new process with respect to file descriptors typedef struct int allocated int used struct spawn action actions int pad posix spawn file actions t flags to be set in the posix spawnattr t define posix spawn resetids  {
	                                 demerits :: 10
	                                restudies :: 10
	                                  resited :: 11
	                                  resites :: 11
	                                  resides :: 10
	                                residents :: 10
	                                 vestries :: 10
	                                destriers :: 10
	                                bestrides :: 11
	                                 respites :: 10
	                                 diesters :: 10
	                                  reisted :: 11
	                                   resets :: 11
	                                 resisted :: 11
	                                 residues :: 10
	                                 oersteds :: 10
	                                  deserts :: 10
                                        }
x define posix spawn setpgroup  {
	semigroup :: 12
   }
x define posix spawn setsigdef  {
	sedgiest :: 11
   }
x define posix spawn setsigmask  {
	sterigmas :: 12
   }
x define posix spawn setschedparam x define posix spawn setscheduler x ifdef use gnu define posix spawn usevfork  {
                }
x endif begin decls spawn a new process executing path with the attributes describes in attrp  {
	         attrap :: 7
	        attraps :: 6
              }
before running the process perform the actions described in file actions this function is a possible cancellation point and therefore not marked with throw extern int posix spawn pid t restrict pid const char restrict path const posix spawn file actions t restrict file actions const posix spawnattr t restrict attrp char const argv restrict arr char const envp restrict arr similar to posix spawn but search for file in the path this function is a possible cancellation point and therefore not marked with throw extern int posix spawnp  {
	                                                                                  prawns :: 7
	                                                                                 spawned :: 7
	                                                                                 spawner :: 7
	                                                                                    snaw :: 7
	                                                                                   spawn :: 9
	                                                                                   shawn :: 7
	                                                                                  spawny :: 8
	                                                                                  spawns :: 7
                                                                                       }
pid t pid const char file const posix spawn file actions t file actions const posix spawnattr t attrp char const argv char const envp initialize data structure with attributes for spawn to default values extern int posix spawnattr init posix spawnattr t attr throw free resources associated with attr extern int posix spawnattr destroy posix spawnattr t attr throw store signal mask for signals with default handling from attr in sigdefault  {
                                                                      }
extern int posix spawnattr getsigdefault  {
   }
const posix spawnattr t restrict attr sigset t restrict sigdefault throw set signal mask for signals with default handling in attr to sigdefault extern int posix spawnattr setsigdefault  {
                          }
posix spawnattr t restrict attr const sigset t restrict sigdefault throw store signal mask for the new process from attr in sigmask extern int posix spawnattr getsigmask  {
	                 sterigmas :: 12
                         }
const posix spawnattr t restrict attr sigset t restrict sigmask throw set signal mask for the new process in attr to sigmask extern int posix spawnattr setsigmask posix spawnattr t restrict attr const sigset t restrict sigmask throw get flag word from the attribute structure extern int posix spawnattr getflags  {
                                                }
const posix spawnattr t restrict attr short int restrict flags throw store flags in the attribute structure extern int posix spawnattr setflags  {
                    }
posix spawnattr t attr short int flags throw get process group id from the attribute structure extern int posix spawnattr getpgroup  {
                   }
const posix spawnattr t restrict attr pid t restrict pgroup  {
        }
throw store process group id in the attribute structure extern int posix spawnattr setpgroup posix spawnattr t attr pid t pgroup throw get scheduling policy from the attribute structure extern int posix spawnattr getschedpolicy const posix spawnattr t restrict attr int restrict schedpolicy  {
                                         }
throw store scheduling policy in the attribute structure extern int posix spawnattr setschedpolicy posix spawnattr t attr int schedpolicy throw get scheduling parameters from the attribute structure extern int posix spawnattr getschedparam const posix spawnattr t restrict attr struct sched param restrict schedparam  {
	                                      disc :: -1000
                                         }
throw store scheduling parameters in the attribute structure extern int posix spawnattr setschedparam posix spawnattr t restrict attr const struct sched param restrict schedparam throw initialize data structure for file attribute for spawn call extern int posix spawn file actions init posix spawn file actions t file actions throw free resources associated with file actions extern int posix spawn file actions destroy posix spawn file actions t file actions throw add an action to file actions which tells the implementation to call open for the given file during the spawn call extern int posix spawn file actions addopen  {
                                                                                                }
posix spawn file actions t restrict file actions int fd const char restrict path int oflag mode t mode throw add an action to file actions which tells the implementation to call close for the given file descriptor during the spawn call extern int posix spawn file actions addclose  {
	                                       shillalas :: -1000
                                               }
posix spawn file actions t file actions int fd throw add an action to file actions which tells the implementation to call dup for the given file descriptors during the spawn call extern int posix spawn file actions adddup  {
                                     }
posix spawn file actions t file actions int fd int newfd  {
	     nowed :: 6
	     newed :: 6
	       new :: 6
         }
throw end decls endif spawn h ifndef gnu stab indicate the gnu stab h is in use define gnu stab define define stab name code string name code enum stab debug code include bits stab def last unused stab code undef define stab endif gnu stab copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa iso c integer types stdint h ifndef stdint h define stdint h include features h include bits wchar h include bits wordsize h exact integral types signed there is some amount of overlap  {
	                                                                                                                                                                                                             overlap :: -1000
                                                                                                                                                                                                                   }
with sys types h as known by inet code ifndef int t defined define int t defined typedef signed char int t typedef short int int t typedef int int t if wordsize typedef long int int t else extension typedef long long int int t endif endif unsigned typedef unsigned char uint t typedef unsigned short int uint t ifndef uint t defined typedef unsigned int uint t define uint t defined endif if wordsize typedef unsigned long int uint t else extension typedef unsigned long long int uint t endif small types signed typedef signed char int least t typedef short int int least t typedef int int least t if wordsize typedef long int int least t else extension typedef long long int int least t endif unsigned typedef unsigned char uint least t typedef unsigned short int uint least t typedef unsigned int uint least t if wordsize typedef unsigned long int uint least t else extension typedef unsigned long long int uint least t endif fast types signed typedef signed char int fast t if wordsize typedef long int int fast t typedef long int int fast t typedef long int int fast t else typedef int int fast t typedef int int fast t extension typedef long long int int fast t endif unsigned typedef unsigned char uint fast t if wordsize typedef unsigned long int uint fast t typedef unsigned long int uint fast t typedef unsigned long int uint fast t else typedef unsigned int uint fast t typedef unsigned int uint fast t extension typedef unsigned long long int uint fast t endif types for void pointers if wordsize ifndef intptr t defined typedef long int intptr t define intptr t defined endif typedef unsigned long int uintptr t else ifndef intptr t defined typedef int intptr t define intptr t defined endif typedef unsigned int uintptr t endif largest integral types if wordsize typedef long int intmax t typedef unsigned long int uintmax t else extension typedef long long int intmax t extension typedef unsigned long long int uintmax t endif the iso c standard specifies that in c implementations these macros should only be defined if explicitly requested if defined cplusplus defined stdc limit macros if wordsize define int c c c l define uint c c c ul else define int c c c ll define uint c c c ull endif limits of integral types minimum of signed integral types define int min define int min define int min define int min int c maximum of signed integral types define int max define int max define int max define int max int c maximum of unsigned integral types define uint max define uint max define uint max u define uint max uint c minimum of signed integral types having a minimum size define int least min define int least min define int least min define int least min int c maximum of signed integral types having a minimum size define int least max define int least max define int least max define int least max int c maximum of unsigned integral types having a minimum size define uint least max define uint least max define uint least max u define uint least max uint c minimum of fast signed integral types having a minimum size define int fast min if wordsize define int fast min l define int fast min l else define int fast min define int fast min endif define int fast min int c maximum of fast signed integral types having a minimum size define int fast max if wordsize define int fast max l define int fast max l else define int fast max define int fast max endif define int fast max int c maximum of fast unsigned integral types having a minimum size define uint fast max if wordsize define uint fast max ul define uint fast max ul else define uint fast max u define uint fast max u endif define uint fast max uint c values to test for integral types holding void pointer if wordsize define intptr min l define intptr max l define uintptr max ul else define intptr min define intptr max define uintptr max u endif minimum for largest signed integral type define intmax min int c maximum for largest signed integral type define intmax max int c maximum for largest unsigned integral type define uintmax max uint c limits of other integer types limits of ptrdiff t type if wordsize define ptrdiff min l define ptrdiff max l else define ptrdiff min define ptrdiff max endif limits of sig atomic t define sig atomic min define sig atomic max limit of size t type if wordsize define size max ul else define size max u endif limits of wchar t ifndef wchar min these constants might also be defined in wchar h define wchar min wchar min define wchar max wchar max endif limits of wint t define wint min u define wint max u endif c limit macros the iso c standard specifies that in c implementations these should only be defined if explicitly requested if defined cplusplus defined stdc constant macros signed define int c c c define int c c c define int c c c if wordsize define int c c c l else define int c c c ll endif unsigned define uint c c c define uint c c c define uint c c c u if wordsize define uint c c c ul else define uint c c c ull endif maximal type if wordsize define intmax c c c l define uintmax c c c ul else define intmax c c c ll define uintmax c c c ull endif endif c constant macros endif stdint h functions to access file structure internals copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa this header contains the same definitions as the header of the same name on sun s solaris os ifndef stdio ext h define stdio ext h include stdio h enum query current state of the locking status fsetlocking  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 forelocking :: 15
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           }
query define fsetlocking query fsetlocking query the library protects all uses of the stream functions except for uses of the unlocked functions by calls equivalent to flockfile fsetlocking internal define fsetlocking internal fsetlocking internal the user will take care of locking fsetlocking bycaller  {
	                                 bacillary :: 10
	                                 caballero :: 10
	                                  recaller :: 10
	                                  cymbaler :: 10
	                                    recall :: 10
                                         }
define fsetlocking bycaller fsetlocking bycaller begin decls return the size of the buffer of fp in bytes currently in use by the given stream extern size t fbufsize  {
                          }
file fp throw return non zero value iff the stream fp is opened readonly  {
	    spoonways :: -1000
            }
or if the last operation on the stream was a read operation extern int freading  {
	     dreamings :: 11
	      redating :: 10
	      fretting :: 10
	      derating :: 10
	      defaming :: 10
	      drafting :: 10
	      freshing :: 10
	      defacing :: 10
	      refacing :: 10
	      readding :: 10
	     treadings :: 12
	      steading :: 10
	      trending :: 10
	      kneading :: 10
	      arcading :: 10
	      sheading :: 10
	      fielding :: 10
	      fredaine :: 10
	      creating :: 10
	      treating :: 10
	      greasing :: 10
	      drearing :: 11
	      dreaming :: 12
	      creaming :: 10
	      breaming :: 10
	      creaking :: 10
	      breaking :: 10
	      freaking :: 13
	      wreaking :: 10
	      dreading :: 13
	      treading :: 13
	      pleading :: 10
	      bearding :: 10
	      yearding :: 10
	      afearing :: 11
	    dreamingly :: 10
             }
file fp throw return non zero value iff the stream fp is opened write only or append only or if the last operation on the stream was a write operation extern int fwriting  {
	                        twirling :: 10
	                        swifting :: 11
	                       fruitings :: 11
	                        fritting :: 11
	                        flirting :: 11
	                        fruiting :: 12
	                        drifting :: 10
	                        grifting :: 10
	                       flirtings :: 10
	                        meriting :: 10
                               }
file fp throw return non zero value iff stream fp is not opened write only or append only extern int freadable  {
	           freezable :: 11
	          breakables :: 11
	           breakable :: 12
	           pleadable :: 12
	           kneadable :: 12
	           abradable :: 11
	           draftable :: 12
	           deferable :: 11
	           unfadable :: 11
	           drapeable :: 12
	           tradeable :: 12
	           amendable :: 11
	           creatable :: 12
	           treatable :: 12
	           clearable :: 11
	           frameable :: 13
                   }
file fp throw return non zero value iff stream fp is not opened read only extern int fwritable  {
	        filtrable :: 12
	        fatigable :: 11
	        fightable :: 11
	        heritably :: 11
	        heritable :: 12
	        twistable :: 11
	        irritable :: 12
	        veritably :: 11
	        veritable :: 12
	        worktable :: 11
                }
file fp throw return non zero value iff the stream fp is line buffered extern int flbf  {
               }
file fp throw discard all pending buffered i o on the stream fp extern void fpurge  {
	        frugged :: 7
	         spurge :: 9
	        spurges :: 8
              }
file fp throw return amount of output in bytes pending on a stream fp extern size t fpending  {
	         founding :: -1000
                }
file fp throw flush all line buffered files extern void flushlbf  {
	 flushable :: 10
         }
void set locking status of stream fp to type extern int fsetlocking file fp int type throw end decls endif stdio ext h define iso c stdio on top of c iostreams  {
	                       onstream :: 11
	                      pastromis :: 11
	                      upstreams :: 12
	                      isotherms :: 12
	                      mistraces :: 11
	                     costmaries :: 11
                              }
copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa iso c standard input output stdio h ifndef stdio h if defined need file defined need file define stdio h include features h begin decls define need size t define need null include stddef h include bits types h define need file define need file endif don t need file if defined file defined defined need file define outside of namespace so the c is happy struct io file begin namespace std the opaque type of streams this is the definition used elsewhere typedef struct io file file end namespace std if defined use largefile defined use svid defined use posix defined use bsd defined use isoc defined use xopen defined use posix using namespace std file endif define file defined endif file not defined undef need file if defined file defined defined need file the opaque type of streams this is the definition used elsewhere typedef struct io file file define file defined endif file not defined undef need file ifdef stdio h define stdio uses iostream include libio h if defined use xopen defined use xopen k ifdef gnuc ifndef va list defined typedef g va list va list define va list defined endif else include stdarg h endif endif ifdef use xopen k ifndef off t defined ifndef use file offset typedef off t off t else typedef off t off t endif define off t defined endif if defined use largefile defined off t defined typedef off t off t define off t defined endif ifndef ssize t defined typedef ssize t ssize t define ssize t defined endif endif the type of the second argument to fgetpos  {
                                                                                                                                                                                                                                                                                                                                                                                                                    }
and fsetpos  {
 }
begin namespace std ifndef use file offset typedef g fpos t fpos t else typedef g fpos t fpos t endif end namespace std ifdef use largefile typedef g fpos t fpos t endif the possibilities for the third argument to setvbuf  {
                                        }
define iofbf  {
	boffin :: 6
 }
fully buffered define iolbf  {
	foible :: 6
  }
line buffered define ionbf  {
	gonif :: 6
	ion :: 6
  }
no buffering  {
	buffering :: -1000
 }
default buffer size ifndef bufsiz define bufsiz io bufsiz endif end of file character some things throughout the library rely on this being ifndef eof define eof endif the possibilities for the third argument to fseek  {
	                              frees :: 6
	                              flees :: 6
	                              steek :: 6
	                               skee :: 6
	                              smeek :: 6
	                              sleek :: 6
                                  }
these values should not be changed define seek set seek from beginning of file define seek cur seek from current position define seek end seek from end of file ifdef use gnu define seek data seek to next data define seek hole seek to next hole endif if defined use svid defined use xopen default path prefix for tempnam  {
                                                         }
and tmpnam  {
	topman :: 7
 }
define p tmpdir  {
 }
tmp endif get the values l tmpnam how long an array of chars must be to be passed to tmpnam tmp max the minimum number of unique filenames  {
	                  filenames :: -1000
                          }
generated by tmpnam and tempnam when it uses tmpnam s name space or tempnam the two are separate l ctermid  {
	         spermiduct :: 9
	            chirmed :: 9
	            thermic :: 9
                  }
how long an array to pass to ctermid l cuserid  {
	  cruised :: 9
	 curbside :: 10
	  suberic :: 9
	curbsides :: 9
	 curtsied :: 9
	   ciders :: 9
	curarised :: 9
        }
how long an array to pass to cuserid fopen max minimum number of files that can be open at once filename max maximum length of a filename include bits stdio lim h standard streams extern struct io file stdin standard input stream extern struct io file stdout standard output stream extern struct io file stderr standard error output stream c c say they re macros make them happy define stdin stdin define stdout stdout define stderr stderr begin namespace std remove file filename extern int remove const char filename throw rename file old to new extern int rename const char old const char new throw end namespace std ifdef use atfile rename file old relative to oldfd  {
                                                                                                                   }
to new relative to newfd extern int renameat  {
	revalenta :: 10
	renamed :: 10
	renames :: 10
	remanet :: 10
	reanimate :: 11
	reanimates :: 10
	reanimated :: 10
	 rename :: 11
      }
int oldfd const char old int newfd const char new throw endif begin namespace std create a temporary file and open it read write this function is a possible cancellation point and therefore not marked with throw ifndef use file offset extern file tmpfile  {
	                                    emptily :: 9
                                          }
void wur else ifdef redirect extern file redirect tmpfile void tmpfile wur else define tmpfile tmpfile endif endif ifdef use largefile extern file tmpfile void wur endif generate a temporary filename extern char tmpnam char s throw wur end namespace std ifdef use misc this is the reentrant variant of tmpnam the only difference is that it does not allow s to be null extern char tmpnam r char s throw wur endif if defined use svid defined use xopen generate a unique temporary filename using up to five  {
	                                                                                    five :: -1000
                                                                                       }
characters of pfx  {
	pyx :: 3
	pox :: 3
	pix :: 3
	pax :: 3
 }
if it is not null the directory to put this file in is searched for as follows first the environment variable tmpdir is checked if it contains the name of a writable directory that directory is used if not and if dir is not null that value is checked if that fails p tmpdir is tried and finally  {
	                                                  finally :: -1000
                                                        }
tmp the storage for the filename is allocated by malloc extern char tempnam const char dir const char pfx throw attribute malloc wur endif begin namespace std close stream this function is a possible cancellation point and therefore not marked with throw extern int fclose  {
	                                      fucose :: 8
	                                       floes :: 7
	                                       flocs :: 7
	                                       filos :: 7
	                                       coles :: 7
	                                      filose :: 9
	                                      felons :: 7
                                           }
file stream flush stream or all streams if stream is null this function is a possible cancellation point and therefore not marked with throw extern int fflush  {
                         }
file stream end namespace std ifdef use misc faster versions when locking is not required this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int fflush unlocked file stream endif ifdef use gnu close all streams this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int fcloseall  {
	                                                                                              perforable :: -1000
                                                                                                       }
void endif begin namespace std ifndef use file offset open a file and create a new stream for it this function is a possible cancellation point and therefore not marked with throw extern file fopen const char restrict filename const char restrict modes wur open a file replacing an existing stream with it this function is a possible cancellation point and therefore not marked with throw extern file freopen  {
                                                                   }
const char restrict filename const char restrict modes file restrict stream wur else ifdef redirect extern file redirect fopen const char restrict filename const char restrict modes fopen wur extern file redirect freopen const char restrict filename const char restrict modes file restrict stream freopen wur else define fopen fopen define freopen freopen endif endif end namespace std ifdef use largefile extern file fopen const char restrict filename const char restrict modes wur extern file freopen const char restrict filename const char restrict modes file restrict stream wur endif ifdef use posix create a new stream that refers to an existing system file descriptor extern file fdopen int fd const char modes throw wur endif ifdef use gnu create a new stream that refers to the given magic cookie and uses the given functions for input and output extern file fopencookie  {
                                                                                                                                           }
void restrict magic cookie const char restrict modes io cookie io functions t io funcs throw wur endif ifdef use xopen k create a new stream that refers to a memory buffer extern file fmemopen  {
                                 }
void s size t len const char modes throw wur open a stream that writes into a malloc d buffer that is expanded as necessary bufloc  {
	                 bullocky :: 7
	                 bullocks :: 7
	                  bullock :: 8
	                     bufo :: 7
                        }
and sizeloc  {
 }
are updated with the buffer s location and the number of characters written on fflush or fclose extern file open memstream  {
	           midstream :: 11
                   }
char bufloc size t sizeloc throw wur endif begin namespace std if buf is null make stream unbuffered else make it use buffer buf of size bufsiz extern void setbuf  {
	                        fetus :: 7
                            }
file restrict stream char restrict buf throw make stream use buffering mode mode if buf is not null use n bytes of it for buffering else allocate an internal buffer n bytes long extern int setvbuf file restrict stream char restrict buf int modes size t n throw end namespace std ifdef use bsd if buf is null make stream unbuffered else make it use size bytes of buf for buffering extern void setbuffer  {
	                                                                restuffed :: 12
                                                                        }
file restrict stream char restrict buf size t size throw make stream line buffered extern void setlinebuf  {
	        setlines :: 12
	         subline :: 12
	         setline :: 14
               }
file stream throw endif begin namespace std write formatted output to stream this function is a possible cancellation point and therefore not marked with throw extern int fprintf file restrict stream const char restrict format write formatted output to stdout this function is a possible cancellation point and therefore not marked with throw extern int printf const char restrict format write formatted output to s extern int sprintf char restrict s const char restrict format thrownl write formatted output to s from argument list arg this function is a possible cancellation point and therefore not marked with throw extern int vfprintf file restrict s const char restrict format g va list arg write formatted output to stdout from argument list arg this function is a possible cancellation point and therefore not marked with throw extern int vprintf  {
	                                                                                                                                  sprint :: 9
                                                                                                                                       }
const char restrict format g va list arg write formatted output to s from argument list arg extern int vsprintf  {
                  }
char restrict s const char restrict format g va list arg thrownl end namespace std if defined use bsd defined use isoc defined use unix begin namespace c maximum chars of output to write in maxlen extern int snprintf char restrict s size t maxlen const char restrict format thrownl attribute format printf extern int vsnprintf char restrict s size t maxlen const char restrict format g va list arg thrownl attribute format printf end namespace c endif ifdef use gnu write formatted output to a string dynamically allocated with malloc store the address of the string in ptr extern int vasprintf  {
                                                                                                    }
char restrict ptr const char restrict f g va list arg thrownl attribute format printf wur extern int asprintf char restrict ptr const char restrict fmt thrownl attribute format printf wur extern int asprintf char restrict ptr const char restrict fmt thrownl attribute format printf wur endif ifdef use xopen k write formatted output to a file descriptor these functions are not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation they are cancellation points and therefore not marked with throw extern int vdprintf  {
                                                                                               }
int fd const char restrict fmt g va list arg attribute format printf extern int dprintf  {
	    sideswiping :: -1000
              }
int fd const char restrict fmt attribute format printf endif begin namespace std read formatted input from stream this function is a possible cancellation point and therefore not marked with throw extern int fscanf  {
                                }
file restrict stream const char restrict format wur read formatted input from stdin this function is a possible cancellation point and therefore not marked with throw extern int scanf const char restrict format wur read formatted input from s extern int sscanf  {
	                                  secants :: 7
                                        }
const char restrict s const char restrict format throw if defined use isoc defined use gnu defined ldbl compat defined redirect defined strict ansi defined use xopen k ifdef redirect for strict iso c or posix compliance disallow as as and a gnu extension which conflicts with valid a followed by letter s s or extern int redirect fscanf file restrict stream const char restrict format isoc fscanf wur extern int redirect scanf const char restrict format isoc scanf wur extern int redirect nth sscanf const char restrict s const char restrict format isoc sscanf else extern int isoc fscanf file restrict stream const char restrict format wur extern int isoc scanf const char restrict format wur extern int isoc sscanf const char restrict s const char restrict format throw define fscanf isoc fscanf define scanf isoc scanf define sscanf isoc sscanf endif endif end namespace std ifdef use isoc begin namespace c read formatted input from s into argument list arg this function is a possible cancellation point and therefore not marked with throw extern int vfscanf file restrict s const char restrict format g va list arg attribute format scanf wur read formatted input from stdin into argument list arg this function is a possible cancellation point and therefore not marked with throw extern int vscanf  {
                                                                                                                                                                                                                        }
const char restrict format g va list arg attribute format scanf wur read formatted input from s into argument list arg extern int vsscanf  {
                      }
const char restrict s const char restrict format g va list arg throw attribute format scanf if defined use gnu defined ldbl compat defined redirect defined strict ansi defined use xopen k ifdef redirect for strict iso c or posix compliance disallow as as and a gnu extension which conflicts with valid a followed by letter s s or extern int redirect vfscanf file restrict s const char restrict format g va list arg isoc vfscanf attribute format scanf wur extern int redirect vscanf const char restrict format g va list arg isoc vscanf attribute format scanf wur extern int redirect nth vsscanf const char restrict s const char restrict format g va list arg isoc vsscanf attribute format scanf else extern int isoc vfscanf file restrict s const char restrict format g va list arg wur extern int isoc vscanf const char restrict format g va list arg wur extern int isoc vsscanf const char restrict s const char restrict format g va list arg throw define vfscanf isoc vfscanf define vscanf isoc vscanf define vsscanf isoc vsscanf endif endif end namespace c endif use iso c x begin namespace std read a character from stream these functions are possible cancellation points and therefore not marked with throw extern int fgetc file stream extern int getc file stream read a character from stdin this function is a possible cancellation point and therefore not marked with throw extern int getchar  {
	                                                                                                                                                                                                                                       tubenose :: -1000
                                                                                                                                                                                                                                              }
void end namespace std the c standard explicitly says this is a macro so we always do the optimization for it define getc fp io getc fp if defined use posix defined use misc these are defined in posix these functions are possible cancellation points and therefore not marked with throw extern int getc unlocked file stream extern int getchar unlocked void endif use posix or misc ifdef use misc faster version when locking is not necessary this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int fgetc unlocked file stream endif use misc begin namespace std write a character to stream these functions are possible cancellation points and therefore not marked with throw these functions is a possible cancellation point and therefore not marked with throw extern int fputc  {
                                                                                                                                                             }
int c file stream extern int putc int c file stream write a character to stdout this function is a possible cancellation point and therefore not marked with throw extern int putchar  {
	                         kutcha :: 9
	                       patchery :: 9
	                       patchers :: 9
	                       purchase :: 9
	                        patcher :: 10
	                       petchary :: 10
	                       outcharm :: 10
	                       putchers :: 10
	                       pushcart :: 10
	                      pushcarts :: 9
	                        putcher :: 11
	                          patch :: 9
	                      outcharms :: 9
	                      outcharge :: 9
                              }
int c end namespace std the c standard explicitly says this can be a macro so we always do the optimization for it define putc ch fp io putc ch fp ifdef use misc faster version when locking is not necessary this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int fputc unlocked int c file stream endif use misc if defined use posix defined use misc these are defined in posix these functions are possible cancellation points and therefore not marked with throw extern int putc unlocked int c file stream extern int putchar unlocked int c endif use posix or misc if defined use svid defined use misc defined use xopen defined use xopen k get a word int from stream extern int getw file stream write a word int to stream extern int putw int w file stream endif begin namespace std get a newline terminated string of finite length from stream this function is a possible cancellation point and therefore not marked with throw extern char fgets char restrict s int n file restrict stream wur get a newline terminated string from stdin removing the newline do not use this function there is no limit on how much it will read this function is a possible cancellation point and therefore not marked with throw extern char gets char s wur end namespace std ifdef use gnu this function does the same as fgets but does not lock the stream this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern char fgets unlocked char restrict s int n file restrict stream wur endif ifdef use xopen k read up to and including a delimiter from stream into lineptr  {
	                                                                                                                                                                                                                                                                                                                                           linter :: 9
	                                                                                                                                                                                                                                                                                                                                            liner :: 9
                                                                                                                                                                                                                                                                                                                                                }
and null terminate it lineptr is a pointer returned from malloc or null pointing to n characters of space it is realloc d as necessary returns the number of characters read not including the null terminator or on error or eof these functions are not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation they are cancellation points and therefore not marked with throw extern io ssize t getdelim  {
                                                                                }
char restrict lineptr size t restrict n int delimiter file restrict stream wur extern io ssize t getdelim char restrict lineptr size t restrict n int delimiter file restrict stream wur like getdelim but reads up to a newline this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern io ssize t getline char restrict lineptr size t restrict n file restrict stream wur endif begin namespace std write a string to stream this function is a possible cancellation point and therefore not marked with throw extern int fputs  {
	                                                                                                               sputa :: 6
	                                                                                                               pouts :: 6
                                                                                                                   }
const char restrict s file restrict stream write a string followed by a newline to stdout this function is a possible cancellation point and therefore not marked with throw extern int puts const char s push a character back onto the input buffer of stream this function is a possible cancellation point and therefore not marked with throw extern int ungetc int c file stream read chunks of generic data from stream this function is a possible cancellation point and therefore not marked with throw extern size t fread void restrict ptr size t size size t n file restrict stream wur write chunks of generic data to stream this function is a possible cancellation point and therefore not marked with throw extern size t fwrite const void restrict ptr size t size size t n file restrict s end namespace std ifdef use gnu this function does the same as fputs but does not lock the stream this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int fputs unlocked const char restrict s file restrict stream endif ifdef use misc faster versions when locking is not necessary these functions are not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation they are cancellation points and therefore not marked with throw extern size t fread unlocked void restrict ptr size t size size t n file restrict stream wur extern size t fwrite unlocked const void restrict ptr size t size size t n file restrict stream endif begin namespace std seek to a certain position on stream this function is a possible cancellation point and therefore not marked with throw extern int fseek file stream long int off int whence  {
	                                                                                                                                                                                                                                                                                                                            whence :: -1000
                                                                                                                                                                                                                                                                                                                                 }
return the current position of stream this function is a possible cancellation point and therefore not marked with throw extern long int ftell  {
	              stellify :: 6
	                stells :: 6
	                stella :: 6
	                 stell :: 7
                     }
file stream wur rewind to the beginning of stream this function is a possible cancellation point and therefore not marked with throw extern void rewind file stream end namespace std the single unix specification version specifies an alternative more adequate interface for the two functions above which deal with file offset long int is not the right type these definitions are originally defined in the large file support api if defined use largefile defined use xopen k ifndef use file offset seek to a certain position on stream this function is a possible cancellation point and therefore not marked with throw extern int fseeko  {
                                                                                                      }
file stream off t off int whence return the current position of stream this function is a possible cancellation point and therefore not marked with throw extern off t ftello  {
	                       flotel :: 7
	                        stell :: 7
	                      feedlot :: 7
                            }
file stream wur else ifdef redirect extern int redirect fseeko file stream off t off int whence fseeko extern off t redirect ftello file stream ftello else define fseeko fseeko define ftello ftello endif endif endif begin namespace std ifndef use file offset get stream s position this function is a possible cancellation point and therefore not marked with throw extern int fgetpos file restrict stream fpos t restrict pos set stream s position this function is a possible cancellation point and therefore not marked with throw extern int fsetpos file stream const fpos t pos else ifdef redirect extern int redirect fgetpos file restrict stream fpos t restrict pos fgetpos extern int redirect fsetpos file stream const fpos t pos fsetpos else define fgetpos fgetpos define fsetpos fsetpos endif endif end namespace std ifdef use largefile extern int fseeko file stream off t off int whence extern off t ftello file stream wur extern int fgetpos file restrict stream fpos t restrict pos extern int fsetpos file stream const fpos t pos endif begin namespace std clear the error and eof indicators for stream extern void clearerr  {
	                                                                                                                                                                                    cleaver :: 10
	                                                                                                                                                                                    cleared :: 10
	                                                                                                                                                                                    clearer :: 12
	                                                                                                                                                                                    cleaner :: 10
                                                                                                                                                                                          }
file stream throw return the eof indicator for stream extern int feof file stream throw wur return the error indicator for stream extern int ferror file stream throw wur end namespace std ifdef use misc faster versions when locking is not required extern void clearerr unlocked file stream throw extern int feof unlocked file stream throw wur extern int ferror unlocked file stream throw wur endif begin namespace std print a message describing the meaning of the value of errno this function is a possible cancellation point and therefore not marked with throw extern void perror const char s end namespace std provide the declarations for sys errlist  {
	                                                                                                    realist :: 9
                                                                                                          }
and sys nerr  {
	murr :: -1000
 }
if they are available on this system even if available these variables should not be used directly the strerror function provides all the necessary functionality include bits sys errlist h ifdef use posix return the system file descriptor for stream extern int fileno file stream throw wur endif use posix ifdef use misc faster version when locking is not required extern int fileno unlocked file stream throw wur endif if defined use posix defined use svid defined use bsd defined use misc create a new stream connected to a pipe  {
	                                                                                     pipe :: -1000
                                                                                        }
running the given command this function is a possible cancellation point and therefore not marked with throw extern file popen  {
	           popeling :: 6
	             popery :: 6
	              copen :: 7
	             copens :: 6
	            pepinos :: 6
	               pope :: 8
	               pone :: 6
	               pepo :: 6
	               nope :: 7
	              popes :: 7
	              nopes :: 6
	                pop :: 6
                  }
const char command const char modes wur close a stream opened by popen and return the status of its child this function is a possible cancellation point and therefore not marked with throw extern int pclose  {
	                             police :: 7
	                              coles :: 7
	                             pilose :: 9
	                             aslope :: 7
	                            phloxes :: 7
	                            polices :: 8
	                             splore :: 7
	                              polos :: 7
	                              poles :: 8
                                  }
file stream endif ifdef use posix return the name of the controlling terminal extern char ctermid char s throw endif use posix ifdef use xopen return the name of the current user extern char cuserid char s endif use x open but not issue ifdef use gnu struct obstack see obstack h write formatted output to an obstack extern int obstack printf struct obstack restrict obstack const char restrict format thrownl attribute format printf extern int obstack vprintf struct obstack restrict obstack const char restrict format g va list args thrownl attribute format printf endif use gnu if defined use posix defined use misc these are defined in posix acquire ownership of stream extern void flockfile file stream throw try to acquire ownership of stream but do not block if it is not possible extern int ftrylockfile file stream throw wur relinquish the ownership granted for stream extern void funlockfile file stream throw endif posix misc if defined use xopen defined use xopen k defined use gnu the x open standard requires some functions and variables to be declared here which do not belong into this header but we have to follow in gnu mode we don t do this nonsense  {
	                                                                                                                                                                                                nonsense :: -1000
                                                                                                                                                                                                       }
define need getopt include getopt h endif x open but not issue and not for gnu if we are compiling with optimizing read this file it contains several optimizing inline functions and macros ifdef use extern inlines include bits stdio h endif if use fortify level defined extern always inline include bits stdio h endif ifdef ldbl compat include bits stdio ldbl h endif end decls endif stdio h included endif stdio h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa iso c standard general utilities stdlib h ifndef stdlib h include features h get size t wchar t and null from stddef h define need size t ifndef need malloc and calloc define need wchar t define need null endif include stddef h begin decls ifndef need malloc and calloc define stdlib h if defined use xopen defined use xopen k defined sys wait h xpg requires a few symbols from sys wait h being defined include bits waitflags  {
	                                                                                                                                                                                                                                                                                     wagtails :: 11
                                                                                                                                                                                                                                                                                            }
h include bits waitstatus  {
  }
h ifdef use bsd lots of hair  {
	  hair :: -1000
     }
to allow traditional bsd use of union wait as well as posix use of int for the status word if defined gnuc defined cplusplus define wait int status extension union typeof status in int i in status i else define wait int status int status endif this is the type of the argument to wait the funky  {
	                                                   funky :: -1000
                                                       }
union causes redeclarations  {
	tendential :: -1000
 }
with either int or union wait to be allowed without complaint wait status defn is the type used in the actual function definitions if defined gnuc gnuc defined cplusplus define wait status void define wait status defn void else this works in gcc and later typedef union union wait uptr  {
	                                          uptrend :: 5
	                                            spurt :: 5
	                                           uptorn :: 5
	                                           uptore :: 5
	                                           uptear :: 5
                                                }
int iptr wait status attribute transparent union define wait status defn int endif else don t use bsd define wait int status status define wait status int define wait status defn int endif use bsd define the macros sys wait h also would define this way define wexitstatus  {
                                              }
status wexitstatus wait int status define wtermsig  {
     }
status wtermsig wait int status define wstopsig  {
     }
status wstopsig wait int status define wifexited  {
     }
status wifexited wait int status define wifsignaled  {
     }
status wifsignaled wait int status define wifstopped  {
	worshipped :: 12
	misstopped :: 14
     }
status wifstopped wait int status ifdef wifcontinued  {
	discontinued :: 18
	discontinues :: 17
	discontinue :: 18
     }
define wifcontinued status wifcontinued wait int status endif endif x open or xpg and sys wait h not included begin namespace std returned by div typedef struct int quot quotient int rem remainder div t returned by ldiv ifndef ldiv t defined typedef struct long int quot quotient long int rem remainder ldiv t define ldiv t defined endif end namespace std if defined use isoc defined lldiv t defined begin namespace c returned by lldiv extension typedef struct long long int quot quotient long long int rem remainder lldiv t define lldiv t defined end namespace c endif the largest number rand will return same as int max define rand max we define these the same for all machines changes from this to the outside world should be done in exit define exit failure failing exit status define exit success successful exit status maximum length of a multibyte character in the current locale define mb cur max ctype get mb cur max extern size t ctype get mb cur max void throw wur begin namespace std convert a string to a floating point number extern double atof  {
	                                                                                                                                                                                      aloft :: 6
	                                                                                                                                                                                       atop :: 5
	                                                                                                                                                                                       atom :: 5
	                                                                                                                                                                                       atok :: 5
	                                                                                                                                                                                       atoc :: 5
                                                                                                                                                                                          }
const char nptr throw attribute pure nonnull wur convert a string to an integer extern int atoi  {
	          atopic :: 5
	          atonic :: 5
	          atomic :: 5
	          aroint :: 5
	          anoint :: 5
	           stoai :: 5
	            atop :: 5
	            atom :: 5
	            atok :: 5
	            atoc :: 5
               }
const char nptr throw attribute pure nonnull wur convert a string to a long integer extern long int atol  {
	            atolls :: 5
	             atoll :: 6
	             aloft :: 5
	            stolas :: 5
	             stola :: 6
	              atop :: 5
	              atom :: 5
	              atok :: 5
	              atoc :: 5
	              alto :: 5
                 }
const char nptr throw attribute pure nonnull wur end namespace std if defined use isoc defined glibc have long long defined use misc begin namespace c convert a string to a long long integer extension extern long long int atoll  {
	                                  atoll :: -1000
                                      }
const char nptr throw attribute pure nonnull wur end namespace c endif begin namespace std convert a string to a floating point number extern double strtod  {
	                    dorts :: 7
	                 strouted :: 7
	                   strout :: 7
	                   stroud :: 7
	                   stator :: 8
	                    torts :: 7
	                     stot :: 7
	                     sort :: 7
	                   sotted :: 7
	                   sorted :: 8
	                 stradiot :: 7
                        }
const char restrict nptr char restrict endptr throw nonnull wur end namespace std ifdef use isoc begin namespace c likewise for float and long double sizes of floating point numbers extern float strtof  {
	                           forts :: 7
	                          strout :: 7
	                          strift :: 7
	                          stator :: 8
	                           torts :: 7
	                            stot :: 7
	                            sort :: 7
                               }
const char restrict nptr char restrict endptr throw nonnull wur extern long double strtold  {
            }
const char restrict nptr char restrict endptr throw nonnull wur end namespace c endif begin namespace std convert a string to a long integer extern long int strtol const char restrict nptr char restrict endptr int base throw nonnull wur convert a string to an unsigned long integer extern unsigned long int strtoul const char restrict nptr char restrict endptr int base throw nonnull wur end namespace std if defined glibc have long long defined use bsd convert a string to a quadword  {
                                                                                 }
integer extension extern long long int strtoq  {
	strout :: 7
	stator :: 8
	 torts :: 7
	  stot :: 7
	  sort :: 7
     }
const char restrict nptr char restrict endptr int base throw nonnull wur convert a string to an unsigned quadword integer extension extern unsigned long long int strtouq  {
	                    strout :: 9
	                   surtout :: 9
                         }
const char restrict nptr char restrict endptr int base throw nonnull wur endif gcc and use bsd if defined use isoc defined glibc have long long defined use misc begin namespace c convert a string to a quadword integer extension extern long long int strtoll const char restrict nptr char restrict endptr int base throw nonnull wur convert a string to an unsigned quadword integer extension extern unsigned long long int strtoull const char restrict nptr char restrict endptr int base throw nonnull wur end namespace c endif iso c or gcc and use misc ifdef use gnu the concept of one static locale per category is not very well thought out many applications will need to process its data using information from several different locales another problem is the implementation of the internationalization handling in the iso c standard library to support this another set of the functions using locale data exist which take an additional argument attention even though several l interfaces are part of posix these are not structure for reentrant locale using functions this is an almost opaque type for the user level programs include xlocale h special versions of the functions above which take the locale to use as an additional parameter extern long int strtol l const char restrict nptr char restrict endptr int base locale t loc throw nonnull wur extern unsigned long int strtoul l const char restrict nptr char restrict endptr int base locale t loc throw nonnull wur extension extern long long int strtoll l const char restrict nptr char restrict endptr int base locale t loc throw nonnull wur extension extern unsigned long long int strtoull l const char restrict nptr char restrict endptr int base locale t loc throw nonnull wur extern double strtod l const char restrict nptr char restrict endptr locale t loc throw nonnull wur extern float strtof l const char restrict nptr char restrict endptr locale t loc throw nonnull wur extern long double strtold l const char restrict nptr char restrict endptr locale t loc throw nonnull wur endif gnu ifdef use extern inlines begin namespace std extern inline double nth atof const char nptr return strtod nptr char null extern inline int nth atoi const char nptr return int strtol nptr char null extern inline long int nth atol const char nptr return strtol nptr char null end namespace std if defined use misc defined use isoc begin namespace c extension extern inline long long int nth atoll const char nptr return strtoll nptr char null end namespace c endif endif optimizing and inlining if defined use svid defined use xopen extended convert n to base using the digits a za z least significant digit first returns a pointer to static storage overwritten by the next call extern char l a long int n throw wur read a number from a string s in base as above extern long int a l const char s throw attribute pure nonnull wur endif use svid extended x open if defined use svid defined use xopen extended defined use bsd include sys types h we need int t these are the functions that actually do things the random srandom  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             transoms :: 9
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              tsardom :: 9
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              stardom :: 10
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              transom :: 10
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
initstate  {
	stipitate :: 11
	nictitates :: 13
	nictitated :: 11
	institutes :: 12
	instituter :: 12
	instituted :: 12
	antistate :: 13
	insatiate :: 12
	intestates :: 11
	ministate :: 12
	enstatites :: 11
	antistatic :: 11
	nictitate :: 12
	institute :: 13
	instigate :: 12
	inusitate :: 13
	instigates :: 11
	instigated :: 11
	reinstate :: 11
	instituters :: 11
	enstatite :: 12
	itinerates :: 11
	intestate :: 13
	antistat :: 11
 }
and setstate  {
	substate :: 10
	steatites :: 11
	seatmates :: 10
	hesitates :: 10
	outstate :: 10
	outstates :: 10
	spectates :: 10
 }
functions are those from bsd unices  {
	uricase :: 7
	unties :: 8
	inures :: 7
	unites :: 9
	unisex :: 8
	undies :: 8
	uncles :: 8
	indues :: 7
	incuse :: 7
	inches :: 7
	nieces :: 7
	unicostate :: 7
	winces :: 7
	ounces :: 7
	juices :: 8
	crines :: 7
	minces :: 7
	quines :: 7
	clines :: 7
	uniters :: 7
	unifaces :: 7
	unipeds :: 7
	unicode :: 7
	chines :: 7
	eniacs :: 7
	unite :: 7
	unces :: 7
	 unis :: 7
	bunces :: 7
	since :: 7
	urines :: 8
	punces :: 7
    }
the rand and srand functions are required by the ansi standard we provide both interfaces to the same random number generator return a random long integer between and rand max inclusive extern long int random void throw seed the random number generator with the given number extern void srandom unsigned int seed throw initialize the random number generator to use state buffer statebuf  {
	                                                        statue :: 10
	                                                         state :: 10
                                                             }
of length statelen  {
	zymosis :: -1000
 }
and seed it with seed optimal  {
	optimal :: -1000
    }
lengths are and the bigger the better values less than will cause an error and values greater than will be rounded  {
	             rounded :: -1000
                   }
down extern char initstate unsigned int seed char statebuf size t statelen throw nonnull switch the random number generator to state buffer statebuf which should have been previously initialized by initstate extern char setstate char statebuf throw nonnull ifdef use misc reentrant versions of the random family of functions these functions all use the following data structure to contain state rather than global state variables struct random data int t fptr front pointer int t rptr  {
                                                                          }
rear pointer int t state array of state values int rand type type of random number generator int rand deg degree  {
	              degree :: -1000
                   }
of random number generator int rand sep distance between front and rear int t end ptr pointer behind state table extern int random r struct random data restrict buf int t restrict result throw nonnull extern int srandom r unsigned int seed struct random data buf throw nonnull extern int initstate r unsigned int seed char restrict statebuf size t statelen struct random data restrict buf throw nonnull extern int setstate r char restrict statebuf struct random data restrict buf throw nonnull endif use misc endif use svid extended x open bsd begin namespace std return a random integer between and rand max inclusive extern int rand void throw seed the random number generator with the given number extern void srand unsigned int seed throw end namespace std ifdef use posix reentrant interface according to posix extern int rand r unsigned int seed throw endif if defined use svid defined use xopen system v style bit random number generator functions return non negative double precision floating point value in extern double drand  {
	                                                                                                                                                                      grand :: 7
	                                                                                                                                                                      dryad :: 6
	                                                                                                                                                                      dread :: 6
	                                                                                                                                                                      drank :: 6
	                                                                                                                                                                      brand :: 7
	                                                                                                                                                                    branded :: 6
	                                                                                                                                                                    daunder :: 6
	                                                                                                                                                                     darned :: 6
	                                                                                                                                                                   drawdown :: 6
	                                                                                                                                                                     grands :: 6
	                                                                                                                                                                     grande :: 6
	                                                                                                                                                                       drad :: 7
	                                                                                                                                                                    dranted :: 7
	                                                                                                                                                                    drained :: 6
	                                                                                                                                                                     brandy :: 6
	                                                                                                                                                                     brands :: 6
                                                                                                                                                                          }
void throw extern double erand  {
	brandise :: 6
	grandees :: 6
	grandest :: 6
	brandies :: 6
	slander :: 6
	grand :: 7
	meander :: 6
	eland :: 7
	drank :: 6
	uranide :: 6
	dearn :: 6
	crane :: 6
	brand :: 7
	branded :: 6
	brander :: 6
	deaner :: 6
	craned :: 7
	franked :: 6
	cranked :: 6
	pranked :: 6
	pranged :: 6
	pranced :: 6
	stander :: 6
	blander :: 6
	trend :: 6
	grands :: 6
	grande :: 8
	earn :: 6
	dean :: 6
	granted :: 6
	grander :: 6
	dranted :: 6
	tranted :: 6
	tranced :: 6
	brandy :: 6
	brands :: 6
	araneid :: 6
	 era :: 6
   }
unsigned short int xsubi  {
  }
throw nonnull return non negative long integer in extern long int lrand  {
	      laund :: 6
	    slander :: 6
	      grand :: 7
	      gland :: 6
	     larned :: 6
	      eland :: 6
	      drank :: 6
	      brand :: 7
	      bland :: 6
	      aland :: 6
	    blander :: 6
	     grands :: 6
	     grande :: 6
	       larn :: 6
	    grandly :: 7
	     brandy :: 6
	     brands :: 6
	    laundry :: 6
	    launder :: 6
	      lyard :: 6
	      liard :: 6
          }
void throw extern long int nrand  {
	grand :: 7
	nhandu :: 6
	drank :: 6
	brand :: 7
	grands :: 6
	grande :: 6
	brandy :: 6
	brands :: 6
    }
unsigned short int xsubi throw nonnull return signed long integers in extern long int mrand  {
	         grand :: 7
	       meander :: 7
	         drank :: 6
	         brand :: 7
	       maunder :: 6
	        grands :: 6
	        grande :: 6
	          dram :: 6
	       grandma :: 6
	       grandam :: 6
	        brandy :: 6
	        brands :: 6
	         maund :: 6
	      meanders :: 6
             }
void throw extern long int jrand  {
	grand :: 7
	drank :: 6
	brand :: 7
	grands :: 6
	grande :: 6
	brandy :: 6
	brands :: 6
    }
unsigned short int xsubi throw nonnull seed random number generator extern void srand long int seedval  {
	        several :: 9
	        sleaved :: 9
              }
throw extern unsigned short int seed unsigned short int seed v throw nonnull extern void lcong  {
	          klong :: 6
	          flong :: 6
	          along :: 6
	           clon :: 6
              }
unsigned short int param throw nonnull ifdef use misc data structure for communication with thread safe versions this type is to be regarded  {
	              regarded :: -1000
                     }
as opaque it s only exported because users have to allocate objects of this type struct drand data unsigned short int x current state unsigned short int old x old state unsigned short int c additive  {
	                           additive :: -1000
                                  }
const in congruential  {
	congruent :: 18
	congruently :: 18
	conferential :: 17
	confidential :: 15
 }
formula unsigned short int init flag for initializing unsigned long long int a factor in congruential formula return non negative double precision floating point value in extern int drand r struct drand data restrict buffer double restrict result throw nonnull extern int erand r unsigned short int xsubi struct drand data restrict buffer double restrict result throw nonnull return non negative long integer in extern int lrand r struct drand data restrict buffer long int restrict result throw nonnull extern int nrand r unsigned short int xsubi struct drand data restrict buffer long int restrict result throw nonnull return signed long integers in extern int mrand r struct drand data restrict buffer long int restrict result throw nonnull extern int jrand r unsigned short int xsubi struct drand data restrict buffer long int restrict result throw nonnull seed random number generator extern int srand r long int seedval struct drand data buffer throw nonnull extern int seed r unsigned short int seed v struct drand data buffer throw nonnull extern int lcong r unsigned short int param struct drand data buffer throw nonnull endif use misc endif use svid or x open endif don t just need malloc and calloc ifndef malloc and calloc defined define malloc and calloc defined begin namespace std allocate size bytes of memory extern void malloc size t size throw attribute malloc wur allocate nmemb elements of size bytes each all initialized to extern void calloc size t nmemb size t size throw attribute malloc wur end namespace std endif ifndef need malloc and calloc begin namespace std re allocate the previously allocated block in ptr making the new block size bytes long attribute malloc is not used because if realloc returns the same pointer that was passed to it aliasing needs to be allowed between objects pointed by the old and new pointers extern void realloc void ptr size t size throw attribute warn unused result free a block allocated by malloc realloc or calloc extern void free void ptr throw end namespace std ifdef use misc free a block an alias for free sun unices extern void cfree void ptr throw endif use misc if defined use gnu defined use bsd defined use misc include alloca h endif use gnu bsd or misc if defined use xopen extended defined use xopen k defined use bsd allocate size bytes on a page boundary the storage cannot be freed extern void valloc size t size throw attribute malloc wur endif ifdef use xopen k allocate memory of size bytes with an alignment of alignment extern int posix memalign void memptr size t alignment size t size throw nonnull wur endif begin namespace std abort execution and generate a core dump extern void abort void throw attribute noreturn register a function to be called when exit is called extern int atexit void func void throw nonnull ifdef use gnu xxx there should be a macro to signal with c revision is used xxx this function is in the c x revision register a function to be called when quick exit is called ifdef cplusplus extern c int at quick exit void func void throw asm at quick exit nonnull else extern int at quick exit void func void throw nonnull endif endif end namespace std ifdef use misc register a function to be called with the status given to exit and the given argument extern int on exit void func int status void arg void arg throw nonnull endif begin namespace std call all functions registered with atexit and on exit in the reverse of the order in which they were registered perform stdio cleanup and terminate program execution with status extern void exit int status throw attribute noreturn ifdef use gnu xxx there should be a macro to signal with c revision is used xxx this function is in the c x revision call all functions registered with at quick exit in the reverse of the order in which they were registered and terminate program execution with status extern void quick exit int status throw attribute noreturn endif end namespace std ifdef use isoc begin namespace c terminate the program with status without calling any of the functions registered with atexit or on exit extern void exit int status throw attribute noreturn end namespace c endif begin namespace std return the value of envariable  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              investable :: 12
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              retainable :: 13
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              regainable :: 13
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              invertible :: 12
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              insertable :: 12
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              unreliable :: 12
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              inerasable :: 13
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              invaluable :: 13
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              governable :: 12
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              unvariable :: 17
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              invariably :: 14
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              invariable :: 17
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             invariables :: 16
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       }
name or null if it doesn t exist extern char getenv  {
	    gerent :: 8
	    geneva :: 7
	    genets :: 7
	     genet :: 8
	    regent :: 7
	      nete :: 7
	      gene :: 7
	   gerents :: 7
         }
const char name throw nonnull wur end namespace std this function is similar to the above but returns null if the programs is running with suid or sgid enabled extern char secure getenv const char name throw nonnull wur if defined use svid defined use xopen the svid says this is in stdio h but this seems a better place put string which is of the form name value in the environment if there is no remove name from the environment extern int putenv  {
	                                                                              puton :: 7
	                                                                              paten :: 7
	                                                                             pudent :: 8
                                                                                  }
char string throw nonnull endif if defined use bsd defined use xopen k set name to value in the environment if replace is nonzero overwrite an existing value extern int setenv  {
	                        sevens :: 7
	                        sedent :: 8
	                      veterans :: 7
	                      sevenths :: 7
	                       seventh :: 9
	                       seventy :: 9
	                        resent :: 7
	                     seventhly :: 7
	                        steven :: 7
	                         tenes :: 7
	                         steen :: 8
	                          sene :: 7
	                          nete :: 7
	                         sewen :: 7
	                         seven :: 9
	                         semen :: 7
	                       detenus :: 7
	                         neves :: 7
	                         netes :: 8
	                       tensive :: 7
                             }
const char name const char value int replace throw nonnull remove the variable name from the environment extern int unsetenv  {
	             unseen :: 10
	           unnethes :: 10
	            uneaten :: 10
                  }
const char name throw nonnull endif ifdef use misc the clearenv  {
	    cleave :: 11
	  cleavers :: 11
	  cleanser :: 10
	  cleaners :: 11
	 clearness :: 10
	   cleaved :: 10
	   cleaves :: 10
	   cleaver :: 12
	   cleared :: 11
	   clearer :: 10
	   cleaner :: 12
         }
was planned  {
	planned :: -1000
 }
to be added to posix but probably never made it nevertheless the posix standard posix bindings for fortran  {
	         forerank :: 10
	        foreranks :: 9
	          forwarn :: 9
	          foreran :: 11
                }
requires this function extern int clearenv void throw endif if defined use misc defined use xopen extended defined use xopen k generate a unique temporary file name from template the last six characters of template must be xxxxxx  {
                                    }
they are replaced with a string that makes the file name unique returns template or a null pointer if it cannot get a unique file name extern char mktemp  {
	                      metump :: 8
	                     metumps :: 7
                           }
char template throw nonnull wur endif if defined use misc defined use xopen extended defined use xopen k generate a unique temporary file name from template the last six characters of template must be xxxxxx they are replaced with a string that makes the filename unique returns a file descriptor open on the file for reading and writing or if it cannot create a uniquely  {
	                                                        uniquely :: -1000
                                                               }
named file this function is a possible cancellation point and therefore not marked with throw ifndef use file offset extern int mkstemp  {
                    }
char template nonnull wur else ifdef redirect extern int redirect mkstemp char template mkstemp nonnull wur else define mkstemp mkstemp endif endif ifdef use largefile extern int mkstemp char template nonnull wur endif endif ifdef use misc similar to mkstemp but the template can have a suffix after the xxxxxx the length of the suffix is specified in the second parameter this function is a possible cancellation point and therefore not marked with throw ifndef use file offset extern int mkstemps  {
                                                                               }
char template int suffixlen  {
	suffixal :: 12
	suffixes :: 11
	suffixed :: 12
	suffixion :: 11
	suffix :: 12
  }
nonnull wur else ifdef redirect extern int redirect mkstemps char template int suffixlen mkstemps nonnull wur else define mkstemps mkstemps endif endif ifdef use largefile extern int mkstemps char template int suffixlen nonnull wur endif endif if defined use bsd defined use xopen k create a unique temporary directory from template the last six characters of template must be xxxxxx they are replaced with a string that makes the directory name unique returns template or a null pointer if it cannot get a unique name the directory is created mode extern char mkdtemp  {
                                                                                           }
char template throw nonnull wur endif ifdef use gnu generate a unique temporary file name from template similar to mkstemp but allow the caller to pass additional flags which are used in the open call to create the file this function is a possible cancellation point and therefore not marked with throw ifndef use file offset extern int mkostemp  {
                                                         }
char template int flags nonnull wur else ifdef redirect extern int redirect mkostemp char template int flags mkostemp nonnull wur else define mkostemp mkostemp endif endif ifdef use largefile extern int mkostemp char template int flags nonnull wur endif similar to mkostemp but the template can have a suffix after the xxxxxx the length of the suffix is specified in the second parameter this function is a possible cancellation point and therefore not marked with throw ifndef use file offset extern int mkostemps  {
                                                                                 }
char template int suffixlen int flags nonnull wur else ifdef redirect extern int redirect mkostemps char template int suffixlen int flags mkostemps nonnull wur else define mkostemps mkostemps endif endif ifdef use largefile extern int mkostemps char template int suffixlen int flags nonnull wur endif endif begin namespace std execute the given line as a shell command this function is a cancellation point and therefore not marked with throw extern int system const char command wur end namespace std ifdef use gnu return a malloc d string containing the canonical absolute name of the existing named file extern char canonicalize file name const char name throw nonnull wur endif if defined use bsd defined use xopen extended return the canonical absolute name of file name if resolved is null the result is malloc d otherwise if the canonical name is path max chars or more returns null with errno set to enametoolong if the name fits in fewer than path max chars returns the name in resolved extern char realpath  {
	                                                                                                                                                                 pearlash :: 10
                                                                                                                                                                        }
const char restrict name char restrict resolved throw wur endif shorthand  {
	 shorthand :: -1000
         }
for type of comparison functions ifndef compar fn t define compar fn t typedef int compar fn t const void const void ifdef use gnu typedef compar fn t comparison fn t endif endif ifdef use gnu typedef int compar d fn t const void const void void endif begin namespace std do a binary search for key in base which consists of nmemb elements of size bytes each using compar to perform the comparisons  {
	                                                               comparisons :: -1000
                                                                         }
extern void bsearch  {
	mesarch :: 9
	breach :: 9
 }
const void key const void base size t nmemb size t size compar fn t compar nonnull wur sort nmemb elements of base of size bytes each using compar to perform the comparisons extern void qsort void base size t nmemb size t size compar fn t compar nonnull ifdef use gnu extern void qsort r void base size t nmemb size t size compar d fn t compar void arg nonnull endif return the absolute value of x extern int abs int x throw attribute const wur extern long int labs  {
	                                                                                       labs :: -1000
                                                                                          }
long int x throw attribute const wur end namespace std ifdef use isoc extension extern long long int llabs  {
	             flabs :: 7
	             blays :: 6
	             blaws :: 6
	             blats :: 6
	             blams :: 6
	             blahs :: 6
	             blags :: 6
	             blaes :: 6
	             blads :: 6
	             balls :: 6
	              slab :: 7
	             slabs :: 7
                 }
long long int x throw attribute const wur endif begin namespace std return the div t ldiv t or lldiv t representation of the value of numer over denom gcc may have built ins for these someday extern div t div int numer int denom throw attribute const wur extern ldiv t ldiv long int numer long int denom throw attribute const wur end namespace std ifdef use isoc begin namespace c extension extern lldiv t lldiv long long int numer long long int denom throw attribute const wur end namespace c endif if defined use xopen extended defined use xopen k defined use svid convert floating point numbers to strings the returned values are valid only until another call to the same function convert value to a string with ndigit  {
	                                                                                                                            nidget :: 7
	                                                                                                                           dignity :: 7
	                                                                                                                           editing :: 8
                                                                                                                                 }
digits and return a pointer to this set decpt  {
	   depot :: 6
	 decrypt :: 6
	  depict :: 6
       }
with the position of the decimal character and sign with the sign of the number extern char ecvt  {
	             echt :: 5
                }
double value int ndigit int restrict decpt int restrict sign throw nonnull wur convert value to a string rounded to ndigit decimal digits set decpt with the position of the decimal character and sign with the sign of the number extern char fcvt  {
                                         }
double value int ndigit int restrict decpt int restrict sign throw nonnull wur if possible convert value to a string with ndigit significant digits otherwise use exponential representation the resulting string will be written to buf extern char gcvt  {
                                     }
double value int ndigit char buf throw nonnull wur ifdef use misc long double versions of above functions extern char qecvt  {
                   }
long double value int ndigit int restrict decpt int restrict sign throw nonnull wur extern char qfcvt  {
               }
long double value int ndigit int restrict decpt int restrict sign throw nonnull wur extern char qgcvt  {
               }
long double value int ndigit char buf throw nonnull wur reentrant version of the functions above which provide their own buffers extern int ecvt r double value int ndigit int restrict decpt int restrict sign char restrict buf size t len throw nonnull extern int fcvt r double value int ndigit int restrict decpt int restrict sign char restrict buf size t len throw nonnull extern int qecvt r long double value int ndigit int restrict decpt int restrict sign char restrict buf size t len throw nonnull extern int qfcvt r long double value int ndigit int restrict decpt int restrict sign char restrict buf size t len throw nonnull endif misc endif use misc use x open unix begin namespace std return the length of the multibyte character in s which is no longer than n extern int mblen  {
	                                                                                                                                      milneb :: 6
	                                                                                                                                      yblent :: 6
	                                                                                                                                       melon :: 6
                                                                                                                                           }
const char s size t n throw wur return the length of the given multibyte character putting its wchar t representation in pwc extern int mbtowc wchar t restrict pwc const char restrict s size t n throw wur put the multibyte character represented by wchar in s returning its length extern int wctomb char s wchar t wchar throw wur convert a multibyte string to a wide char string extern size t mbstowcs wchar t restrict pwcs  {
	                                                                         pics :: 5
	                                                                         pacs :: 5
                                                                            }
const char restrict s size t n throw convert a wide char string to multibyte string extern size t wcstombs char restrict s const wchar t restrict pwcs size t n throw end namespace std ifdef use svid determine whether the string value of response matches the affirmation  {
	                                    affirmation :: -1000
                                              }
or negative response expression as specified by the lc messages category in the program s current locale returns if affirmative  {
	        affirmative :: -1000
                  }
if negative and if not matching extern int rpmatch  {
	rematched :: 9
	rematches :: 9
	 repatch :: 10
	 rematch :: 11
       }
const char response throw nonnull wur endif if defined use xopen extended defined use xopen k parse comma separated suboption  {
	          subtopian :: 12
	         abruptions :: 11
	           suboptic :: 12
	          sublation :: 12
                  }
from optionp  {
	potion :: 10
	potions :: 9
	option :: 11
	optionee :: 9
	optioned :: 9
	optional :: 9
	options :: 10
 }
and match against strings in tokens if found return index and set valuep  {
	     valuers :: 8
	     vaguely :: 7
	       value :: 10
	       valse :: 7
	       vague :: 7
	        vale :: 7
	       salue :: 7
	      values :: 9
	      valuer :: 9
	      valued :: 9
           }
to optional value introduced by an equal sign if the suboption is not part of tokens return in valuep beginning of unknown suboption on exit optionp is set to the beginning of the next token or at the terminating nul character extern int getsubopt  {
                                          }
char restrict optionp char const restrict tokens char restrict valuep throw nonnull wur endif ifdef use xopen setup des tables according key extern void setkey const char key throw nonnull endif x open pseudo terminal handling ifdef use xopen kxsi return a master pseudo terminal handle extern int posix openpt int oflag wur endif ifdef use xopen the next four functions all take a master pseudo tty fd and perform an operation on the associated slave chown  {
	                                                                    clownish :: 6
	                                                                       crown :: 7
	                                                                       clown :: 7
	                                                                       chows :: 7
	                                                                     chowing :: 7
	                                                                      crowns :: 6
	                                                                      chowry :: 6
	                                                                      chowse :: 6
	                                                                      chowed :: 6
	                                                                      choana :: 6
	                                                                       shown :: 7
	                                                                    chowsing :: 6
	                                                                        chow :: 8
	                                                                        chon :: 7
                                                                           }
the slave to the calling user extern int grantpt  {
	   grant :: 9
       }
int fd throw release an internal lock so the slave can be opened call after grantpt extern int unlockpt  {
	            unlock :: 12
	          unlocked :: 10
	          unsocket :: 10
	         uplocking :: 10
	           unlocks :: 11
	           uplocks :: 10
	            uplock :: 11
                 }
int fd throw return the pathname of the pseudo terminal slave assoicated  {
	associative :: 13
	 fascinated :: 12
	 ascorbates :: 12
	 ostracised :: 12
	 tossicated :: 14
	  auspicate :: 12
	 auspicates :: 12
	 auspicated :: 14
	 dislocates :: 12
	 dislocated :: 12
	 mislocated :: 12
	 masticated :: 13
	 dacoitages :: 12
	 associates :: 13
	 associated :: 18
	 castigated :: 12
	 suscitated :: 12
	  associate :: 16
          }
with the master fd is open on or null on errors the returned storage is good until the next call to this function extern char ptsname  {
	                  pastime :: 9
	                 prenames :: 9
	                 pennames :: 9
                        }
int fd throw wur endif ifdef use gnu store at most buflen characters of the pathname of the slave pseudo terminal associated with the master fd is open on in buf return on success otherwise an error number extern int ptsname r int fd char buf size t buflen throw nonnull open a master pseudo terminal and return its file descriptor extern int getpt  {
	                                                          tempt :: 6
	                                                          petit :: 6
                                                              }
void endif ifdef use bsd put the minute minute and minute load averages  {
	    averages :: -1000
           }
into the first nelem  {
	teleman :: 7
	elmen :: 6
	velamen :: 6
	neem :: 6
	mene :: 6
	leme :: 6
	newel :: 6
	nevel :: 6
	nebel :: 6
  }
elements of loadavg  {
 }
return the number written never more than three but may be less than nelem or if an error occurred extern int getloadavg  {
                    }
double loadavg int nelem throw nonnull endif define some macros helping to catch buffer overflows if use fortify level defined extern always inline include bits stdlib h endif ifdef ldbl compat include bits stdlib ldbl h endif endif don t just need malloc and calloc undef need malloc and calloc end decls endif stdlib h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa iso c standard string handling string h ifndef string h define string h include features h begin decls get size t and null from stddef h define need size t define need null include stddef h tell the caller that we provide correct c prototypes if defined cplusplus gnuc prereq define correct iso cpp  {
	                                                                                                                                                                                                                                               cop :: 3
	                                                                                                                                                                                                                                               cep :: 3
	                                                                                                                                                                                                                                               cap :: 3
                                                                                                                                                                                                                                                 }
string h proto endif begin namespace std copy n bytes of src to dest extern void memcpy void restrict dest const void restrict src size t n throw nonnull copy n bytes of src to dest guaranteeing  {
	                        guaranteeing :: -1000
                                   }
correct behavior for overlapping  {
	overlapping :: -1000
  }
strings extern void memmove void dest const void src size t n throw nonnull end namespace std copy no more than n bytes of src to dest stopping when c is found return the position in dest one byte past where c was copied or null if c was not found in the first n bytes of src if defined use svid defined use bsd defined use xopen extern void memccpy  {
                                                                     }
void restrict dest const void restrict src int c size t n throw nonnull endif svid begin namespace std set n bytes of s to c extern void memset void s int c size t n throw nonnull compare n bytes of s and s extern int memcmp const void s const void s size t n throw attribute pure nonnull search n bytes of s for c ifdef correct iso cpp string h proto extern c extern void memchr  {
	                                                                       marchmen :: 7
                                                                              }
void s int c size t n throw asm memchr attribute pure nonnull extern const void memchr const void s int c size t n throw asm memchr attribute pure nonnull ifdef optimize extern always inline void memchr void s int c size t n throw return builtin memchr s c n extern always inline const void memchr const void s int c size t n throw return builtin memchr s c n endif else extern void memchr const void s int c size t n throw attribute pure nonnull endif end namespace std ifdef use gnu search in s for c this is similar to memchr but there is no length limit ifdef correct iso cpp string h proto extern c void rawmemchr  {
                                                                                                                          }
void s int c throw asm rawmemchr attribute pure nonnull extern c const void rawmemchr const void s int c throw asm rawmemchr attribute pure nonnull else extern void rawmemchr const void s int c throw attribute pure nonnull endif search n bytes of s for the final occurrence of c ifdef correct iso cpp string h proto extern c void memrchr  {
                                                            }
void s int c size t n throw asm memrchr attribute pure nonnull extern c const void memrchr const void s int c size t n throw asm memrchr attribute pure nonnull else extern void memrchr const void s int c size t n throw attribute pure nonnull endif endif begin namespace std copy src to dest extern char strcpy char restrict dest const char restrict src throw nonnull copy no more than n characters of src to dest extern char strncpy char restrict dest const char restrict src size t n throw nonnull append src onto dest extern char strcat  {
	                                                                                             striate :: 8
	                                                                                              tracts :: 7
	                                                                                            scrattle :: 7
	                                                                                            scratted :: 7
	                                                                                            striated :: 7
	                                                                                            striatum :: 7
	                                                                                             mercats :: 7
	                                                                                              strict :: 8
	                                                                                              strati :: 7
	                                                                                              strath :: 7
	                                                                                              strata :: 7
	                                                                                              strait :: 8
	                                                                                               start :: 7
	                                                                                               scrat :: 7
	                                                                                            straucht :: 7
	                                                                                            sectator :: 7
                                                                                                   }
char restrict dest const char restrict src throw nonnull append no more than n characters from src onto dest extern char strncat  {
	              straint :: 9
	            truncates :: 9
                    }
char restrict dest const char restrict src size t n throw nonnull compare s and s extern int strcmp const char s const char s throw attribute pure nonnull compare n characters of s and s extern int strncmp const char s const char s size t n throw attribute pure nonnull compare the collated  {
	                                              collated :: -1000
                                                     }
forms of s and s extern int strcoll const char s const char s throw attribute pure nonnull put a transformation of src into no more than n bytes of dest extern size t strxfrm char restrict dest const char restrict src size t n throw nonnull end namespace std ifdef use xopen k the following functions are equivalent to the both above but they take the locale they use for the collation as an extra argument this is not standardsized  {
	                                                                       standards :: 16
	                                                                   standardbreds :: 16
	                                                                     standardize :: 16
	                                                                     standardise :: 17
	                                                                    standardizes :: 18
	                                                                    standardized :: 19
	                                                                    standardised :: 20
                                                                               }
but something like will come include xlocale h compare the collated forms of s and s using rules from l extern int strcoll l const char s const char s locale t l throw attribute pure nonnull put a transformation of src into no more than n bytes of dest extern size t strxfrm l char dest const char src size t n locale t l throw nonnull endif if defined use svid defined use bsd defined use xopen extended defined use xopen k duplicate s returning an identical malloc d string extern char strdup const char s throw attribute malloc nonnull endif return a malloc d copy of at most n bytes of string the resultant  {
	                                                                                                           resultant :: -1000
                                                                                                                   }
string is terminated even if no null terminator appears before string n if defined use xopen k extern char strndup const char string size t n throw attribute malloc nonnull endif if defined use gnu defined gnuc duplicate s returning an identical alloca d string define strdupa  {
	                                        stroup :: 9
                                             }
s extension const char old s size t len strlen old char new char builtin alloca len char memcpy new old len return an alloca d copy of at most n bytes of string define strndupa  {
	                            standup :: 13
                                  }
s n extension const char old s size t len strnlen old n char new char builtin alloca len new len char memcpy new old len endif begin namespace std find the first occurrence of c in s ifdef correct iso cpp string h proto extern c extern char strchr char s int c throw asm strchr attribute pure nonnull extern const char strchr const char s int c throw asm strchr attribute pure nonnull ifdef optimize extern always inline char strchr char s int c throw return builtin strchr s c extern always inline const char strchr const char s int c throw return builtin strchr s c endif else extern char strchr const char s int c throw attribute pure nonnull endif find the last occurrence of c in s ifdef correct iso cpp string h proto extern c extern char strrchr  {
	                                                                                                                                       starcher :: 9
                                                                                                                                              }
char s int c throw asm strrchr attribute pure nonnull extern const char strrchr const char s int c throw asm strrchr attribute pure nonnull ifdef optimize extern always inline char strrchr char s int c throw return builtin strrchr s c extern always inline const char strrchr const char s int c throw return builtin strrchr s c endif else extern char strrchr const char s int c throw attribute pure nonnull endif end namespace std ifdef use gnu this function is similar to strchr but it returns a pointer to the closing nul byte in case c is not found in s ifdef correct iso cpp string h proto extern c char strchrnul  {
	                                                                                                            baiter :: -1000
                                                                                                                 }
char s int c throw asm strchrnul attribute pure nonnull extern c const char strchrnul const char s int c throw asm strchrnul attribute pure nonnull else extern char strchrnul const char s int c throw attribute pure nonnull endif endif begin namespace std return the length of the initial segment of s which consists entirely of characters not in reject extern size t strcspn  {
                                                               }
const char s const char reject throw attribute pure nonnull return the length of the initial segment of s which consists entirely of characters in accept extern size t strspn  {
	                      stripes :: 7
	                      strains :: 7
	                     spraints :: 7
	                    stripings :: 7
	                       strops :: 8
	                       strips :: 8
	                       streps :: 8
	                       straps :: 8
	                       stirps :: 7
	                     serpents :: 7
	                      sprints :: 7
                            }
const char s const char accept throw attribute pure nonnull find the first occurrence in s of any character in accept ifdef correct iso cpp string h proto extern c extern char strpbrk  {
                               }
char s const char accept throw asm strpbrk attribute pure nonnull extern const char strpbrk const char s const char accept throw asm strpbrk attribute pure nonnull ifdef optimize extern always inline char strpbrk char s const char accept throw return builtin strpbrk s accept extern always inline const char strpbrk const char s const char accept throw return builtin strpbrk s accept endif else extern char strpbrk const char s const char accept throw attribute pure nonnull endif find the first occurrence of needle  {
	                                                                              needle :: -1000
                                                                                   }
in haystack  {
	haystack :: -1000
 }
ifdef correct iso cpp string h proto extern c extern char strstr  {
	   starters :: 7
	     sturts :: 7
	     struts :: 7
	     starts :: 7
	   stertors :: 7
          }
char haystack const char needle throw asm strstr attribute pure nonnull extern const char strstr const char haystack const char needle throw asm strstr attribute pure nonnull ifdef optimize extern always inline char strstr char haystack const char needle throw return builtin strstr haystack needle extern always inline const char strstr const char haystack const char needle throw return builtin strstr haystack needle endif else extern char strstr const char haystack const char needle throw attribute pure nonnull endif divide s into tokens separated by characters in delim extern char strtok  {
	                                                                                   strooke :: 7
	                                                                                    strout :: 7
	                                                                                    strook :: 8
	                                                                                    stator :: 8
	                                                                                     torts :: 7
	                                                                                      stot :: 7
	                                                                                      sort :: 7
                                                                                         }
char restrict s const char restrict delim throw nonnull end namespace std divide s into tokens separated by characters in delim information passed between calls are stored in save ptr extern char strtok r char restrict s const char restrict delim char restrict save ptr throw nonnull if defined use posix defined use misc extern char strtok r char restrict s const char restrict delim char restrict save ptr throw nonnull endif ifdef use gnu similar to strstr but this function ignores the case of both strings ifdef correct iso cpp string h proto extern c char strcasestr  {
                                                                                                }
char haystack const char needle throw asm strcasestr attribute pure nonnull extern c const char strcasestr const char haystack const char needle throw asm strcasestr attribute pure nonnull else extern char strcasestr const char haystack const char needle throw attribute pure nonnull endif endif ifdef use gnu find the first occurrence of needle in haystack needle is needlelen  {
	                                               needlelike :: 12
                                                        }
bytes long haystack is haystacklen  {
	haystack :: 16
	haystacks :: 14
   }
bytes long extern void memmem  {
   }
const void haystack size t haystacklen const void needle size t needlelen throw attribute pure nonnull copy n bytes of src to dest return pointer to bytes after the last written byte extern void mempcpy  {
                                 }
void restrict dest const void restrict src size t n throw nonnull extern void mempcpy void restrict dest const void restrict src size t n throw nonnull endif begin namespace std return the length of s extern size t strlen const char s throw attribute pure nonnull end namespace std ifdef use xopen k find the length of string but scan at most maxlen characters if no terminator is found in that many characters return maxlen extern size t strnlen const char string size t maxlen throw attribute pure nonnull endif begin namespace std return a string describing the meaning of the errno code in errnum extern char strerror int errnum throw end namespace std if defined use xopen k defined use misc reentrant version of strerror there are flavors  {
	                                                                                                                          flavors :: -1000
                                                                                                                                }
of strerror r gnu which returns the string and may or may not use the supplied temporary buffer and posix one which fills the string into the buffer to use the posix version d xopen source or d posix c source l without d gnu source is needed otherwise the gnu version is preferred if defined use xopen k defined use gnu fill buf with a string describing the meaning of the errno code in errnum ifdef redirect nth extern int redirect nth strerror r int errnum char buf size t buflen xpg strerror r nonnull else extern int xpg strerror r int errnum char buf size t buflen throw nonnull define strerror r xpg strerror r endif else if a temporary buffer is required at most buflen bytes of buf will be used extern char strerror r int errnum char buf size t buflen throw nonnull endif endif ifdef use xopen k translate error number to string according to the locale l extern char strerror l int errnum locale t l throw endif we define this function always since bzero  {
                                                                                                                                                                                   }
is sometimes needed when the namespace rules does not allow this extern void bzero void s size t n throw nonnull ifdef use bsd copy n bytes of src to dest like memmove but args reversed  {
	                           reversed :: -1000
                                  }
extern void bcopy const void src void dest size t n throw nonnull set n bytes of s to extern void bzero void s size t n throw nonnull compare n bytes of s and s same as memcmp extern int bcmp  {
	                                     bump :: 5
                                        }
const void s const void s size t n throw attribute pure nonnull find the first occurrence of c in s same as strchr ifdef correct iso cpp string h proto extern c extern char index char s int c throw asm index attribute pure nonnull extern const char index const char s int c throw asm index attribute pure nonnull if defined optimize defined correct iso cpp strings h proto extern always inline char index char s int c throw return builtin index s c extern always inline const char index const char s int c throw return builtin index s c endif else extern char index const char s int c throw attribute pure nonnull endif find the last occurrence of c in s same as strrchr ifdef correct iso cpp string h proto extern c extern char rindex  {
	                                                                                                                                     cindery :: 7
	                                                                                                                                     cinders :: 7
	                                                                                                                                     pinders :: 7
	                                                                                                                                      binder :: 8
	                                                                                                                                     minders :: 7
	                                                                                                                                       diner :: 7
	                                                                                                                                      pinder :: 8
	                                                                                                                                     winders :: 7
	                                                                                                                                      dinger :: 7
	                                                                                                                                     tindery :: 7
	                                                                                                                                     tinders :: 7
	                                                                                                                                      winder :: 8
	                                                                                                                                      kinder :: 8
	                                                                                                                                      rinsed :: 8
	                                                                                                                                      rinked :: 8
	                                                                                                                                      ringed :: 8
	                                                                                                                                      rinded :: 8
	                                                                                                                                      finder :: 8
	                                                                                                                                      ridden :: 8
	                                                                                                                                      minder :: 8
	                                                                                                                                      renied :: 7
	                                                                                                                                     hinders :: 7
	                                                                                                                                      tinder :: 8
	                                                                                                                                      hinder :: 8
	                                                                                                                                      randie :: 7
	                                                                                                                                      cinder :: 8
	                                                                                                                                     bindery :: 7
	                                                                                                                                     binders :: 7
	                                                                                                                                   tinderbox :: 7
	                                                                                                                                      jinxed :: 7
	                                                                                                                                        rine :: 7
	                                                                                                                                        rind :: 8
	                                                                                                                                       ronde :: 7
	                                                                                                                                       rinse :: 7
	                                                                                                                                       rindy :: 7
	                                                                                                                                       rinds :: 7
	                                                                                                                                     finders :: 7
                                                                                                                                           }
char s int c throw asm rindex attribute pure nonnull extern const char rindex const char s int c throw asm rindex attribute pure nonnull if defined optimize defined correct iso cpp strings h proto extern always inline char rindex char s int c throw return builtin rindex s c extern always inline const char rindex const char s int c throw return builtin rindex s c endif else extern char rindex const char s int c throw attribute pure nonnull endif return the position of the first bit set in i or if none are set the least significant bit is position the most significant extern int ffs  {
	                                                                                                         ifs :: 3
	                                                                                                         efs :: 3
                                                                                                           }
int i throw attribute const the following two functions are non standard but necessary for non bit platforms ifdef use gnu extern int ffsl  {
                      }
long int l throw attribute const ifdef gnuc extension extern int ffsll  {
          }
long long int ll throw attribute const endif endif compare s and s ignoring  {
	     ignoring :: -1000
            }
case extern int strcasecmp const char s const char s throw attribute pure nonnull compare no more than n chars of s and s ignoring case extern int strncasecmp  {
                           }
const char s const char s size t n throw attribute pure nonnull endif use bsd ifdef use gnu again versions of a few functions which use the given locale instead of the global one extern int strcasecmp l const char s const char s locale t loc throw attribute pure nonnull extern int strncasecmp l const char s const char s size t n locale t loc throw attribute pure nonnull endif ifdef use bsd return the next delim delimited token from stringp terminating it with a and update stringp to point past it extern char strsep  {
	                                                                                          stroups :: 7
	                                                                                          stripes :: 8
	                                                                                          streeks :: 7
	                                                                                          streels :: 7
	                                                                                          stramps :: 7
	                                                                                          stopers :: 8
	                                                                                          sparest :: 7
	                                                                                         strophes :: 7
	                                                                                          stirpes :: 7
	                                                                                           syrtes :: 7
	                                                                                           stupes :: 7
	                                                                                           strops :: 7
	                                                                                           strips :: 7
	                                                                                           strews :: 7
	                                                                                           streps :: 9
	                                                                                           straps :: 7
	                                                                                           straes :: 8
	                                                                                           stores :: 7
	                                                                                           stopes :: 7
	                                                                                           stipes :: 7
	                                                                                           stapes :: 7
	                                                                                            strep :: 7
	                                                                                            steps :: 7
	                                                                                             sers :: 7
	                                                                                           sprues :: 7
	                                                                                           sprees :: 7
	                                                                                         serpents :: 7
	                                                                                          sitreps :: 8
	                                                                                           sperst :: 7
	                                                                                          spryest :: 8
	                                                                                          sprites :: 7
	                                                                                          spriest :: 8
                                                                                                }
char restrict stringp const char restrict delim throw nonnull endif ifdef use xopen k return a string describing the meaning of the signal number in sig extern char strsignal int sig throw copy src to dest returning the address of the terminating in dest extern char stpcpy  {
                                             }
char restrict dest const char restrict src throw nonnull extern char stpcpy char restrict dest const char restrict src throw nonnull copy no more than n characters of src to dest returning the address of the last character written into dest extern char stpncpy  {
                                          }
char restrict dest const char restrict src size t n throw nonnull extern char stpncpy char restrict dest const char restrict src size t n throw nonnull endif ifdef use gnu compare s and s as strings holding name indices version numbers extern int strverscmp  {
                                           }
const char s const char s throw attribute pure nonnull sautee  {
	   equates :: 7
	   sauteed :: 11
	   saunter :: 7
	    sautes :: 7
	    sauted :: 8
	   eluates :: 7
	  sauterne :: 9
	   austere :: 7
	    salute :: 7
	   shuteye :: 7
	    saeter :: 7
	 sauternes :: 7
	 cauterise :: 7
	 cauteries :: 7
	   subteen :: 7
	   dauties :: 7
	    suttee :: 8
	    statue :: 7
	    bustee :: 7
	      saut :: 8
	     saute :: 9
	   baubees :: 7
         }
string briskly  {
	briskly :: -1000
 }
extern char strfry  {
	starry :: 8
 }
char string throw nonnull frobnicate  {
	clofibrate :: 12
   }
n bytes of s extern void memfrob  {
     }
void s size t n throw nonnull ifndef basename return the file name within directory of filename we don t declare the function if the basename macro is available defined in libgen h which makes the xpg version of this function available ifdef correct iso cpp string h proto extern c char basename char filename throw asm basename nonnull extern c const char basename const char filename throw asm basename nonnull else extern char basename const char filename throw nonnull endif endif endif if defined gnuc gnuc if defined optimize defined optimize size defined no inline defined cplusplus when using gnu cc we provide some optimized versions of selected functions from this header there are two kinds of optimizations machine dependent optimizations most probably using inline assembler code these might be quite expensive since the code size can increase significantly  {
	                                                                                                                                   weregild :: -1000
                                                                                                                                          }
these optimizations are not used unless the symbol use string inlines is defined before including this header machine independent optimizations which do not increase the code size significantly and which optimize mainly situations where one or more arguments are compile time constants these optimizations are used always when the compiler is taught  {
	                                             taught :: -1000
                                                  }
to optimize one can inhibit all optimizations by defining no string inlines get the machine dependent optimizations if any include bits string h these are generic optimizations which do not add too much inline code include bits string h endif if use fortify level defined extern always inline functions with security checks include bits string h endif endif end decls endif string h stringprep h header file for stringprep functions copyright c simon josefsson this file is part of gnu libidn gnu libidn is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version gnu libidn is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with gnu libidn if not write to the free software foundation inc franklin street fifth floor boston ma usa ifndef stringprep h define stringprep h ifndef idnapi if defined libidn building defined have visibility have visibility define idnapi attribute visibility default elif defined libidn building defined msc ver defined libidn static define idnapi declspec dllexport elif defined msc ver defined libidn static define idnapi declspec dllimport else define idnapi endif endif include stddef h size t include sys types h ssize t include idn int h uint t ifdef cplusplus extern c endif define stringprep version error codes typedef enum stringprep ok stringprep errors stringprep contains unassigned stringprep contains prohibited  {
	                                                                                                                                                                                                                                                                                   prohibited :: -1000
                                                                                                                                                                                                                                                                                            }
stringprep bidi  {
	biding :: 6
	bindi :: 5
	bifid :: 6
	nidi :: 5
	midi :: 5
	bid :: 5
 }
both l and ral  {
	haler :: 3
	baler :: 3
	ralphs :: 3
	waler :: 3
	valor :: 3
	taler :: 3
	rial :: 3
	real :: 3
	rale :: 5
	rail :: 4
	marl :: 3
	lars :: 3
	larn :: 3
	lark :: 3
	lari :: 3
	lare :: 3
	lard :: 3
	lair :: 3
	laer :: 3
	jarl :: 3
	harl :: 3
	farl :: 3
	earl :: 3
	carl :: 3
	arle :: 3
	relay :: 3
	relax :: 3
	rayle :: 3
	rawly :: 3
	ravel :: 3
	ratel :: 3
	ralph :: 4
	rally :: 3
	rales :: 4
	rails :: 3
	raile :: 3
	paler :: 3
	sal :: 3
	ray :: 3
	rax :: 3
	raw :: 3
	rat :: 3
	ras :: 3
	rap :: 3
	ran :: 3
	ram :: 3
	raj :: 3
	rai :: 3
	rah :: 3
	rag :: 3
	rad :: 3
	pal :: 3
	mal :: 3
	lar :: 4
	gal :: 3
	dal :: 3
	bal :: 3
	aal :: 3
	 la :: 3
  }
stringprep bidi leadtrail  {
 }
not ral stringprep bidi contains prohibited error in calling application stringprep too small buffer stringprep profile error stringprep flag error stringprep unknown profile internal errors stringprep nfkc failed stringprep malloc error stringprep rc flags used when calling stringprep typedef enum stringprep no nfkc stringprep no bidi stringprep no unassigned stringprep profile flags steps in a stringprep profile typedef enum stringprep nfkc stringprep bidi stringprep map table stringprep unassigned table stringprep prohibit table stringprep bidi prohibit table stringprep bidi ral table stringprep bidi l table stringprep profile steps define stringprep max map chars struct stringprep table element uint t start uint t end if only one character uint t map stringprep max map chars null if end is not typedef struct stringprep table element stringprep table element struct stringprep table stringprep profile steps operation stringprep profile flags flags const stringprep table element table typedef struct stringprep table stringprep profile struct stringprep profiles const char name const stringprep profile tables typedef struct stringprep profiles stringprep profiles extern idnapi const stringprep profiles stringprep profiles profiles extern idnapi const stringprep table element stringprep rfc a extern idnapi const stringprep table element stringprep rfc b extern idnapi const stringprep table element stringprep rfc b extern idnapi const stringprep table element stringprep rfc b extern idnapi const stringprep table element stringprep rfc c extern idnapi const stringprep table element stringprep rfc c extern idnapi const stringprep table element stringprep rfc c extern idnapi const stringprep table element stringprep rfc c extern idnapi const stringprep table element stringprep rfc c extern idnapi const stringprep table element stringprep rfc c extern idnapi const stringprep table element stringprep rfc c extern idnapi const stringprep table element stringprep rfc c extern idnapi const stringprep table element stringprep rfc c extern idnapi const stringprep table element stringprep rfc c extern idnapi const stringprep table element stringprep rfc c extern idnapi const stringprep table element stringprep rfc d extern idnapi const stringprep table element stringprep rfc d nameprep  {
	                                                                                                                                                                                                                                                                                                                             pampered :: 10
                                                                                                                                                                                                                                                                                                                                    }
extern idnapi const stringprep profile stringprep nameprep define stringprep nameprep in maxlen stringprep in maxlen stringprep nameprep define stringprep nameprep no unassigned in maxlen stringprep in maxlen stringprep no unassigned stringprep nameprep sasl extern idnapi const stringprep profile stringprep saslprep  {
	                              sapropels :: 10
	                                sappers :: 10
                                      }
extern idnapi const stringprep table element stringprep saslprep space map extern idnapi const stringprep profile stringprep plain extern idnapi const stringprep profile stringprep trace define stringprep plain in maxlen stringprep in maxlen stringprep plain kerberos extern idnapi const stringprep profile stringprep kerberos define stringprep kerberos in maxlen stringprep in maxlen stringprep kerberos xmpp  {
                                                   }
extern idnapi const stringprep profile stringprep xmpp nodeprep  {
      }
extern idnapi const stringprep profile stringprep xmpp resourceprep  {
      }
extern idnapi const stringprep table element stringprep xmpp nodeprep prohibit define stringprep xmpp nodeprep in maxlen stringprep in maxlen stringprep xmpp nodeprep define stringprep xmpp resourceprep in maxlen stringprep in maxlen stringprep xmpp resourceprep iscsi  {
	                             issei :: 6
	                              sics :: 6
                                 }
extern idnapi const stringprep profile stringprep iscsi extern idnapi const stringprep table element stringprep iscsi prohibit define stringprep iscsi in maxlen stringprep in maxlen stringprep iscsi api extern idnapi int stringprep i uint t ucs size t len size t maxucs  {
	                                  mancus :: 7
                                       }
len stringprep profile flags flags const stringprep profile profile extern idnapi int stringprep zi uint t ucs size t maxucs len stringprep profile flags flags const stringprep profile profile extern idnapi int stringprep char in size t maxlen stringprep profile flags flags const stringprep profile profile extern idnapi int stringprep profile const char in char out const char profile stringprep profile flags flags extern idnapi const char stringprep strerror stringprep rc rc extern idnapi const char stringprep check version const char req version utility extern idnapi int stringprep unichar  {
                                                                                       }
to utf uint t c char outbuf extern idnapi uint t stringprep utf to unichar const char p extern idnapi uint t stringprep utf to ucs const char str ssize t len size t items written extern idnapi char stringprep ucs to utf const uint t str ssize t len size t items read size t items written extern idnapi char stringprep utf nfkc normalize const char str ssize t len extern idnapi uint t stringprep ucs nfkc normalize uint t str ssize t len extern idnapi const char stringprep locale charset void extern idnapi char stringprep convert const char str const char to codeset const char from codeset extern idnapi char stringprep locale to utf const char str extern idnapi char stringprep utf to locale const char str ifdef cplusplus endif endif stringprep h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef strings h define strings h we don t need and should not read this file if string h was already read the one exception being that if use bsd isn t defined then these aren t defined in string h so we need to define them here if defined string h defined use bsd include features h define need size t include stddef h tell the caller that we provide correct c prototypes if defined cplusplus gnuc prereq define correct iso cpp strings h proto endif begin decls if defined use misc defined use xopen k compare n bytes of s and s same as memcmp extern int bcmp const void s const void s size t n throw attribute pure copy n bytes of src to dest like memmove but args reversed extern void bcopy const void src void dest size t n throw set n bytes of s to extern void bzero void s size t n throw find the first occurrence of c in s same as strchr ifdef correct iso cpp strings h proto extern c extern char index char s int c throw asm index attribute pure nonnull extern const char index const char s int c throw asm index attribute pure nonnull if defined optimize defined correct iso cpp string h proto extern always inline char index char s int c throw return builtin index s c extern always inline const char index const char s int c throw return builtin index s c endif else extern char index const char s int c throw attribute pure nonnull endif find the last occurrence of c in s same as strrchr ifdef correct iso cpp strings h proto extern c extern char rindex char s int c throw asm rindex attribute pure nonnull extern const char rindex const char s int c throw asm rindex attribute pure nonnull if defined optimize defined correct iso cpp string h proto extern always inline char rindex char s int c throw return builtin rindex s c extern always inline const char rindex const char s int c throw return builtin rindex s c endif else extern char rindex const char s int c throw attribute pure nonnull endif endif if defined use misc defined use xopen k defined use xopen k xsi return the position of the first bit set in i or if none are set the least significant bit is position the most significant extern int ffs int i throw attribute const endif compare s and s ignoring case extern int strcasecmp const char s const char s throw attribute pure compare no more than n chars of s and s ignoring case extern int strncasecmp const char s const char s size t n throw attribute pure ifdef use xopen k the following functions are equivalent to the both above but they take the locale they use for the collation as an extra argument this is not standardsized but something like will come include xlocale h again versions of a few functions which use the given locale instead of the global one extern int strcasecmp l const char s const char s locale t loc throw attribute pure nonnull extern int strncasecmp l const char s const char s size t n locale t loc throw attribute pure nonnull endif end decls endif string h endif strings h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef stropts  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 strouts :: 11
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 stroups :: 9
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  strops :: 10
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 sprouts :: 10
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       }
h define stropts h include features h include bits types h include bits xtitypes  {
	     tintypes :: 11
            }
h ifndef gid t defined typedef gid t gid t define gid t defined endif ifndef uid t defined typedef uid t uid t define uid t defined endif typedef t uscalar  {
	                        subalar :: 9
	                        facular :: 9
	                       lacunars :: 9
	                        macular :: 9
	                        oscular :: 10
	                        secular :: 9
                              }
t t uscalar t get system specific contants  {
	rendezvouses :: -1000
      }
include bits stropts h begin decls test whether fildes is associated with a stream based file extern int isastream  {
	        midstreams :: 11
	        airstreams :: 13
	         airstream :: 13
	         midstream :: 11
                 }
int fildes throw receive next message from a streams file this function is a cancellation point and therefore not marked with throw extern int getmsg  {
                       }
int fildes struct strbuf  {
	stub :: 7
  }
restrict ctlptr  {
 }
struct strbuf restrict dataptr int restrict flagsp  {
	flagons :: 7
	flagships :: 7
	 frags :: 7
	 flogs :: 7
	 flays :: 7
	 flats :: 7
	 flaps :: 9
	 flans :: 7
	 flams :: 7
	 flaks :: 7
	 flags :: 10
	 flabs :: 7
	plages :: 7
	 blags :: 7
	flagship :: 9
	  slag :: 7
	 slags :: 7
	  flap :: 7
	  flag :: 8
     }
receive next message from a streams file with flagsp allowing to control which message this function is a cancellation point and therefore not marked with throw extern int getpmsg  {
                           }
int fildes struct strbuf restrict ctlptr struct strbuf restrict dataptr int restrict bandp  {
	       bandy :: 7
	       baned :: 6
	       bands :: 7
	       banda :: 6
	      bandog :: 6
	      bandit :: 6
	      bander :: 6
	        pand :: 7
	        band :: 8
	       pandy :: 6
	       pands :: 6
	         ban :: 6
           }
int restrict flagsp perform the i o control operation specified by request on fd one argument may follow its presence  {
	           presence :: -1000
                  }
and type depend on request return value depends on request usually indicates error extern int ioctl int fd unsigned long int request throw send a message on a stream this function is a cancellation point and therefore not marked with throw extern int putmsg  {
	                                    nutmegs :: 7
	                                      tumps :: 7
	                                       puts :: 7
	                                    putlogs :: 7
                                          }
int fildes const struct strbuf ctlptr const struct strbuf dataptr int flags send a message on a stream to the band this function is a cancellation point and therefore not marked with throw extern int putpmsg  {
                                  }
int fildes const struct strbuf ctlptr const struct strbuf dataptr int band int flags attach a streams based file descriptor fildes to a file path in the file system name space extern int fattach  {
                                }
int fildes const char path throw detach a name path from a streams based file descriptor extern int fdetach  {
                 }
const char path throw end decls endif stropts h copyright c todd  {
	    toddles :: 5
	    toddler :: 5
	    toddies :: 5
	     toddle :: 6
	      toddy :: 7
	       told :: 5
	       toed :: 5
	       toad :: 5
	        tod :: 5
          }
c miller  {
	miller :: -1000
 }
todd miller courtesan  {
	courtesan :: -1000
 }
com permission to use copy modify and distribute this software for any purpose with or without fee is hereby granted provided that the above copyright notice and this permission notice appear in all copies the software is provided as is and the author disclaims all warranties with regard to this software including all implied warranties of merchantability and fitness in no event shall the author be liable for any special direct indirect or consequential damages or any damages whatsoever resulting from loss of use data or profits whether in an action of contract negligence or other tortious action arising out of or in connection with the use or performance of this software ifndef sudo  {
	                                                                                                            kudos :: 6
	                                                                                                            judos :: 6
	                                                                                                          sudoral :: 5
	                                                                                                           sudors :: 5
	                                                                                                            updos :: 5
	                                                                                                            sudor :: 7
	                                                                                                             sumo :: 5
	                                                                                                             ludo :: 5
	                                                                                                             kudo :: 5
	                                                                                                             judo :: 5
	                                                                                                             duos :: 5
	                                                                                                              sod :: 5
                                                                                                                }
plugin h define sudo plugin h api version major minor define sudo api version major define sudo api version minor define sudo api mkversion  {
	                 movers :: 11
	              diversion :: 12
	              inversion :: 12
	              obversion :: 12
	              reversion :: 12
	              demersion :: 11
	              immersion :: 11
                      }
x y x y define sudo api version sudo api mkversion sudo api version major sudo api version minor getters  {
	            getters :: -1000
                  }
and setters  {
	setters :: -1000
 }
for api version define sudo api version get major v v define sudo api version get minor v v xffff define sudo api version set major vp n do vp vp x ffff n while define sudo version set minor vp n do vp vp xffff n while conversation  {
	                                    conversation :: -1000
                                               }
function types and defines struct sudo conv message define sudo conv prompt echo  {
	        echo :: -1000
           }
off x do not echo user input define sudo conv prompt echo on x echo user input define sudo conv error msg x error message define sudo conv info msg x informational message define sudo conv prompt mask x mask user input define sudo conv prompt echo ok x flag allow echo if no tty int msg type int timeout const char msg struct sudo conv reply char reply typedef int sudo conv t int num msgs const struct sudo conv message msgs struct sudo conv reply replies  {
	                                                                                replies :: -1000
                                                                                      }
typedef int sudo printf t int msg type const char fmt policy plugin type and defines struct passwd struct policy plugin define sudo policy plugin unsigned int type always sudo policy plugin unsigned int version always sudo api version int open unsigned int version sudo conv t conversation sudo printf t sudo printf char const settings char const user info char const user env void close int exit status int error wait status or error int show version int verbose  {
	                                                                        verbose :: -1000
                                                                              }
int check policy int argc char const argv char env add char command info char argv out char user env out int list int argc char const argv int verbose const char list user int validate void void invalidate int remove int init session struct passwd pwd i o plugin type and defines struct io plugin define sudo io plugin unsigned int type always sudo io plugin unsigned int version always sudo api version int open unsigned int version sudo conv t conversation sudo printf t sudo printf char const settings char const user info char const command info int argc char const argv char const user env void close int exit status int error wait status or error int show version int verbose int log ttyin  {
	                                                                                                                        stying :: 6
	                                                                                                                         tinty :: 6
	                                                                                                                         tatin :: 6
                                                                                                                             }
const char buf unsigned int len int log ttyout  {
	 tryouts :: 7
	  tryout :: 8
       }
const char buf unsigned int len int log stdin const char buf unsigned int len int log stdout const char buf unsigned int len int log stderr const char buf unsigned int len sudoers  {
	                          dusters :: 9
	                          sudsers :: 10
	                          souters :: 9
	                          soupers :: 9
	                          shoders :: 9
	                          sonders :: 9
	                          solders :: 9
	                          dousers :: 10
	                           sudser :: 11
	                           sudors :: 10
	                          sodgers :: 10
	                          undoers :: 10
                                }
group plugin version major minor define group api version major define group api version minor define group api version group api version major group api version minor getters and setters for group version define group api version get major v v define group api version get minor v v xffff define group api version set major vp n do vp vp x ffff n while define group api version set minor vp n do vp vp xffff n while version for compatibility checking group init return on success if unconfigured  {
	                                                                             reconfigured :: 18
	                                                                             reconfigures :: 15
	                                                                              reconfigure :: 16
	                                                                              unconfirmed :: 15
                                                                                        }
on error group cleanup called to clean up resources used by provider user in group returns if user is in group if not note that pwd may be null if the user is not in passwd struct sudoers group plugin unsigned int version int init int version sudo printf t sudo printf char const argv void cleanup void int query const char user const char group const struct passwd pwd endif sudo plugin h include sys syscall  {
	                                                                    rascally :: 9
	                                                                    fiscally :: 9
                                                                           }
h copyright c the regents of the university of california all rights reserved redistribution and use in source and binary forms with or without modification are permitted provided that the following conditions are met redistributions of source code must retain the above copyright notice this list of conditions and the following disclaimer redistributions in binary form must reproduce the above copyright notice this list of conditions and the following disclaimer in the documentation and or other materials provided with the distribution neither the name of the university nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission this software is provided by the regents and contributors as is and any express or implied warranties including but not limited to the implied warranties of merchantability and fitness for a particular purpose are disclaimed in no event shall the regents or contributors be liable for any direct indirect incidental special exemplary or consequential damages including but not limited to procurement of substitute goods or services loss of use data or profits or business interruption however caused and on any theory of liability whether in contract strict liability or tort including negligence or otherwise arising in any way out of the use of this software even if advised of the possibility of such damage sysexits h berkeley ifndef sysexits h define sysexits h sysexits h exit status codes for system programs this include file attempts  {
	                                                                                                                                                                                                                                            attempts :: -1000
                                                                                                                                                                                                                                                   }
to categorize  {
	categorize :: -1000
 }
possible error exit statuses  {
	statuses :: -1000
  }
for system programs notably delivermail  {
   }
and the berkeley network error numbers begin at ex base to reduce the possibility of clashing  {
	       clashing :: -1000
              }
with other exit statuses that random programs may already return the meaning of the codes is approximately as follows ex usage the command was used incorrectly e g with the wrong number of arguments a bad flag a bad syntax in a parameter or whatever ex dataerr  {
                                             }
the input data was incorrect in some way this should only be used for user s data not system files ex noinput  {
	              spinout :: 9
	                noint :: 9
                    }
an input file not a system file did not exist or was not readable this could also include errors like no message to a mailer  {
	                  mailer :: -1000
                       }
if it cared  {
	cared :: -1000
 }
to catch it ex nouser  {
	house :: 7
	louvers :: 7
	douser :: 9
	worsen :: 7
	douse :: 7
	nodders :: 7
	fouters :: 7
	bouse :: 7
	routes :: 7
	rouses :: 7
	rouser :: 9
	roused :: 8
	rouges :: 7
	rouens :: 8
	couters :: 7
	souters :: 7
	nursery :: 7
	coupers :: 7
	soupers :: 7
	mouser :: 9
	pouters :: 7
	pourers :: 7
	mousery :: 8
	mousers :: 7
	touser :: 9
	houser :: 9
	tonsured :: 7
	construe :: 7
	souvenir :: 7
	gougers :: 7
	nozzers :: 7
	touters :: 7
	dousers :: 7
	tousers :: 7
	tourers :: 7
	youse :: 7
	nousled :: 7
	loures :: 7
	touse :: 7
	nurser :: 8
	nursed :: 7
	tonsure :: 8
	undoers :: 7
	noshery :: 7
	noshers :: 7
	souse :: 7
	nous :: 8
	noes :: 7
	rouse :: 9
	roues :: 7
	rouen :: 7
	souter :: 8
	sourer :: 8
	soured :: 7
	souper :: 8
	sorner :: 7
	sonder :: 7
	housers :: 7
	neuters :: 7
	nurse :: 8
	nousle :: 8
	nouses :: 8
	nosier :: 8
	noule :: 7
	nosher :: 8
	noser :: 7
	norsel :: 8
	noise :: 7
	nooser :: 8
	neurs :: 7
	mouse :: 7
	routers :: 7
	louse :: 7
	rousers :: 7
	bournes :: 7
	rounces :: 7
   }
the user specified did not exist this might be used for mail addresses or remote logins  {
	     loginesses :: 7
	         legion :: 7
	        lowsing :: 7
	        lovings :: 9
	         posing :: 7
	        lousing :: 7
	         poling :: 7
	         dosing :: 7
	        holings :: 8
	         doling :: 7
	         lasing :: 7
	         rosing :: 7
	        longish :: 8
	        longies :: 7
	         mosing :: 7
	         yogins :: 9
	         tosing :: 7
	         toling :: 7
	         hosing :: 7
	         aloins :: 7
	         holing :: 7
	         algins :: 8
	        logions :: 8
	        logiest :: 8
	        logania :: 7
	         lysing :: 7
	         cosing :: 7
	         colins :: 8
	         coigns :: 7
	         voling :: 7
	         tigons :: 7
	        polings :: 8
	        lobings :: 9
	         joling :: 7
	         oleins :: 7
	          yogin :: 7
	        legions :: 8
	       posingly :: 7
	       losingly :: 7
	       loginess :: 9
	         loxing :: 8
	         lowing :: 8
	         loving :: 8
	         losing :: 10
	         loring :: 8
	         loping :: 8
	         looing :: 7
	         longes :: 7
	         longas :: 7
	         eloins :: 7
	         groins :: 7
	         logion :: 7
	         logics :: 9
	         logans :: 9
	         lobing :: 8
	           logs :: 7
	         sowing :: 7
	         soring :: 7
	         soling :: 9
	        tolings :: 8
	         gonifs :: 7
	         nosing :: 7
	         ligans :: 8
	        lignose :: 8
	          longs :: 7
	          loins :: 7
	          logie :: 7
	          logic :: 7
	          logia :: 7
	          logan :: 7
              }
ex nohost  {
	hoots :: 7
	hoons :: 7
	cohosted :: 7
	cohost :: 9
	oncost :: 7
	cohosts :: 7
	cohorts :: 7
	toons :: 7
	monostich :: 7
	tohos :: 9
	toho :: 7
	cohosting :: 8
	nomos :: 7
	nolos :: 7
	nohow :: 7
 }
the host specified did not exist this is used in mail addresses or network requests ex unavailable a service is unavailable this can occur if a support program or file does not exist this can also be used as a catchall  {
	                                catchall :: -1000
                                       }
message when something you wanted to do doesn t work but you don t know why ex software an internal software error has been detected this should be limited to non operating system related errors as possible ex oserr  {
	                               brokery :: -1000
                                     }
an operating system error has been detected this is intended to be used for such things as cannot fork cannot create pipe or the like it includes things like getuid  {
	                        getup :: 7
	                       geddit :: 7
	                    retunding :: 7
	                       reduit :: 7
	                     detuning :: 7
                            }
returning a user that does not exist in the passwd file ex osfile  {
	      fusile :: 7
	     defiles :: 7
	     offices :: 7
	      filose :: 7
	     refiles :: 7
	     foibles :: 7
           }
some system file e g etc passwd etc utmp etc does not exist cannot be opened or has some sort of error e g syntax error ex cantcreat  {
	                cantatrices :: 11
	                  cauterant :: 11
	                    cantate :: 11
	                 cantatrice :: 12
	                   carcanet :: 11
                          }
a user specified output file cannot be created ex ioerr  {
	 knackers :: -1000
        }
an error occurred while doing i o on some file ex tempfail  {
	    templar :: 10
          }
temporary failure indicating something that is not really an error in sendmail this means that a mailer e g could not create a connection and the request should be reattempted  {
	                  reattempted :: -1000
                            }
later ex protocol the remote system returned something that was not possible during a protocol exchange ex noperm  {
	            hoper :: 7
	            doper :: 7
	            coper :: 7
	           mopery :: 8
	           mopers :: 8
	           monera :: 7
	           modern :: 7
	            toper :: 7
	             rope :: 7
	             nope :: 8
	             nome :: 7
	             mope :: 7
	            roper :: 7
	            noter :: 7
	            noser :: 7
	            nopes :: 7
	            neper :: 7
	            moper :: 9
	            moner :: 8
	            loper :: 7
                }
you did not have sufficient permission to perform the operation this is not intended for file system problems which should use noinput or cantcreat but rather for higher level permissions define ex ok successful termination define ex base base value for error messages define ex usage command line usage error define ex dataerr data format error define ex noinput cannot open input define ex nouser addressee  {
	                                                        addressee :: -1000
                                                                }
unknown define ex nohost host name unknown define ex unavailable service unavailable define ex software internal software error define ex oserr system error e g can t fork define ex osfile critical os file missing define ex cantcreat can t create user output file define ex ioerr input output error define ex tempfail temp failure user is invited  {
	                                                  invited :: -1000
                                                        }
to retry define ex protocol remote error in protocol define ex noperm permission denied define ex config configuration error define ex max maximum listed value endif sysexits h include sys syslog  {
	                        siglos :: 7
	                       sawlogs :: 7
	                       systole :: 7
	                       dyslogy :: 7
	                     syllogist :: 8
	                     syllogism :: 8
	                     syllogise :: 8
	                    syllogizes :: 7
	                    syllogiser :: 7
	                    syllogised :: 7
	                        stylos :: 7
                             }
h extended tar format from posix copyright c free software foundation inc this file is part of the gnu c library written by david j mackenzie  {
	                mechanize :: 11
                        }
the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef tar h define tar h a tar archive consists of byte blocks each file in the archive has a header block followed by data blocks two blocks of nul bytes indicate the end of the archive the fields of header blocks all strings are stored as iso approximately ascii strings fields are numeric unless otherwise noted below numbers are iso representations of octal numbers with leading zeros as needed linkname  {
	                                                                                                                                                                                    nicknamed :: 11
	                                                                                                                                                                                    nicknames :: 11
	                                                                                                                                                                                    nicknamer :: 11
	                                                                                                                                                                                     nickname :: 12
	                                                                                                                                                                                      linkman :: 12
	                                                                                                                                                                                      lineman :: 11
	                                                                                                                                                                                     linksmen :: 10
	                                                                                                                                                                                     linksman :: 10
	                                                                                                                                                                                   nicknamers :: 10
                                                                                                                                                                                            }
is only valid when typeflag  {
   }
lnktype  {
 }
it doesn t use prefix files that are links to pathnames chars long can not be stored in a tar archive if typeflag lnktype symtype  {
	                 mistype :: 9
                       }
dirtype then size must be devmajor  {
	deviator :: 10
    }
and devminor  {
	dormin :: 10
	verminous :: 10
	devoir :: 10
	vermin :: 10
 }
are only valid for typeflag blktype  {
    }
chrtype  {
 }
chksum  {
	shmuck :: 7
	chums :: 7
 }
contains the sum of all bytes in the header block treating  {
	  treating :: -1000
         }
each byte as an bit unsigned value and treating the bytes of chksum as blank characters uname  {
	          unteam :: 6
	          untame :: 6
	          unseam :: 6
	          unmake :: 6
	          unmade :: 6
	          unawed :: 6
	          unaged :: 6
	           anime :: 6
	          acumen :: 6
	          enamel :: 6
	           unarm :: 6
	         unarmed :: 6
	         enamour :: 6
	         unaimed :: 6
               }
and gname  {
	grame :: 7
	gnome :: 7
	german :: 6
	gemman :: 6
	gamme :: 6
	gasmen :: 7
	gagmen :: 6
	anime :: 6
	bagmen :: 6
	garment :: 6
	ragmen :: 6
	enamel :: 6
	gean :: 6
	gnomes :: 6
	gnomae :: 7
	gnawer :: 6
	gnawed :: 6
 }
are used in preference to uid and gid if those names exist locally  {
	     locally :: -1000
           }
field name byte offset length in bytes field type name nul terminated if nul fits mode uid gid size mtime chksum typeflag see below linkname nul terminated if nul fits magic must be tmagic  {
	                           tragic :: 9
	                          imagist :: 7
	                           agamic :: 7
	                            tragi :: 7
	                          tragics :: 8
                                }
nul term version must be tversion  {
	thermion :: 10
	investor :: 10
	overpaints :: 10
	revision :: 10
	overthinks :: 10
	overtips :: 10
	overthin :: 10
	oversoon :: 10
	overspin :: 11
	aversion :: 13
	eversion :: 13
	overhits :: 10
	emersion :: 10
	overstand :: 10
	overstain :: 11
	exertions :: 10
	overswing :: 10
	aversions :: 11
	eversions :: 11
	thermions :: 11
	overnights :: 10
	evections :: 10
    }
uname nul terminated gname nul terminated devmajor devminor prefix nul terminated if nul fits if the first character of prefix is the file name is name otherwise it is prefix name files whose pathnames don t fit in that length can not be stored in a tar archive the bits in mode define tsuid  {
	                                                tumid :: 6
                                                    }
define tsgid  {
	digits :: 6
	tigs :: 6
 }
define tsvtx  {
	jingal :: -1000
 }
define turead  {
	muriated :: 7
	unread :: 8
	furcated :: 7
	surbated :: 7
	turbaned :: 8
	turned :: 8
	turfed :: 8
	unready :: 7
	outdare :: 7
	thread :: 9
	thready :: 8
	threads :: 8
	curvated :: 7
	torsade :: 7
	tornade :: 7
	surtaxed :: 7
	trued :: 7
	targed :: 7
	turd :: 7
	tared :: 8
	tare :: 7
	dure :: 7
	turbanned :: 7
 }
define tuwrite  {
	turgites :: 9
	turfites :: 9
	turgite :: 10
	turfite :: 10
	unwrite :: 10
	unwrites :: 9
 }
define tuexec  {
 }
define tgread  {
	agreed :: 7
	thread :: 9
	thready :: 8
	threads :: 8
	tergal :: 7
	torsade :: 7
	tornade :: 7
	threading :: 8
	terga :: 8
	targed :: 9
	targe :: 7
	tared :: 8
	tare :: 7
	grated :: 7
	tragedy :: 7
 }
define tgwrite  {
	turgite :: 9
	tergite :: 9
 }
define tgexec  {
	yirks :: -1000
 }
define toread  {
	tornades :: 9
	tornadic :: 7
	formated :: 7
	borated :: 7
	ported :: 7
	dorted :: 7
	dogear :: 7
	doater :: 7
	doter :: 7
	toreador :: 8
	forbade :: 7
	troade :: 7
	aortae :: 7
	cordate :: 8
	toward :: 7
	toured :: 7
	togaed :: 7
	toerag :: 7
	toazed :: 7
	throed :: 7
	thread :: 9
	thready :: 8
	threads :: 8
	teredo :: 7
	torsade :: 10
	tornado :: 7
	tornade :: 10
	toreadors :: 7
	tores :: 7
	targed :: 7
	tore :: 8
	tora :: 7
	tared :: 8
	tardo :: 7
	tare :: 7
	tonearm :: 7
	dore :: 7
	roted :: 7
	sorted :: 7
	portaled :: 7
	portaged :: 7
	torsades :: 9
	oared :: 7
	tornadoes :: 7
 }
define towrite  {
	activations :: -1000
 }
define toexec  {
	coextend :: 7
	coexerts :: 8
	coexert :: 9
 }
the values for typeflag values a z are reserved for custom implementations all other values are reserved for future posix revisions define regtype  {
	            duennaship :: -1000
                     }
regular file preferred code define aregtype  {
    }
regular file alternate code define lnktype hard link define symtype symbolic link hard if not supported define chrtype character special define blktype block special define dirtype directory define fifotype  {
                           }
named pipe define conttype  {
	contempts :: 10
	contempt :: 11
  }
contiguous file regular file if not supported contents of magic field and its length define tmagic ustar  {
	          ultras :: 6
	           astir :: 6
	           aster :: 6
	           surat :: 6
	            ursa :: 6
	           sitar :: 6
	         uncarts :: 6
	          usward :: 6
	         updarts :: 6
               }
define tmaglen  {
	flagmen :: 9
	tangled :: 9
	tangles :: 9
	tangler :: 9
	teagle :: 9
	mangle :: 9
	tangle :: 10
 }
contents of the version field and its length define tversion define tverslen  {
	 prevalents :: 10
	   oversmen :: 10
	  overslept :: 11
          }
endif tar h compatible termio h for old struct termio ioctl interface this is obsolete use the posix struct termios interface defined in termios h instead include termios h include sys ioctl h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa posix standard general terminal interface termios h ifndef termios h define termios h include features h if defined use unix defined use xopen k we need pid t include bits types h ifndef pid t defined typedef pid t pid t define pid t defined endif endif begin decls get the system dependent definitions of struct termios tcflag  {
                                                                                                                                                                                                                               }
t cc t speed t and all the macros specifying the flag bits include bits termios h ifdef use bsd compare a character c to a value val from the c cc array in a struct termios if val is posix vdisable  {
	                                 voidable :: 12
	                                variables :: 10
	                                 slidable :: 11
	                                 evasible :: 10
	                                 editable :: 10
	                                 raisable :: 10
	                                 drivable :: 11
	                                 seisable :: 10
	                                vendables :: 10
                                        }
no character can match it define cceq  {
     }
val c c val val posix vdisable endif return the output baud  {
	       baud :: -1000
          }
rate stored in termios p extern speed t cfgetospeed  {
       }
const struct termios termios p throw return the input baud rate stored in termios p extern speed t cfgetispeed  {
                 }
const struct termios termios p throw set the output baud rate stored in termios p to speed extern int cfsetospeed  {
                  }
struct termios termios p speed t speed throw set the input baud rate stored in termios p to speed extern int cfsetispeed  {
                    }
struct termios termios p speed t speed throw ifdef use bsd set both the input and output baud rates  {
	             rates :: -1000
                 }
in termios op to speed extern int cfsetspeed  {
      }
struct termios termios p speed t speed throw endif put the state of fd into termios p extern int tcgetattr  {
                  }
int fd struct termios termios p throw set the state of fd to termios p values for optional actions tcsa  {
	               tosa :: 5
	               scat :: 5
	              scrat :: 5
	              sceat :: 5
	               cast :: 5
	              octas :: 5
	                tas :: 5
                  }
are in bits termios h extern int tcsetattr  {
      }
int fd int optional actions const struct termios termios p throw ifdef use bsd set termios p to indicate raw mode extern void cfmakeraw  {
                      }
struct termios termios p throw endif send zero bits on fd extern int tcsendbreak  {
            }
int fd int duration throw wait for pending output to be written on fd this function is a cancellation point and therefore not marked with throw extern int tcdrain  {
	                     detrain :: 9
                           }
int fd flush pending data on fd values for queue selector tc i o io flush are in bits termios h extern int tcflush  {
                      }
int fd int queue selector throw suspend or restart transmission  {
	transmission :: -1000
        }
on fd values for action tc io off on are in bits termios h extern int tcflow  {
               }
int fd int action throw ifdef use unix get process group id for session leader  {
	        leader :: -1000
             }
for controlling terminal fd extern pid t tcgetsid  {
      }
int fd throw endif ifdef use bsd include sys ttydefaults  {
        }
h endif end decls endif termios h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa iso c standard type generic math tgmath  {
                                                                                                                                                  }
h ifndef tgmath h define tgmath h include the needed headers include math h include complex h since complex is currently not really implemented in most c compilers and if it is implemented the implementations differ this makes it quite difficult to write a generic implementation of this header we do not try this for now and instead concentrate  {
	                                               concentrate :: -1000
                                                         }
only on gnu cc once we have more information support for other compilers might follow if gnuc prereq ifdef no long double math define tgml  {
	                   tasse :: -1000
                       }
fct fct else define tgml fct fct l endif this is ugly but unless gcc gets appropriate builtins we have to do something like this don t ask how it works if type is a floating type if type is an integer type allows for bool expands to an integer constant expression if gnuc prereq define floating type type builtin classify  {
	                                                    classify :: -1000
                                                           }
type type builtin classify type type builtin classify type real type else define floating type type type type endif the tgmath real type for t where e is if t is an integer type and for a floating type define tgmath real type sub t e typeof typeof double void e typeof t void e the tgmath real type of expr define tgmath real type expr tgmath real type sub typeof typeof expr floating type typeof expr we have two kinds of generic macros to support functions which are only defined on real valued  {
	                                                                                       valued :: -1000
                                                                                            }
parameters and those which are defined for complex functions as well define tgmath unary  {
	        unary :: -1000
            }
real only val fct extension sizeof val sizeof double builtin classify type val tgmath real type val fct val sizeof val sizeof float tgmath real type val fct f val tgmath real type val tgml fct val define tgmath unary real ret only val rettype  {
	                                      petter :: 9
	                                     pretype :: 9
                                           }
fct extension sizeof val sizeof double builtin classify type val rettype fct val sizeof val sizeof float rettype fct f val rettype tgml fct val define tgmath binary first real only val val fct extension sizeof val sizeof double builtin classify type val tgmath real type val fct val val sizeof val sizeof float tgmath real type val fct f val val tgmath real type val tgml fct val val define tgmath binary real only val val fct extension sizeof val sizeof double sizeof val sizeof double builtin classify type val val typeof tgmath real type val tgmath real type val tgml fct val val sizeof val sizeof double sizeof val sizeof double builtin classify type val builtin classify type val typeof tgmath real type val tgmath real type val fct val val typeof tgmath real type val tgmath real type val fct f val val define tgmath ternary  {
	                                                                                                                                             ternary :: -1000
                                                                                                                                                   }
first second real only val val val fct extension sizeof val sizeof double sizeof val sizeof double builtin classify type val val typeof tgmath real type val tgmath real type val tgml fct val val val sizeof val sizeof double sizeof val sizeof double builtin classify type val builtin classify type val typeof tgmath real type val tgmath real type val fct val val val typeof tgmath real type val tgmath real type val fct f val val val define tgmath ternary real only val val val fct extension sizeof val sizeof double sizeof val sizeof double sizeof val sizeof double builtin classify type val val val typeof tgmath real type val tgmath real type val tgmath real type val tgml fct val val val sizeof val sizeof double sizeof val sizeof double sizeof val sizeof double builtin classify type val builtin classify type val builtin classify type val typeof tgmath real type val tgmath real type val tgmath real type val fct val val val typeof tgmath real type val tgmath real type val tgmath real type val fct f val val val xxx this definition has to be changed as soon as the compiler understands  {
	                                                                                                                                                                                         understands :: -1000
                                                                                                                                                                                                   }
the imaginary keyword define tgmath unary real imag val fct cfct  {
	      bust :: -1000
         }
extension sizeof real val sizeof double builtin classify type real val sizeof real val sizeof val tgmath real type val fct val tgmath real type val cfct val sizeof real val sizeof float sizeof real val sizeof val tgmath real type val fct f val tgmath real type val cfct f val sizeof real val sizeof val tgmath real type val tgml fct val tgmath real type val tgml cfct val define tgmath unary imag val cfct extension sizeof real val sizeof double builtin classify type real val typeof tgmath real type val complex i cfct val sizeof real val sizeof float typeof tgmath real type val complex i cfct f val typeof tgmath real type val complex i tgml cfct val xxx this definition has to be changed as soon as the compiler understands the imaginary keyword define tgmath unary real imag ret real val fct cfct extension sizeof real val sizeof double builtin classify type real val sizeof real val sizeof val typeof real tgmath real type val fct val typeof real tgmath real type val cfct val sizeof real val sizeof float sizeof real val sizeof val typeof real tgmath real type val fct f val typeof real tgmath real type val cfct f val sizeof real val sizeof val typeof real tgmath real type val tgml fct val typeof real tgmath real type val tgml cfct val xxx this definition has to be changed as soon as the compiler understands the imaginary keyword define tgmath binary real imag val val fct cfct extension sizeof real val sizeof double sizeof real val sizeof double builtin classify type real val real val sizeof real val sizeof val sizeof real val sizeof val typeof tgmath real type val tgmath real type val tgml fct val val typeof tgmath real type val tgmath real type val tgml cfct val val sizeof real val sizeof double sizeof real val sizeof double builtin classify type real val builtin classify type real val sizeof real val sizeof val sizeof real val sizeof val typeof tgmath real type val tgmath real type val fct val val typeof tgmath real type val tgmath real type val cfct val val sizeof real val sizeof val sizeof real val sizeof val typeof tgmath real type val tgmath real type val fct f val val typeof tgmath real type val tgmath real type val cfct f val val else error unsupported compiler you cannot use tgmath h endif unary functions defined for real and complex values trigonometric  {
	                                                                                                                                                                                                                                                                                                                                                                                                                     trigonometric :: -1000
                                                                                                                                                                                                                                                                                                                                                                                                                                 }
functions arc cosine  {
	cosine :: -1000
 }
of x define acos  {
	atocs :: 5
	acorns :: 5
	ocas :: 6
	scopa :: 5
	avos :: 5
	ados :: 5
	aces :: 5
	abos :: 5
  }
val tgmath unary real imag val acos cacos  {
	  cycas :: 6
	  cocos :: 7
	  cocoa :: 6
	  cocks :: 6
	  cocas :: 8
	  casco :: 7
	  cacas :: 6
	  caboc :: 6
	 cocoas :: 7
	cacoons :: 6
	cachous :: 6
	 accost :: 7
	  tacos :: 7
	   coca :: 6
	cacolets :: 6
	cacodyls :: 6
	 cascos :: 6
	  pacos :: 7
	 cacaos :: 6
	 cabocs :: 7
      }
arc sine of x define asin  {
	kains :: 5
	azines :: 5
	gains :: 5
	fains :: 5
	cains :: 5
	ayins :: 6
	anise :: 5
	anils :: 5
	amins :: 6
	airns :: 5
	amines :: 5
	alines :: 5
	agings :: 5
	acinus :: 5
	wains :: 5
	tains :: 5
	 sain :: 6
	spina :: 5
	saint :: 5
	sains :: 5
	 ayin :: 5
	 anis :: 6
	 amin :: 5
	 akin :: 5
	 ains :: 5
	rains :: 5
	pains :: 5
	mains :: 5
	  ani :: 5
    }
val tgmath unary real imag val asin casin  {
	 easing :: 6
	cawings :: 7
	 lasing :: 6
	cavings :: 7
	cations :: 6
	casting :: 6
	 sasine :: 6
	casking :: 6
	casinos :: 7
	casings :: 7
	cashing :: 6
	  canid :: 6
	carinas :: 6
	  camis :: 6
	  cairn :: 6
	  cains :: 7
	  cadis :: 6
	  cabin :: 7
	  basin :: 7
	  basic :: 6
	 nastic :: 6
	 basing :: 6
	racings :: 6
	masonic :: 6
	caginess :: 6
	canines :: 7
	canings :: 7
	camions :: 6
	cabinets :: 6
	cakings :: 7
	lacings :: 6
	 panisc :: 6
	 panics :: 6
	 cosing :: 6
	 cosine :: 6
	facings :: 6
	 rasing :: 6
	 actins :: 6
	 masing :: 6
	 manics :: 6
	chaines :: 6
	  savin :: 6
	  satin :: 6
	  sasin :: 7
	  sarin :: 6
	  sabin :: 6
	   cans :: 6
	   cain :: 6
	 cawing :: 6
	 caving :: 6
	 casino :: 9
	 casini :: 8
	 casing :: 9
	 casein :: 7
	 caring :: 6
	 caning :: 6
	 canine :: 6
	 caking :: 6
	 caging :: 6
	 cabins :: 8
      }
arc tangent of x define atan  {
	disentitles :: -1000
    }
val tgmath unary real imag val atan catan  {
	catenary :: 6
	catnaps :: 6
	cateran :: 6
	catenas :: 7
	catenae :: 7
	satanic :: 7
	 satang :: 6
	  cotan :: 7
	  carat :: 6
	  caman :: 7
	calanthe :: 6
	 ratany :: 6
	 ratans :: 6
	 cetane :: 6
	   tana :: 6
	   anta :: 6
	   acta :: 6
	  ratan :: 7
	 catnap :: 7
	 catena :: 8
	 catalo :: 6
	 captan :: 6
	 cantar :: 6
	 cantal :: 6
	 camans :: 6
	 caftan :: 6
	  octan :: 6
	  natal :: 6
	 vacant :: 7
      }
arc tangent of y x define atan val val tgmath binary real only val val atan cosine of x define cos val tgmath unary real imag val cos ccos  {
	                       crocs :: 5
	                       chocs :: 5
                           }
sine of x define sin val tgmath unary real imag val sin csin  {
	       coins :: 6
	       cions :: 5
	       chins :: 6
	       cains :: 6
	      crines :: 5
	      clints :: 5
	      clinks :: 5
	      clings :: 5
	      clines :: 5
	      chints :: 5
	      chinos :: 5
	      chinks :: 5
	      chines :: 5
	      chinas :: 5
	        coin :: 5
	        chin :: 5
	        cain :: 5
           }
tangent of x define tan val tgmath unary real imag val tan ctan  {
	       chant :: 6
	      crants :: 5
	      chanty :: 5
	      chants :: 5
	      stanch :: 5
	      stance :: 5
	       scant :: 5
	        cyan :: 5
	        clan :: 5
	        cant :: 5
           }
hyperbolic functions hyperbolic arc cosine of x define acosh  {
	    ochs :: 6
	    ocas :: 6
       }
val tgmath unary real imag val acosh cacosh  {
	  cocos :: 7
	  cocas :: 8
	  chocs :: 7
	  chaos :: 7
	caroche :: 7
	  casco :: 7
	 cocoas :: 7
	cachous :: 8
	 accost :: 7
	cacoethes :: 7
	 chacos :: 7
	cockshy :: 7
	  tacos :: 7
	 caroch :: 8
	  pacos :: 7
	 cachou :: 7
	 caches :: 7
	 cabocs :: 7
      }
hyperbolic arc sine of x define asinh  {
	 ayins :: 6
	 arish :: 6
	 apish :: 6
	 anigh :: 6
	 amins :: 6
	ashing :: 6
	ashine :: 6
	 ahint :: 6
	 ahind :: 6
	chinas :: 6
	  shin :: 6
	  sain :: 6
	  hain :: 6
	  anis :: 6
     }
val tgmath unary real imag val asinh casinh  {
	jacinths :: 7
	chainsaw :: 7
	achings :: 7
	cawings :: 7
	cavings :: 7
	casinos :: 7
	casings :: 7
	cashing :: 8
	  chais :: 7
	  cains :: 7
	  cabin :: 7
	  basin :: 7
	 banish :: 7
	canines :: 7
	canings :: 7
	caliphs :: 7
	cakings :: 7
	 danish :: 7
	 chinas :: 7
	 chaine :: 7
	chaines :: 8
	  sasin :: 7
	   cash :: 7
	 casino :: 9
	 casini :: 8
	 casing :: 9
	 casein :: 7
	 cabins :: 8
	 vanish :: 7
      }
hyperbolic arc tangent of x define atanh  {
	acanths :: 6
	acanthi :: 6
	 avant :: 6
	 alant :: 6
	acanth :: 7
	 thana :: 6
	  than :: 6
	   ata :: 6
     }
val tgmath unary real imag val atanh catanh  {
	matachin :: 8
	calanthes :: 7
	catenas :: 7
	catenae :: 7
	catarrh :: 7
	satanic :: 7
	  cotan :: 7
	  caman :: 7
	canthal :: 7
	calanthe :: 8
	 acanth :: 7
	  ratan :: 7
	 catnap :: 7
	 catena :: 8
	matachins :: 7
	matachini :: 7
	 vacant :: 7
      }
hyperbolic cosine of x define cosh  {
	 cosh :: -1000
    }
val tgmath unary real imag val cosh ccosh  {
	  cooch :: 6
	croches :: 6
	  chocs :: 7
	 conchs :: 6
	 chocks :: 6
	cloches :: 6
	   ochs :: 6
	   choc :: 6
      }
hyperbolic sine of x define sinh  {
	sputa :: -1000
    }
val tgmath unary real imag val sinh csinh  {
	  cuish :: 6
	  coins :: 6
	  chins :: 8
	  chino :: 6
	  chink :: 6
	  china :: 6
	  cains :: 6
	chinars :: 6
	 chints :: 7
	 chinos :: 7
	 chinks :: 7
	 chines :: 7
	 chinas :: 7
	   shin :: 6
	   chis :: 6
	   chin :: 7
      }
hyperbolic tangent of x define tanh  {
	 tanh :: -1000
    }
val tgmath unary real imag val tanh ctanh  {
	  chant :: 8
	  chank :: 6
	  chang :: 6
	 acanth :: 6
	 chanty :: 7
	 chants :: 7
	 stanch :: 7
	chantry :: 6
	chantor :: 6
	chantey :: 6
	chanter :: 6
	chantie :: 6
	   than :: 6
	   chat :: 6
	 canthi :: 6
	  natch :: 6
      }
exponential and logarithmic  {
	logarithmic :: -1000
 }
functions exponential function of x define exp val tgmath unary real imag val exp cexp  {
	           cep :: 5
             }
break value into a normalized fraction and an integral power of define frexp  {
	      prefix :: 6
	        prex :: 7
	       prexy :: 6
           }
val val tgmath binary first real only val val frexp x times two to the exp power define ldexp  {
	        cannoneers :: -1000
                 }
val val tgmath binary first real only val val ldexp natural logarithm of x define log val tgmath unary real imag val log clog  {
	                   clog :: -1000
                      }
base ten logarithm of x ifdef use gnu define log val tgmath unary real imag val log clog else define log val tgmath unary real only val log endif return exp x define expm  {
	                            scuff :: -1000
                                }
val tgmath unary real only val expm return log x define log p val tgmath unary real only val log p return the base signed integral exponent of x define logb  {
	                         bogle :: 5
	                          logy :: 5
	                          logs :: 5
	                          loge :: 5
	                          glob :: 5
	                           log :: 6
	                           lob :: 5
	                           bog :: 5
                             }
val tgmath unary real only val logb compute base exponential of x define exp val tgmath unary real only val exp compute base logarithm of x define log val tgmath unary real only val log power functions return x to the y power define pow val val tgmath binary real imag val val pow cpow  {
	                                                  crow :: 5
	                                                  clow :: 5
	                                                  chow :: 5
                                                     }
return the square root of x define sqrt val tgmath unary real imag val sqrt csqrt  {
              }
return sqrt x x y y define hypot val val tgmath binary real only val val hypot return the cube  {
	               cube :: -1000
                  }
root of x define cbrt  {
	curt :: 5
	cort :: 5
	cert :: 5
	cart :: 5
   }
val tgmath unary real only val cbrt nearest integer absolute value and remainder functions smallest integral value not less than x define ceil val tgmath unary real only val ceil absolute value of x define fabs  {
	                             fables :: 5
	                               wabs :: 5
	                               tabs :: 5
	                               sabs :: 5
	                               nabs :: 5
	                               labs :: 5
	                               kabs :: 5
	                               jabs :: 5
	                               fubs :: 5
	                               gabs :: 5
	                               fobs :: 5
	                               fibs :: 5
	                               fays :: 5
	                               fats :: 5
	                               fans :: 5
	                               fahs :: 5
	                               fags :: 5
	                               fads :: 5
	                               dabs :: 5
	                               cabs :: 5
	                                sab :: 5
	                                fas :: 5
	                                fab :: 6
                                  }
val tgmath unary real imag ret real val fabs cabs  {
	     cabs :: -1000
        }
largest integer not greater than x define floor val tgmath unary real only val floor floating point modulo  {
	           modulo :: -1000
                }
remainder of x y define fmod  {
	 food :: 5
	 feod :: 5
    }
val val tgmath binary real only val val fmod round x to integral valuein  {
	     vagueing :: 10
	     mauvline :: 9
	     veluring :: 9
	      valuing :: 9
	     valeting :: 9
	        value :: 10
	     paludine :: 9
	       values :: 9
	       valuer :: 9
	       valued :: 9
	       valine :: 9
            }
floating point format using current rounding direction but do not raise inexact exception define nearbyint  {
	        nearby :: 11
	     betraying :: 12
             }
val tgmath unary real only val nearbyint round x to nearest integral value rounding halfway  {
	       halfway :: -1000
             }
cases away from zero define round val tgmath unary real only val round round x to the integral value in floating point format nearest but not larger in magnitude define trunc val tgmath unary real only val trunc compute remainder of x and y and put in quo a value with sign of x y and magnitude congruent mod n to the magnitude of the integral quotient x y with n define remquo  {
	                                                                 remould :: 7
	                                                                 remount :: 7
                                                                       }
val val val tgmath ternary first second real only val val val remquo round x to nearest integral value according to current rounding direction define lrint  {
	                    glint :: 6
	                    flint :: 6
	                    elint :: 6
	                    clint :: 6
	                   trinal :: 7
	                  tringle :: 6
	                  trindle :: 6
	                    trins :: 6
	                    trine :: 6
	                     trin :: 7
	                  slinter :: 6
	                    print :: 7
                        }
val tgmath unary real ret only val long int lrint define llrint  {
          }
val tgmath unary real ret only val long long int llrint round x to nearest integral value rounding halfway cases away from zero define lround  {
	                  unlord :: 7
	                flounder :: 8
	                  rotund :: 7
	                 grounds :: 8
	              groundless :: 7
	              groundsill :: 7
	               groundsel :: 8
	               flounders :: 7
	               scoundrel :: 7
	                  ground :: 9
	                rotundly :: 7
                       }
val tgmath unary real ret only val long int lround define llround  {
          }
val tgmath unary real ret only val long long int llround return x with its signed changed to y s define copysign  {
	             codesign :: 10
	              cosying :: 11
	           copyrights :: 10
	              copying :: 12
	              copsing :: 11
	              copings :: 10
                    }
val val tgmath binary real only val val copysign error and gamma functions define erf  {
	           erf :: -1000
             }
val tgmath unary real only val erf define erfc  {
	    eric :: 5
	     erf :: 6
       }
val tgmath unary real only val erfc define tgamma  {
	grammatic :: 7
	 grammar :: 7
	  gnamma :: 8
       }
val tgmath unary real only val tgamma define lgamma val tgmath unary real only val lgamma return the integer nearest x in the direction of the prevailing  {
	                prevailing :: -1000
                         }
rounding mode define rint  {
	sinter :: 5
	wintry :: 5
	winter :: 5
	minter :: 5
	tinter :: 5
	hinter :: 5
	vintry :: 5
	vint :: 5
	tint :: 5
	ritt :: 5
	ript :: 5
	riot :: 5
	rins :: 5
	rink :: 5
	ring :: 5
	rine :: 5
	rind :: 5
	rift :: 5
	rent :: 5
	rant :: 5
	pint :: 5
	mint :: 5
	lint :: 5
	hint :: 5
	dint :: 5
	bint :: 5
	riant :: 5
	qintar :: 5
	linter :: 5
	tin :: 5
	rit :: 5
	rin :: 6
  }
val tgmath unary real only val rint return x epsilon  {
	  epsilon :: -1000
        }
if x y x epsilon if x y define nextafter val val tgmath binary real only val val nextafter define nexttoward val val tgmath binary first real only val val nexttoward return the remainder of integer divison  {
	                             divisor :: 11
	                             divines :: 9
	                             divings :: 9
	                            vidicons :: 10
	                             vidicon :: 9
	                            divisors :: 9
	                            division :: 9
                                   }
x y with infinite precision define remainder val val tgmath binary real only val val remainder return x times to the nth power if defined use misc defined use xopen extended define scalb  {
	                          scaler :: 6
	                          scaled :: 6
	                          scabby :: 6
	                        scambler :: 6
	                        scambled :: 6
	                         scribal :: 6
	                        scabbled :: 6
	                        scabbily :: 6
	                            slab :: 6
	                            scab :: 7
	                           scrab :: 6
	                           scaly :: 7
	                           scalp :: 7
	                           scall :: 6
	                           scale :: 7
	                           scald :: 7
	                           scala :: 6
	                           scail :: 6
	                         scamble :: 7
	                         scabble :: 7
                               }
val val tgmath binary real only val val scalb endif return x times to the nth power define scalbn  {
	         scambling :: 7
	          coalbins :: 7
	         scabbling :: 7
	              scan :: 7
	              scab :: 7
	             scaly :: 7
	             scalp :: 7
	             scale :: 7
	             scald :: 7
	           scamble :: 7
	           scaling :: 8
	           scaleni :: 8
	           scalene :: 8
	           scabble :: 7
                 }
val val tgmath binary first real only val val scalbn return x times to the nth power define scalbln  {
	             scall :: 9
                 }
val val tgmath binary first real only val val scalbln return the binary exponent of x which must be nonzero define ilogb val tgmath unary real ret only val int ilogb return positive difference between x and y define fdim  {
                                      }
val val tgmath binary real only val val fdim return maximum numeric value from x and y define fmax  {
	              flax :: 5
                 }
val val tgmath binary real only val val fmax return minimum numeric value from x and y define fmin  {
	           encoded :: -1000
                 }
val val tgmath binary real only val val fmin multiply add function computed as a ternary operation define fma val val val tgmath ternary real only val val val fma absolute value conjugates  {
	                      conjugates :: -1000
                               }
and projection  {
	projection :: -1000
 }
argument value of z define carg val tgmath unary real imag ret real val carg carg complex conjugate of z define conj val tgmath unary imag val conj projection of z onto the riemann  {
	                       mismanners :: 9
                                }
sphere  {
	sphere :: -1000
 }
define cproj  {
 }
val tgmath unary imag val cproj decomposing  {
	decomposing :: -1000
     }
complex values imaginary part of z define cimag  {
	  gamic :: 6
	  cigar :: 6
	camogie :: 6
	   mica :: 6
      }
val tgmath unary real imag ret real val cimag cimag real part of z define creal  {
	          cruel :: 6
	          crena :: 6
	          creel :: 6
	          cream :: 7
	          creak :: 7
	          crawl :: 6
	          craal :: 7
	          coral :: 6
	          cleat :: 6
	          clear :: 8
	          clean :: 6
	          carle :: 6
	          areal :: 7
	       creolian :: 6
	        crestal :: 6
	         oracle :: 6
	         credal :: 7
	         creasy :: 6
	         creant :: 6
	         creamy :: 6
	         creams :: 6
	         creaky :: 6
	         creaks :: 6
	         creagh :: 6
	         cradle :: 7
	         craals :: 6
	        crawled :: 6
	        cradles :: 6
	        craaled :: 7
	         clears :: 7
	       creamily :: 6
	       creakily :: 6
	          ureal :: 7
	        treacly :: 6
	        clearly :: 6
              }
val tgmath unary real imag ret real val creal creal endif tgmath h thread db h interface to libthread  {
	           librate :: 11
	         liberated :: 11
	          librated :: 12
                 }
db so library for debugging lpthread  {
	rethread :: 10
	lathered :: 10
	unthread :: 10
    }
copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef thread db h define thread db h this is the debugger interface for the nptl  {
                                                                                                                                                    }
library it is modelled  {
	modelled :: -1000
  }
closely  {
	closely :: -1000
 }
after the interface with same names in solaris with the goal  {
	      goal :: -1000
         }
to share the same code in the debugger include pthread h include stdint h include sys types h include sys procfs  {
	              proofs :: 8
	              frocks :: 8
	               crops :: 7
	             profuse :: 7
	             process :: 7
	              croups :: 7
	              crofts :: 7
	                pros :: 7
	                prof :: 7
	               profs :: 8
                   }
h error codes of the library typedef enum td ok no error td err no further specified error td nothr  {
	            cothurn :: 6
	            notcher :: 6
	             nother :: 8
	             noters :: 6
	             notary :: 6
	              noter :: 7
	              notch :: 6
	              north :: 7
	             norths :: 6
	                not :: 6
                  }
no matching thread found td nosv  {
	 nosy :: 5
	 nosh :: 5
	 nose :: 5
	novas :: 5
	  nos :: 6
    }
no matching synchronization handle found td nolwp  {
     }
no matching light  {
	light :: -1000
 }
weighted process found td badph  {
	 bad :: 6
   }
invalid process handle td badth invalid thread handle td badsh  {
	    hadst :: 6
	    brash :: 6
	    blash :: 6
	   bashed :: 6
	     dahs :: 6
	     dabs :: 6
	     bash :: 6
	     bahs :: 7
	      bad :: 6
        }
invalid synchronization handle td badta  {
	bastardy :: 6
	bastards :: 6
	batta :: 7
	basta :: 7
	banda :: 6
	battas :: 6
	bantam :: 6
	badman :: 6
	bastard :: 7
   }
invalid thread agent td badkey  {
	beaked :: 7
	beaky :: 7
	bayed :: 7
	baked :: 7
	badge :: 7
	basked :: 8
	barked :: 8
	banked :: 8
	bakery :: 7
	backed :: 8
	darkey :: 8
	yanked :: 7
	yakked :: 7
	yacked :: 7
	bade :: 7
	braked :: 7
	boaked :: 7
   }
invalid key td nomsg no event available td nofpregs  {
       }
no floating point register content available td nolibthread  {
      }
application not linked with thread library td noevent  {
	convented :: 9
	convents :: 9
	convent :: 10
	 voteen :: 9
      }
requested event is not supported td nocapab  {
     }
capability not available td dberr  {
	drear :: 6
   }
internal debug library error td noaplic  {
	complain :: 9
	complicant :: 9
	compliant :: 9
	complin :: 9
	podalic :: 9
    }
operation is not applicable td notsd  {
	carnalise :: -1000
    }
no thread specific data available td malloc out of memory td partialreg  {
	 paraglider :: 12
	    patrial :: 12
	    partial :: 13
	   partials :: 12
          }
not entire register set was read or written td noxregs  {
        }
x register set not available for given thread td tlsdefer  {
	 ulstered :: 10
        }
thread has not yet allocated tls for given module td notalloc  {
	  cotillon :: 11
	 cotillons :: 10
         }
td tlsdefer td version version if libpthread  {
     }
and libthread db do not match td notls  {
	noblest :: 6
	  tolls :: 6
	  toils :: 6
	   lots :: 6
	  rotls :: 7
	  nowts :: 6
	  notes :: 7
	  notal :: 6
	  nolls :: 7
	  noils :: 7
	  noels :: 7
	  lotus :: 6
	  lotes :: 6
	  lotas :: 6
	    not :: 6
      }
there is no tls segment in the given module td err e possible thread states td thr any state is a pseudo state used to select threads regardless of state in td ta thr iter typedef enum td thr any state td thr unknown td thr stopped td thr run td thr active td thr zombie  {
	                                                 zombie :: -1000
                                                      }
td thr sleep td thr stopped asleep  {
	asleep :: -1000
     }
td thr state e thread type user or system td thr any type is a pseudo type used to select threads regardless of type in td ta thr iter typedef enum td thr any type td thr user td thr system td thr type e types of the debugging library handle for a process this type is opaque typedef struct td thragent  {
	                                                    threating :: 10
                                                            }
td thragent t the actual thread handle type this is also opaque typedef struct td thrhandle  {
              }
td thragent t th ta p psaddr  {
	readds :: 7
	padders :: 7
	 prads :: 7
     }
t th unique td thrhandle t forward declaration of a type defined by and for the dynamic linker struct link map flags for td ta thr iter define td thr any user flags xffffffff define td thr lowest priority define td signo mask null define td eventsize  {
	                                     eventides :: 12
	                                       evenest :: 12
	                                      eventers :: 11
	                                      eventide :: 11
	                                     extensive :: 11
                                             }
define bt uishift  {
	upshifts :: 9
	unshift :: 11
	unshifts :: 9
	unshifted :: 9
	upshifted :: 9
	upshift :: 11
	unshifting :: 9
	upshifting :: 9
 }
log base of bt nbipui  {
   }
to extract word index define bt nbipui bt uishift n bits per uint define bt uimask  {
	         unmask :: 9
	         umiaks :: 8
	         umiack :: 7
	         immask :: 8
	       unmasked :: 7
	       unmasker :: 7
	        umiacks :: 8
	          bimas :: 7
	      unmasking :: 8
	        unmasks :: 7
	          umiak :: 7
	           sima :: 7
	          simas :: 7
	          pimas :: 7
	          limas :: 7
              }
bt nbipui to extract bit index bitmask of enabled events typedef struct td thr events uint t event bits td eventsize td thr events t event set manipulation macros define td eventmask  {
	                         events :: 11
                              }
n uint c n bt uimask define td eventword  {
       }
n uint c n bt uishift define td event emptyset  {
	 emptiest :: 11
        }
setp do int i for i td eventsize i i setp event bits i while define td event fillset  {
	             fills :: 10
	             fille :: 9
	             fells :: 9
	            fillet :: 10
	            filles :: 10
	           follies :: 9
	          gillnets :: 9
	           fellies :: 9
	           fellest :: 9
	         fillister :: 9
	             tills :: 9
	           fullest :: 9
	           filmset :: 10
	           fillies :: 9
	           fillers :: 9
	           fillets :: 11
                 }
setp do int i for i td eventsize i i setp event bits i uint c xffffffff while define td event addset  {
	                addle :: 7
	               wadset :: 8
	               addles :: 8
	               adders :: 7
	             adjusted :: 7
	              addrest :: 9
	              address :: 7
	              addicts :: 7
	               oddest :: 7
	                 adds :: 8
                    }
setp n setp event bits td eventword n td eventmask n define td event delset  {
	       delvers :: 7
	        lensed :: 7
	      dealates :: 7
	       deletes :: 7
	       teledus :: 7
	       delates :: 8
	        leased :: 7
	       deiseal :: 7
	        selfed :: 7
	        select :: 7
	      deluster :: 8
	         dulse :: 7
	         desse :: 7
	         dense :: 7
	         delve :: 7
	         deets :: 7
	        belted :: 7
	       lewdest :: 7
	        diesel :: 7
	       helmets :: 7
	       dulcets :: 7
	        devest :: 7
	        pelted :: 7
	        detest :: 7
	        desert :: 7
	        dentel :: 7
	        delves :: 8
	        delist :: 7
	        delate :: 7
	        welted :: 7
	     decretals :: 7
	      relisted :: 7
	      delisted :: 7
	        felted :: 7
	        melted :: 7
	     delusters :: 7
	       velvets :: 7
	       felsite :: 7
	        tensed :: 7
	        temsed :: 7
	        teasel :: 7
	        teased :: 7
	     celsitude :: 7
	       pelmets :: 7
	      desalter :: 7
	         teles :: 7
	        eldest :: 7
	          dels :: 7
	          dees :: 7
	       dessert :: 7
	      deflects :: 7
	      deflates :: 7
	       dentels :: 8
	       densely :: 7
	       dennets :: 7
             }
setp n setp event bits td eventword n td eventmask n define td eventismember  {
            }
setp n td eventmask n setp event bits td eventword n if td eventsize define td eventisempty  {
               }
setp setp event bits setp event bits else error td eventisempty must be changed to match td eventsize endif events reportable  {
	          reportable :: -1000
                   }
by the thread implementation typedef enum td all events pseudo event number td event none td all events depends on context td ready is executable now td sleep blocked in a synchronization obj td switchto  {
	                          twitches :: 10
	                        stitchwort :: 12
	                        stitchwork :: 11
	                            twitch :: 10
	                       stitchworts :: 10
	                           switchy :: 10
	                            switch :: 11
	                            stitch :: 10
                                 }
now assigned to a process td switchfrom  {
	switcher :: 13
	switcheroo :: 13
	switch :: 12
     }
not anymore assigned to a process td lock try trying to get an unavailable lock td catchsig  {
	        cowgrass :: -1000
               }
signal posted to the thread td idle process getting idle td create new thread created td death  {
	           death :: -1000
               }
thread terminated td preempt preempted  {
	preempted :: -1000
   }
td pri inherit inherited  {
	inherited :: -1000
  }
elevated  {
	elevated :: -1000
 }
priority td reap  {
	reap :: -1000
 }
reaped  {
	reaped :: -1000
 }
td concurrency number of processes changing td timeout conditional variable wait timed out td min event num td ready td max event num td timeout td events enable event reporting enabled td event e values representing the different ways  {
	                                  ways :: -1000
                                     }
events are reported typedef enum notify bpt user must insert breakpoint at u bptaddr  {
            }
notify autobpt  {
 }
breakpoint at u bptaddr is automatically inserted notify syscall system call u syscallno  {
           }
will be invoked td notify e description how event type is reported typedef struct td notify td notify e type way the event is reported union psaddr t bptaddr address of breakpoint int syscallno number of system call used u td notify t structure used to report event typedef struct td event msg td event e event event type being reported const td thrhandle t th p thread reporting the event union if td synchandle  {
	                                                                   lyncean :: 12
                                                                         }
t sh handle of synchronization object endif uintptr t data event specific data msg td event msg t structure containing event data available in each thread structure typedef struct td thr events t eventmask mask of enabled events td event e eventnum  {
                                        }
number of last event void eventdata  {
    }
data associated with event td eventbuf  {
	eventfully :: 10
	event :: 10
	eventful :: 12
    }
t gathered statistics about the process typedef struct td ta stats int nthreads  {
	     starned :: 10
	    untreads :: 11
           }
total number of threads in use int r concurrency concurrency level requested by user int nrunnable  {
	      shunnable :: 12
              }
num average runnable  {
	runnable :: -1000
 }
threads numerator  {
	numerator :: -1000
 }
int nrunnable den average runnable threads denominator  {
	denominator :: -1000
     }
int a concurrency num achieved  {
	achieved :: -1000
   }
concurrency level numerator int a concurrency den achieved concurrency level denominator int nlwps  {
	     flecker :: -1000
           }
num average number of processes in use numerator int nlwps den average number of processes in use denominator int nidle  {
	             sidles :: 6
	             sidler :: 6
	             gilden :: 6
	             nirled :: 8
	             nilled :: 8
	             nidget :: 6
	              eldin :: 6
	             nailed :: 7
	             kilned :: 6
	             kidlet :: 6
	             ridley :: 6
	             milden :: 6
	             midleg :: 6
	               nide :: 7
	              sidle :: 7
	               diel :: 6
	              nudie :: 6
	             linked :: 6
	             linden :: 6
	             limned :: 6
	              nides :: 6
	              nidal :: 6
	                nid :: 6
	              lined :: 6
                  }
num average number of idling  {
	idling :: -1000
   }
processes numerator int nidle den average number of idling processes denominator td ta stats t since sun s library is based on solaris threads we have to define a few types to map them to posix threads typedef pthread t thread t typedef pthread key t thread key t callback for iteration over threads typedef int td thr iter f const td thrhandle t void callback for iteration over thread local data typedef int td key iter f thread key t void void void forward declaration this has to be defined by the user struct ps prochandle  {
	                                                                                        cropland :: 13
	                                                                                        prochain :: 12
	                                                                                      doorhandle :: 13
	                                                                                      overhandle :: 12
	                                                                                       croplands :: 12
                                                                                               }
information about the thread typedef struct td thrinfo  {
	 forint :: 9
      }
td thragent t ti ta p process handle unsigned int ti user flags unused thread t ti tid  {
	              tid :: -1000
                }
thread id returned by pthread create char ti tls pointer to thread local data psaddr t ti startfunc  {
	         startful :: 13
                }
start function passed to pthread create psaddr t ti stkbase  {
	 setbacks :: 9
	   steaks :: 9
	   stakes :: 9
        }
base of thread s stack long int ti stksize  {
	stylizes :: 9
       }
size of thread s stack psaddr t ti ro area unused int ti ro size unused td thr state e ti state thread state unsigned char ti db suspended nonzero if suspended by debugger td thr type e ti type type of the thread system vs user thread intptr t ti pc unused intptr t ti sp unused short int ti flags unused int ti pri thread priority lwpid  {
	                                                               lepid :: 7
	                                                              lipide :: 6
	                                                               lipid :: 7
                                                                   }
t ti lid  {
	lid :: -1000
 }
kernel pid for this thread sigset t ti sigmask signal mask unsigned char ti traceme  {
	      trameled :: 9
	     traceless :: 9
	      trackmen :: 10
	      bracelet :: 9
	     forcemeat :: 9
	       cremate :: 9
	         trace :: 9
             }
nonzero if event reporting enabled unsigned char ti preemptflag  {
       }
unused unsigned char ti pirecflag  {
	persiflage :: 12
	persiflages :: 11
   }
unused sigset t ti pending set of pending signals td thr events t ti events set of enabled events td thrinfo t prototypes for exported library functions initialize the thread debug support library extern td err e td init void historical  {
	                              historical :: -1000
                                       }
relict  {
	relict :: -1000
 }
should not be used anymore extern td err e td log void return list of symbols the library can request extern const char td symbol list void generate new thread debug library handle for process ps extern td err e td ta new struct ps prochandle ps td thragent t ta free resources allocated for ta extern td err e td ta delete td thragent t ta get number of currently running threads in process associated with ta extern td err e td ta get nthreads const td thragent t ta int np return process handle passed in td ta new for process associated with ta extern td err e td ta get ph const td thragent t ta struct ps prochandle ph map thread library handle pt to thread debug library handle for process associated with ta and store result in th extern td err e td ta map id thr const td thragent t ta pthread t pt td thrhandle t th map process id lwpid to thread debug library handle for process associated with ta and store result in th extern td err e td ta map lwp thr const td thragent t ta lwpid t lwpid td thrhandle t th call for each thread in a process associated with ta the callback function callback extern td err e td ta thr iter const td thragent t ta td thr iter f callback void cbdata p td thr state e state int ti pri sigset t ti sigmask p unsigned int ti user flags call for each defined thread local data entry the callback function ki extern td err e td ta tsd  {
	                                                                                                                                                                                                                                                                              tsked :: 3
	                                                                                                                                                                                                                                                                              tsadi :: 3
	                                                                                                                                                                                                                                                                              tsade :: 3
	                                                                                                                                                                                                                                                                              tides :: 3
	                                                                                                                                                                                                                                                                               tods :: 4
	                                                                                                                                                                                                                                                                               tids :: 4
	                                                                                                                                                                                                                                                                               teds :: 4
	                                                                                                                                                                                                                                                                               tads :: 4
	                                                                                                                                                                                                                                                                                tsk :: 3
	                                                                                                                                                                                                                                                                                tod :: 3
	                                                                                                                                                                                                                                                                                tid :: 3
	                                                                                                                                                                                                                                                                                ted :: 3
	                                                                                                                                                                                                                                                                                tad :: 3
	                                                                                                                                                                                                                                                                                 ts :: 4
                                                                                                                                                                                                                                                                                  }
iter const td thragent t ta td key iter f ki void p get event address for event extern td err e td ta event addr const td thragent t ta td event e event td notify t ptr enable event in global mask extern td err e td ta set event const td thragent t ta td thr events t event disable event in global mask extern td err e td ta clear event const td thragent t ta td thr events t event return information about last event extern td err e td ta event getmsg const td thragent t ta td event msg t msg set suggested concurrency level for process associated with ta extern td err e td ta setconcurrency const td thragent t ta int level enable collecting  {
	                                                                                                                          collecting :: -1000
                                                                                                                                   }
statistics for process associated with ta extern td err e td ta enable stats const td thragent t ta int enable reset statistics extern td err e td ta reset stats const td thragent t ta retrieve statistics from process associated with ta extern td err e td ta get stats const td thragent t ta td ta stats t statsp  {
	                                                    startups :: 7
	                                                     statusy :: 7
	                                                     statues :: 7
	                                                     stators :: 7
	                                                     statism :: 7
	                                                     statics :: 7
	                                                     staters :: 7
	                                                      status :: 8
	                                                      states :: 8
	                                                      starts :: 7
	                                                       swats :: 7
	                                                       stots :: 7
	                                                       stats :: 10
	                                                       staps :: 8
	                                                        stat :: 7
	                                                       spats :: 9
	                                                       slats :: 7
	                                                       skats :: 7
	                                                       seats :: 7
	                                                       scats :: 7
	                                                      spates :: 7
	                                                       pasts :: 7
                                                           }
validate that th is a thread handle extern td err e td thr validate const td thrhandle t th return information about thread th extern td err e td thr get info const td thrhandle t th td thrinfo t infop retrieve floating point register contents of process running thread th extern td err e td thr getfpregs  {
                                                        }
const td thrhandle t th prfpregset  {
	prepregs :: 14
	prepreg :: 12
    }
t regset  {
	preset :: 7
	geyser :: 7
	secret :: 7
	geste :: 7
	geest :: 7
	reesting :: 7
	reagents :: 7
	restage :: 7
	rennets :: 7
	segreant :: 7
	regrates :: 7
	revest :: 7
	reties :: 7
	retest :: 7
	restem :: 7
	rested :: 7
	resent :: 7
	resect :: 7
	reseat :: 7
	rentes :: 7
	renest :: 7
	regrets :: 9
	regret :: 8
	regoes :: 8
	reglet :: 9
	reglets :: 10
	regest :: 10
	regent :: 8
	reesty :: 7
	reates :: 7
	regents :: 9
	reflets :: 7
	register :: 7
	ragees :: 7
	leglets :: 7
	terser :: 7
	tenser :: 7
	teaser :: 7
	getters :: 7
	groset :: 7
	terse :: 8
	rees :: 7
	serge :: 7
	gerents :: 7
	reuse :: 7
	retes :: 7
	reset :: 7
	reges :: 8
	reest :: 8
	verset :: 8
 }
retrieve general register contents of process running thread th extern td err e td thr getgregs  {
              }
const td thrhandle t th prgregset  {
    }
t gregs  {
	grogs :: 7
	grigs :: 7
	greys :: 6
	grego :: 7
	dregs :: 7
	gressing :: 6
	greasing :: 6
	gurges :: 6
	gregos :: 8
 }
retrieve extended register contents of process running thread th extern td err e td thr getxregs  {
              }
const td thrhandle t th void xregs  {
	 greys :: 6
	 dregs :: 7
     }
get size of extended register set of process running thread th extern td err e td thr getxregsize  {
                }
const td thrhandle t th int sizep  {
	 bizes :: 6
	 wizes :: 6
	  size :: 8
	  sipe :: 7
	  pize :: 7
	 sizes :: 6
	 sizer :: 7
	 sized :: 7
	 siped :: 6
	 pizes :: 8
     }
set floating point register contents of process running thread th extern td err e td thr setfpregs  {
               }
const td thrhandle t th const prfpregset t fpregs set general register contents of process running thread th extern td err e td thr setgregs  {
	                skeggers :: 10
	                staggers :: 10
                       }
const td thrhandle t th prgregset t gregs set extended register contents of process running thread th extern td err e td thr setxregs  {
                      }
const td thrhandle t th const void addr get address of the given module s tls storage area for the given thread extern td err e td thr tlsbase  {
	                     finicky :: -1000
                           }
const td thrhandle t th unsigned long int modid psaddr t base get address of thread local variable extern td err e td thr tls get addr const td thrhandle t th psaddr t map address size t offset psaddr t address enable reporting for event for thread th extern td err e td thr event enable const td thrhandle t th int event enable event for thread th extern td err e td thr set event const td thrhandle t th td thr events t event disable event for thread th extern td err e td thr clear event const td thrhandle t th td thr events t event get event message for thread th extern td err e td thr event getmsg const td thrhandle t th td event msg t msg set priority of thread th extern td err e td thr setprio const td thrhandle t th int prio set pending signals for thread th extern td err e td thr setsigpending  {
                                                                                                                                                                    }
const td thrhandle t th unsigned char n const sigset t ss set signal mask for thread th extern td err e td thr sigsetmask const td thrhandle t th const sigset t ss return thread local data associated with key tk in thread th extern td err e td thr tsd const td thrhandle t th const thread key t tk void data suspend execution of thread th extern td err e td thr dbsuspend  {
                                                                          }
const td thrhandle t th resume execution of thread th extern td err e td thr dbresume  {
               }
const td thrhandle t th endif thread db h libtiff  {
        }
tiffconf  {
 }
h generated from tiffconf h in by configure configuration defines for installed libtiff this file maintained for backward compatibility do not use definitions from this file in your programs ifndef tiffconf define tiffconf define to if the system has the type int undef have int define to if the system has the type int undef have int define to if the system has the type int undef have int the size of a int as computed by sizeof define sizeof int the size of a long as computed by sizeof define sizeof long compatibility stuff define as or according to the floating point format suported  {
	                                                                                                imported :: 10
	                                                                                                unsorted :: 11
	                                                                                                sprouted :: 13
	                                                                                                  deport :: 10
	                                                                                                postured :: 10
	                                                                                                unposted :: 11
	                                                                                                strouted :: 11
	                                                                                                suborned :: 10
	                                                                                                stropped :: 10
	                                                                                                exported :: 10
	                                                                                                reposted :: 11
	                                                                                                reported :: 10
	                                                                                                deported :: 10
	                                                                                                riposted :: 11
	                                                                                                 deports :: 11
	                                                                                                superhot :: 10
                                                                                                       }
by the machine define have ieeefp  {
    }
set the native cpu bit order fillorder  {
	frivoller :: 11
     }
lsb msb or fillorder msb lsb define host fillorder fillorder lsb msb native cpu byte order if big endian motorola or if little endian intel define host bigendian support ccitt  {
                            }
group algorithms define ccitt support support jpeg compression requires ijg jpeg library define jpeg support support jbig  {
               }
compression requires jbig kit  {
	kit :: -1000
  }
library undef jbig support support logluv  {
    }
high dynamic range encoding define logluv support support lzw  {
	kirsches :: -1000
       }
algorithm define lzw support support next bit rle  {
	  clerk :: 3
	  clear :: 3
	  blear :: 3
	   role :: 3
	   rile :: 3
	   riel :: 4
	   rely :: 3
	   real :: 3
	   rale :: 3
	   lier :: 3
	   leer :: 3
	   laer :: 3
	  riels :: 3
	  reels :: 3
	    ule :: 3
	    rye :: 3
	    roe :: 3
	    ree :: 3
	    ole :: 3
	    ale :: 3
	     re :: 3
	     el :: 3
      }
algorithm define next support support old jpeg compresson  {
	compress :: 15
	composes :: 13
	composer :: 12
	comprises :: 12
	comparison :: 13
	poorness :: 12
	composers :: 13
	compassion :: 12
	compensators :: 13
	compressors :: 13
	compression :: 17
	complexions :: 12
	composures :: 12
	compassions :: 12
	compressional :: 15
	completions :: 12
	compulsions :: 12
	compressor :: 16
	compressed :: 12
	campness :: 12
	compressions :: 14
	compursion :: 12
	comparisons :: 13
      }
read contrib ojpeg  {
	promiscuousnesses :: -1000
 }
readme first compilation fails with unpatched  {
	unwitched :: 12
	upcatches :: 11
	bepatched :: 12
	repatched :: 12
	unmatched :: 15
	staunched :: 11
	unteach :: 11
	unhitched :: 12
	unwatched :: 15
	unpaced :: 11
	unlatch :: 11
	unperched :: 12
	unreached :: 11
	uncharted :: 11
	unhatched :: 15
	unscathed :: 12
	unpathed :: 13
	unearthed :: 11
	splatched :: 11
	unlatched :: 15
	unlatches :: 12
    }
ijg jpeg library define ojpeg support support macintosh packbits  {
	 backlit :: 10
	 backfit :: 10
	 backbit :: 11
	backbiters :: 10
	backbites :: 11
	hawkbits :: 10
	 sackbut :: 10
	backlist :: 10
	backfits :: 12
	sackbuts :: 10
	hackbuts :: 10
	backbite :: 10
       }
algorithm define packbits support support pixar  {
	picaro :: 6
	 pira :: 7
	pilar :: 7
	  pix :: 6
    }
log format algorithm requires zlib define pixarlog  {
     }
support support thunderscan  {
	thunderclaps :: 15
	thunderclap :: 14
	thunders :: 15
	chunders :: 14
	countershading :: 14
 }
bit rle algorithm define thunder support support deflate compression define zip  {
	       zip :: -1000
         }
support support strip chopping  {
	objuration :: -1000
  }
whether or not to convert single strip uncompressed images to mutiple  {
	  multiped :: 9
         }
strips  {
	strips :: -1000
 }
of kb to reduce memory usage define stripchop  {
	strophic :: 11
      }
default tiff stripchop enable subifd  {
	subidea :: 7
	subindex :: 7
	sulfid :: 7
	subfix :: 7
	subfield :: 7
   }
tag support define subifd support treat extra sample as alpha default enabled the rgba interface will treat a fourth sample with no extrasample  {
	             quaesitum :: -1000
                     }
value as being assocalpha  {
  }
many packages produce rgba files but don t mark the alpha properly define default extrasample as alpha pick up ycbcr subsampling  {
	         subsampling :: -1000
                   }
info from the jpeg data stream to support files lacking the tag default enabled define check jpeg ycbcr subsampling support ms mdi  {
	                idiom :: 3
	                 muid :: 4
	                 modi :: 3
	                 mind :: 3
	                 mild :: 3
	                 mids :: 3
	                 midi :: 3
	                 maid :: 4
	                 imid :: 3
	                 idem :: 3
	                 amid :: 3
	                odism :: 3
	                muids :: 3
	                maids :: 3
	                  moi :: 3
	                  mid :: 4
	                  dim :: 3
	                  adi :: 3
	                   mi :: 3
	                   id :: 3
                    }
magic number files as tiff define mdi support feature support definitions xxx these macros are obsoleted  {
	        outwell :: -1000
              }
don t use them in your apps macros stays  {
	   stays :: -1000
       }
here for backward compatibility and should be always defined define colorimetry  {
	colorimetry :: -1000
         }
support define ycbcr support define cmyk support define icc support define photoshop support define iptc  {
	         pitch :: 5
	         optic :: 5
             }
support endif tiffconf id tiff h v bfriesen  {
	befingers :: 10
      }
exp copyright c sam leffler  {
   }
copyright c silicon graphics inc permission to use copy modify distribute and sell this software and its documentation for any purpose is hereby granted without fee provided that i the above copyright notices and this permission notice appear in all copies of the software and related documentation and ii the names of sam leffler and silicon graphics may not be used in any advertising or publicity relating  {
	                                                          relating :: -1000
                                                                 }
to the software without the specific prior written permission of sam leffler and silicon graphics the software is provided as is and without warranty of any kind express implied or otherwise including without limitation any warranty of merchantability or fitness for a particular purpose in no event shall sam leffler or silicon graphics be liable for any special incidental indirect or consequential damages of any kind or any damages whatsoever resulting from loss of use data or profits whether or not advised of the possibility of damage and on any theory of liability arising out of or in connection with the use or performance of this software ifndef tiff define tiff include tiffconf h tag image file format tiff based on rev from developer  {
	                                                                                                                  developer :: -1000
                                                                                                                          }
s desk aldus  {
	lauds :: 6
	almudes :: 6
	duals :: 6
	alums :: 6
	aloud :: 6
	alods :: 6
	almud :: 6
	almuds :: 7
	aldose :: 6
	udals :: 6
 }
corporation  {
	corporation :: -1000
 }
first ave south  {
	south :: -1000
 }
suite seattle  {
	platelets :: 9
	slatted :: 9
	slatter :: 9
	sextolet :: 9
	spattee :: 10
	twattles :: 9
	heartlets :: 9
	startler :: 9
	startled :: 9
	septate :: 9
	slattered :: 9
	teasel :: 9
	startle :: 10
	prattles :: 9
	brattles :: 9
 }
wa http partners  {
	partners :: -1000
 }
adobe com asn developer pdfs  {
	redonning :: -1000
   }
tn  {
	tun :: 2
	ton :: 2
	tin :: 2
	ten :: 2
	tan :: 2
	ant :: 2
	t :: 2
 }
tiff pdf for big tiff design notes see the following link http www remotesensing  {
	   remoteness :: 18
            }
org libtiff bigtiffdesign  {
 }
html define tiff version define tiff bigtiff version define tiff bigendian x d d define tiff littleendian x define mdi littleendian x define mdi bigendian x intrinsic  {
	                 intrinsic :: -1000
                         }
data types required by the file format bit quantities int uint bit quantities int uint bit quantities int uint strings unsigned char ifndef have int typedef signed char int nb non ansi compilers may not grok  {
	                               grow :: 5
	                               grot :: 5
                                  }
endif typedef unsigned char uint ifndef have int typedef short int endif typedef unsigned short uint sizeof uint must if sizeof int ifndef have int typedef int int endif typedef unsigned int uint sizeof uint must elif sizeof long ifndef have int typedef long int endif typedef unsigned long uint sizeof uint must endif for tiffreassigntagtoignore  {
                                                      }
enum tiffignoresense  {
 }
ignore tag table tis  {
	tis :: -1000
  }
store tis extract tis empty tiff header typedef struct uint tiff magic magic number defines byte order define tiff magic size uint tiff version tiff version number define tiff version size uint tiff diroff  {
	                           ripoff :: 8
	                          difform :: 7
	                          ripoffs :: 7
                                }
byte offset to first directory define tiff diroffset  {
      }
size tiffheader  {
	tracheide :: 12
 }
tiff image file directories are comprised  {
	comprised :: -1000
    }
of a table of field descriptors of the form shown below the table is sorted in ascending  {
	       ascending :: -1000
               }
order by tag the values associated with each entry are disjoint  {
	  disjoint :: -1000
         }
and may appear anywhere in the file so long as they are placed on a word boundary if the value is bytes or less then it is placed in the offset field to save space if the value is less than bytes it is left justified  {
	                                  precritical :: -1000
                                            }
in the offset field typedef struct uint tdir  {
	   stir :: -1000
      }
tag see below uint tdir type data type see below uint tdir count number of items length in spec uint tdir offset byte offset to field data tiffdirentry  {
                          }
nb in the comments below items marked with a are obsoleted by revision items marked with a are introduced in revision items marked with a are introduced post revision items marked with a are obsoleted by revision items marked with a are introduced by adobe dng specification tag data type information note rationals  {
	                                           rationals :: -1000
                                                   }
are the ratio of two bit integer values typedef enum tiff notype placeholder  {
	 placeholder :: -1000
           }
tiff byte bit unsigned integer tiff ascii bit bytes w last byte null tiff short bit unsigned integer tiff long bit unsigned integer tiff rational bit unsigned fraction tiff sbyte  {
	                        style :: 6
	                         stye :: 6
                            }
bit signed integer tiff undefined bit untyped  {
     }
data tiff sshort  {
	shorts :: 7
	assort :: 7
	exhorts :: 7
	cohorts :: 7
	schouts :: 7
	schorls :: 7
	sutors :: 7
	stoors :: 7
 }
bit signed integer tiff slong  {
	klong :: 7
	alongst :: 7
	flong :: 7
	clons :: 6
	klongs :: 8
	along :: 7
	eloigns :: 6
	flongs :: 8
	spongily :: 6
	slowing :: 6
	sloping :: 6
	stong :: 7
	snog :: 6
	slog :: 7
	slung :: 7
	sloan :: 6
	sling :: 7
	slang :: 7
	spongy :: 6
	sponge :: 6
	slough :: 6
	slangy :: 6
   }
bit signed integer tiff srational  {
	serotinal :: 11
	sartorial :: 11
	antisolar :: 11
	artisanal :: 11
	stationary :: 13
	alation :: 11
	spaniolate :: 11
	baritonal :: 11
	factional :: 11
	suctional :: 12
	sectional :: 12
	pactional :: 11
	torsional :: 12
	erosional :: 11
	trainloads :: 11
	stational :: 15
	alations :: 12
   }
bit signed fraction tiff float bit ieee floating point tiff double bit ieee floating point tiff ifd bit unsigned integer offset tiffdatatype  {
                    }
tiff tag definitions define tifftag  {
   }
subfiletype  {
 }
subfile data descriptor define filetype  {
	fileted :: 10
   }
reducedimage  {
 }
x reduced resolution version define filetype page x one page of many define filetype mask x transparency mask define tifftag osubfiletype  {
                   }
kind of data in subfile define ofiletype  {
	heliotype :: 11
     }
image full resolution image data define ofiletype reducedimage reduced size image data define ofiletype page one page of many define tifftag imagewidth image width in pixels define tifftag imagelength  {
                           }
image height in pixels define tifftag bitspersample  {
     }
bits per channel sample define tifftag compression data compression technique define compression none dump mode define compression ccittrle  {
	        sweatings :: -1000
                }
ccitt modified huffman rle define compression ccittfax  {
     }
ccitt group fax encoding define compression ccitt t ccitt t tiff name define compression ccittfax ccitt group fax encoding define compression ccitt t ccitt t tiff name define compression lzw lempel  {
	                         lemel :: 8
	                        semple :: 7
	                        kemple :: 7
	                        temple :: 7
                             }
ziv  {
	zit :: 3
	zip :: 3
	zin :: 3
	zig :: 3
	viz :: 4
	div :: 3
 }
welch  {
	welch :: -1000
 }
define compression ojpeg jpeg define compression jpeg jpeg dct compression define compression next next bit rle define compression ccittrlew  {
                 }
w word alignment define compression packbits macintosh rle define compression thunderscan thunderscan rle codes are reserved for ansi it tiff it dkelly  {
	                dwell :: 7
	                skell :: 7
	               skelly :: 9
                    }
apago  {
	apogean :: 6
	apogeal :: 6
	apogamy :: 6
	apagogic :: 6
	apagoges :: 6
	apagoge :: 7
 }
com define compression it ctpad  {
	caped :: 6
   }
it ct w padding define compression it lw it linework  {
	 lacework :: 10
	 pipework :: 10
	 wirework :: 10
	 firework :: 10
	 lifework :: 13
	linkworks :: 12
	lifeworks :: 12
	 timework :: 10
	 pilework :: 12
	 linkwork :: 13
        }
rle define compression it mp it monochrome picture  {
	picture :: -1000
      }
define compression it bl it binary line art  {
	    art :: -1000
      }
compression codes are reserved for pixar define compression pixarfilm  {
       }
pixar companded  {
	compends :: 11
	compared :: 11
	compadre :: 12
	campodeid :: 11
	compendia :: 12
	companders :: 13
	compend :: 12
	comparted :: 12
	company :: 11
	compassed :: 12
	companies :: 12
	compander :: 14
	compadres :: 11
	compacted :: 11
	commended :: 11
	commanded :: 14
 }
bit lzw define compression pixarlog pixar companded bit zip define compression deflate deflate compression define compression adobe deflate deflate compression as recognized by adobe compression code is reserved for oceana  {
	                     oceanaut :: 10
	                       ozaena :: 7
	                      choanae :: 8
	                     comanage :: 7
	                   oceanarium :: 8
	                      oceanid :: 7
	                  oceanariums :: 7
	                       choana :: 7
	                       octane :: 7
	                       oceans :: 8
	                        ocean :: 9
	                    oceanaria :: 7
	                    oceanauts :: 9
                            }
matrix dev oceana com define compression dcs  {
	 disco :: 3
	 disci :: 3
	  scud :: 3
	  scad :: 3
	  docs :: 3
	  disc :: 4
	   dos :: 3
	   dis :: 3
	   das :: 3
     }
kodak  {
	whalery :: -1000
 }
dcs encoding define compression jbig iso jbig define compression sgilog  {
	   sigloi :: 7
	  giglots :: 7
	  soilage :: 7
	     soil :: 7
	  epilogs :: 7
        }
sgi log luminance  {
	luminance :: -1000
 }
rle define compression sgilog sgi log bit packed define compression jp leadtools  {
          }
jpeg define tifftag photometric  {
	photometric :: -1000
  }
photometric interpretation define photometric miniswhite min value is white define photometric minisblack min value is black define photometric rgb rgb color model define photometric palette color map indexed define photometric mask holdout  {
	                        holdout :: -1000
                              }
mask define photometric separated color separations define photometric ycbcr ccir define photometric cielab cie l a b define photometric icclab  {
	            acclaim :: 7
                  }
icc l a b adobe tiff technote  {
	pochette :: 10
	techno :: 10
	technetium :: 10
     }
define photometric itulab  {
	inula :: 7
 }
itu l a b define photometric logl cie log l define photometric logluv cie log l u v define tifftag threshholding  {
                   }
thresholding  {
	threshold :: 18
	threshing :: 15
	thresholds :: 16
 }
used on data define threshhold bilevel  {
	belive :: 9
	liveable :: 9
    }
b w art scan define threshhold halftone  {
	halftone :: -1000
     }
or dithered  {
	dithered :: -1000
 }
scan define threshhold errordiffuse  {
  }
usually floyd steinberg define tifftag cellwidth  {
    }
dithering matrix width define tifftag celllength  {
	challenge :: 12
    }
dithering matrix height define tifftag fillorder data order within a byte define fillorder msb lsb most significant least define fillorder lsb msb least significant most define tifftag documentname  {
	               documentable :: 15
                          }
name of doc image is from define tifftag imagedescription  {
       }
info about image define tifftag make scanner manufacturer name define tifftag model scanner model name number define tifftag stripoffsets  {
                 }
offsets to data strips define tifftag orientation image orientation define orientation topleft  {
	 toploftier :: 9
	   toplofty :: 9
          }
row top col lhs  {
	shul :: 3
	losh :: 4
	lash :: 4
	ohs :: 3
	los :: 3
	lis :: 3
	les :: 3
	las :: 3
	ehs :: 3
	ahs :: 3
	 sh :: 3
  }
define orientation topright  {
	outright :: 11
 }
row top col rhs  {
	shri :: 3
	rush :: 4
	rhus :: 4
	resh :: 4
	rehs :: 3
	rash :: 4
	rahs :: 3
	rushy :: 3
	rishi :: 3
	rheas :: 3
	rho :: 3
	res :: 3
	ras :: 3
	ohs :: 3
	ehs :: 3
	ahs :: 3
	 sh :: 3
  }
define orientation botright  {
	bedright :: 10
	outright :: 12
	outrightly :: 10
 }
row bottom col rhs define orientation botleft  {
	 botte :: 9
	bottle :: 9
     }
row bottom col lhs define orientation lefttop  {
	flattop :: 9
	leftmost :: 9
     }
row lhs col top define orientation righttop  {
	righto :: 10
	tightrope :: 12
	rightmost :: 11
	tightropes :: 11
     }
row rhs col top define orientation rightbot  {
	righto :: 10
	rightmost :: 11
	rightest :: 10
     }
row rhs col bottom define orientation leftbot  {
	leftmost :: 9
     }
row lhs col bottom define tifftag samplesperpixel  {
     }
samples per pixel define tifftag rowsperstrip  {
    }
rows per strip of data define tifftag stripbytecounts  {
      }
bytes counts for strips define tifftag minsamplevalue  {
     }
minimum sample value define tifftag maxsamplevalue  {
	mactation :: -1000
    }
maximum sample value define tifftag xresolution  {
	coevolutions :: 14
	prosecution :: 14
    }
pixels resolution in x define tifftag yresolution  {
	coevolutions :: 14
	prosecution :: 14
	coevolutionary :: 14
     }
pixels resolution in y define tifftag planarconfig  {
     }
storage organization define planarconfig contig single image plane define planarconfig separate separate planes of data define tifftag pagename  {
	         paginate :: 10
	         nametape :: 10
                }
page name image is from define tifftag xposition  {
	postilion :: 11
      }
x page offset of image lhs define tifftag yposition  {
	postilion :: 11
       }
y page offset of image lhs define tifftag freeoffsets  {
       }
byte offset to free block define tifftag freebytecounts  {
      }
sizes of free blocks define tifftag grayresponseunit  {
     }
gray scale curve accuracy define grayresponseunit s tenths  {
	 tenths :: -1000
      }
of a unit define grayresponseunit s hundredths  {
	hundredths :: -1000
     }
of a unit define grayresponseunit s thousandths  {
	thousandths :: -1000
     }
of a unit define grayresponseunit s ten thousandths of a unit define grayresponseunit s hundred thousandths define tifftag grayresponsecurve  {
                 }
gray scale response curve define tifftag group options flag bits define tifftag t options tiff proper name alias define group opt dencoding  {
	            precoding :: 11
	            conceding :: 13
	            seconding :: 12
	            dondering :: 12
	            beaconing :: 11
	            deaconing :: 13
	            defunding :: 11
                    }
x dimensional  {
	dimensional :: -1000
 }
coding define group opt uncompressed x data not compressed define group opt fillbits  {
	   fillister :: 10
	    billfish :: 10
           }
x fill to byte boundary define tifftag group options flag bits define tifftag t options tiff proper name define group opt uncompressed x data not compressed define tifftag resolutionunit  {
	               revolutionist :: 18
                           }
units of resolutions define resunit  {
	acrolith :: -1000
   }
none no meaningful units define resunit inch english define resunit centimeter  {
	centimeter :: -1000
         }
metric  {
	metric :: -1000
 }
define tifftag pagenumber  {
	wavenumber :: 14
 }
page numbers of multi page define tifftag colorresponseunit  {
      }
color curve accuracy define colorresponseunit s tenths of a unit define colorresponseunit s hundredths of a unit define colorresponseunit s thousandths of a unit define colorresponseunit s ten thousandths of a unit define colorresponseunit s hundred thousandths define tifftag transferfunction colorimetry info define tifftag software name release define tifftag datetime creation date and time define tifftag artist  {
	                                                  artist :: -1000
                                                       }
creator of image define tifftag hostcomputer  {
    }
machine where created define tifftag predictor  {
	predictor :: -1000
    }
prediction scheme w lzw define predictor none no prediction scheme used define predictor horizontal horizontal differencing define predictor floatingpoint  {
                 }
floating point predictor define tifftag whitepoint image white point define tifftag primarychromaticities  {
          }
primary chromaticities  {
	chromaticities :: -1000
 }
define tifftag colormap rgb map for pallette  {
	pallette :: -1000
     }
image define tifftag halftonehints  {
  }
highlight  {
	highlight :: -1000
 }
shadow info define tifftag tilewidth  {
	pasters :: -1000
   }
tile width in pixels define tifftag tilelength  {
     }
tile height in pixels define tifftag tileoffsets  {
     }
offsets to data tiles  {
	tiles :: -1000
  }
define tifftag tilebytecounts  {
 }
byte counts for tiles define tifftag badfaxlines  {
     }
lines w wrong pixel count define tifftag cleanfaxdata  {
	hackmatacks :: -1000
      }
regenerated  {
	regenerated :: -1000
 }
line info define cleanfaxdata clean no errors detected define cleanfaxdata regenerated receiver  {
	   receiver :: -1000
          }
regenerated lines define cleanfaxdata unclean  {
	unclean :: -1000
   }
uncorrected  {
	uncorrected :: -1000
 }
errors exist define tifftag consecutivebadfaxlines  {
   }
max consecutive bad lines define tifftag subifd subimage  {
	mucilages :: 10
	subimago :: 13
	subimagos :: 11
      }
descriptors define tifftag inkset  {
	invest :: 7
	instep :: 7
	insert :: 7
	insect :: 7
	inkles :: 8
	inkjet :: 9
	inkers :: 7
	inset :: 7
	inkle :: 7
	infest :: 7
	incest :: 7
	anklets :: 7
	reknits :: 7
	inkstone :: 7
	intakes :: 7
	inkpots :: 7
	inkless :: 7
	inkiest :: 8
  }
inks in separated image define inkset cmyk cyan  {
	   cyan :: -1000
      }
magenta  {
	magenta :: -1000
 }
yellow  {
	yellow :: -1000
 }
black color define inkset multiink  {
	multipion :: 10
   }
multi ink or hi fi color define tifftag inknames  {
	insnares :: 10
       }
ascii names of inks define tifftag numberofinks  {
     }
number of inks define tifftag dotrange  {
	estrangelo :: 10
	citrange :: 10
	dragonet :: 10
	estrange :: 10
	outrang :: 10
	astringed :: 10
	outranked :: 10
	outranged :: 13
	outranges :: 11
	estranged :: 11
	outrange :: 12
    }
and dot codes define tifftag targetprinter  {
    }
separation target define tifftag extrasamples  {
   }
info about extra samples define extrasample unspecified unspecified data define extrasample assocalpha associated alpha data define extrasample unassalpha  {
                }
unassociated  {
	unassociated :: -1000
 }
alpha data define tifftag sampleformat  {
   }
data sample format define sampleformat uint unsigned integer data define sampleformat int signed integer data define sampleformat ieeefp ieee floating point data define sampleformat void untyped data define sampleformat complexint  {
	                 complimented :: 12
	                complexations :: 13
	                     compleat :: 12
	                     compline :: 13
	                   compliment :: 14
	                   complexity :: 16
	                   complexest :: 13
	                   complexion :: 15
	                   complexing :: 17
	                   complexify :: 14
	                   completist :: 14
	                   completive :: 12
	                   completion :: 14
	                   completing :: 16
	                   complicant :: 12
	                  complecting :: 12
	                  compliments :: 13
	                 complexioned :: 12
	                 complexional :: 12
	                complexifying :: 12
	                    simpleton :: 12
	                    complines :: 12
	                    compliant :: 12
	                    complaint :: 12
	                   complacent :: 12
	                  complexions :: 14
	                  completists :: 13
	                  completions :: 13
	                      complex :: 14
	                      complin :: 12
	                   compelling :: 12
	                 complexities :: 12
	                   couplement :: 12
	                   complement :: 12
                            }
complex signed int define sampleformat complexieeefp  {
    }
complex ieee floating define tifftag sminsamplevalue  {
    }
variable minsamplevalue define tifftag smaxsamplevalue  {
   }
variable maxsamplevalue define tifftag clippath  {
	chappatis :: 10
	chappati :: 11
   }
clippath adobe tiff technote define tifftag xclippathunits  {
     }
xclippathunits adobe tiff technote define tifftag yclippathunits  {
     }
yclippathunits adobe tiff technote define tifftag indexed indexed adobe tiff technote define tifftag jpegtables  {
	    stageable :: 12
	   vegetables :: 12
            }
jpeg table stream define tifftag opiproxy  {
    }
opi proxy adobe tiff technote tags are obsoleted by technical note which specifies a revised  {
	       revised :: -1000
             }
jpeg in tiff scheme define tifftag jpegproc  {
     }
jpeg processing algorithm define jpegproc baseline baseline sequential define jpegproc lossless huffman coded  {
	  pegmatites :: -1000
           }
lossless define tifftag jpegifoffset  {
  }
pointer to soi marker define tifftag jpegifbytecount  {
     }
jfif stream length define tifftag jpegrestartinterval  {
    }
restart interval length define tifftag jpeglosslesspredictors  {
    }
lossless proc predictor define tifftag jpegpointtransform  {
    }
lossless point transform define tifftag jpegqtables  {
    }
q matrice  {
	matrice :: -1000
 }
offsets define tifftag jpegdctables  {
  }
dct table offsets define tifftag jpegactables  {
    }
ac coefficient offsets define tifftag ycbcrcoefficients  {
    }
rgb ycbcr transform define tifftag ycbcrsubsampling  {
    }
ycbcr subsampling factors define tifftag ycbcrpositioning  {
    }
subsample  {
	subsample :: -1000
 }
positioning  {
	positioning :: -1000
 }
define ycbcrposition centered  {
	centered :: -1000
 }
as in postscript level define ycbcrposition cosited as in ccir define tifftag referenceblackwhite  {
           }
colorimetry info define tifftag xmlpacket  {
   }
xml packet adobe xmp specification january define tifftag opiimageid  {
       }
opi imageid  {
	image :: 9
	imaged :: 10
	imagine :: 9
	imagined :: 10
 }
adobe tiff technote tags are private tags registered to island  {
	   island :: -1000
        }
graphics define tifftag refpts  {
	respot :: 7
	repots :: 8
	refits :: 9
	erupts :: 7
	reft :: 7
	refit :: 7
  }
image reference points define tifftag regiontackpoint  {
    }
region xform tack  {
	tack :: -1000
 }
point define tifftag regionwarpcorners  {
  }
warp  {
	warp :: -1000
 }
quadrilateral  {
	quadrilateral :: -1000
 }
define tifftag regionaffine  {
 }
affine  {
	affine :: -1000
 }
transformation mat tags are private tags registered to sgi define tifftag matteing  {
	   mantling :: 10
	   sauteing :: 10
	    matting :: 11
	   mutating :: 11
	  magnetist :: 10
	     mitten :: 10
	   matutine :: 11
	   battling :: 10
	   tattling :: 10
	   rattling :: 10
	   wattling :: 10
	   mattings :: 10
	     mattin :: 10
	   estating :: 10
	  mattering :: 12
	      matte :: 10
	   mottling :: 10
          }
use extrasamples define tifftag datatype use sampleformat define tifftag imagedepth  {
        }
z depth of image define tifftag tiledepth  {
     }
z depth data tile tags are private tags registered to pixar tifftag pixar imagefullwidth  {
            }
and tifftag pixar imagefulllength  {
  }
are set when an image has been cropped  {
	cropped :: -1000
      }
out of a larger image they reflect the size of the original uncropped  {
	   uncropped :: -1000
           }
image the tifftag xposition and tifftag yposition can be used to determine the position of the smaller image in the larger one define tifftag pixar imagefullwidth full image size in x define tifftag pixar imagefulllength full image size in y tags are used to identify special image modes and data used by pixar s texture  {
	                                               texture :: -1000
                                                     }
formats define tifftag pixar textureformat  {
   }
texture map format define tifftag pixar wrapmodes  {
	rhapsodes :: 11
	rhapsode :: 11
     }
s t wrap modes define tifftag pixar fovcot  {
      }
cotan  {
	cotan :: -1000
 }
fov for env maps define tifftag pixar matrix worldtoscreen  {
       }
define tifftag pixar matrix worldtocamera  {
   }
tag is a private tag registered to eastman  {
	eastland :: 10
	peatman :: 9
	meatman :: 9
	manteaus :: 9
	gateman :: 9
	camstane :: 9
	batsman :: 9
	baseman :: 10
      }
kodak define tifftag writerserialnumber  {
  }
device serial number tag is listed in the spec w unknown ownership define tifftag copyright copyright string iptc tag from richtiff  {
	            richting :: 10
                   }
specifications define tifftag richtiffiptc  {
  }
are reserved for ansi it tiff it dkelly apago com define tifftag it site site name define tifftag it colorsequence  {
	         depilation :: -1000
                  }
color seq rgb cmyk etc define tifftag it header ddes  {
	    deeds :: 5
	     odes :: 5
	     ides :: 5
        }
header define tifftag it rasterpadding  {
   }
raster scanline padding define tifftag it bitsperrunlength  {
     }
of bits in short run define tifftag it bitsperextendedrunlength  {
       }
of bits in long run define tifftag it colortable  {
	culturable :: 12
	colostral :: 13
	colorectal :: 12
	colorably :: 12
	colorable :: 14
	corollate :: 13
	colourable :: 16
	consolable :: 12
	collator :: 12
	collaborate :: 12
	collarbone :: 12
	collatable :: 12
       }
lw colortable define tifftag it imagecolorindicator  {
    }
bp bl image color switch define tifftag it bkgcolorindicator  {
       }
bp bl bg color switch define tifftag it imagecolorvalue  {
       }
bp bl image color value define tifftag it bkgcolorvalue  {
	draughtsmen :: -1000
       }
bp bl bg color value define tifftag it pixelintensityrange  {
       }
mp pixel intensity  {
	intensity :: -1000
 }
value define tifftag it transparencyindicator  {
   }
hc transparency switch define tifftag it colorcharacterization  {
     }
color character table define tifftag it hcusage  {
	scutage :: 10
	haulages :: 9
	scutages :: 9
     }
hc usage indicator define tifftag it trapindicator  {
     }
trapping  {
	trapping :: -1000
 }
indicator untrapped  {
	untrampled :: 12
	untapped :: 11
	uncropped :: 12
	unsnapped :: 11
	unpropped :: 12
	unpapered :: 11
	untread :: 11
	unstopped :: 11
	catnapped :: 11
	petnapped :: 11
	unpraised :: 11
	unstepped :: 11
	unstamped :: 11
	untraced :: 11
	untraded :: 11
	undrape :: 11
	enwrapped :: 12
	unwrapped :: 15
	inwrapped :: 12
	attrapped :: 12
	entrapped :: 15
	entrapper :: 11
	untracked :: 12
	untrained :: 11
 }
trapped  {
	trapped :: -1000
 }
define tifftag it cmykequivalent  {
  }
cmyk color equivalents  {
	equivalents :: -1000
 }
tags are private tags registered to texas  {
	 texas :: -1000
     }
instruments  {
	instruments :: -1000
 }
define tifftag framecount sequence frame count tag is private tag registered to adobe for photoshop define tifftag photoshop tags and are documented in exif  {
	                   exit :: 5
                      }
specification define tifftag exififd  {
  }
pointer to exif private directory tag is a private tag registered to adobe define tifftag iccprofile icc profile data tag is a private tag registered to pixel magic define tifftag jbigoptions  {
                             }
jbig options define tifftag gpsifd  {
   }
pointer to gps private directory tags are private tags registered to sgi define tifftag faxrecvparams  {
	      umbelled :: -1000
             }
encoded class ses parms define tifftag faxsubaddress  {
     }
received subaddr  {
	subadar :: 9
 }
string define tifftag faxrecvtime  {
  }
receive time secs define tifftag faxdcs  {
    }
encoded fax ses params table t tags are registered to sgi gregl  {
	   greylags :: 6
	      grego :: 7
	    gurgled :: 6
	    gurglet :: 6
	    gurgles :: 6
	     gargle :: 7
	    gargled :: 6
	    gargles :: 6
	    gargler :: 6
	     raggle :: 6
	     gurgle :: 7
	    greylag :: 7
	    gregale :: 6
	     gregos :: 6
	       gleg :: 7
	     glegly :: 6
          }
sgi com define tifftag stonits  {
	stonish :: 9
	stations :: 9
	stoits :: 9
	stints :: 9
	stoniest :: 12
   }
sample value to nits  {
	nits :: -1000
  }
tag is a private tag registered to fedex  {
	  feued :: 6
	  feted :: 6
	  desex :: 6
	   feed :: 6
      }
define tifftag fedex edr  {
	dub :: -1000
  }
unknown use define tifftag interoperabilityifd  {
	interoperabilities :: 27
	interoperability :: 29
   }
pointer to interoperability private directory adobe digital negative dng format tags define tifftag dngversion  {
	   ingression :: 13
	   degression :: 13
	   conversing :: 13
	   conversion :: 13
	    vignerons :: 12
            }
dng version number define tifftag dngbackwardversion  {
    }
dng compatibility version define tifftag uniquecameramodel  {
    }
name for the camera  {
	camera :: -1000
  }
model define tifftag localizedcameramodel  {
  }
localized camera model name define tifftag cfaplanecolor  {
     }
cfapattern  {
 }
linearraw  {
 }
space mapping define tifftag cfalayout  {
   }
spatial  {
	spatial :: -1000
 }
layout of the cfa define tifftag linearizationtable  {
     }
lookup table description define tifftag blacklevelrepeatdim  {
    }
repeat pattern size for the blacklevel tag define tifftag blacklevel zero light encoding level define tifftag blackleveldeltah  {
               }
zero light encoding level differences columns define tifftag blackleveldeltav  {
	flouncier :: -1000
       }
zero light encoding level differences rows define tifftag whitelevel  {
	     dot :: -1000
       }
fully saturated  {
	saturated :: -1000
 }
encoding level define tifftag defaultscale  {
   }
default scale factors define tifftag defaultcroporigin  {
    }
origin of the final image area define tifftag defaultcropsize  {
       }
size of the final image area define tifftag colormatrix  {
       }
xyz reference color space transformation matrix define tifftag colormatrix xyz reference color space transformation matrix define tifftag cameracalibration  {
                }
calibration  {
	calibration :: -1000
 }
matrix define tifftag cameracalibration calibration matrix define tifftag reductionmatrix  {
	reductionist :: 19
       }
dimensionality  {
	tarmacadam :: -1000
 }
reduction matrix define tifftag reductionmatrix dimensionality reduction matrix define tifftag analogbalance  {
         }
gain  {
	gain :: -1000
 }
applied the stored raw values define tifftag asshotneutral  {
      }
selected white balance  {
	syphilis :: -1000
 }
in linear reference space define tifftag asshotwhitexy  {
     }
selected white balance in x y chromaticity  {
	chromaticity :: -1000
     }
coordinates define tifftag baselineexposure  {
  }
how much to move the zero point define tifftag baselinenoise  {
        }
relative noise  {
	noise :: -1000
 }
level define tifftag baselinesharpness  {
  }
relative amount of sharpening  {
	sharpening :: -1000
  }
define tifftag bayergreensplit  {
 }
how closely the values of the green pixels in the blue green rows track the values of the green pixels in the red green rows define tifftag linearresponselimit  {
                          }
non linear encoding range define tifftag cameraserialnumber  {
	assagaied :: -1000
     }
camera s serial number define tifftag lensinfo  {
	lensing :: 11
     }
info about the lens define tifftag chromablurradius  {
     }
chroma blur  {
	blur :: -1000
 }
radius define tifftag antialiasstrength  {
  }
relative strength  {
	strength :: -1000
 }
of the camera s anti alias filter define tifftag shadowscale  {
        }
used by adobe camera raw define tifftag dngprivatedata  {
      }
manufacturer s private data define tifftag makernotesafety  {
     }
whether the exif makernote tag is safe to preserve along with the rest of the exif data define tifftag calibrationilluminant  {
                  }
illuminant define tifftag calibrationilluminant illuminant define tifftag bestqualityscale  {
      }
best quality multiplier define tifftag rawdatauniqueid  {
    }
unique identifier for the raw image data define tifftag originalrawfilename  {
        }
file name of the original raw file define tifftag originalrawfiledata  {
	proteinous :: -1000
        }
contents of the original raw file define tifftag activearea  {
       }
active non masked  {
	masked :: -1000
 }
pixels of the sensor  {
	sensor :: -1000
  }
define tifftag maskedareas  {
 }
list of coordinates of fully masked pixels define tifftag asshoticcprofile  {
        }
these two tags used to define tifftag asshotpreprofilematrix  {
      }
map cameras s color space into icc profile space define tifftag currenticcprofile  {
	     pidgin :: -1000
          }
define tifftag currentpreprofilematrix  {
 }
tag is an undefined tag used by eastman kodak define tifftag dcshueshiftvalues  {
          }
hue shift correction data the following are pseudo tags that can be used to control codec specific functionality these tags are not written to file note that these values start at xffff so that they ll never collide  {
	                              collide :: -1000
                                    }
with aldus assigned tags if you want your private pseudo tags registered i e added to this file please post a bug report via the tracking system at http www remotesensing org libtiff bugs html with the appropriate c definitions to add define tifftag faxmode  {
	                                      foamed :: 9
                                           }
group format control define faxmode classic  {
	classic :: -1000
    }
x default include rtc  {
	richt :: 3
	recut :: 3
	recto :: 3
	recti :: 3
	recta :: 3
	roc :: 3
	rec :: 3
  }
define faxmode nortc  {
	contr :: 7
	cortins :: 6
	cortin :: 7
	cornet :: 6
	contra :: 6
	tronc :: 6
	noticer :: 6
	toric :: 6
	torn :: 6
	torc :: 6
	noritic :: 6
	cort :: 7
	corn :: 6
	carton :: 6
	north :: 7
	norths :: 6
	nor :: 6
 }
x no rtc at end of data define faxmode noeol  {
	   colone :: 6
	     oleo :: 6
	     nolo :: 7
	     noel :: 6
	  moellon :: 6
	  noodled :: 6
	  noodles :: 6
	    nolos :: 6
	   noodle :: 7
	    nerol :: 6
        }
x no eol code at end of row define faxmode bytealign  {
	 betraying :: 11
         }
x byte align row define faxmode wordalign  {
	wording :: 11
	worldling :: 12
	worldlings :: 11
     }
x word align row define faxmode classf  {
	classmen :: 7
	classing :: 7
	classify :: 9
	classed :: 8
	classer :: 8
	classic :: 7
	clashes :: 7
	 glass :: 7
	classifier :: 7
	classified :: 7
	 crass :: 7
	 clays :: 7
	 claws :: 7
	 class :: 10
	 claps :: 7
	 clans :: 7
	 clams :: 7
	 claes :: 7
	 clads :: 7
	 calfs :: 7
	flasks :: 7
	crossfall :: 7
	crassly :: 7
	clasts :: 8
	classy :: 9
	clasps :: 8
     }
faxmode nortc tiff class f define tifftag jpegquality  {
      }
compression quality level note quality level is on the ijg scale default value is define tifftag jpegcolormode  {
               }
auto rgb ycbcr convert define jpegcolormode raw x no conversion default define jpegcolormode rgb x do auto conversion define tifftag jpegtablesmode  {
                   }
what to put in jpegtables define jpegtablesmode quant x include quantization tbls define jpegtablesmode huff x include huffman tbls note default is jpegtablesmode quant jpegtablesmode huff define tifftag faxfillfunc  {
                           }
g g fill function define tifftag pixarlogdatafmt  {
     }
pixarlogcodec  {
 }
i o data sz  {
	drouking :: -1000
  }
define pixarlogdatafmt bit regular u char samples define pixarlogdatafmt bitabgr  {
        }
abgr order u chars define pixarlogdatafmt bitlog  {
	giglot :: 7
	 bigot :: 7
	diglot :: 7
	biltongs :: 7
	biologist :: 7
	tiglon :: 7
	biology :: 8
	biltong :: 8
	  bito :: 7
     }
bit log encoded raw define pixarlogdatafmt bitpicio  {
	biotitic :: 10
     }
as per picio  {
	pionic :: 6
	pinion :: 6
	picine :: 6
	picolin :: 6
	piciform :: 6
 }
define pixarlogdatafmt bit signed short samples define pixarlogdatafmt float ieee float samples are allocated to oceana matrix dev oceana com define tifftag dcsimagertype  {
                     }
imager  {
	imager :: -1000
 }
model filter define dcsimagermodel  {
  }
m m chip  {
	chip :: -1000
 }
x define dcsimagermodel m m chip x define dcsimagermodel m m chip x define dcsimagerfilter  {
             }
ir infrared  {
	infrared :: -1000
 }
filter define dcsimagerfilter mono monochrome filter define dcsimagerfilter cfa color filter array define dcsimagerfilter other other filter define tifftag dcsinterpmode  {
                  }
interpolation mode define dcsinterpmode normal x whole image default define dcsinterpmode preview x preview of image x define tifftag dcsbalancearray  {
                  }
color balance values define tifftag dcscorrectmatrix  {
    }
color correction values define tifftag dcsgamma  {
    }
gamma value define tifftag dcstoeshoulderpts  {
   }
toe shoulder  {
	shoulder :: -1000
 }
points define tifftag dcscalibrationfd  {
  }
calibration file desc note quality level is on the zlib scale default value is define tifftag zipquality  {
	      nuptiality :: 12
	      inequality :: 13
               }
compression quality level define tifftag pixarlogquality  {
    }
pixarlog uses same scale is allocated to oceana matrix dev oceana com define tifftag dcscliprectangle  {
             }
area of image to acquire define tifftag sgilogdatafmt  {
      }
sgilog user data format define sgilogdatafmt float ieee float samples define sgilogdatafmt bit bit samples define sgilogdatafmt raw uninterpreted data define sgilogdatafmt bit bit rgb monitor values define tifftag sgilogencode  {
                            }
sgilog data encoding control define sgilogencode nodither  {
	endotherm :: 10
	ornithes :: 10
	endothermic :: 10
	dinothere :: 10
	norite :: 10
     }
do not dither encoded values define sgilogencode randither  {
	randier :: 12
	tarnishers :: 11
	tarnisher :: 12
	tarnished :: 11
	hardliner :: 11
      }
randomly  {
	randomly :: -1000
 }
dither encd  {
	end :: 5
 }
values exif tags define exiftag  {
	driftage :: 9
   }
exposuretime  {
 }
exposure time define exiftag fnumber  {
   }
f number define exiftag exposureprogram  {
   }
exposure program define exiftag spectralsensitivity  {
	glitzily :: -1000
   }
spectral sensitivity  {
	sensitivity :: -1000
 }
define exiftag isospeedratings  {
 }
iso speed rating  {
	rating :: -1000
 }
define exiftag oecf  {
 }
optoelectric  {
	optoelectronic :: 18
	optoelectronics :: 17
 }
conversion factor define exiftag exifversion  {
   }
exif version define exiftag datetimeoriginal  {
   }
date and time of original data generation define exiftag datetimedigitized  {
        }
date and time of digital data generation define exiftag componentsconfiguration  {
        }
meaning of each component define exiftag compressedbitsperpixel  {
     }
image compression mode define exiftag shutterspeedvalue  {
    }
shutter speed define exiftag aperturevalue  {
   }
aperture define exiftag brightnessvalue  {
	brightness :: 19
  }
brightness define exiftag exposurebiasvalue  {
  }
exposure bias define exiftag maxaperturevalue  {
   }
maximum lens aperture define exiftag subjectdistance  {
    }
subject distance define exiftag meteringmode  {
   }
metering mode define exiftag lightsource  {
	lighthouse :: 14
	righteously :: 15
	lightsome :: 14
	righteous :: 15
   }
light source define exiftag flash  {
	flash :: -1000
   }
flash define exiftag focallength  {
  }
lens focal length define exiftag subjectarea  {
	subjective :: 14
	subjected :: 14
    }
subject area define exiftag makernote manufacturer notes define exiftag usercomment  {
        }
user comments define exiftag subsectime  {
	subjective :: 13
	subsect :: 13
	subjectivise :: 12
	subsecive :: 13
	susceptible :: 12
	susceptive :: 12
	subsection :: 13
	summertimes :: 12
	suppertimes :: 12
	subjectives :: 15
   }
datetime subseconds  {
	subsections :: 13
	subsidences :: 12
	subsects :: 12
	subdecisions :: 13
	subdeacons :: 12
	subsectors :: 13
 }
define exiftag subsectimeoriginal  {
 }
datetimeoriginal subseconds define exiftag subsectimedigitized  {
   }
datetimedigitized subseconds define exiftag flashpixversion  {
   }
supported flashpix version define exiftag colorspace color space information define exiftag pixelxdimension  {
          }
valid image width define exiftag pixelydimension  {
    }
valid image height define exiftag relatedsoundfile  {
    }
related audio  {
	audio :: -1000
 }
file define exiftag flashenergy  {
  }
flash energy  {
	energy :: -1000
 }
define exiftag spatialfrequencyresponse  {
 }
spatial frequency response define exiftag focalplanexresolution  {
    }
focal plane x resolution define exiftag focalplaneyresolution  {
     }
focal plane y resolution define exiftag focalplaneresolutionunit  {
     }
focal plane resolution unit define exiftag subjectlocation  {
     }
subject location define exiftag exposureindex  {
   }
exposure index define exiftag sensingmethod  {
   }
sensing method define exiftag filesource  {
	telecourse :: 12
	forecourse :: 12
	firehouse :: 12
	ciseleur :: 12
   }
file source define exiftag scenetype  {
	stenotype :: 11
   }
scene type define exiftag cfapattern cfa pattern define exiftag customrendered  {
        }
custom image processing define exiftag exposuremode  {
    }
exposure mode define exiftag whitebalance  {
   }
white balance define exiftag digitalzoomratio  {
   }
digital zoom  {
	zoom :: -1000
 }
ratio define exiftag focallengthin  {
  }
mmfilm  {
 }
focal length in mm film  {
	scurf :: -1000
   }
define exiftag scenecapturetype  {
 }
scene capture type define exiftag gaincontrol  {
	effervescently :: -1000
    }
gain control define exiftag contrast contrast define exiftag saturation saturation define exiftag sharpness  {
	   sharpness :: -1000
           }
sharpness define exiftag devicesettingdescription  {
  }
device settings description define exiftag subjectdistancerange  {
    }
subject distance range define exiftag gaincontrol gain control define exiftag gaincontrol gain control define exiftag imageuniqueid  {
              }
unique image id endif tiff vim  {
	  vim :: -1000
    }
set ts sts  {
	styes :: 3
	studs :: 3
	stubs :: 3
	stows :: 3
	stops :: 3
	stobs :: 3
	stoas :: 3
	stirs :: 3
	sties :: 3
	stews :: 3
	steps :: 3
	stens :: 3
	stems :: 3
	steds :: 3
	stays :: 3
	staws :: 3
	stash :: 3
	stars :: 3
	staps :: 3
	stags :: 3
	stabs :: 3
	sits :: 3
	sist :: 4
	sets :: 3
	psst :: 3
	uts :: 3
	sos :: 3
	sis :: 3
	ses :: 3
	its :: 3
	ats :: 3
	st :: 3
 }
sw noet  {
	suspensefully :: -1000
 }
local variables mode c c basic offset fill column end id tiffio  {
	    toffish :: 7
	    toffies :: 7
	   tiffings :: 7
	   tiffined :: 7
	    tiffing :: 8
	    tiffins :: 8
	     tiffin :: 9
	       toff :: 7
	       tiff :: 7
	     soffit :: 7
          }
h v bfriesen exp copyright c sam leffler copyright c silicon graphics inc permission to use copy modify distribute and sell this software and its documentation for any purpose is hereby granted without fee provided that i the above copyright notices and this permission notice appear in all copies of the software and related documentation and ii the names of sam leffler and silicon graphics may not be used in any advertising or publicity relating to the software without the specific prior written permission of sam leffler and silicon graphics the software is provided as is and without warranty of any kind express implied or otherwise including without limitation any warranty of merchantability or fitness for a particular purpose in no event shall sam leffler or silicon graphics be liable for any special incidental indirect or consequential damages of any kind or any damages whatsoever resulting from loss of use data or profits whether or not advised of the possibility of damage and on any theory of liability arising out of or in connection with the use or performance of this software ifndef tiffio define tiffio tiff i o library definitions include tiff h include tiffvers  {
	                                                                                                                                                                                           pifflers :: 10
	                                                                                                                                                                                           rifflers :: 10
                                                                                                                                                                                                  }
h tiff is defined as an incomplete type to hide the library s internal data structures from clients typedef struct tiff tiff the following typedefs define the intrinsic size of data types used in the exported interfaces these definitions depend on the proper definition of types in tiff h note also that the varargs  {
	                                             vagarish :: 9
                                                    }
interface used to pass tag types and values uses the types defined in tiff h directly nb ttag  {
	             stag :: 5
                }
t is unsigned int and not unsigned short because ansi c requires that the type before the ellipsis  {
	         ellipsis :: -1000
                }
be a promoted type i e one of int unsigned int pointer or double and because we defined pseudo tags that are outside the range of legal aldus assigned tags nb tsize t is int and not uint because some functions return nb toff  {
	                                       toff :: -1000
                                          }
t is not off t for many reasons tiffs  {
	   tiffs :: -1000
       }
max out at bit file offsets being the most important and to ensure that it is unsigned rather than signed typedef uint ttag t directory tag typedef uint tdir t directory index typedef uint tsample  {
	                          tramples :: 12
	                          trampler :: 10
	                          trampled :: 10
	                           stemple :: 9
	                         tramplers :: 11
	                         stampless :: 10
	                           trample :: 11
	                           tramels :: 9
	                          whamples :: 9
	                          examples :: 9
                                 }
t sample number typedef uint tstrile  {
	titlers :: 9
	nitriles :: 9
	estriol :: 9
	titres :: 9
	sterile :: 9
	tortile :: 9
	tetryls :: 9
    }
t strip or tile number typedef tstrile t tstrip  {
	 tropist :: 7
	  titres :: 7
	  esprit :: 7
	  sitrep :: 7
       }
t strip number typedef tstrile t ttile  {
	titlers :: 6
	toilet :: 8
	stilets :: 6
	titles :: 7
	titler :: 7
	titled :: 7
	tilter :: 6
	tilted :: 6
	twilted :: 6
	tritely :: 6
	stilet :: 7
	stiles :: 6
	stiled :: 6
	 utile :: 7
	 twite :: 6
	 twilt :: 6
	 trite :: 6
	 toile :: 6
	 title :: 8
	 thite :: 6
	 stile :: 7
	  teil :: 6
	toiletry :: 6
	toilets :: 7
     }
t tile number typedef int tsize t i o size in bytes typedef void tdata  {
	         adyta :: 6
             }
t image data ref typedef uint toff t file offset if defined win defined win defined win define win endif on windows you should define use win fileio  {
	                    filemot :: 7
	                      folie :: 7
	                     folkie :: 7
	                   filioque :: 7
	                       file :: 7
	                      pilei :: 7
	                    filmier :: 7
                          }
if you are using tif win c or avoid win fileio if you are using something else like tif unix c by default tif unix c is assumed if defined windows defined win defined windows if defined cygwin defined avoid win fileio defined use win fileio define avoid win fileio endif endif if defined use win fileio define vc extralean  {
	                                                 extralegal :: 12
	                                                   external :: 11
	                                                    exarate :: 11
                                                          }
include windows h ifdef win declare handle thandle  {
	thanked :: 9
	thankless :: 9
	chandlery :: 9
	chandlers :: 9
	twangled :: 9
	 thenal :: 10
	  thane :: 9
	chandler :: 10
      }
t win file handle else typedef hfile  {
	 heils :: 6
	 chile :: 6
	 while :: 6
	heiled :: 6
	hailer :: 6
	hailed :: 6
     }
thandle t client data handle endif win else typedef void thandle t client data handle endif use win fileio flags to pass to tiffprintdirectory  {
                      }
to control printing of data structures that are potentially very large bit or these flags to enable printing multiple items define tiffprint none x no extra info define tiffprint strips x strips tiles info define tiffprint curves x color gray response curves define tiffprint colormap x colormap define tiffprint jpegqtables x jpeg q matrices  {
	                                             matrices :: -1000
                                                    }
define tiffprint jpegactables x jpeg ac tables define tiffprint jpegdctables x jpeg dc tables colour  {
	        colour :: -1000
             }
conversion stuff reference white define d x f define d y f define d z f define d x f define d y f define d z f structure for holding information about a display device typedef unsigned char tiffrgbvalue  {
                                      }
bit samples typedef struct float d mat xyz luminance matrix float d ycr  {
	        scry :: 4
	       scray :: 3
	        cory :: 3
	         yar :: 3
           }
light o p for reference white float d ycg  {
	   yogic :: 3
	    cagy :: 3
	     yug :: 3
       }
float d ycb uint d vrwr  {
    }
pixel values for ref white uint d vrwg  {
      }
uint d vrwb  {
 }
float d y r residual light for black pixel float d y g float d y b float d gammar  {
	              gumma :: 7
	              grama :: 8
	              gemma :: 7
	              gamma :: 10
	             gammer :: 8
	             gammas :: 9
	             dammar :: 9
	            mammary :: 8
	            gammers :: 7
	             ragman :: 7
	            dammars :: 8
	            tammars :: 8
	             malmag :: 7
	             magmas :: 7
	             tammar :: 9
	             gramas :: 7
	            gramary :: 7
	              mamma :: 7
	              magma :: 8
                  }
gamma values for the three guns  {
	 hens :: -1000
    }
float d gammag  {
	gamma :: 9
	gammas :: 8
	gagman :: 8
	malmags :: 7
	malmag :: 8
	magmas :: 7
	mamma :: 7
	magma :: 8
 }
float d gammab  {
	gumma :: 7
	gemma :: 7
	gamma :: 10
	gamba :: 8
	gammas :: 9
	gambas :: 7
	bagman :: 7
	malmag :: 7
	magmas :: 7
	mamma :: 7
	mamba :: 7
	magma :: 8
 }
tiffdisplay  {
 }
typedef struct ycbcr rgb support tiffrgbvalue clamptab  {
     }
range clamping table int cr r tab int cb b tab int cr g tab int cb g tab int y tab tiffycbcrtorgb  {
                     }
typedef struct cie lab rgb support int range size of conversion table define cielabtorgb  {
	     sodomise :: -1000
            }
table range float rstep  {
	estop :: 6
	ester :: 6
	retypes :: 6
	retapes :: 6
	aster :: 6
	peters :: 6
	ripest :: 6
	paters :: 6
	recepts :: 6
	streps :: 6
	strep :: 7
	rets :: 6
	rotes :: 6
	rites :: 6
	retes :: 6
	rates :: 6
  }
gstep  {
	gytes :: 6
	getups :: 7
	gites :: 6
	getup :: 6
	gates :: 6
	estop :: 6
	gets :: 6
 }
bstep  {
	estop :: 6
	bites :: 6
	betes :: 6
	bates :: 6
	bets :: 6
 }
float x y z reference white point tiffdisplay display float yr r cielabtorgb table range conversion of yr to r float yg  {
	                 ygoe :: 2
	                  yug :: 2
	                  ygo :: 3
                    }
g cielabtorgb table range conversion of yg to g float yb b cielabtorgb table range conversion of yb to b tiffcielabtorgb  {
                   }
rgba style image support typedef struct tiffrgbaimage  {
     }
tiffrgbaimage the image reading and conversion routines invoke put routines to copy image whatever tiles of raw image data a default set of routines are provided to convert copy raw image data to bit packed abgr format rasters  {
	                              rasters :: -1000
                                    }
applications can supply alternate routines that unpack the data into a different format or for example unpack the data and draw the unpacked  {
	              unpacked :: -1000
                     }
raster on the display typedef void tilecontigroutine  {
     }
tiffrgbaimage uint uint uint uint uint int int unsigned char typedef void tileseparateroutine  {
           }
tiffrgbaimage uint uint uint uint uint int int unsigned char unsigned char unsigned char unsigned char rgba reader state struct tiffrgbaimage tiff tif image handle int stoponerr  {
	                  propones :: 11
	                  stopover :: 12
                         }
stop on read error int iscontig  {
	escorting :: 10
	escoting :: 10
	incognitas :: 10
    }
data is packed separate int alpha type of alpha data present uint width image width uint height image height uint bitspersample image bits sample uint samplesperpixel image samples pixel uint orientation image orientation uint req orientation requested orientation uint photometric image photometric interp uint redcmap  {
	                                      redcap :: 10
	                                     redcaps :: 9
                                           }
colormap pallete  {
	platelet :: 9
	palleted :: 13
	pallette :: 11
	galleted :: 10
	pallescent :: 9
	palletizes :: 10
	palletizer :: 10
	palletized :: 10
	palletiser :: 10
	palletised :: 10
	pellet :: 10
	pelleted :: 10
	pallets :: 10
	palette :: 9
	pallet :: 11
	prelate :: 9
	fellate :: 9
	palletizers :: 9
	palletize :: 11
	palletise :: 11
	pallettes :: 10
	pellets :: 9
 }
uint greencmap  {
 }
uint bluecmap  {
	bluesman :: 10
	bluecoat :: 10
	bluecaps :: 11
	bluecap :: 12
 }
get image data routine int get tiffrgbaimage uint uint uint put decoded strip tile union void any tiffrgbaimage tilecontigroutine contig tileseparateroutine separate put tiffrgbvalue map sample mapping array uint bwmap  {
                            }
black white map uint palmap  {
	halma :: 7
	paspalum :: 7
	palampore :: 7
	palpate :: 7
	palmary :: 7
	palmate :: 7
	pampas :: 7
	palpal :: 7
	palmar :: 8
	talma :: 7
	papal :: 7
	pampa :: 8
   }
palette image map tiffycbcrtorgb ycbcr ycbcr conversion state tiffcielabtorgb cielab cie l a b conversion state int row offset int col offset macros for extracting  {
	              extracting :: -1000
                       }
components from the packed abgr form returned by tiffreadrgbaimage  {
       }
define tiffgetr  {
 }
abgr abgr xff define tiffgetg  {
	neurosporas :: -1000
   }
abgr abgr xff define tiffgetb  {
   }
abgr abgr xff define tiffgeta  {
   }
abgr abgr xff a codec is a software package that implements  {
	implements :: -1000
         }
decoding encoding or decoding encoding of a compression algorithm the library provides a collection of builtin codecs  {
	          codecs :: -1000
               }
more codecs may be registered through calls to the library and or the builtin implementations may be overridden typedef int tiffinitmethod  {
                   }
tiff int typedef struct char name uint scheme tiffinitmethod init tiffcodec  {
         }
include stdio h include stdarg h share internal logluv conversion routines ifndef logluv public define logluv public endif if defined gnuc defined attribute define attribute x nothing endif if defined c plusplus defined cplusplus extern c endif typedef void tifferrorhandler  {
                                      }
const char const char va list typedef void tifferrorhandlerext  {
	glumnesses :: -1000
       }
thandle t const char const char va list typedef tsize t tiffreadwriteproc  {
          }
thandle t tdata t tsize t typedef toff t tiffseekproc  {
        }
thandle t toff t int typedef int tiffcloseproc  {
      }
thandle t typedef toff t tiffsizeproc  {
    }
thandle t typedef int tiffmapfileproc  {
   }
thandle t tdata t toff t typedef void tiffunmapfileproc  {
       }
thandle t tdata t toff t typedef void tiffextendproc  {
       }
tiff extern const char tiffgetversion  {
   }
void extern const tiffcodec tifffindcodec  {
   }
uint extern tiffcodec tiffregistercodec  {
  }
uint const char tiffinitmethod extern void tiffunregistercodec  {
     }
tiffcodec extern int tiffiscodecconfigured  {
  }
uint extern tiffcodec tiffgetconfiguredcodecs  {
  }
void auxiliary functions extern tdata t tiffmalloc  {
     }
tsize t extern tdata t tiffrealloc  {
    }
tdata t tsize t extern void tiffmemset  {
     }
tdata t int tsize t extern void tiffmemcpy  {
      }
tdata t const tdata t tsize t extern int tiffmemcmp  {
        }
const tdata t const tdata t tsize t extern void tifffree  {
	strictnesses :: -1000
         }
tdata t stuff related to tag handling and creating custom tags extern int tiffgettaglistcount  {
            }
tiff extern ttag t tiffgettaglistentry  {
   }
tiff int tag index define tiff any tiff notype for field descriptor searching define tiff variable marker for variable length tags define tiff spp  {
	                   pups :: 3
	                   pops :: 3
	                   pips :: 3
	                   paps :: 3
	                  oppos :: 3
	                    sup :: 3
	                    sop :: 3
	                    sip :: 3
	                    sap :: 3
                      }
marker for samplesperpixel tags define tiff variable marker for uint var length tags define field custom typedef struct ttag t field tag field s tag short field readcount  {
	                unaccounted :: 11
	                  reductant :: 12
	                    readout :: 11
	                  headcount :: 15
	                 reductants :: 11
                          }
read count tiff variable tiff spp short field writecount  {
	intercounty :: 12
       }
write count tiff variable tiffdatatype field type type of associated data unsigned short field bit bit in fieldsset  {
	          tieless :: 12
	        fieldsmen :: 11
	         fielders :: 11
	       fieldstone :: 11
                }
bit vector unsigned char field oktochange  {
    }
if true can change while writing unsigned char field passcount  {
	  passout :: 11
	cashpoints :: 11
        }
if true pass dir count on set char field name ascii name tifffieldinfo  {
           }
typedef struct tifftagvalue  {
	huzzaing :: -1000
 }
const tifffieldinfo info int count void value tifftagvalue extern void tiffmergefieldinfo  {
         }
tiff const tifffieldinfo int extern const tifffieldinfo tifffindfieldinfo  {
      }
tiff ttag t tiffdatatype extern const tifffieldinfo tifffindfieldinfobyname  {
      }
tiff const char tiffdatatype extern const tifffieldinfo tifffieldwithtag  {
      }
tiff ttag t extern const tifffieldinfo tifffieldwithname  {
     }
tiff const char typedef int tiffvsetmethod  {
    }
tiff ttag t va list typedef int tiffvgetmethod  {
      }
tiff ttag t va list typedef void tiffprintmethod  {
      }
tiff file long typedef struct tiffvsetmethod vsetfield  {
     }
tag set routine tiffvgetmethod vgetfield  {
   }
tag get routine tiffprintmethod printdir  {
   }
directory print routine tifftagmethods  {
  }
extern tifftagmethods tiffaccesstagmethods  {
 }
tiff extern void tiffgetclientinfo  {
  }
tiff const char extern void tiffsetclientinfo  {
    }
tiff void const char extern void tiffcleanup  {
     }
tiff extern void tiffclose tiff extern int tiffflush  {
      }
tiff extern int tiffflushdata  {
  }
tiff extern int tiffgetfield  {
  }
tiff ttag t extern int tiffvgetfield  {
    }
tiff ttag t va list extern int tiffgetfielddefaulted  {
      }
tiff ttag t extern int tiffvgetfielddefaulted  {
    }
tiff ttag t va list extern int tiffreaddirectory  {
      }
tiff extern int tiffreadcustomdirectory  {
  }
tiff toff t const tifffieldinfo size t extern int tiffreadexifdirectory  {
        }
tiff toff t extern tsize t tiffscanlinesize  {
     }
tiff extern tsize t tiffoldscanlinesize  {
   }
tiff extern tsize t tiffnewscanlinesize  {
   }
tiff extern tsize t tiffrasterscanlinesize  {
   }
tiff extern tsize t tiffstripsize  {
   }
tiff extern tsize t tiffrawstripsize  {
	monography :: -1000
   }
tiff tstrip t extern tsize t tiffvstripsize  {
     }
tiff uint extern tsize t tifftilerowsize  {
    }
tiff extern tsize t tifftilesize  {
   }
tiff extern tsize t tiffvtilesize  {
   }
tiff uint extern uint tiffdefaultstripsize  {
   }
tiff uint extern void tiffdefaulttilesize  {
   }
tiff uint uint extern int tifffileno  {
    }
tiff extern int tiffsetfileno  {
  }
tiff int extern thandle t tiffclientdata  {
    }
tiff extern thandle t tiffsetclientdata  {
   }
tiff thandle t extern int tiffgetmode  {
    }
tiff extern int tiffsetmode  {
  }
tiff int extern int tiffistiled  {
   }
tiff extern int tiffisbyteswapped  {
  }
tiff extern int tiffisupsampled  {
  }
tiff extern int tiffismsb  {
  }
lsb tiff extern int tiffisbigendian  {
   }
tiff extern tiffreadwriteproc tiffgetreadproc  {
  }
tiff extern tiffreadwriteproc tiffgetwriteproc  {
  }
tiff extern tiffseekproc tiffgetseekproc  {
  }
tiff extern tiffcloseproc tiffgetcloseproc  {
  }
tiff extern tiffsizeproc tiffgetsizeproc  {
  }
tiff extern tiffmapfileproc tiffgetmapfileproc  {
	needlework :: -1000
  }
tiff extern tiffunmapfileproc tiffgetunmapfileproc  {
  }
tiff extern uint tiffcurrentrow  {
  }
tiff extern tdir t tiffcurrentdirectory  {
	straitnesses :: -1000
   }
tiff extern tdir t tiffnumberofdirectories  {
   }
tiff extern uint tiffcurrentdiroffset  {
  }
tiff extern tstrip t tiffcurrentstrip  {
   }
tiff extern ttile t tiffcurrenttile  {
   }
tiff extern int tiffreadbuffersetup  {
  }
tiff tdata t tsize t extern int tiffwritebuffersetup  {
      }
tiff tdata t tsize t extern int tiffsetupstrips  {
      }
tiff extern int tiffwritecheck  {
  }
tiff int const char extern void tifffreedirectory  {
     }
tiff extern int tiffcreatedirectory  {
  }
tiff extern int tifflastdirectory  {
  }
tiff extern int tiffsetdirectory  {
	butylates :: -1000
  }
tiff tdir t extern int tiffsetsubdirectory  {
    }
tiff uint extern int tiffunlinkdirectory  {
   }
tiff tdir t extern int tiffsetfield  {
    }
tiff ttag t extern int tiffvsetfield  {
    }
tiff ttag t va list extern int tiffwritedirectory  {
      }
tiff extern int tiffcheckpointdirectory  {
  }
tiff extern int tiffrewritedirectory  {
  }
tiff extern int tiffreassigntagtoignore enum tiffignoresense int if defined c plusplus defined cplusplus extern void tiffprintdirectory tiff file long extern int tiffreadscanline  {
                    }
tiff tdata t uint tsample t extern int tiffwritescanline  {
	 skookum :: -1000
       }
tiff tdata t uint tsample t extern int tiffreadrgbaimage tiff uint uint uint int extern int tiffreadrgbaimageoriented  {
               }
tiff uint uint uint int orientation botleft int else extern void tiffprintdirectory tiff file long extern int tiffreadscanline tiff tdata t uint tsample t extern int tiffwritescanline tiff tdata t uint tsample t extern int tiffreadrgbaimage tiff uint uint uint int extern int tiffreadrgbaimageoriented tiff uint uint uint int int endif extern int tiffreadrgbastrip  {
                                                    }
tiff tstrip t uint extern int tiffreadrgbatile  {
     }
tiff uint uint uint extern int tiffrgbaimageok  {
	nonlanguages :: -1000
     }
tiff char extern int tiffrgbaimagebegin  {
   }
tiffrgbaimage tiff int char extern int tiffrgbaimageget  {
     }
tiffrgbaimage uint uint uint extern void tiffrgbaimageend  {
     }
tiffrgbaimage extern tiff tiffopen  {
  }
const char const char ifdef win extern tiff tiffopenw  {
       }
const wchar t const char endif win extern tiff tifffdopen  {
        }
int const char const char extern tiff tiffclientopen  {
      }
const char const char thandle t tiffreadwriteproc tiffreadwriteproc tiffseekproc tiffcloseproc tiffsizeproc tiffmapfileproc tiffunmapfileproc extern const char tifffilename  {
               }
tiff extern const char tiffsetfilename  {
	mislippen :: -1000
   }
tiff const char extern void tifferror const char const char attribute format printf extern void tifferrorext  {
              }
thandle t const char const char attribute format printf extern void tiffwarning  {
	diffracting :: 14
          }
const char const char attribute format printf extern void tiffwarningext  {
        }
thandle t const char const char attribute format printf extern tifferrorhandler tiffseterrorhandler  {
	  fiberless :: -1000
          }
tifferrorhandler extern tifferrorhandlerext tiffseterrorhandlerext  {
	beautifuler :: -1000
  }
tifferrorhandlerext extern tifferrorhandler tiffsetwarninghandler  {
  }
tifferrorhandler extern tifferrorhandlerext tiffsetwarninghandlerext  {
  }
tifferrorhandlerext extern tiffextendproc tiffsettagextender  {
  }
tiffextendproc extern ttile t tiffcomputetile  {
	smatched :: -1000
   }
tiff uint uint uint tsample t extern int tiffchecktile  {
       }
tiff uint uint uint tsample t extern ttile t tiffnumberoftiles  {
        }
tiff extern tsize t tiffreadtile  {
	differential :: 15
   }
tiff tdata t uint uint uint tsample t extern tsize t tiffwritetile  {
          }
tiff tdata t uint uint uint tsample t extern tstrip t tiffcomputestrip  {
	     secesh :: -1000
          }
tiff uint tsample t extern tstrip t tiffnumberofstrips  {
      }
tiff extern tsize t tiffreadencodedstrip  {
   }
tiff tstrip t tdata t tsize t extern tsize t tiffreadrawstrip  {
         }
tiff tstrip t tdata t tsize t extern tsize t tiffreadencodedtile  {
         }
tiff ttile t tdata t tsize t extern tsize t tiffreadrawtile  {
         }
tiff ttile t tdata t tsize t extern tsize t tiffwriteencodedstrip  {
	suggestive :: -1000
         }
tiff tstrip t tdata t tsize t extern tsize t tiffwriterawstrip  {
         }
tiff tstrip t tdata t tsize t extern tsize t tiffwriteencodedtile  {
	avuncularities :: -1000
         }
tiff ttile t tdata t tsize t extern tsize t tiffwriterawtile  {
         }
tiff ttile t tdata t tsize t extern int tiffdatawidth  {
        }
tiffdatatype table of tag datatype widths extern void tiffsetwriteoffset  {
       }
tiff toff t extern void tiffswabshort  {
    }
uint extern void tiffswablong  {
  }
uint extern void tiffswabdouble  {
  }
double extern void tiffswabarrayofshort  {
  }
uint unsigned long extern void tiffswabarrayoftriples  {
    }
uint unsigned long extern void tiffswabarrayoflong  {
    }
uint unsigned long extern void tiffswabarrayofdouble  {
    }
double unsigned long extern void tiffreversebits  {
    }
unsigned char unsigned long extern const unsigned char tiffgetbitrevtable  {
       }
int ifdef logluv public define u neu  {
	neural :: 3
	  nuke :: 3
	  nude :: 3
	  neum :: 5
	  neuk :: 5
	  menu :: 3
	  genu :: 3
	 noule :: 3
	 nexus :: 3
	 nevus :: 3
	 neurs :: 4
	 neums :: 4
	 neume :: 3
	 neuks :: 4
	 negus :: 3
	 meuni :: 3
	   new :: 3
	   net :: 3
	   nep :: 3
	   nek :: 3
	   nef :: 3
	   ned :: 3
	   neb :: 3
	   meu :: 3
	   leu :: 3
	   jeu :: 3
	   feu :: 3
	    ne :: 4
     }
define v neu define uvscale  {
	upscaled :: 10
	upscales :: 9
	unscale :: 11
	unscaled :: 10
	unscales :: 9
	upscale :: 11
	bascule :: 9
   }
extern double logl toy int extern double logl toy int extern void xyztorgb  {
           }
float uint extern int uv decode double double int extern void logluv toxyz  {
           }
uint float extern void logluv toxyz uint float if defined c plusplus defined cplusplus extern int logl fromy  {
	            frowy :: 7
	            frory :: 6
	            foamy :: 6
	            flory :: 6
	         fromenty :: 6
	           formyl :: 7
	          formyls :: 6
	             from :: 8
	             form :: 6
	            roomy :: 6
	              fro :: 6
                }
double int sgilogencode nodither extern int logl fromy double int sgilogencode nodither extern int uv encode double double int sgilogencode nodither extern uint logluv fromxyz  {
                       }
float int sgilogencode nodither extern uint logluv fromxyz float int sgilogencode nodither else extern int logl fromy double int extern int logl fromy double int extern int uv encode double double int extern uint logluv fromxyz float int extern uint logluv fromxyz float int endif endif logluv public extern int tiffcielabtorgbinit  {
                                                 }
tiffcielabtorgb tiffdisplay float extern void tiffcielabtoxyz  {
    }
tiffcielabtorgb uint int int float float float extern void tiffxyztorgb  {
        }
tiffcielabtorgb float float float uint uint uint extern int tiffycbcrtorgbinit  {
        }
tiffycbcrtorgb float float extern void tiffycbcrtorgb tiffycbcrtorgb uint int int uint uint uint if defined c plusplus defined cplusplus endif endif tiffio vim set ts sts sw noet local variables mode c c basic offset fill column end define tifflib  {
                                      }
version str libtiff version ncopyright  {
	trophying :: 12
   }
c sam leffler ncopyright c silicon graphics inc this define can be used in code that requires compilation related definitions specific to a version or versions of the library runtime version checking should be done based on the string returned by tiffgetversion define tifflib version copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa iso c standard date and time time h ifndef time h if defined need time t defined need clock t defined need timespec define time h include features h begin decls endif ifdef time h get size t and null from stddef h define need size t define need null include stddef h this defines clocks  {
	                                                                                                                                                                                                                                    clocks :: -1000
                                                                                                                                                                                                                                         }
per sec which is the number of processor clock ticks per second include bits time h this is the obsolete posix name for the same constant if defined strict ansi defined use xopen k ifndef clk tck  {
	                                tuck :: 3
	                                tock :: 3
	                                tick :: 3
	                                tack :: 3
	                                 tsk :: 3
	                                 ick :: 3
                                   }
define clk tck clocks per sec endif endif endif time h included if defined clock t defined defined time h defined need clock t define clock t defined include bits types h begin namespace std returned by clock typedef clock t clock t end namespace std if defined use xopen defined use posix defined use misc using namespace std clock t endif endif clock t not defined and time h or need clock t undef need clock t if defined time t defined defined time h defined need time t define time t defined include bits types h begin namespace std returned by time typedef time t time t end namespace std if defined use posix defined use misc defined use svid using namespace std time t endif endif time t not defined and time h or need time t undef need time t if defined clockid t defined defined time h defined use posix defined need clockid t define clockid t defined include bits types h clock id used in clock and timer functions typedef clockid t clockid t endif clockid t not defined and time h or need clockid t undef clockid time t if defined timer t defined defined time h defined use posix defined need timer t define timer t defined include bits types h timer id returned by timer create typedef timer t timer t endif timer t not defined and time h or need timer t undef need timer t if defined timespec defined defined time h defined use posix defined use misc defined need timespec define timespec defined include bits types h this defines time t for us posix b structure for a time value this is like a struct timeval but has nanoseconds  {
	                                                                                                                                                                                                                                                                                       nanoseconds :: -1000
                                                                                                                                                                                                                                                                                                 }
instead of microseconds  {
	microseconds :: -1000
 }
struct timespec time t tv sec seconds long int tv nsec  {
	     sneck :: 5
         }
nanoseconds endif timespec not defined and time h or need timespec undef need timespec ifdef time h begin namespace std used by other time functions struct tm int tm sec seconds leap second int tm min minutes int tm hour hours int tm mday  {
	                                        mya :: 5
                                          }
day int tm mon month int tm year year int tm wday day of week int tm yday  {
                }
days in year int tm isdst  {
	didst :: 6
	midsts :: 6
	 tids :: 6
	midst :: 6
    }
dst ifdef use bsd long int tm gmtoff  {
      }
seconds east of utc const char tm zone  {
	   zone :: -1000
      }
timezone abbreviation else long int tm gmtoff seconds east of utc const char tm zone timezone abbreviation endif end namespace std if defined use xopen defined use posix defined use misc using namespace std tm endif ifdef use posix posix b structure for timer start values and intervals struct itimerspec  {
	                                        imprecise :: 12
                                                }
struct timespec it interval struct timespec it value we can use a simple forward declaration struct sigevent endif posix b ifdef use xopen k ifndef pid t defined typedef pid t pid t define pid t defined endif endif begin namespace std time used by the program so far user time system time the result clocks per second is program time in seconds extern clock t clock void throw return the current time and put it in timer if timer is not null extern time t time time t timer throw return the difference between time and time extern double difftime  {
                                                                                                   }
time t time time t time throw attribute const return the time t representation of tp and normalize tp extern time t mktime  {
                     }
struct tm tp throw format tp into s according to format write no more than maxsize characters and return the number of characters written or if it would exceed maxsize extern size t strftime char restrict s size t maxsize const char restrict format const struct tm restrict tp throw end namespace std ifdef use xopen parse s according to format and store binary time information in tp the return value is a pointer to the first unparsed character in s extern char strptime  {
	                                                                          termtimes :: 10
	                                                                           sorptive :: 10
                                                                                  }
const char restrict s const char restrict fmt struct tm tp throw endif ifdef use xopen k similar to the two functions above but take the information from the provided locale and not the global locale include xlocale h extern size t strftime l char restrict s size t maxsize const char restrict format const struct tm restrict tp locale t loc throw endif ifdef use gnu extern char strptime l const char restrict s const char restrict fmt struct tm tp locale t loc throw endif begin namespace std return the struct tm representation of timer in universal coordinated  {
	                                                                                           trisemic :: -1000
                                                                                                  }
time aka greenwich  {
	creeshing :: 11
	greensick :: 12
	greenish :: 11
	rechewing :: 11
	greenfinch :: 11
 }
mean time extern struct tm gmtime const time t timer throw return the struct tm representation of timer in the local timezone extern struct tm localtime  {
	               localities :: 12
	                cobaltine :: 11
	                corallite :: 11
	                loyalties :: 11
	                localisms :: 11
	                localites :: 12
	                 localize :: 11
	                 localism :: 12
	                 localise :: 11
	                 localite :: 13
	                 localist :: 11
	                 locality :: 11
	                collimate :: 11
	                   locale :: 11
	                collative :: 11
                        }
const time t timer throw end namespace std if defined use posix defined use misc return the struct tm representation of timer in utc using tp to store the result extern struct tm gmtime r const time t restrict timer struct tm restrict tp throw return the struct tm representation of timer in local time using tp to store the result extern struct tm localtime r const time t restrict timer struct tm restrict tp throw endif posix or misc begin namespace std return a string of the form day mon dd hh mm ss yyyy n that is the representation of tp in this format extern char asctime  {
	                                                                                                     pastime :: 9
	                                                                                                    airtimes :: 9
                                                                                                           }
const struct tm tp throw equivalent to asctime localtime timer extern char ctime  {
	       crime :: 7
	       clime :: 7
	       chime :: 7
	      crimes :: 6
	      crimed :: 6
	      climes :: 6
	      chimes :: 6
	      chimer :: 6
	      chimed :: 6
	      stimes :: 6
	      stimed :: 6
	       stime :: 7
	        item :: 6
	        etic :: 6
	     climate :: 6
           }
const time t timer throw end namespace std if defined use posix defined use misc reentrant versions of the above functions return in buf a string of the form day mon dd hh mm ss yyyy n that is the representation of tp in this format extern char asctime r const struct tm restrict tp char restrict buf throw equivalent to asctime r localtime r timer tmp buf extern char ctime r const time t restrict timer char restrict buf throw endif posix or misc defined in localtime c extern char tzname  {
	                                                                                     untame :: 7
	                                                                                   vizament :: 7
	                                                                                     zonate :: 7
                                                                                          }
current timezone names extern int daylight  {
	daylight :: -1000
    }
if daylight saving time is ever in use extern long int timezone seconds west  {
	         west :: -1000
            }
of utc ifdef use posix same as above extern char tzname set time conversion information from the tz environment variable if tz is not defined a locale dependent default is used extern void tzset  {
	                             test :: 6
                                }
void throw endif if defined use svid defined use xopen extern int daylight extern long int timezone endif ifdef use svid set the system time to when this call is restricted to the superuser extern int stime  {
	                               stime :: -1000
                                   }
const time t when throw endif nonzero if year is a leap year every years except every th isn t and every th is define isleap  {
	                    islet :: 7
	                    isled :: 7
	                  pineals :: 7
	                  splenia :: 7
	                   asleep :: 7
	                  beleaps :: 7
	                 impearls :: 7
	                   espial :: 8
	                  illapse :: 7
	                  isleman :: 7
	                  upleaps :: 7
	                     isle :: 8
	                    salep :: 7
	                    piles :: 7
	                    pales :: 7
                        }
year year year year ifdef use misc miscellaneous functions many unices inherited from the public domain localtime package these are included only for compatibility like mktime but for tp represents universal time not local time extern time t timegm  {
	                                 gimme :: 7
	                                  time :: 7
	                                  tige :: 7
                                     }
struct tm tp throw another name for mktime extern time t timelocal  {
	  polemical :: 11
          }
struct tm tp throw return the number of days in year extern int dysize  {
	      assized :: 7
	      resized :: 7
	      unsized :: 7
	      dorizes :: 7
            }
int year throw attribute const endif ifdef use posix pause execution for a number of nanoseconds this function is a cancellation point and therefore not marked with throw extern int nanosleep  {
                             }
const struct timespec requested time struct timespec remaining get resolution of clock clock id extern int clock getres  {
	          searest :: 7
	           eagres :: 7
	           serges :: 7
	           geyser :: 7
	           gestes :: 8
	           gerbes :: 8
	           genres :: 9
	           genets :: 7
	           secret :: 7
	            geste :: 8
	            genre :: 7
	            geest :: 7
	            geare :: 7
	           geests :: 7
	          dearest :: 7
	           peters :: 7
	           deters :: 7
	         segreant :: 7
	          nearest :: 7
	           reties :: 8
	           retems :: 7
	           rentes :: 7
	          regrets :: 8
	           regret :: 7
	           regoes :: 7
	          reglets :: 7
	           regest :: 7
	           reates :: 7
	          petrels :: 7
	           metres :: 9
	           meters :: 7
	           merges :: 7
	           ternes :: 7
	           terces :: 7
	           gutser :: 7
	          greyest :: 8
	          getters :: 8
	          gesture :: 7
	           certes :: 7
	            terse :: 7
	            teers :: 7
	           greves :: 7
	           greets :: 8
	           greces :: 7
	           grebes :: 7
	           grates :: 7
	            serge :: 7
	          gerents :: 7
	            retes :: 7
	           verges :: 7
	            petre :: 7
	           egrets :: 7
	            metre :: 7
                }
clockid t clock id struct timespec res throw get current value of clock clock id and store it in tp extern int clock gettime  {
	                teatime :: 10
	               teatimes :: 9
                      }
clockid t clock id struct timespec tp throw set clock clock id to value tp extern int clock settime clockid t clock id const struct timespec tp throw ifdef use xopen k high resolution sleep with the specified clock this function is a cancellation point and therefore not marked with throw extern int clock nanosleep clockid t clock id int flags const struct timespec req struct timespec rem return clock id for cpu time clock extern int clock getcpuclockid pid t pid clockid t clock id throw endif create new per process timer using clock id extern int timer create clockid t clock id struct sigevent restrict evp  {
                                                                                                          }
timer t restrict timerid  {
	demerit :: 9
	tiderips :: 9
	timider :: 10
	dimeric :: 10
	dimetric :: 9
	tiderip :: 10
	timer :: 9
	tigerism :: 9
  }
throw delete timer timerid extern int timer delete timer t timerid throw set timer timerid to value returning old value in ovlaue  {
	              ovulate :: 7
	               volage :: 7
	                volae :: 7
	                uveal :: 7
	                ovule :: 7
                    }
extern int timer settime timer t timerid int flags const struct itimerspec restrict value struct itimerspec restrict ovalue  {
	          ovulate :: 8
	           avulse :: 7
	           ovules :: 7
	           ovular :: 7
	         ovalness :: 7
	             oval :: 8
	           uvulae :: 7
	            ovule :: 8
	            ovals :: 7
	         ovulated :: 7
	         ovulates :: 7
                }
throw get current value of timer timerid and store it in vlaue  {
	    vihuela :: 6
	      clave :: 6
	    valuers :: 6
	    vaguely :: 6
	      value :: 8
	      vague :: 6
	       veal :: 6
	      slave :: 6
	     values :: 7
	     valuer :: 7
	     valued :: 7
          }
extern int timer gettime timer t timerid struct itimerspec value throw get expiration overrun  {
	      overrun :: -1000
            }
for timer timerid extern int timer getoverrun  {
     }
timer t timerid throw endif ifdef use xopen extended set to one of the following values to indicate an error the datemsk  {
	                dates :: 9
	               datums :: 9
	               daters :: 9
	                satem :: 9
                    }
environment variable is null or undefined the template file cannot be opened for reading failed to get file status information the template file is not a regular file an error is encountered while reading the template file memory allication  {
	                            acieration :: 12
	                            illocution :: 13
	                           palliations :: 12
	                            lapidation :: 12
	                            validation :: 13
	                            allocution :: 13
	                             allantoic :: 13
	                           allegations :: 13
	                            glaciation :: 13
	                          indicational :: 12
	                            alineation :: 12
	                           salivations :: 12
	                            bilocation :: 13
	                            allocating :: 15
	                            allocation :: 17
	                            capitation :: 12
	                         illocutionary :: 12
	                            lorication :: 13
	                           antilogical :: 12
	                            radication :: 13
	                            abdication :: 14
	                           activations :: 12
	                            aprication :: 14
	                            salivation :: 13
	                           abdications :: 13
	                            allegation :: 14
	                           validations :: 12
	                            alienation :: 12
	                           glaciations :: 12
	                           bilocations :: 12
	                           allocutions :: 12
	                           allocations :: 16
	                            alligation :: 17
	                            alligating :: 13
	                            lamination :: 12
	                            palliation :: 13
	                            dilatation :: 12
	                            ampliation :: 12
                                     }
failed not enough memory available there is no line in the template that matches the input invalid input specification example february  {
                   }
or a time is specified that can not be represented in a time t representing the time in seconds since utc january extern int getdate  {
	                 gestate :: -1000
                       }
err parse the given string as a date specification and return a value representing the value the templates  {
	        templates :: -1000
                }
from the file identified by the environment variable datemsk are used in case of an error getdate err is set this function is a possible cancellation point and therefore not marked with throw extern struct tm getdate const char string endif ifdef use gnu since getdate is not reentrant because of the use of getdate err and the static buffer to return the result in we provide a thread safe variant the functionality is the same the result is returned in the buffer pointed to by resbufp  {
                                                                                     }
and in case of an error the return value is with the same values as given above for getdate err this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int getdate r const char restrict string struct tm restrict resbufp endif end decls endif time h included endif time h not already included tld h declarations for tld restriction checking copyright c simon josefsson copyright c free software foundation inc author thomas jacob  {
	                                                                                                jabot :: 6
	                                                                                                carob :: 6
	                                                                                                cabob :: 6
	                                                                                                bacon :: 6
	                                                                                            jacobuses :: 6
	                                                                                              jacobus :: 8
	                                                                                             jacobins :: 7
	                                                                                             jackboot :: 6
                                                                                                    }
internet de this file is part of gnu libidn gnu libidn is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version gnu libidn is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with gnu libidn if not write to the free software foundation inc franklin street fifth floor boston ma usa ifndef tld h define tld h ifndef idnapi if defined libidn building defined have visibility have visibility define idnapi attribute visibility default elif defined libidn building defined msc ver defined libidn static define idnapi declspec dllexport elif defined msc ver defined libidn static define idnapi declspec dllimport else define idnapi endif endif ifdef cplusplus extern c endif get size t include stdlib h get uint t include idn int h interval of valid code points in the tld struct tld table element uint t start start of range uint t end end of range end start if single typedef struct tld table element tld table element list valid code points in a tld struct tld table const char name tld name e g no const char version version string from tld file size t nvalid  {
	                                                                                                                                                                                                                                                           navaid :: 7
	                                                                                                                                                                                                                                                           nailed :: 7
	                                                                                                                                                                                                                                                           vialed :: 7
	                                                                                                                                                                                                                                                           dualin :: 7
                                                                                                                                                                                                                                                                }
number of entries in data const tld table element valid sorted array of valid code points typedef struct tld table tld table error codes typedef enum tld success tld invalid invalid character found tld nodata char domain or inlen tld malloc error tld iconv error tld no tld workaround typo in earlier versions tld notld tld no tld tld rc extern idnapi const char tld strerror tld rc rc extract tld as ascii string of ucs domain name into out extern idnapi int tld get const uint t in size t inlen char out extern idnapi int tld get z const uint t in char out extern idnapi int tld get z const char in char out return structure corresponding to the named tld from specified list of tld tables or return null if no matching tld can be found extern idnapi const tld table tld get table const char tld const tld table tables return structure corresponding to the named tld first looking thru overrides  {
	                                                                                                                                                            overrides :: -1000
                                                                                                                                                                    }
then thru built in list or return null if no matching tld can be found extern idnapi const tld table tld default table const char tld const tld table overrides check nameprepped  {
                              }
domain name for valid characters as defined by the relevant registering  {
	registering :: -1000
         }
body plus a z if error is tld invalid set errpos  {
	    proser :: 7
	    prores :: 8
	    porers :: 7
	  proposer :: 8
	   propers :: 7
	    ropers :: 7
	   gropers :: 7
	    pareos :: 7
	   pretors :: 7
	   presort :: 7
	    repros :: 8
	      errs :: 7
	   purpose :: 7
         }
to position of offending  {
	offending :: -1000
  }
character extern idnapi int tld check t const uint t in size t inlen size t errpos const tld table tld extern idnapi int tld check tz const uint t in size t errpos const tld table tld utility interfaces that uses tld get to find tld of string then tld default table with overrides to find proper tld table for the string and then hands over to tld check t extern idnapi int tld check const uint t in size t inlen size t errpos const tld table overrides extern idnapi int tld check z const uint t in size t errpos const tld table overrides extern idnapi int tld check z const char in size t errpos const tld table overrides extern idnapi int tld check lz const char in size t errpos const tld table overrides ifdef cplusplus endif endif tld h copyright c the regents of the university of california all rights reserved redistribution and use in source and binary forms with or without modification are permitted provided that the following conditions are met redistributions of source code must retain the above copyright notice this list of conditions and the following disclaimer redistributions in binary form must reproduce the above copyright notice this list of conditions and the following disclaimer in the documentation and or other materials provided with the distribution neither the name of the university nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission this software is provided by the regents and contributors as is and any express or implied warranties including but not limited to the implied warranties of merchantability and fitness for a particular purpose are disclaimed in no event shall the regents or contributors be liable for any direct indirect incidental special exemplary or consequential damages including but not limited to procurement of substitute goods or services loss of use data or profits or business interruption however caused and on any theory of liability whether in contract strict liability or tort including negligence or otherwise arising in any way out of the use of this software even if advised of the possibility of such damage ttyent  {
	                                                                                                                                                                                                                                                                                                                                                                          attent :: 7
                                                                                                                                                                                                                                                                                                                                                                               }
h berkeley ifndef ttyent h define ttyent h include features h define path ttys  {
	         tuis :: -1000
            }
etc ttys define ttys off off define ttys on on define ttys secure secure define ttys window window struct ttyent char ty name terminal device name char ty getty command to execute usually getty char ty type terminal type for termcap  {
                                       }
define tty on x enable logins start ty getty program define tty secure x allow uid of to login int ty status status flags char ty window command to start up window manager char ty comment comment field begin decls extern struct ttyent getttyent  {
                                          }
void throw extern struct ttyent getttynam  {
    }
const char tty throw extern int setttyent  {
     }
void throw extern int endttyent  {
   }
void throw end decls endif ttyent h copyright c d r commander all rights reserved redistribution and use in source and binary forms with or without modification are permitted provided that the following conditions are met redistributions of source code must retain the above copyright notice this list of conditions and the following disclaimer redistributions in binary form must reproduce the above copyright notice this list of conditions and the following disclaimer in the documentation and or other materials provided with the distribution neither the name of the libjpeg turbo project nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission this software is provided by the copyright holders and contributors as is and any express or implied warranties including but not limited to the implied warranties of merchantability and fitness for a particular purpose are disclaimed in no event shall the copyright holders or contributors be liable for any direct indirect incidental special exemplary or consequential damages including but not limited to procurement of substitute goods or services loss of use data or profits or business interruption however caused and on any theory of liability whether in contract strict liability or tort including negligence or otherwise arising in any way out of the use of this software even if advised of the possibility of such damage ifndef turbojpeg  {
	                                                                                                                                                                                                                               turbojet :: 11
                                                                                                                                                                                                                                      }
h define turbojpeg h if defined win defined dlldefine  {
       }
define dllexport declspec dllexport else define dllexport endif define dllcall  {
        }
addtogroup  {
 }
turbojpeg turbojpeg api this api provides an interface for generating decoding and transforming  {
	transforming :: -1000
           }
planar yuv and jpeg images in memory the number of chrominance  {
	chrominance :: -1000
         }
subsampling options define tj  {
	drouking :: -1000
  }
numsamp  {
	sunlamp :: 9
 }
chrominance subsampling options when an image is converted from the rgb to the ycbcr colorspace as part of the jpeg compression process some of the cb and cr chrominance components can be discarded or averaged  {
	                          averaged :: -1000
                                 }
together to produce a smaller image with little perceptible  {
	perceptible :: -1000
       }
loss of image clarity  {
	clarity :: -1000
  }
the human eye  {
	fie :: -1000
 }
is more sensitive  {
	sensitive :: -1000
 }
to small changes in brightness than small changes in color this is called chrominance subsampling enum tjsamp  {
	          stramp :: 7
               }
chrominance subsampling no chrominance subsampling the jpeg or yuv image will contain one chrominance component for every pixel in the source image tjsamp chrominance subsampling the jpeg or yuv image will contain one chrominance component for every x block of pixels in the source image tjsamp chrominance subsampling the jpeg or yuv image will contain one chrominance component for every x block of pixels in the source image tjsamp grayscale the jpeg or yuv image will contain no chrominance components tjsamp gray chrominance subsampling the jpeg or yuv image will contain one chrominance component for every x block of pixels in the source image tjsamp mcu block width in pixels for a given level of chrominance subsampling mcu block sizes x for no subsampling or grayscale x for x for x for static const int tjmcuwidth  {
                                                                                                                                      }
tj numsamp mcu block height in pixels for a given level of chrominance subsampling mcu block sizes x for no subsampling or grayscale x for x for x for static const int tjmcuheight  {
                               }
tj numsamp the number of pixel formats define tj numpf  {
        }
pixel formats enum tjpf  {
  }
rgb pixel format the red green and blue components in the image are stored in byte pixels in the order r g b from lowest to highest byte address within each pixel tjpf rgb bgr pixel format the red green and blue components in the image are stored in byte pixels in the order b g r from lowest to highest byte address within each pixel tjpf bgr rgbx pixel format the red green and blue components in the image are stored in byte pixels in the order r g b from lowest to highest byte address within each pixel the x component is ignored when compressing and undefined when decompressing  {
	                                                                                                 decompressing :: -1000
                                                                                                             }
tjpf rgbx bgrx pixel format the red green and blue components in the image are stored in byte pixels in the order b g r from lowest to highest byte address within each pixel the x component is ignored when compressing and undefined when decompressing tjpf bgrx xbgr pixel format the red green and blue components in the image are stored in byte pixels in the order r g b from highest to lowest byte address within each pixel the x component is ignored when compressing and undefined when decompressing tjpf xbgr xrgb pixel format the red green and blue components in the image are stored in byte pixels in the order b g r from highest to lowest byte address within each pixel the x component is ignored when compressing and undefined when decompressing tjpf xrgb grayscale pixel format each byte pixel represents a luminance brightness level from to tjpf gray rgba pixel format this is the same as ref tjpf rgbx except that when decompressing the x component is guaranteed to be xff which can be interpreted as an opaque alpha channel tjpf rgba bgra pixel format this is the same as ref tjpf bgrx except that when decompressing the x component is guaranteed to be xff which can be interpreted as an opaque alpha channel tjpf bgra abgr pixel format this is the same as ref tjpf xbgr except that when decompressing the x component is guaranteed to be xff which can be interpreted as an opaque alpha channel tjpf abgr argb pixel format this is the same as ref tjpf xrgb except that when decompressing the x component is guaranteed to be xff which can be interpreted as an opaque alpha channel tjpf argb red offset in bytes for a given pixel format this specifies the number of bytes that the red component is offset from the start of the pixel for instance if a pixel of format tj bgrx is stored in tt char pixel tt then the red component will be tt pixel tjredoffset  {
                                                                                                                                                                                                                                                                                                                                                  }
tj bgrx tt static const int tjredoffset tj numpf green offset in bytes for a given pixel format this specifies the number of bytes that the green component is offset from the start of the pixel for instance if a pixel of format tj bgrx is stored in tt char pixel tt then the green component will be tt pixel tjgreenoffset  {
                                                           }
tj bgrx tt static const int tjgreenoffset tj numpf blue offset in bytes for a given pixel format this specifies the number of bytes that the blue component is offset from the start of the pixel for instance if a pixel of format tj bgrx is stored in tt char pixel tt then the blue component will be tt pixel tjblueoffset  {
                                                           }
tj bgrx tt static const int tjblueoffset tj numpf pixel size in bytes for a given pixel format static const int tjpixelsize  {
	          cyclothymic :: -1000
                    }
tj numpf the uncompressed source destination image is stored in bottom up windows opengl  {
	       phenol :: 7
	      spangle :: 7
	       openly :: 8
	         open :: 8
	       sponge :: 7
	        oping :: 7
	        opens :: 7
            }
order not top down x order define tjflag  {
      }
bottomup  {
	airscape :: -1000
 }
turn off cpu auto detection and force turbojpeg to use mmx code ipp and bit libjpeg turbo versions only define tjflag forcemmx  {
	                force :: 10
                    }
turn off cpu auto detection and force turbojpeg to use sse  {
	     suets :: 3
	     stews :: 3
	     steps :: 3
	     stens :: 3
	     stems :: 3
	     steds :: 3
	      uses :: 3
	      shes :: 4
	      seys :: 3
	      sews :: 3
	      sets :: 3
	      sese :: 3
	      sers :: 3
	      seps :: 3
	      sens :: 3
	      sels :: 3
	      seis :: 3
	      segs :: 3
	      sees :: 4
	      secs :: 3
	      seas :: 3
	     spews :: 3
	     speos :: 3
	     specs :: 3
	     sneds :: 3
	     snebs :: 3
	      oses :: 3
	     smews :: 3
	     sleys :: 3
	     slews :: 3
	     sleds :: 3
	     skews :: 3
	     skers :: 3
	     skeps :: 3
	     skeos :: 3
	     skegs :: 3
	     shews :: 3
	     sheds :: 3
	     sheas :: 3
	     seers :: 3
	     seeps :: 3
	     seems :: 3
	     seels :: 3
	     seeks :: 3
	     seeds :: 3
	      eses :: 3
	       use :: 3
	       ses :: 4
	       ose :: 3
	       ess :: 3
	        es :: 3
         }
code bit ipp and bit libjpeg turbo versions only define tjflag forcesse  {
	     forces :: 10
	    forceps :: 10
	  farceuses :: 10
	  forceless :: 12
	  forcepses :: 13
	  processed :: 10
	 forcedness :: 12
	   farceuse :: 10
	   porpesse :: 10
          }
turn off cpu auto detection and force turbojpeg to use sse code bit ipp and bit libjpeg turbo versions only define tjflag forcesse turn off cpu auto detection and force turbojpeg to use sse code bit ipp version only define tjflag forcesse use fast inaccurate  {
	                                  inaccurate :: -1000
                                           }
chrominance upsampling routines in the jpeg decompressor libjpeg and libjpeg turbo versions only define tjflag fastupsample  {
              }
disable buffer re allocation if passed to tjcompress  {
	decompress :: 14
	recompress :: 14
      }
or tjtransform  {
	untransformed :: 14
	retransforms :: 14
	retransformed :: 14
	retransform :: 16
 }
this flag will cause those functions to generate an error if the jpeg image buffer is invalid or too small rather than attempting  {
	            attempting :: -1000
                     }
to allocate or reallocate that buffer this reproduces  {
	reproduces :: -1000
      }
the behavior of earlier versions of turbojpeg define tjflag norealloc  {
	collarbone :: 11
        }
number of transform operations define tj numxop  {
     }
transform operations for tjtransform enum tjxop  {
    }
do not transform the position of the image pixels tjxop none flip mirror  {
	      mirror :: -1000
           }
image horizontally this transform is imperfect  {
	imperfect :: -1000
    }
if there are any partial mcu blocks on the right edge  {
	      edge :: -1000
         }
see tjxopt  {
 }
perfect tjxop hflip  {
 }
flip mirror image vertically this transform is imperfect if there are any partial mcu blocks on the bottom edge see tjxopt perfect tjxop vflip  {
                      }
transpose  {
	transpose :: -1000
 }
image flip mirror along upper left to lower right axis this transform is always perfect tjxop transpose transverse  {
	       transverse :: -1000
                }
transpose image flip mirror along upper right to lower left axis this transform is imperfect if there are any partial mcu blocks in the image see tjxopt perfect tjxop transverse rotate image clockwise  {
	                       clockwise :: -1000
                               }
by degrees  {
	degrees :: -1000
 }
this transform is imperfect if there are any partial mcu blocks on the bottom edge see tjxopt perfect tjxop rot rotate image degrees this transform is imperfect if there are any partial mcu blocks in the image see tjxopt perfect tjxop rot rotate image counter clockwise by degrees this transform is imperfect if there are any partial mcu blocks on the right edge see tjxopt perfect tjxop rot this option will cause tjtransform to return an error if the transform is not perfect lossless transforms operate on mcu blocks whose size depends on the level of chrominance subsampling used see tjmcuwidth and tjmcuheight if the image s width or height is not evenly  {
	                                                                                                          evenly :: -1000
                                                                                                               }
divisible  {
	divisible :: -1000
 }
by the mcu block size then there will be partial mcu blocks on the right and or bottom edges  {
	             edges :: -1000
                 }
it is not possible to move these partial mcu blocks to the top or left of the image so any transform that would require that is imperfect if this option is not specified then any partial mcu blocks that cannot be transformed will be left in place which will create odd looking strips on the right or bottom edge of the image define tjxopt perfect this option will cause tjtransform to discard any partial mcu blocks that cannot be transformed define tjxopt trim this option will enable lossless cropping  {
	                                                                                cropping :: -1000
                                                                                       }
see tjtransform for more information define tjxopt crop this option will discard the color data in the input image and produce a grayscale output image define tjxopt gray this option will prevent tjtransform from outputting  {
	                        outputting :: -1000
                                 }
a jpeg image for this particular transform this can be used in conjunction with a custom filter to capture the transformed dct coefficients without transcoding them define tjxopt nooutput scaling factor typedef struct numerator int num denominator int denom tjscalingfactor  {
                                      }
cropping region typedef struct the left boundary of the cropping region this must be evenly divisible by the mcu block width see tjmcuwidth int x the upper boundary of the cropping region this must be evenly divisible by the mcu block height see tjmcuheight int y the width of the cropping region setting this to is the equivalent of setting it to the width of the source jpeg image x int w the height of the cropping region setting this to is the equivalent of setting it to the height of the source jpeg image y int h tjregion  {
                                                                                                 }
lossless transform typedef struct tjtransform cropping region tjregion r one of the ref tjxop transform operations int op the bitwise or of one of more of the ref tjxopt crop transform options int options arbitrary data that can be accessed within the body of the callback function void data a callback function that can be used to modify the dct coefficients after they are losslessly  {
	                                                      songlessly :: 13
	                                                      listlessly :: 13
	                                                      spotlessly :: 12
	                                                      costlessly :: 13
	                                                      lovelessly :: 14
	                                                      soullessly :: 15
	                                                      selflessly :: 12
                                                               }
transformed but before they are transcoded  {
	transuded :: 12
	transcend :: 12
	transduce :: 13
	ancestored :: 12
	transposed :: 13
	wainscoted :: 12
	transected :: 12
	transduced :: 15
	transcended :: 12
    }
to a new jpeg file this allows for custom filters or other transformations to be applied in the frequency domain param coeffs  {
	               scoffs :: 7
	                coffs :: 7
	            coiffeuse :: 7
	            coiffeurs :: 7
	              scoffed :: 7
	              scoffer :: 7
	               feoffs :: 7
	               coiffe :: 8
	               cloffs :: 8
	              coiffed :: 7
	              coiffes :: 9
	              coffles :: 7
	              coffers :: 7
	              coffees :: 7
	                scoff :: 7
                    }
pointer to an array of transformed dct coefficients note this pointer is not guaranteed to be valid once the callback returns so applications wishing  {
	                wishing :: -1000
                      }
to hand off the dct coefficients to another function or library should make a copy of them within the body of the callback param arrayregion  {
                       }
tjregion structure containing the width and height of the array pointed to by tt coeffs tt as well as its offset relative to the component plane turbojpeg implementations may choose to split each component plane into multiple dct coefficient arrays and call the callback function once for each array param planeregion  {
                                                 }
tjregion structure containing the width and height of the component plane to which tt coeffs tt belongs  {
	         belongs :: -1000
               }
param componentid  {
	component :: 18
	compensation :: 15
	companioned :: 15
	components :: 17
	componential :: 18
	compensations :: 14
	nondomestic :: 14
 }
id number of the component plane to which tt coeffs tt belongs y cb and cr have respectively id s of and in typical jpeg images param transformid  {
	                  transform :: 18
	               transforming :: 17
	                transformed :: 19
	                transformer :: 14
	                 transforms :: 16
	               transmogrify :: 15
	             transmogrified :: 14
	                  rainstorm :: 14
                          }
id number of the transformed image to which tt coeffs tt belongs this is the same as the index of the transform in the transforms array that was passed to tjtransform param transform a pointer to a tjtransform structure that specifies the parameters and or cropping region for this transform return if the callback was successful or if an error occurred int customfilter  {
                                                             }
short coeffs tjregion arrayregion tjregion planeregion int componentindex  {
      }
int transformindex  {
	transforming :: 21
	transformed :: 19
 }
struct tjtransform transform tjtransform turbojpeg instance handle typedef void tjhandle  {
	stoneworks :: -1000
        }
pad the given width to the nearest bit boundary define tjpad  {
	     taped :: 6
         }
width width compute the scaled value of tt dimension tt using the given scaling factor this macro performs the integer equivalent of tt ceil dimension scalingfactor  {
                        }
tt define tjscaled  {
	upscaled :: 10
	unscaled :: 10
	sulcated :: 10
	rescaled :: 10
	descaled :: 10
	descale :: 10
 }
dimension scalingfactor dimension scalingfactor num scalingfactor denom scalingfactor denom ifdef cplusplus extern c endif create a turbojpeg compressor instance return a handle to the newly created instance or null if an error occurred see tjgeterrorstr  {
                                 }
dllexport tjhandle dllcall tjinitcompress  {
  }
void compress an rgb or grayscale image into a jpeg image param handle a handle to a turbojpeg compressor or transformer  {
	         transformer :: -1000
                   }
instance param srcbuf  {
 }
pointer to an image buffer containing rgb or grayscale pixels to be compressed param width width in pixels of the source image param pitch  {
	                  pitch :: -1000
                      }
bytes per line of the source image normally this should be tt width tjpixelsize pixelformat  {
	      pheasant :: -1000
             }
tt if the image is unpadded or tt tjpad width tjpixelsize pixelformat tt if each line of the image is padded to the nearest bit boundary as is the case for windows bitmaps  {
	                         bitmaps :: -1000
                               }
you can also be clever  {
	clever :: -1000
   }
and use this parameter to skip lines etc setting this parameter to is the equivalent of setting it to tt width tjpixelsize pixelformat tt param height height in pixels of the source image param pixelformat pixel format of the source image see ref tjpf pixel formats param jpegbuf address of a pointer to an image buffer that will receive the jpeg image turbojpeg has the ability to reallocate the jpeg buffer to accommodate  {
	                                                                explores :: -1000
                                                                       }
the size of the jpeg image thus you can choose to pre allocate the jpeg buffer with an arbitrary size using tjalloc  {
	              challot :: 9
                    }
and let turbojpeg grow the buffer as needed set tt jpegbuf tt to null to tell turbojpeg to allocate the buffer for you or pre allocate the buffer to a worst  {
	                         worst :: -1000
                             }
case size determined by calling tjbufsize  {
    }
this should ensure that the buffer never has to be re allocated setting tjflag norealloc guarantees this if you choose option tt jpegsize  {
                     }
tt should be set to the size of your pre allocated buffer in any case unless you have set tjflag norealloc you should always check tt jpegbuf tt upon return from this function as it may have changed param jpegsize pointer to an unsigned long variable that holds the size of the jpeg image buffer if tt jpegbuf tt points to a pre allocated buffer then tt jpegsize tt should be set to the size of the buffer upon return tt jpegsize tt will contain the size of the jpeg image in bytes param jpegsubsamp  {
                                                                                             }
the level of chrominance subsampling to be used when generating the jpeg image see ref tjsamp chrominance subsampling options param jpegqual the image quality of the generated jpeg image worst best param flags the bitwise or of one or more of the ref tjflag bottomup flags return if successful or if an error occurred see tjgeterrorstr dllexport int dllcall tjcompress tjhandle handle unsigned char srcbuf int width int pitch int height int pixelformat unsigned char jpegbuf unsigned long jpegsize int jpegsubsamp int jpegqual int flags the maximum size of the buffer in bytes required to hold a jpeg image with the given parameters the number of bytes returned by this function is larger than the size of the uncompressed source image the reason for this is that the jpeg format uses bit coefficients and it is thus possible for a very high quality jpeg image with very high frequency content to expand rather than compress when converted to the jpeg format such images represent a very rare  {
	                                                                                                                                                                  rare :: -1000
                                                                                                                                                                     }
corner case but since there is no way to predict the size of a jpeg image prior to compression the corner case has to be handled param width width of the image in pixels param height height of the image in pixels param jpegsubsamp the level of chrominance subsampling to be used when generating the jpeg image see ref tjsamp chrominance subsampling options return the maximum size of the buffer in bytes required to hold the image or if the arguments are out of bounds  {
	                                                                              bounds :: -1000
                                                                                   }
dllexport unsigned long dllcall tjbufsize int width int height int jpegsubsamp the size of the buffer in bytes required to hold a yuv planar image with the given parameters param width width of the image in pixels param height height of the image in pixels param subsamp level of chrominance subsampling in the image see ref tjsamp chrominance subsampling options return the size of the buffer in bytes required to hold the image or if the arguments are out of bounds dllexport unsigned long dllcall tjbufsizeyuv  {
                                                                                    }
int width int height int subsamp encode an rgb or grayscale image into a yuv planar image this function uses the accelerated  {
	          accelerated :: -1000
                    }
color conversion routines in turbojpeg s underlying codec to produce a planar yuv image that is suitable for x video specifically if the chrominance components are subsampled  {
	                subsampled :: -1000
                         }
along the horizontal dimension then the width of the luminance plane is padded to in the output image same goes  {
	               goes :: -1000
                  }
for the height of the luminance plane if the chrominance components are subsampled along the vertical dimension also each line of each plane in the output image is padded to bytes although this will work with any subsampling option it is really only useful in combination with tj which produces an image compatible with the i aka yuv p format param handle a handle to a turbojpeg compressor or transformer instance param srcbuf pointer to an image buffer containing rgb or grayscale pixels to be encoded param width width in pixels of the source image param pitch bytes per line of the source image normally this should be tt width tjpixelsize pixelformat tt if the image is unpadded or tt tjpad width tjpixelsize pixelformat tt if each line of the image is padded to the nearest bit boundary as is the case for windows bitmaps you can also be clever and use this parameter to skip lines etc setting this parameter to is the equivalent of setting it to tt width tjpixelsize pixelformat tt param height height in pixels of the source image param pixelformat pixel format of the source image see ref tjpf pixel formats param dstbuf  {
                                                                                                                                                                                                    }
pointer to an image buffer that will receive the yuv image use tjbufsizeyuv to determine the appropriate size for this buffer based on the image width height and level of chrominance subsampling param subsamp the level of chrominance subsampling to be used when generating the yuv image see ref tjsamp chrominance subsampling options param flags the bitwise or of one or more of the ref tjflag bottomup flags return if successful or if an error occurred see tjgeterrorstr dllexport int dllcall tjencodeyuv  {
                                                                                }
tjhandle handle unsigned char srcbuf int width int pitch int height int pixelformat unsigned char dstbuf int subsamp int flags create a turbojpeg decompressor instance return a handle to the newly created instance or null if an error occurred see tjgeterrorstr dllexport tjhandle dllcall tjinitdecompress  {
                                           }
void retrieve information about a jpeg image without decompressing it param handle a handle to a turbojpeg decompressor or transformer instance param jpegbuf pointer to a buffer containing a jpeg image param jpegsize size of the jpeg image in bytes param width pointer to an integer variable that will receive the width in pixels of the jpeg image param height pointer to an integer variable that will receive the height in pixels of the jpeg image param jpegsubsamp pointer to an integer variable that will receive the level of chrominance subsampling used when compressing the jpeg image see ref tjsamp chrominance subsampling options return if successful or if an error occurred see tjgeterrorstr dllexport int dllcall tjdecompressheader  {
                                                                                                                   }
tjhandle handle unsigned char jpegbuf unsigned long jpegsize int width int height int jpegsubsamp returns a list of fractional scaling factors that the jpeg decompressor in this implementation of turbojpeg supports param numscalingfactors  {
                               }
pointer to an integer variable that will receive the number of elements in the list return a pointer to a list of fractional scaling factors or null if an error is encountered see tjgeterrorstr dllexport tjscalingfactor dllcall tjgetscalingfactors  {
                                    }
int numscalingfactors decompress a jpeg image to an rgb or grayscale image param handle a handle to a turbojpeg decompressor or transformer instance param jpegbuf pointer to a buffer containing the jpeg image to decompress param jpegsize size of the jpeg image in bytes param dstbuf pointer to an image buffer that will receive the decompressed  {
	                                           decompressed :: -1000
                                                      }
image this buffer should normally be tt pitch scaledheight  {
       }
tt bytes in size where tt scaledheight tt can be determined by calling tjscaled with the jpeg image height and one of the scaling factors returned by tjgetscalingfactors the dstbuf pointer may also be used to decompress into a specific region of a larger buffer param width desired width in pixels of the destination image if this is smaller than the width of the jpeg image being decompressed then turbojpeg will use scaling in the jpeg decompressor to generate the largest possible image that will fit within the desired width if width is set to then only the height will be considered when determining the scaled image size param pitch bytes per line of the destination image normally this is tt scaledwidth  {
                                                                                                                        }
tjpixelsize pixelformat tt if the decompressed image is unpadded else tt tjpad scaledwidth tjpixelsize pixelformat tt if each line of the decompressed image is padded to the nearest bit boundary as is the case for windows bitmaps note tt scaledwidth tt can be determined by calling tjscaled with the jpeg image width and one of the scaling factors returned by tjgetscalingfactors you can also be clever and use the pitch parameter to skip lines etc setting this parameter to is the equivalent of setting it to tt scaledwidth tjpixelsize pixelformat tt param height desired height in pixels of the destination image if this is smaller than the height of the jpeg image being decompressed then turbojpeg will use scaling in the jpeg decompressor to generate the largest possible image that will fit within the desired height if height is set to then only the width will be considered when determining the scaled image size param pixelformat pixel format of the destination image see ref tjpf pixel formats param flags the bitwise or of one or more of the ref tjflag bottomup flags return if successful or if an error occurred see tjgeterrorstr dllexport int dllcall tjdecompress tjhandle handle unsigned char jpegbuf unsigned long jpegsize unsigned char dstbuf int width int pitch int height int pixelformat int flags decompress a jpeg image to a yuv planar image this function performs jpeg decompression but leaves  {
	                                                                                                                                                                                                                                  leaves :: -1000
                                                                                                                                                                                                                                       }
out the color conversion step so a planar yuv image is generated instead of an rgb image the padding of the planes in this image is the same as the images generated by tjencodeyuv note that if the width or height of the image is not an even multiple of the mcu block size see tjmcuwidth and tjmcuheight then an intermediate buffer copy will be performed within turbojpeg param handle a handle to a turbojpeg decompressor or transformer instance param jpegbuf pointer to a buffer containing the jpeg image to decompress param jpegsize size of the jpeg image in bytes param dstbuf pointer to an image buffer that will receive the yuv image use tjbufsizeyuv to determine the appropriate size for this buffer based on the image width height and level of subsampling param flags the bitwise or of one or more of the ref tjflag bottomup flags return if successful or if an error occurred see tjgeterrorstr dllexport int dllcall tjdecompresstoyuv  {
                                                                                                                                                                }
tjhandle handle unsigned char jpegbuf unsigned long jpegsize unsigned char dstbuf int flags create a new turbojpeg transformer instance return a handle to the newly created instance or null if an error occurred see tjgeterrorstr dllexport tjhandle dllcall tjinittransform  {
                                     }
void losslessly transform a jpeg image into another jpeg image lossless transforms work by moving the raw coefficients from one jpeg image structure to another without altering  {
	                  altering :: -1000
                         }
the values of the coefficients while this is typically faster than decompressing the image transforming it and re compressing it lossless transforms are not free each lossless transform requires reading and huffman decoding all of the coefficients in the source image regardless of the size of the destination image thus this function provides a means of generating multiple transformed images from the same source or of applying multiple transformations simultaneously in order to eliminate the need to read the source coefficients multiple times param handle a handle to a turbojpeg transformer instance param jpegbuf pointer to a buffer containing the jpeg image to transform param jpegsize size of the jpeg image in bytes param n the number of transformed jpeg images to generate param dstbufs  {
                                                                                                                           }
pointer to an array of n image buffers tt dstbufs i tt will receive a jpeg image that has been transformed using the parameters in tt transforms i tt turbojpeg has the ability to reallocate the jpeg buffer to accommodate the size of the jpeg image thus you can choose to pre allocate the jpeg buffer with an arbitrary size using tjalloc and let turbojpeg grow the buffer as needed set tt dstbufs i tt to null to tell turbojpeg to allocate the buffer for you or pre allocate the buffer to a worst case size determined by calling tjbufsize with the cropped width and height this should ensure that the buffer never has to be re allocated setting tjflag norealloc guarantees this if you choose option tt dstsizes  {
	                                                                                                                        outsizes :: 10
                                                                                                                               }
i tt should be set to the size of your pre allocated buffer in any case unless you have set tjflag norealloc you should always check tt dstbufs i tt upon return from this function as it may have changed param dstsizes pointer to an array of n unsigned long variables that will receive the actual sizes in bytes of each transformed jpeg image if tt dstbufs i tt points to a pre allocated buffer then tt dstsizes i tt should be set to the size of the buffer upon return tt dstsizes i tt will contain the size of the jpeg image in bytes param transforms pointer to an array of n tjtransform structures each of which specifies the transform parameters and or cropping region for the corresponding transformed output image param flags the bitwise or of one or more of the ref tjflag bottomup flags return if successful or if an error occurred see tjgeterrorstr dllexport int dllcall tjtransform tjhandle handle unsigned char jpegbuf unsigned long jpegsize int n unsigned char dstbufs unsigned long dstsizes tjtransform transforms int flags destroy a turbojpeg compressor decompressor or transformer instance param handle a handle to a turbojpeg compressor decompressor or transformer instance return if successful or if an error occurred see tjgeterrorstr dllexport int dllcall tjdestroy  {
                                                                                                                                                                                                                     }
tjhandle handle allocate an image buffer for use with turbojpeg you should always use this function to allocate the jpeg destination buffer s for tjcompress and tjtransform unless you are disabling  {
	                     disabling :: -1000
                             }
automatic buffer re allocation by setting tjflag norealloc param bytes the number of bytes to allocate return a pointer to a newly allocated buffer with the specified number of bytes sa tjfree  {
                              }
dllexport unsigned char dllcall tjalloc int bytes free an image buffer previously allocated by turbojpeg you should always use this function to free jpeg destination buffer s that were automatically re allocated by tjcompress or tjtransform or that were manually allocated using tjalloc param buffer address of the buffer to free sa tjalloc dllexport void dllcall tjfree unsigned char buffer returns a descriptive error message explaining  {
	                                                       explaining :: -1000
                                                                }
why the last command failed return a descriptive error message explaining why the last command failed dllexport char dllcall tjgeterrorstr void backward compatibility functions and macros nothing to see here define numsubopt  {
                              }
tj numsamp define tj tjsamp define tj tjsamp define tj tjsamp define tj tjsamp define tj grayscale tjsamp gray define tj bgr define tj bottomup tjflag bottomup define tj forcemmx tjflag forcemmx define tj forcesse tjflag forcesse define tj forcesse tjflag forcesse define tj alphafirst define tj forcesse tjflag forcesse define tj fastupsample tjflag fastupsample define tj yuv dllexport unsigned long dllcall tjbufsize int width int height dllexport unsigned long dllcall tjbufsizeyuv int width int height int jpegsubsamp dllexport int dllcall tjcompress tjhandle handle unsigned char srcbuf int width int pitch int height int pixelsize unsigned char dstbuf unsigned long compressedsize  {
                                                                                                   }
int jpegsubsamp int jpegqual int flags dllexport int dllcall tjencodeyuv tjhandle handle unsigned char srcbuf int width int pitch int height int pixelsize unsigned char dstbuf int subsamp int flags dllexport int dllcall tjdecompressheader tjhandle handle unsigned char jpegbuf unsigned long jpegsize int width int height dllexport int dllcall tjdecompress tjhandle handle unsigned char jpegbuf unsigned long jpegsize unsigned char dstbuf int width int pitch int height int pixelsize int flags ifdef cplusplus endif endif copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa system v abi compliant user level context switching  {
	                                                                                                                                                                                                               switching :: -1000
                                                                                                                                                                                                                       }
support ifndef ucontext h define ucontext h include features h get machine dependent definition of data structures include sys ucontext h begin decls get user context and store it in variable pointed to by ucp extern int getcontext  {
                                    }
ucontext t ucp thrownl set user context from information of variable pointed to by ucp extern int setcontext  {
                }
const ucontext t ucp thrownl save current context in context variable pointed to by oucp  {
	       harmins :: -1000
             }
and set context from variable pointed to by ucp extern int swapcontext  {
          }
ucontext t restrict oucp const ucontext t restrict ucp thrownl manipulate  {
	manipulate :: -1000
         }
user context ucp to continue with calling functions func and the argc parameters following argc when the context is used the next time in setcontext or swapcontext we cannot say anything about the parameters func takes void is as good as any other choice extern void makecontext  {
                                             }
ucontext t ucp void func void int argc throw end decls endif ucontext h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef ulimit  {
	                                                                                                                                               ulitis :: 8
	                                                                                                                                              utility :: 7
	                                                                                                                                              stimuli :: 7
                                                                                                                                                    }
h define ulimit h include features h constants used as the first parameter for ulimit they denote limits which can be set or retrieved using this function enum ul getfsize  {
                            }
return limit on the size of a file in units of bytes define ul getfsize ul getfsize ul setfsize  {
                 }
set limit on the size of a file to second argument define ul setfsize ul setfsize ul getmaxbrk  {
                }
return the maximum possible address of the data segment ul getopenmax  {
         }
return the maximum number of files that the calling process can open begin decls control process limits according to cmd extern long int ulimit int cmd throw end decls endif ulimit h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa posix standard symbolic constants unistd h ifndef unistd h define unistd h include features h begin decls these may be used to determine what facilities are present at compile time their values can be obtained at run time from sysconf ifdef use xopen k posix standard approved  {
	                                                                                                                                                                                                            approved :: -1000
                                                                                                                                                                                                                   }
as iso iec as of september  {
    }
define posix version l elif defined use xopen k posix standard approved as iso iec as of december  {
	        decimetre :: 10
	         recombed :: 10
	       encumbered :: 10
	         remember :: 10
	         decenter :: 10
	         deceiver :: 10
	        decametre :: 10
                }
define posix version l elif defined use posix posix standard approved as iso iec as of june define posix version l elif defined use posix posix standard approved as iso iec as of september define posix version l else posix standard approved as iso iec as of september define posix version l endif these are not ifdef use posix because they are in the theoretically  {
	                                                   theoretically :: -1000
                                                               }
application owned namespace ifdef use xopen k define posix this version l the utilities on gnu systems also correspond to this version elif defined use xopen k the utilities on gnu systems also correspond to this version define posix this version l elif defined use posix the utilities on gnu systems also correspond to this version define posix this version l else the utilities on gnu systems also correspond to this version define posix this version l endif the utilities on gnu systems also correspond to this version define posix version posix this version if defined the implementation supports the c language bindings option define posix c bind posix this version if defined the implementation supports the c language development utilities option define posix c dev posix this version if defined the implementation supports the software development utilities option define posix sw dev posix this version if defined the implementation supports the creation of locales with the localedef  {
	                                                                                                                                                    localized :: 11
	                                                                                                                                                    localised :: 11
	                                                                                                                                                       locale :: 11
                                                                                                                                                            }
utility define posix localedef posix this version x open version number to which the library conforms  {
	       conforms :: -1000
              }
it is selectable ifdef use xopen k define xopen version elif defined use xopen k define xopen version elif defined use unix define xopen version else define xopen version endif commands and utilities from xpg are available define xopen xcu  {
	                                   crux :: 3
	                                    ecu :: 3
                                      }
version we are compatible with the old published standards as well define xopen xpg define xopen xpg define xopen xpg the x open unix extensions are available define xopen unix encryption is present define xopen crypt the enhanced  {
	                             enhanced :: -1000
                                    }
internationalization capabilities according to xpg are present define xopen enh i n the legacy interfaces are also available define xopen legacy get values of posix options if these symbols are defined the corresponding features are always available if not they may be available sometimes the current values can be obtained with sysconf posix job  {
	                                                  job :: -1000
                                                    }
control job control is supported posix saved ids processes have a saved set user id and a saved set group id posix realtime  {
	              mealtime :: 13
	              realties :: 12
	             declaimer :: 10
	             reclaimer :: 10
	             reclaimed :: 11
	               mealier :: 10
	             realities :: 10
	              reactive :: 10
	            retailment :: 10
	            reactively :: 10
	               realtie :: 13
	              relative :: 11
	              pearlite :: 10
	              meantime :: 10
	             wealthier :: 10
	             mealtimes :: 12
	             healthier :: 10
	             relatives :: 10
                     }
signals real time queued signals are supported posix priority scheduling priority scheduling is supported posix timers  {
	         timers :: -1000
              }
posix clocks and timers are supported posix asynchronous io asynchronous i o is supported posix prioritized  {
	    prioritized :: -1000
              }
io prioritized asynchronous i o is supported posix synchronized  {
	synchronized :: -1000
       }
io synchronizing  {
	synchronizing :: -1000
 }
file data is supported posix fsync the fsync function is present posix mapped files mapping of files to memory is supported posix memlock  {
	              hemlocks :: 10
	               hemlock :: 11
                     }
locking of all memory is supported posix memlock range locking of ranges of memory is supported posix memory protection setting of memory protections  {
	           protections :: -1000
                     }
is supported posix message passing posix message queues  {
	 queues :: -1000
      }
are supported posix semaphores  {
	semaphores :: -1000
  }
posix counting semaphores are supported posix shared memory objects posix shared memory objects are supported posix threads posix c pthreads are supported posix thread attr stackaddr thread stack address attribute option supported posix thread attr stacksize thread stack size attribute option supported posix thread safe functions thread safe functions are supported posix thread priority scheduling posix c thread execution scheduling supported posix thread prio inherit thread priority inheritance option supported posix thread prio protect thread priority protection option supported posix thread process shared process shared synchronization supported posix pii  {
	                                                                                     oxy :: -1000
                                                                                       }
protocol independent interfaces are supported posix pii xti xti protocol indep interfaces are supported posix pii socket socket protocol indep interfaces are supported posix pii internet internet family of protocols supported posix pii internet stream connection mode internet protocol supported posix pii internet dgram connectionless  {
	                                  connection :: 19
	                                 connections :: 20
	                                connectional :: 19
                                           }
internet protocol supported posix pii osi iso osi family of protocols supported posix pii osi cots  {
	           cots :: -1000
              }
connection mode iso osi service supported posix pii osi clts  {
	  soapier :: -1000
        }
connectionless iso osi service supported posix poll implementation supports poll function posix select implementation supports select and pselect  {
	         reelects :: 9
	         prelects :: 12
	          prelect :: 11
	         prefects :: 9
	        prelector :: 9
	      prelections :: 9
	       prelectors :: 10
                }
xopen realtime x open realtime support is available xopen realtime threads x open realtime thread support is available xopen shm shared memory interface according to xpg xbs  {
	                       xis :: 3
	                       obs :: 3
	                       abs :: 3
                         }
ilp  {
	imply :: 3
	impel :: 3
	slip :: 3
	plim :: 3
	plie :: 3
	lips :: 3
	flip :: 3
	clip :: 3
	blip :: 3
	lip :: 4
	imp :: 3
	ilk :: 3
	alp :: 3
 }
off implementation provides environment with bit int long pointer and off t types xbs ilp offbig  {
	        offings :: 7
	         offing :: 8
              }
implementation provides environment with bit int long and pointer and off t with at least bits xbs lp off implementation provides environment with bit int and bit long pointer and off t types xbs lpbig  {
                                 }
offbig implementation provides environment with at least bits int and long pointer and off t with at least bits if any of these symbols is defined as the corresponding option is not true for any file if any is defined as other than the corresponding option is true for all files if a symbol is not defined at all the value for a specific file can be obtained from pathconf  {
                                                                    }
and fpathconf  {
 }
posix chown restricted only the super user can use chown to change the owner of a file chown can only be used to change the group id of a file to a group of which the calling process is a member posix no trunc pathname components longer than name max generate an error posix vdisable if defined if the value of an element of the c cc member of struct termios is posix vdisable no character will have the effect associated with that element posix sync io synchronous i o may be performed posix async io asynchronous i o may be performed posix prio io prioritized asynchronous i o may be performed support for the large file support interface is not generally available if it is available the following constants are defined to one lfs largefile low level i o supports large files lfs stdio standard i o supports large files include bits posix opt h get the environment definitions from unix if defined use unix defined use xopen k include bits environments h endif standard file descriptors define stdin fileno standard input define stdout fileno standard output define stderr fileno standard error output all functions that are not declared anywhere else include bits types h ifndef ssize t defined typedef ssize t ssize t define ssize t defined endif define need size t define need null include stddef h if defined use xopen defined use xopen k the single unix specification says that some more types are available here ifndef gid t defined typedef gid t gid t define gid t defined endif ifndef uid t defined typedef uid t uid t define uid t defined endif ifndef off t defined ifndef use file offset typedef off t off t else typedef off t off t endif define off t defined endif if defined use largefile defined off t defined typedef off t off t define off t defined endif ifndef useconds  {
                                                                                                                                                                                                                                                                                                                                 }
t defined typedef useconds t useconds t define useconds t defined endif ifndef pid t defined typedef pid t pid t define pid t defined endif endif x open if defined use misc defined use xopen extended defined use xopen k ifndef intptr t defined typedef intptr t intptr t define intptr t defined endif endif if defined use bsd defined use xopen ifndef socklen t defined typedef socklen t socklen t define socklen t defined endif endif values for the second argument to access these may be or d together define r ok test for read permission define w ok test for write permission define x ok test for execute permission define f ok test for existence test for access to name using the real uid and real gid extern int access const char name int type throw nonnull ifdef use gnu test for access to name using the effective uid and gid as normal file operations use extern int euidaccess  {
                                                                                                                                                                }
const char name int type throw nonnull an alias for euidaccess used by some other systems extern int eaccess  {
                 }
const char name int type throw nonnull endif ifdef use atfile test for access to file relative to the directory fd is open on if at eaccess is set in flag then use effective ids like eaccess otherwise use real ids like access extern int faccessat  {
                                            }
int fd const char file int type int flag throw nonnull wur endif use gnu values for the whence argument to lseek ifndef stdio h stdio h has the same definitions define seek set seek from beginning of file define seek cur seek from current position define seek end seek from end of file ifdef use gnu define seek data seek to next data define seek hole seek to next hole endif endif if defined use bsd defined l set old bsd names for the same constants just for compatibility define l set seek set define l incr seek cur define l xtnd  {
                                                                                                     }
seek end endif move fd s file position to offset bytes from the beginning of the file if whence is seek set the current position if whence is seek cur or the end of the file if whence is seek end return the new file position ifndef use file offset extern off t lseek int fd off t offset int whence throw else ifdef redirect nth extern off t redirect nth lseek int fd off t offset int whence lseek else define lseek lseek endif endif ifdef use largefile extern off t lseek int fd off t offset int whence throw endif close the file descriptor fd this function is a cancellation point and therefore not marked with throw extern int close int fd read nbytes into buf from fd return the number read for errors or for eof this function is a cancellation point and therefore not marked with throw extern ssize t read int fd void buf size t nbytes wur write n bytes of buf to fd return the number written or this function is a cancellation point and therefore not marked with throw extern ssize t write int fd const void buf size t n wur if defined use unix defined use xopen k ifndef use file offset read nbytes into buf from fd at the given position offset without changing the file pointer return the number read for errors or for eof this function is a cancellation point and therefore not marked with throw extern ssize t pread int fd void buf size t nbytes off t offset wur write n bytes of buf to fd at the given position offset without changing the file pointer return the number written or this function is a cancellation point and therefore not marked with throw extern ssize t pwrite  {
	                                                                                                                                                                                                                                                                                                   sporidesms :: -1000
                                                                                                                                                                                                                                                                                                            }
int fd const void buf size t n off t offset wur else ifdef redirect extern ssize t redirect pread int fd void buf size t nbytes off t offset pread wur extern ssize t redirect pwrite int fd const void buf size t nbytes off t offset pwrite wur else define pread pread define pwrite pwrite endif endif ifdef use largefile read nbytes into buf from fd at the given position offset without changing the file pointer return the number read for errors or for eof extern ssize t pread int fd void buf size t nbytes off t offset wur write n bytes of buf to fd at the given position offset without changing the file pointer return the number written or extern ssize t pwrite int fd const void buf size t n off t offset wur endif endif create a one way communication channel pipe if successful two file descriptors are stored in pipedes  {
	                                                                                                                                                      impedes :: 10
	                                                                                                                                                     pipeless :: 9
	                                                                                                                                                        piped :: 9
                                                                                                                                                            }
bytes written on pipedes can be read from pipedes returns if successful if not extern int pipe int pipedes throw wur ifdef use gnu same as pipe but apply flags passed in flags to the new file descriptors extern int pipe int pipedes int flags throw wur endif schedule an alarm in seconds seconds the process will get a sigalrm  {
	                                                   regalism :: 9
                                                          }
if seconds is zero any currently scheduled  {
	scheduled :: -1000
     }
alarm will be cancelled the function returns the number of seconds remaining until the last alarm scheduled would have signaled or zero if there wasn t one there is no return value to indicate an error but you can set errno to and check its value after calling alarm and this might tell you the signal may come late due to processor scheduling extern unsigned int alarm unsigned int seconds throw make the process sleep for seconds seconds or until a signal arrives and is not ignored the function returns the number of seconds less than seconds which it actually slept  {
	                                                                                               slept :: -1000
                                                                                                   }
thus zero if it slept the full time if a signal handler does a longjmp or modifies  {
	        modifies :: -1000
               }
the handling of the sigalrm signal while inside sleep call the handling of the sigalrm signal afterwards is undefined there is no return value to indicate error but if sleep returns seconds it probably didn t work this function is a cancellation point and therefore not marked with throw extern unsigned int sleep unsigned int seconds if defined use xopen extended defined use xopen k defined use bsd set an alarm to go off generating a sigalrm signal in value microseconds if interval is nonzero when the alarm goes off the timer is reset to go off every interval microseconds thereafter  {
	                                                                                          thereafter :: -1000
                                                                                                   }
returns the number of microseconds remaining before the alarm extern useconds t ualarm  {
	   malarious :: 7
	      alarum :: 7
	     labarum :: 8
	     malarky :: 7
	    labarums :: 7
	      malars :: 8
	       talar :: 7
	       ramal :: 7
	       malar :: 9
           }
useconds t value useconds t interval throw sleep useconds microseconds or until a signal arrives that is not blocked or ignored this function is a cancellation point and therefore not marked with throw extern int usleep  {
	                             asleep :: 9
	                              upsee :: 8
	                            upkeeps :: 7
	                             spleen :: 7
	                              pulse :: 7
                                  }
useconds t useconds endif suspend the process until a signal arrives this always returns and sets errno to eintr this function is a cancellation point and therefore not marked with throw extern int pause void change the owner and group of file extern int chown const char file uid t owner gid t group throw nonnull wur if defined use bsd defined use xopen extended defined use xopen k change the owner and group of the file that fd is open on extern int fchown  {
                                                                                   }
int fd uid t owner gid t group throw wur change owner and group of file if it is a symbolic link the ownership of the symbolic link is changed extern int lchown  {
                               }
const char file uid t owner gid t group throw nonnull wur endif use bsd x open unix ifdef use atfile change the owner and group of file relative to the directory fd is open on extern int fchownat  {
                                     }
int fd const char file uid t owner gid t group int flag throw nonnull wur endif use gnu change the process s working directory to path extern int chdir const char path throw nonnull wur if defined use bsd defined use xopen extended defined use xopen k change the process s working directory to the one fd is open on extern int fchdir  {
                                                              }
int fd throw wur endif get the pathname of the current working directory and put it in size bytes of buf returns null if the directory couldn t be determined or size was too small if successful returns buf in gnu if buf is null an array is allocated with malloc the array is size bytes long unless size in which case it is as big as necessary extern char getcwd  {
                                                                     }
char buf size t size throw wur ifdef use gnu return a malloc d string containing the current directory name if the environment variable pwd is set and its value is correct that value is used extern char get current dir name void throw endif if defined use xopen extended defined use xopen k defined use bsd put the absolute pathname of the current working directory in buf if successful return buf if not put an error message in buf and return null buf should be at least path max bytes long extern char getwd  {
	                                                                                     phantasms :: -1000
                                                                                             }
char buf throw nonnull attribute deprecated wur endif duplicate fd returning a new file descriptor on the same file extern int dup int fd throw wur duplicate fd to fd closing fd and making it open on the same file extern int dup int fd int fd throw ifdef use gnu duplicate fd to fd closing fd and making it open on the same file while setting flags according to flags extern int dup int fd int fd int flags throw endif null terminated array of name value environment variables extern char environ ifdef use gnu extern char environ endif replace the current process executing path with arguments argv and environment envp argv and envp are terminated by null pointers extern int execve  {
	                                                                                                                   execute :: 7
	                                                                                                                 executive :: 7
                                                                                                                         }
const char path char const argv char const envp throw nonnull ifdef use xopen k execute the file fd refers to overlaying  {
	           overlaying :: -1000
                    }
the running program image argv and envp are passed to the new program as for execve extern int fexecve  {
                 }
int fd char const argv char const envp throw nonnull endif execute path with arguments argv and environment from environ extern int execv const char path char const argv throw nonnull execute path with all arguments after path until a null pointer and the argument after that for environment extern int execle  {
	                                          execrable :: 7
	                                              excel :: 7
	                                            execute :: 7
	                                            elected :: 7
                                                  }
const char path const char arg throw nonnull execute path with all arguments after path until a null pointer and environment from environ extern int execl const char path const char arg throw nonnull execute file searching in the path environment variable if it contains no slashes  {
	                                       slashes :: -1000
                                             }
with arguments argv and environment from environ extern int execvp  {
	    execs :: 7
	     exec :: 8
        }
const char file char const argv throw nonnull execute file searching in the path environment variable if it contains no slashes with all arguments after file until a null pointer and environment from environ extern int execlp  {
	                           parochins :: -1000
                                   }
const char file const char arg throw nonnull ifdef use gnu execute file searching in the path environment variable if it contains no slashes with arguments argv and environment from environ extern int execvpe  {
                                }
const char file char const argv char const envp throw nonnull endif if defined use misc defined use xopen add inc to priority of the current process extern int nice int inc throw wur endif terminate program execution with the low order bits of status extern void exit int status attribute noreturn get the pc symbols for the name argument to pathconf and fpathconf the sc symbols for the name argument to sysconf and the cs symbols for the name argument to confstr  {
	                                                                             confr :: 9
	                                                                         confuters :: 10
	                                                                           confits :: 10
	                                                                           confers :: 9
	                                                                           confest :: 9
	                                                                            confit :: 9
	                                                                        confitures :: 9
	                                                                          confutes :: 9
	                                                                          confuter :: 9
                                                                                 }
include bits confname  {
	conferment :: 10
 }
h get file specific configuration information about path extern long int pathconf const char path int name throw nonnull get file specific configuration about descriptor fd extern long int fpathconf int fd int name throw get the value of the system variable name extern long int sysconf int name throw ifdef use posix get the value of the string valued system variable name extern size t confstr int name char buf size t len throw endif get the process id of the calling process extern pid t getpid  {
	                                                                                 gipped :: 7
	                                                                                 gimped :: 7
	                                                                                 geddit :: 7
	                                                                                 peptid :: 7
	                                                                                 trepid :: 7
	                                                                                 griped :: 7
                                                                                      }
void throw get the process id of the calling process s parent extern pid t getppid  {
	        gripped :: 9
              }
void throw get the process group id of the calling process this function is different on old bsd ifndef favor bsd extern pid t getpgrp  {
                       }
void throw else ifdef redirect nth extern pid t redirect nth getpgrp pid t pid getpgid  {
              }
else define getpgrp getpgid endif endif get the process group id of process pid extern pid t getpgid pid t pid throw if defined use xopen extended defined use xopen k extern pid t getpgid pid t pid throw endif set the process group id of the process matching pid to pgid  {
	                                               paid :: 5
                                                  }
if pid is zero the current process s process group id is set if pgid is zero the process id of the process is used extern int setpgid  {
                          }
pid t pid pid t pgid throw if defined use svid defined use bsd defined use xopen extended both system v and bsd have setpgrp  {
                       }
functions but with different calling conventions the bsd function is the same as posix setpgid above the system v function takes no arguments and puts the calling process in its on group like setpgid new programs should always use setpgid instead the default in gnu is to provide the system v function the bsd function is available under d bsd source ifndef favor bsd set the process group id of the calling process to its own pid this is exactly the same as setpgid extern int setpgrp void throw else another name for setpgid above ifdef redirect nth extern int redirect nth setpgrp pid t pid pid t pgrp setpgid else define setpgrp setpgid endif endif favor bsd endif use svid or bsd create a new session with the calling process as its leader the process group ids of the session and the calling process are set to the process id of the calling process which is returned extern pid t setsid  {
	                                                                                                                                                       troubadour :: -1000
                                                                                                                                                                }
void throw if defined use xopen extended defined use xopen k return the session id of the given process extern pid t getsid  {
	                gestic :: 7
	                 gites :: 7
	                 geist :: 8
	                geddit :: 7
	                 deist :: 7
	                bedsit :: 7
	               outside :: 7
	                guised :: 7
	                  gits :: 7
	                  gets :: 8
	                  geds :: 7
                     }
pid t pid throw endif get the real user id of the calling process extern uid t getuid void throw get the effective user id of the calling process extern uid t geteuid  {
                               }
void throw get the real group id of the calling process extern gid t getgid  {
	        tigged :: 8
             }
void throw get the effective group id of the calling process extern gid t getegid  {
	       haslets :: -1000
             }
void throw if size is zero return the number of supplementary  {
	supplementary :: -1000
         }
groups the calling process is in otherwise fill in the group ids of its supplementary groups in list and return the number written extern int getgroups  {
	                outgroups :: 12
                        }
int size gid t list throw wur ifdef use gnu return nonzero iff the calling process is in group gid extern int group member gid t gid throw endif set the user id of the calling process to uid if the calling process is the super user set the real and effective user ids and the saved set user id to uid if not the effective user id is set to uid extern int setuid uid t uid throw if defined use bsd defined use xopen extended set the real user id of the calling process to ruid  {
	                                                                                           guider :: 5
	                                                                                             suid :: 5
	                                                                                             ruin :: 5
	                                                                                             quid :: 5
	                                                                                             raid :: 5
	                                                                                             muid :: 5
	                                                                                            rudie :: 5
	                                                                                              dui :: 5
                                                                                                }
and the effective user id of the calling process to euid extern int setreuid  {
	    amorosity :: -1000
            }
uid t ruid uid t euid throw endif if defined use bsd defined use xopen k set the effective user id of the calling process to uid extern int seteuid  {
                            }
uid t uid throw endif use bsd set the group id of the calling process to gid if the calling process is the super user set the real and effective group ids and the saved set group id to gid if not the effective group id is set to gid extern int setgid  {
	                                              singed :: 7
	                                             seagirt :: 7
	                                              sieged :: 7
	                                              stogie :: 7
	                                              staged :: 7
	                                               sited :: 7
	                                               sengi :: 7
                                                   }
gid t gid throw if defined use bsd defined use xopen extended set the real group id of the calling process to rgid  {
	                 grids :: 5
	                 gride :: 5
	                  raid :: 5
	                  grid :: 6
	                  gird :: 5
                     }
and the effective group id of the calling process to egid extern int setregid  {
	    secreting :: 10
            }
gid t rgid gid t egid throw endif if defined use bsd defined use xopen k set the effective group id of the calling process to gid extern int setegid  {
	                      taslets :: -1000
                            }
gid t gid throw endif use bsd ifdef use gnu fetch the real user id effective user id and saved set user id of the calling process extern int getresuid  {
	                   geometrids :: 11
                            }
uid t ruid uid t euid uid t suid throw fetch the real group id effective group id and saved set group id of the calling process extern int getresgid  {
                            }
gid t rgid gid t egid gid t sgid throw set the real user id effective user id and saved set user id of the calling process to ruid euid and suid respectively extern int setresuid  {
	                         servitudes :: 11
                                  }
uid t ruid uid t euid uid t suid throw set the real group id effective group id and saved set group id of the calling process to rgid egid and sgid respectively extern int setresgid  {
                                  }
gid t rgid gid t egid gid t sgid throw endif clone the calling process creating an exact copy return for errors to the new process and the process id of the new process to the old process extern pid t fork void thrownl if defined use xopen extended defined use xopen k defined use bsd clone the calling process but without copying the whole address space the calling process is suspended until the new process exits or is replaced by a call to execve return for errors to the new process and the process id of the new process to the old process extern pid t vfork  {
                                                                                                          }
void throw endif use bsd or xpg return the pathname of the terminal fd is open on or null on errors the returned storage is good only until the next call to this function extern char ttyname  {
                                   }
int fd throw store at most buflen characters of the pathname of the terminal fd is open on in buf return on success otherwise an error number extern int ttyname r int fd char buf size t buflen throw nonnull wur return if fd is a valid descriptor associated with a terminal zero if not extern int isatty  {
	                                                   shitty :: 7
	                                                   scatty :: 8
	                                                   aseity :: 7
	                                                   toasty :: 7
                                                        }
int fd throw if defined use bsd defined use xopen extended defined use unix return the index into the active logins file utmp for the controlling terminal extern int ttyslot  {
                            }
void throw endif make a link to from named to extern int link const char from const char to throw nonnull wur ifdef use atfile like link but relative paths in to and from are interpreted relative to fromfd  {
	                                  from :: 7
                                     }
and tofd  {
	told :: 5
	tofu :: 5
	toed :: 5
	toad :: 5
	tod :: 5
 }
respectively extern int linkat  {
	lineated :: 7
	lankiest :: 7
	tinkly :: 7
	tinkle :: 7
	tineal :: 7
	tindal :: 7
	tincal :: 7
	tink :: 7
	linkage :: 8
	lint :: 7
	link :: 8
	lank :: 7
	lineate :: 8
	linkages :: 7
	libant :: 7
	linky :: 7
	links :: 7
	linga :: 7
  }
int fromfd const char from int tofd const char to int flags throw nonnull wur endif if defined use bsd defined use xopen extended defined use xopen k make a symbolic link to from named to extern int symlink const char from const char to throw nonnull wur read the contents of the symbolic link path into no more than len bytes of buf the contents are not null terminated returns the number of characters read or for errors extern ssize t readlink  {
	                                                                           pearlin :: 10
	                                                                          readying :: 10
	                                                                          dragline :: 10
	                                                                         headliner :: 10
	                                                                          dearling :: 11
	                                                                          hardline :: 10
	                                                                          reddling :: 10
                                                                                 }
const char restrict path char restrict buf size t len throw nonnull wur endif use bsd ifdef use atfile like symlink but a relative path in to is interpreted relative to tofd extern int symlinkat  {
                                 }
const char from int tofd const char to throw nonnull wur like readlink but a relative path is interpreted relative to fd extern ssize t readlinkat  {
                        }
int fd const char restrict path char restrict buf size t len throw nonnull wur endif remove the link name extern int unlink const char name throw nonnull ifdef use atfile remove the link name relative to fd extern int unlinkat  {
	                                  unlink :: 12
	                                unlinked :: 10
	                                 unlinks :: 11
	                              unsinkable :: 10
                                       }
int fd const char name int flag throw nonnull endif remove the directory path extern int rmdir  {
	           rider :: 6
	           mudir :: 6
               }
const char path throw nonnull return the foreground  {
	oxymora :: -1000
      }
process group id of fd extern pid t tcgetpgrp  {
       }
int fd throw set the foreground process group id of fd set pgrp id extern int tcsetpgrp  {
               }
int fd pid t pgrp id throw return the login name of the user this function is a possible cancellation point and therefore not marked with throw extern char getlogin  {
	                     geologic :: 10
	                    geologist :: 11
	                    neologist :: 10
	                    geologian :: 11
	                   geologists :: 10
	                   geologians :: 10
	                    retooling :: 10
                            }
void if defined use reentrant defined use posix return at most name len characters of the login name of the user in name if it cannot be determined or some other error occurred return the error code otherwise return this function is a possible cancellation point and therefore not marked with throw extern int getlogin r char name size t name len nonnull endif ifdef use bsd set the login name returned by getlogin extern int setlogin  {
	                                                                   sectoring :: 10
	                                                                   geologist :: 10
	                                                                   enologist :: 11
	                                                                   neologist :: 12
	                                                                   neologism :: 10
	                                                                  enologists :: 10
	                                                                  neologists :: 11
	                                                                   reclosing :: 10
	                                                                   retooling :: 10
                                                                           }
const char name throw nonnull endif ifdef use posix get definitions and prototypes for functions to process the arguments in argv argc of them minus the program name for options given in opts define need getopt include getopt h endif if defined use bsd defined use unix defined use xopen k put the name of the current host in no more than len bytes of name the result is null terminated if len is large enough for the full name and the terminator extern int gethostname  {
                                                                                    }
char name size t len throw nonnull endif if defined use bsd defined use xopen defined use unix set the name of the current host to name which is len bytes long this call is restricted to the super user extern int sethostname  {
                                         }
const char name size t len throw nonnull wur set the current machine s internet number to id this call is restricted to the super user extern int sethostid  {
	                  methodists :: 12
	                   methodist :: 11
                           }
long int id throw wur get and set the nis aka yp domain name if any called just like gethostname and sethostname the nis domain name is usually the empty string when not using nis extern int getdomainname  {
                                    }
char name size t len throw nonnull wur extern int setdomainname  {
         }
const char name size t len throw nonnull wur revoke access permissions to all processes currently communicating  {
	   communicating :: -1000
               }
with the control terminal and then send a sighup signal to the process group of the control terminal extern int vhangup  {
                   }
void throw revoke the access of all descriptors currently open on file extern int revoke const char file throw nonnull wur enable statistical  {
	           statistical :: -1000
                     }
profiling writing samples of the pc into at most size bytes of sample buffer every processor clock tick while profiling is enabled the system examines  {
	                examines :: -1000
                       }
the user pc and increments  {
	increments :: -1000
   }
sample buffer pc offset scale if scale is zero disable profiling returns zero on success on error extern int profil unsigned short int sample buffer size t size size t offset unsigned int scale throw nonnull turn accounting  {
	                           accounting :: -1000
                                    }
on if name is an existing file the system will then write a record for each process as it terminates to this file if name is null turn accounting off this call is restricted to the super user extern int acct const char name throw successive calls return the shells listed in etc shells extern char getusershell  {
                                                       }
void throw extern void endusershell  {
   }
void throw discard cached info extern void setusershell  {
      }
void throw rewind and re read the file put the program in the background and dissociate  {
	     dissociate :: -1000
              }
from the controlling terminal if nochdir is zero do chdir if noclose is zero redirects  {
	     redirects :: -1000
             }
stdin stdout and stderr to dev null extern int daemon int nochdir int noclose throw wur endif use bsd x open if defined use bsd defined use xopen defined use xopen k make path be the root directory the starting point for absolute paths this call is restricted to the super user extern int chroot  {
	                                              scrootch :: 8
	                                               chronon :: 7
	                                                cohort :: 8
	                                               cheroot :: 7
	                                               cohorts :: 7
	                                               torgoch :: 7
	                                                chromo :: 8
	                                                 thoro :: 7
	                                                cahoot :: 8
                                                     }
const char path throw nonnull wur prompt with prompt and read a string from the terminal without echoing  {
	          echoing :: -1000
                }
uses dev tty if possible otherwise stderr and stdin extern char getpass  {
	   gestapos :: 9
	    petsais :: 9
          }
const char prompt nonnull endif use bsd x open if defined use bsd defined use xopen defined use xopen k make all changes done to fd actually appear on disk this function is a cancellation point and therefore not marked with throw extern int fsync int fd endif use bsd x open unix ifdef use gnu make all changes done to all files on the file system associated with fd actually appear on disk extern int syncfs  {
	                                                                     syncoms :: 7
	                                                                      synchs :: 9
	                                                                       syncs :: 9
	                                                                        sync :: 7
                                                                           }
int fd throw endif if defined use bsd defined use xopen extended return identifier for the current host extern long int gethostid  {
	             gothites :: 11
	            methodist :: 11
                    }
void make all changes done to all files actually appear on disk extern void sync void throw if defined use bsd defined use xopen k return the number of bytes in a page this is the system s page size which is not necessarily  {
	                                necessarily :: -1000
                                          }
the same as the hardware page size extern int getpagesize void throw attribute const return the maximum number of file descriptors the current process could possibly have extern int getdtablesize  {
                            }
void throw endif endif use bsd x open unix if defined use bsd defined use xopen extended defined use xopen k truncate file to length bytes ifndef use file offset extern int truncate const char file off t length throw nonnull wur else ifdef redirect nth extern int redirect nth truncate const char file off t length truncate nonnull wur else define truncate truncate endif endif ifdef use largefile extern int truncate const char file off t length throw nonnull wur endif endif use bsd x open unix posix if defined use bsd defined use xopen extended defined use xopen k truncate the file fd is open on to length bytes ifndef use file offset extern int ftruncate  {
	                                                                                                            fornicate :: 11
	                                                                                                            fortunate :: 12
	                                                                                                            fecundate :: 11
                                                                                                                    }
int fd off t length throw wur else ifdef redirect nth extern int redirect nth ftruncate int fd off t length ftruncate wur else define ftruncate ftruncate endif endif ifdef use largefile extern int ftruncate int fd off t length throw wur endif endif use bsd x open unix posix if defined use xopen extended defined use xopen k defined use misc set the end of accessible data space aka the break to addr returns zero on success and for errors with errno set extern int brk void addr throw wur increase or decrease the end of accessible data space by delta bytes if successful returns the address the previous end of data space i e the beginning of the new space if delta returns void for errors with errno set extern void sbrk  {
	                                                                                                                                burks :: 5
	                                                                                                                                barks :: 5
	                                                                                                                                 serk :: 5
	                                                                                                                                 sark :: 5
                                                                                                                                    }
intptr t delta throw endif ifdef use misc invoke system call number sysno  {
	     syphons :: 6
	     syncoms :: 6
	      synods :: 6
	       sysop :: 6
	       sonsy :: 6
           }
passing it the remaining arguments this is completely system dependent and not often useful in unix syscall sets errno for all errors and most calls return for errors in many systems you cannot pass arguments or get return values for all system calls pipe fork and getppid typically among them in mach all system calls take normal arguments and always return an error code zero for success extern long int syscall long int sysno throw endif use misc if defined use misc defined use xopen extended defined f lock note these declarations also appear in fcntl h be sure to keep both files consistent some systems have them there and some here and some software depends on the macros being defined without including both lockf is a simpler interface to the locking facilities of fcntl len is always relative to the current file position the cmd argument is one of the following this function is a cancellation point and therefore not marked with throw define f ulock unlock a previously locked region define f lock lock a region for exclusive use define f tlock test and lock a region for exclusive use define f test test a region for other processes locks ifndef use file offset extern int lockf int fd int cmd off t len wur else ifdef redirect extern int redirect lockf int fd int cmd off t len lockf wur else define lockf lockf endif endif ifdef use largefile extern int lockf int fd int cmd off t len wur endif endif use misc and f lock not already defined ifdef use gnu evaluate expression and repeat as long as it returns with errno set to eintr define temp failure retry expression extension long int result do result long int expression while result l errno eintr result endif if defined use posix defined use unix synchronize at least the data part of a file with the underlying media extern int fdatasync  {
                                                                                                                                                                                                                                                                                                                                  }
int fildes endif use posix xpg specifies that prototypes for the encryption functions must be defined here ifdef use xopen encrypt at most characters from key using salt to perturb des extern char crypt const char key const char salt throw nonnull encrypt data in block in place if edflag is zero otherwise decrypt block in place extern void encrypt char libc block int edflag throw nonnull swab pairs bytes in the first n bytes of the area pointed to by from and copy the result to to the value of to must not be in the range from n from if n is odd the first byte in from is without partner extern void swab const void restrict from void restrict to ssize t n throw nonnull endif the single unix specification demands  {
	                                                                                                                              demands :: -1000
                                                                                                                                    }
this prototype to be here it is also found in stdio h if defined use xopen defined use xopen k return the name of the controlling terminal extern char ctermid char s throw endif define some macros helping to catch buffer overflows if use fortify level defined extern always inline include bits unistd h endif end decls endif unistd h include sys ustat  {
	                                                       astuter :: 6
	                                                        astute :: 7
	                                                        astrut :: 6
	                                                       nutates :: 6
	                                                        estate :: 6
	                                                         sutta :: 6
                                                             }
h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa posix standard set file access and modification times utime  {
	                                                                                                                                         stimes :: 6
	                                                                                                                                         stimed :: 6
	                                                                                                                                          utile :: 7
	                                                                                                                                          urite :: 6
	                                                                                                                                          unite :: 6
	                                                                                                                                          stime :: 7
	                                                                                                                                           item :: 6
                                                                                                                                              }
h ifndef utime h define utime h include features h begin decls include bits types h if defined use xopen defined use xopen k define need time t include time h endif structure describing file times struct utimbuf  {
                                    }
time t actime  {
	actin :: 7
	actively :: 7
	micate :: 7
	metical :: 7
	acmite :: 10
	accite :: 7
	acoemeti :: 8
	actives :: 8
	acmites :: 9
	metic :: 7
 }
access time time t modtime  {
	multimode :: 9
	mistimed :: 9
	tommied :: 9
   }
modification time set the access and modification times of file to those given in file times if file times is null set them to the current time extern int utime const char file const struct utimbuf file times throw nonnull end decls endif utime h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef utmp h define utmp h include features h include sys types h begin decls get system dependent values and data structures include bits utmp h compatibility names for the strings of the canonical file names define utmp file path utmp define utmp filename path utmp define wtmp file path wtmp define wtmp filename path wtmp make fd be the controlling terminal stdin stdout and stderr then close fd returns on success nonzero on error extern int login tty int fd throw write the given entry into utmp and wtmp extern void login const struct utmp entry throw write the utmp entry to say the user on ut line has logged out extern int logout  {
	                                                                                                                                                                                                                                                                                                 loto :: 7
	                                                                                                                                                                                                                                                                                                 logo :: 8
	                                                                                                                                                                                                                                                                                                logos :: 7
	                                                                                                                                                                                                                                                                                                logoi :: 7
                                                                                                                                                                                                                                                                                                    }
const char ut line throw append to wtmp an entry for the current time and the given info extern void logwtmp  {
                   }
const char ut line const char ut name const char ut host throw append entry utmp to the wtmp like file wtmp file extern void updwtmp  {
                        }
const char wtmp file const struct utmp utmp throw change name of the utmp file to be examined  {
	         examined :: -1000
                }
extern int utmpname  {
 }
const char file throw read next entry from a utmp like file extern struct utmp getutent  {
	      teguments :: 10
	       tegument :: 11
              }
void throw reset the input stream to the beginning of the file extern void setutent  {
	     teguments :: 10
	      nettiest :: 10
             }
void throw close the current open file extern void endutent  {
	 unnetted :: 10
	 undecent :: 11
	unpatented :: 10
        }
void throw search forward from the current point in the utmp file until the next entry with a ut type matching id ut type extern struct utmp getutid  {
                          }
const struct utmp id throw search forward from the current point in the utmp file until the next entry with a ut line matching line ut line extern struct utmp getutline  {
	                     lettering :: 11
                             }
const struct utmp line throw write out entry pointed to by utmp ptr into the utmp file extern struct utmp pututline  {
                   }
const struct utmp utmp ptr throw ifdef use misc reentrant versions of the file for handling utmp files extern int getutent r struct utmp buffer struct utmp result throw extern int getutid r const struct utmp id struct utmp buffer struct utmp result throw extern int getutline r const struct utmp line struct utmp buffer struct utmp result throw endif use misc end decls endif utmp h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef utmpx  {
	                                                                                                                                                                                                      tump :: 6
                                                                                                                                                                                                         }
h define utmpx h include features h include sys time h required according to unix ifndef pid t defined typedef pid t pid t define pid t defined endif get system dependent values and data structures include bits utmpx h ifdef use gnu compatibility names for the strings of the canonical file names define utmpx file path utmpx define utmpx filename path utmpx define wtmpx  {
                                                               }
file path wtmpx define wtmpx filename path wtmpx endif for the getutmp  {
          }
x functions we need the struct utmp ifdef use gnu struct utmp endif begin decls open user accounting database this function is a possible cancellation point and therefore not marked with throw extern void setutxent  {
                                 }
void close user accounting database this function is a possible cancellation point and therefore not marked with throw extern void endutxent  {
	            unnetted :: 11
                   }
void get the next entry from the user accounting database this function is a possible cancellation point and therefore not marked with throw extern struct utmpx getutxent  {
                         }
void get the user accounting database entry corresponding to id this function is a possible cancellation point and therefore not marked with throw extern struct utmpx getutxid  {
                         }
const struct utmpx id get the user accounting database entry corresponding to line this function is a possible cancellation point and therefore not marked with throw extern struct utmpx getutxline  {
                            }
const struct utmpx line write the entry utmpx into the user accounting database this function is a possible cancellation point and therefore not marked with throw extern struct utmpx pututxline  {
                            }
const struct utmpx utmpx ifdef use gnu change name of the utmpx file to be examined this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int utmpxname  {
                                                      }
const char file append entry utmp to the wtmpx like file wtmpx file this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern void updwtmpx  {
                                                   }
const char wtmpx file const struct utmpx utmpx copy the information in utmpx to utmp this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern void getutmp const struct utmpx utmpx struct utmp utmp copy the information in utmp to utmpx this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern void getutmpx  {
                                                                                                           }
const struct utmp utmp struct utmpx utmpx endif end decls endif utmpx h old compatibility names for limits h and float h constants copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa this interface is obsolete new programs should use limits h and or float h instead of values h ifndef values h define values h include features h include limits h define typebits  {
	                                                                                                                                                                                     typiest :: 11
                                                                                                                                                                                           }
type sizeof type char bit define charbits  {
	chartists :: 10
	cohabits :: 11
	charriest :: 10
	crabbiest :: 10
	charts :: 10
	chariot :: 10
	chartist :: 11
	chartism :: 11
	charpies :: 10
	charlies :: 10
	chariots :: 12
     }
typebits char define shortbits  {
	frostbit :: 11
	shortlists :: 11
	theorbists :: 11
	frostbites :: 11
	shortlist :: 13
	shortcuts :: 12
  }
typebits short int define intbits  {
	intuit :: 9
	titbits :: 10
	nitwits :: 9
	tidbits :: 9
	intwist :: 9
	intuits :: 11
   }
typebits int define longbits  {
	ringbolts :: 10
	kingbolts :: 10
	lingots :: 10
  }
typebits long int define ptrbits  {
	turbits :: 10
	probits :: 10
	stript :: 9
   }
typebits char define doublebits  {
	doublets :: 13
	quodlibets :: 12
	doubtable :: 12
	doublet :: 12
	doubles :: 12
  }
typebits double define floatbits  {
	frostbit :: 12
	flatboats :: 11
	frostbite :: 11
	floatiest :: 12
  }
typebits float define minshort  {
	hindmost :: 10
	minster :: 10
	manihots :: 10
	misthrown :: 10
	monitors :: 10
  }
shrt min define minint  {
	kinin :: 7
	minting :: 8
	minivan :: 7
	minions :: 7
	minings :: 8
	miniate :: 7
	mannitic :: 7
	minnie :: 7
	minion :: 8
	mining :: 9
	minuting :: 7
	tining :: 8
	timing :: 7
	mini :: 7
	misinter :: 7
	liniment :: 7
	misintend :: 7
	linin :: 7
  }
int min define minlong  {
	morling :: 9
	mignon :: 10
	moiling :: 9
  }
long min define maxshort  {
  }
shrt max define maxint int max define maxlong  {
	 magnox :: 9
      }
long max define hibits  {
	binits :: 8
	habit :: 7
	habitus :: 7
	tibias :: 8
	vibist :: 7
	habits :: 9
  }
minshort define hibitl  {
	habit :: 7
	hili :: 7
 }
minlong include float h define maxdouble  {
	mouldable :: 11
    }
dbl max define maxfloat flt max define mindouble  {
	mindblower :: 11
      }
dbl min define minfloat  {
  }
flt min define dminexp  {
  }
dbl min exp define fminexp  {
   }
flt min exp define dmaxexp  {
   }
dbl max exp define fmaxexp  {
   }
flt max exp ifdef use misc some systems define this name instead of char bit or charbits define bitsperbyte  {
                 }
char bit endif endif values h include sys wait h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa iso c standard extended multibyte and wide character utilities wchar h ifndef wchar h if defined need mbstate t defined need wint t define wchar h include features h endif ifdef wchar h get file definition define need file if defined use unix defined use xopen k define need file endif include stdio h get va list definition define need va list include stdarg h include bits wchar h get size t wchar t wint t and null from stddef h define need size t define need wchar t define need null endif if defined wchar h defined need wint t defined wint type undef need wint t define need wint t include stddef h we try to get wint t from stddef h but not all gcc versions define it there so define it ourselves  {
	                                                                                                                                                                                                                                                                              ourselves :: -1000
                                                                                                                                                                                                                                                                                      }
if it remains undefined ifndef wint t integral type unchanged by default argument promotions  {
	   promotions :: -1000
            }
that can hold any value corresponding to members of the extended character set as well as at least one value that does not correspond to any member of the extended character set define wint t typedef unsigned int wint t else work around problems with the stddef h file which doesn t put wint t in the std namespace if defined cplusplus defined glibcpp use namespaces defined wint type begin namespace std typedef wint type wint t end namespace std endif endif tell the caller that we provide correct c prototypes if defined cplusplus gnuc prereq define correct iso cpp wchar h proto endif endif if defined wchar h defined need mbstate t defined mbstate t defined define mbstate t defined conversion state information typedef struct int count union ifdef wint type wint type wch else wint t wch endif char wchb  {
                                                                                                                                            }
value value so far mbstate t endif undef need mbstate t the rest of the file is only used if used if need mbstate t is not defined ifdef wchar h begin namespace c public type typedef mbstate t mbstate t end namespace c ifdef use gnu using namespace c mbstate t endif ifndef wchar min these constants might also be defined in inttypes h define wchar min wchar min define wchar max wchar max endif ifndef weof  {
	                                                                       woofer :: 5
	                                                                       woofed :: 5
	                                                                         woof :: 5
                                                                            }
define weof xffffffffu endif for xpg compliance we have to define the stuff from wctype  {
	        ectype :: 9
	        ectopy :: 7
	       cotypes :: 7
	        cotype :: 8
	       ectypes :: 8
	       ectypal :: 7
             }
h here as well if defined use xopen defined use unix include wctype h endif begin decls begin namespace std this incomplete type is defined in time h but needed here because of wcsftime  {
                                }
struct tm end namespace std xxx we have to clean this up at some point since tm is in the std namespace but wcsftime is in c the type wouldn t be found without inserting  {
	                         inserting :: -1000
                                 }
it in the global namespace using namespace std tm begin namespace std copy src to dest extern wchar t wcscpy  {
                  }
wchar t restrict dest const wchar t restrict src throw copy no more than n wide characters of src to dest extern wchar t wcsncpy  {
                       }
wchar t restrict dest const wchar t restrict src size t n throw append src onto dest extern wchar t wcscat  {
                   }
wchar t restrict dest const wchar t restrict src throw append no more than n wide characters of src onto dest extern wchar t wcsncat  {
                       }
wchar t restrict dest const wchar t restrict src size t n throw compare s and s extern int wcscmp  {
                  }
const wchar t s const wchar t s throw attribute pure compare n wide characters of s and s extern int wcsncmp  {
                    }
const wchar t s const wchar t s size t n throw attribute pure end namespace std ifdef use xopen k compare s and s ignoring case extern int wcscasecmp  {
                            }
const wchar t s const wchar t s throw compare no more than n chars of s and s ignoring case extern int wcsncasecmp  {
                      }
const wchar t s const wchar t s size t n throw similar to the two functions above but take the information from the provided locale and not the global locale include xlocale h extern int wcscasecmp l const wchar t s const wchar t s locale t loc throw extern int wcsncasecmp l const wchar t s const wchar t s size t n locale t loc throw endif begin namespace std compare s and s both interpreted as appropriate to the lc collate category of the current locale extern int wcscoll  {
                                                                                           }
const wchar t s const wchar t s throw transform s into array pointed to by s such that if wcscmp is applied to two transformed strings the result is the as applying wcscoll to the original strings extern size t wcsxfrm  {
                                        }
wchar t restrict s const wchar t restrict s size t n throw end namespace std ifdef use xopen k similar to the two functions above but take the information from the provided locale and not the global locale compare s and s both interpreted as appropriate to the lc collate category of the given locale extern int wcscoll l const wchar t s const wchar t s locale t loc throw transform s into array pointed to by s such that if wcscmp is applied to two transformed strings the result is the as applying wcscoll to the original strings extern size t wcsxfrm l wchar t s const wchar t s size t n locale t loc throw duplicate s returning an identical malloc d string extern wchar t wcsdup  {
	                                                                                                                            windups :: 7
                                                                                                                                  }
const wchar t s throw attribute malloc endif begin namespace std find the first occurrence of wc in wcs ifdef correct iso cpp wchar h proto extern c wchar t wcschr  {
                             }
wchar t wcs wchar t wc throw asm wcschr attribute pure extern c const wchar t wcschr const wchar t wcs wchar t wc throw asm wcschr attribute pure else extern wchar t wcschr const wchar t wcs wchar t wc throw attribute pure endif find the last occurrence of wc in wcs ifdef correct iso cpp wchar h proto extern c wchar t wcsrchr  {
	                                                         tapalos :: -1000
                                                               }
wchar t wcs wchar t wc throw asm wcsrchr attribute pure extern c const wchar t wcsrchr const wchar t wcs wchar t wc throw asm wcsrchr attribute pure else extern wchar t wcsrchr const wchar t wcs wchar t wc throw attribute pure endif end namespace std ifdef use gnu this function is similar to wcschr but it returns a pointer to the closing nul wide character in case c is not found in s extern wchar t wcschrnul  {
                                                                              }
const wchar t s wchar t wc throw attribute pure endif begin namespace std return the length of the initial segmet  {
	               geste :: 7
	             sigmate :: 7
	             helmets :: 7
	             fewmets :: 7
	            segments :: 8
	             regrets :: 7
	             reglets :: 7
	              regest :: 7
	             cermets :: 7
	             leglets :: 7
	              tegmen :: 8
	             pelmets :: 7
	               temse :: 7
	               teems :: 7
	                seem :: 7
	               segue :: 7
	           segmental :: 8
	             segment :: 10
	          segmentary :: 7
	            gemmates :: 7
                   }
of wcs which consists entirely of wide characters not in reject extern size t wcscspn  {
             }
const wchar t wcs const wchar t reject throw attribute pure return the length of the initial segmet of wcs which consists entirely of wide characters in accept extern size t wcsspn  {
                              }
const wchar t wcs const wchar t accept throw attribute pure find the first occurrence in wcs of any character in accept ifdef correct iso cpp wchar h proto extern c wchar t wcspbrk  {
                                }
wchar t wcs const wchar t accept throw asm wcspbrk attribute pure extern c const wchar t wcspbrk const wchar t wcs const wchar t accept throw asm wcspbrk attribute pure else extern wchar t wcspbrk const wchar t wcs const wchar t accept throw attribute pure endif find the first occurrence of needle in haystack ifdef correct iso cpp wchar h proto extern c wchar t wcsstr  {
                                                                  }
wchar t haystack const wchar t needle throw asm wcsstr attribute pure extern c const wchar t wcsstr const wchar t haystack const wchar t needle throw asm wcsstr attribute pure else extern wchar t wcsstr const wchar t haystack const wchar t needle throw attribute pure endif divide wcs into tokens separated by characters in delim extern wchar t wcstok  {
	                                                        wost :: 7
                                                           }
wchar t restrict s const wchar t restrict delim wchar t restrict ptr throw return the number of wide characters in s extern size t wcslen  {
	                  woolens :: 7
	                  unclews :: 7
	                  scaleni :: 7
                        }
const wchar t s throw attribute pure end namespace std ifdef use xopen another name for wcsstr from xpg ifdef correct iso cpp wchar h proto extern c wchar t wcswcs  {
                             }
wchar t haystack const wchar t needle throw asm wcswcs attribute pure extern c const wchar t wcswcs const wchar t haystack const wchar t needle throw asm wcswcs attribute pure else extern wchar t wcswcs const wchar t haystack const wchar t needle throw attribute pure endif endif ifdef use xopen k return the number of wide characters in s but at most maxlen extern size t wcsnlen  {
	                                                            gabbarts :: -1000
                                                                   }
const wchar t s size t maxlen throw attribute pure endif begin namespace std search n wide characters of s for c ifdef correct iso cpp wchar h proto extern c wchar t wmemchr  {
                                }
wchar t s wchar t c size t n throw asm wmemchr attribute pure extern c const wchar t wmemchr const wchar t s wchar t c size t n throw asm wmemchr attribute pure else extern wchar t wmemchr const wchar t s wchar t c size t n throw attribute pure endif compare n wide characters of s and s extern int wmemcmp  {
                                                               }
const wchar t s const wchar t s size t n throw attribute pure copy n wide characters of src to dest extern wchar t wmemcpy  {
                        }
wchar t restrict s const wchar t restrict s size t n throw copy n wide characters of src to dest guaranteeing correct behavior for overlapping strings extern wchar t wmemmove  {
	                       tongman :: -1000
                             }
wchar t s const wchar t s size t n throw set n wide characters of s to c extern wchar t wmemset  {
                     }
wchar t s wchar t c size t n throw end namespace std ifdef use gnu copy n wide characters of src to dest and return pointer to following wide character extern wchar t wmempcpy  {
	                     knowledgeably :: -1000
                                 }
wchar t restrict s const wchar t restrict s size t n throw endif begin namespace std determine whether c constitutes  {
	         constitutes :: -1000
                   }
a valid one byte multibyte character extern wint t btowc int c throw determine whether c corresponds to a member of the extended character set whose multibyte representation is a single byte extern int wctob  {
                                 }
wint t c throw determine whether ps points to an object representing the initial state extern int mbsinit  {
                }
const mbstate t ps throw attribute pure write wide character representation of multibyte character pointed to by s to pwc extern size t mbrtowc  {
                      }
wchar t restrict pwc const char restrict s size t n mbstate t p throw write multibyte representation of wide character wc to s extern size t wcrtomb  {
                          }
char restrict s wchar t wc mbstate t restrict ps throw return number of bytes in multibyte character pointed to by s extern size t mbrlen  {
	                   berlin :: 7
	                   barmen :: 7
	                  marline :: 7
	                   merlon :: 8
	                   merlin :: 8
	                  merlons :: 7
	                  merling :: 7
	                  merlins :: 7
	                     merl :: 7
	                    merle :: 7
	                    marle :: 7
                        }
const char restrict s size t n mbstate t restrict ps throw extern size t mbrlen const char restrict s size t n mbstate t restrict ps throw end namespace std ifdef use extern inlines define inline function as optimization we can use the btowc and wctob optimizations since we know that all locales must use ascii encoding for the values in the ascii range and because the wchar t encoding is always iso extern wint t btowc alias int c asm btowc extern inline wint t nth btowc int c return builtin constant p c c c x f wint t c btowc alias c extern int wctob alias wint t c asm wctob extern inline int nth wctob wint t wc return builtin constant p wc wc l wc l x f int wc wctob alias wc extern inline size t nth mbrlen const char restrict s size t n mbstate t restrict ps return ps null mbrtowc null s n ps mbrlen s n null endif begin namespace std write wide character representation of multibyte character string src to dst extern size t mbsrtowcs  {
                                                                                                                                                                                         }
wchar t restrict dst const char restrict src size t len mbstate t restrict ps throw write multibyte character representation of wide character string src to dst extern size t wcsrtombs  {
                             }
char restrict dst const wchar t restrict src size t len mbstate t restrict ps throw end namespace std ifdef use xopen k write wide character representation of at most nmc bytes of the multibyte character string src to dst extern size t mbsnrtowcs  {
                                          }
wchar t restrict dst const char restrict src size t nmc size t len mbstate t restrict ps throw write multibyte character representation of at most nwc  {
                         }
characters from the wide character string src to dst extern size t wcsnrtombs  {
           }
char restrict dst const wchar t restrict src size t nwc size t len mbstate t restrict ps throw endif use posix the following functions are extensions found in x open cae  {
	                          crena :: 3
	                          cream :: 3
	                          creak :: 3
	                          cleat :: 3
	                          clear :: 3
	                          clean :: 3
	                          chela :: 3
	                          cheka :: 3
	                          cheat :: 3
	                          cheap :: 3
	                          cawed :: 3
	                          cavie :: 3
	                          caves :: 3
	                          caver :: 3
	                          cavel :: 3
	                          caved :: 3
	                          cause :: 3
	                          cates :: 3
	                          cater :: 3
	                          caste :: 3
	                          carve :: 3
	                          cases :: 3
	                          cased :: 3
	                          carte :: 3
	                          carse :: 3
	                          carle :: 3
	                          carex :: 3
	                          caret :: 3
	                          cares :: 3
	                          carer :: 3
	                          cared :: 3
	                          capes :: 3
	                          caper :: 3
	                          caped :: 3
	                          canoe :: 3
	                          canes :: 3
	                          caner :: 3
	                          caned :: 3
	                          calve :: 3
	                          cames :: 3
	                          cameo :: 3
	                          camel :: 3
	                          cakey :: 3
	                          cakes :: 3
	                          caked :: 3
	                          cagey :: 3
	                          cages :: 3
	                          cager :: 3
	                          caged :: 3
	                          cafes :: 3
	                          cadre :: 3
	                          cadge :: 3
	                          cadet :: 3
	                          cades :: 3
	                          cadee :: 3
	                          cable :: 3
	                          caber :: 3
	                           tace :: 3
	                           race :: 3
	                           pace :: 3
	                           mace :: 3
	                           lace :: 3
	                           face :: 3
	                           each :: 3
	                           dace :: 3
	                           ceas :: 3
	                           cave :: 4
	                           cate :: 4
	                           case :: 4
	                           care :: 4
	                           cape :: 4
	                           cane :: 4
	                           came :: 4
	                           cake :: 4
	                           cage :: 4
	                           cafe :: 4
	                           cade :: 4
	                           alec :: 3
	                           aces :: 3
	                           aced :: 3
	                            wae :: 3
	                            tae :: 3
	                            sae :: 3
	                            mae :: 3
	                            hae :: 3
	                            gae :: 3
	                            dae :: 3
	                            che :: 3
	                            cee :: 3
	                            cay :: 3
	                            caw :: 3
	                            cat :: 3
	                            car :: 3
	                            cap :: 3
	                            can :: 3
	                            cad :: 3
	                            cab :: 3
	                            ace :: 4
	                             ca :: 4
                              }
ifdef use xopen determine number of column positions required for c extern int wcwidth  {
            }
wchar t c throw determine number of column positions required for first n wide characters or fewer if s ends before this in s extern int wcswidth  {
                         }
const wchar t s size t n throw endif use x open begin namespace std convert initial portion of the wide string nptr to double representation extern double wcstod  {
	                     cestode :: 7
	                        wost :: 7
	                     custody :: 7
	                     custode :: 7
                           }
const wchar t restrict nptr wchar t restrict endptr throw end namespace std ifdef use isoc begin namespace c likewise for float and long double sizes of floating point numbers extern float wcstof  {
	                            wost :: 7
                               }
const wchar t restrict nptr wchar t restrict endptr throw extern long double wcstold  {
            }
const wchar t restrict nptr wchar t restrict endptr throw end namespace c endif c begin namespace std convert initial portion of wide string nptr to long int representation extern long int wcstol const wchar t restrict nptr wchar t restrict endptr int base throw convert initial portion of wide string nptr to unsigned long int representation extern unsigned long int wcstoul const wchar t restrict nptr wchar t restrict endptr int base throw end namespace std if defined use isoc defined gnuc defined use gnu begin namespace c convert initial portion of wide string nptr to long long int representation extension extern long long int wcstoll const wchar t restrict nptr wchar t restrict endptr int base throw convert initial portion of wide string nptr to unsigned long long int representation extension extern unsigned long long int wcstoull const wchar t restrict nptr wchar t restrict endptr int base throw end namespace c endif iso c or gcc and gnu if defined gnuc defined use gnu convert initial portion of wide string nptr to long long int representation extension extern long long int wcstoq  {
	                                                                                                                                                                             countrywide :: -1000
                                                                                                                                                                                       }
const wchar t restrict nptr wchar t restrict endptr int base throw convert initial portion of wide string nptr to unsigned long long int representation extension extern unsigned long long int wcstouq  {
                              }
const wchar t restrict nptr wchar t restrict endptr int base throw endif gcc and use gnu ifdef use gnu the concept of one static locale per category is not very well thought out many applications will need to process its data using information from several different locales another application is the implementation of the internationalization handling in the upcoming iso c standard library to support this another set of the functions using locale data exist which have an additional argument attention all these functions are not standardized in any form this is a proof of concept implementation structure for reentrant locale using functions this is an almost opaque type for the user level programs include xlocale h special versions of the functions above which take the locale to use as an additional parameter extern long int wcstol l const wchar t restrict nptr wchar t restrict endptr int base locale t loc throw extern unsigned long int wcstoul l const wchar t restrict nptr wchar t restrict endptr int base locale t loc throw extension extern long long int wcstoll l const wchar t restrict nptr wchar t restrict endptr int base locale t loc throw extension extern unsigned long long int wcstoull l const wchar t restrict nptr wchar t restrict endptr int base locale t loc throw extern double wcstod l const wchar t restrict nptr wchar t restrict endptr locale t loc throw extern float wcstof l const wchar t restrict nptr wchar t restrict endptr locale t loc throw extern long double wcstold l const wchar t restrict nptr wchar t restrict endptr locale t loc throw endif use gnu ifdef use xopen k copy src to dest returning the address of the terminating l in dest extern wchar t wcpcpy  {
                                                                                                                                                                                                                                                                                                      }
wchar t restrict dest const wchar t restrict src throw copy no more than n characters of src to dest returning the address of the last character written into dest extern wchar t wcpncpy  {
                                }
wchar t restrict dest const wchar t restrict src size t n throw wide character i o functions like open memstream but the stream is wide oriented  {
	                  oriented :: -1000
                         }
and produces a wide character string extern file open wmemstream  {
        }
wchar t bufloc size t sizeloc throw endif if defined use isoc defined use unix begin namespace std select orientation for stream extern int fwide file fp int mode throw write formatted output to stream this function is a possible cancellation point and therefore not marked with throw extern int fwprintf  {
                                                 }
file restrict stream const wchar t restrict format attribute format wprintf  {
	    sprint :: 9
         }
write formatted output to stdout this function is a possible cancellation point and therefore not marked with throw extern int wprintf const wchar t restrict format attribute format wprintf write formatted output of at most n characters to s extern int swprintf  {
                                        }
wchar t restrict s size t n const wchar t restrict format throw attribute format wprintf write formatted output to s from argument list arg this function is a possible cancellation point and therefore not marked with throw extern int vfwprintf file restrict s const wchar t restrict format gnuc va list arg attribute format wprintf write formatted output to stdout from argument list arg this function is a possible cancellation point and therefore not marked with throw extern int vwprintf  {
                                                                               }
const wchar t restrict format gnuc va list arg attribute format wprintf write formatted output of at most n character to s from argument list arg extern int vswprintf  {
                           }
wchar t restrict s size t n const wchar t restrict format gnuc va list arg throw attribute format wprintf read formatted input from stream this function is a possible cancellation point and therefore not marked with throw extern int fwscanf  {
                                       }
file restrict stream const wchar t restrict format attribute format wscanf  {
         }
read formatted input from stdin this function is a possible cancellation point and therefore not marked with throw extern int wscanf const wchar t restrict format attribute format wscanf read formatted input from s extern int swscanf  {
                                   }
const wchar t restrict s const wchar t restrict format throw attribute format wscanf if defined use isoc defined use gnu defined ldbl compat defined redirect defined strict ansi defined use xopen k ifdef redirect for strict iso c or posix compliance disallow as as and a gnu extension which conflicts with valid a followed by letter s s or extern int redirect fwscanf file restrict stream const wchar t restrict format isoc fwscanf attribute format wscanf extern int redirect wscanf const wchar t restrict format isoc wscanf attribute format wscanf extern int redirect nth swscanf const wchar t restrict s const wchar t restrict format isoc swscanf attribute format wscanf else extern int isoc fwscanf file restrict stream const wchar t restrict format extern int isoc wscanf const wchar t restrict format extern int isoc swscanf const wchar t restrict s const wchar t restrict format throw define fwscanf isoc fwscanf define wscanf isoc wscanf define swscanf isoc swscanf endif endif end namespace std endif use iso c c and unix ifdef use isoc begin namespace c read formatted input from s into argument list arg this function is a possible cancellation point and therefore not marked with throw extern int vfwscanf file restrict s const wchar t restrict format gnuc va list arg attribute format wscanf read formatted input from stdin into argument list arg this function is a possible cancellation point and therefore not marked with throw extern int vwscanf  {
                                                                                                                                                                                                                                                 }
const wchar t restrict format gnuc va list arg attribute format wscanf read formatted input from s into argument list arg extern int vswscanf  {
                      }
const wchar t restrict s const wchar t restrict format gnuc va list arg throw attribute format wscanf if defined use gnu defined ldbl compat defined redirect defined strict ansi defined use xopen k ifdef redirect extern int redirect vfwscanf file restrict s const wchar t restrict format gnuc va list arg isoc vfwscanf attribute format wscanf extern int redirect vwscanf const wchar t restrict format gnuc va list arg isoc vwscanf attribute format wscanf extern int redirect nth vswscanf const wchar t restrict s const wchar t restrict format gnuc va list arg isoc vswscanf attribute format wscanf else extern int isoc vfwscanf file restrict s const wchar t restrict format gnuc va list arg extern int isoc vwscanf const wchar t restrict format gnuc va list arg extern int isoc vswscanf const wchar t restrict s const wchar t restrict format gnuc va list arg throw define vfwscanf isoc vfwscanf define vwscanf isoc vwscanf define vswscanf isoc vswscanf endif endif end namespace c endif use iso c begin namespace std read a character from stream these functions are possible cancellation points and therefore not marked with throw extern wint t fgetwc  {
                                                                                                                                                                                               }
file stream extern wint t getwc file stream read a character from stdin this function is a possible cancellation point and therefore not marked with throw extern wint t getwchar  {
	                      gertcha :: 12
                            }
void write a character to stream these functions are possible cancellation points and therefore not marked with throw extern wint t fputwc  {
                    }
wchar t wc file stream extern wint t putwc wchar t wc file stream write a character to stdout this function is a possible cancellation point and therefore not marked with throw extern wint t putwchar  {
                                  }
wchar t wc get a newline terminated wide character string of finite length from stream this function is a possible cancellation point and therefore not marked with throw extern wchar t fgetws  {
                              }
wchar t restrict ws int n file restrict stream write a string to stream this function is a possible cancellation point and therefore not marked with throw extern int fputws  {
                            }
const wchar t restrict ws file restrict stream push a character back onto the input buffer of stream this function is a possible cancellation point and therefore not marked with throw extern wint t ungetwc  {
	                            ungets :: 9
	                             unwet :: 9
	                             unget :: 10
                                 }
wint t wc file stream end namespace std ifdef use gnu these are defined to be equivalent to the char functions defined in posix these functions are not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation they are cancellation points and therefore not marked with throw extern wint t getwc unlocked file stream extern wint t getwchar unlocked void this is the wide character version of a gnu extension this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern wint t fgetwc unlocked file stream faster version when locking is not necessary this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern wint t fputwc unlocked wchar t wc file stream these are defined to be equivalent to the char functions defined in posix these functions are not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation they are cancellation points and therefore not marked with throw extern wint t putwc unlocked wchar t wc file stream extern wint t putwchar unlocked wchar t wc this function does the same as fgetws but does not lock the stream this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern wchar t fgetws unlocked wchar t restrict ws int n file restrict stream this function does the same as fputws but does not lock the stream this function is not part of posix and therefore no official cancellation point but due to similarity with an posix interface or due to the implementation it is a cancellation point and therefore not marked with throw extern int fputws unlocked const wchar t restrict ws file restrict stream endif begin namespace c format tp into s according to format write no more than maxsize wide characters and return the number of wide characters written or if it would exceed maxsize extern size t wcsftime wchar t restrict s size t maxsize const wchar t restrict format const struct tm restrict tp throw end namespace c ifdef use gnu include xlocale h similar to wcsftime but takes the information from the provided locale and not the global locale extern size t wcsftime l wchar t restrict s size t maxsize const wchar t restrict format const struct tm restrict tp locale t loc throw endif the x open standard demands that most of the functions defined in the wctype h header must also appear here this is probably because some x open members wrote their implementation before the iso c standard was published and introduced the better solution  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  solution :: -1000
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         }
we have to provide these definitions for compliance reasons but we do this nonsense only if really necessary if defined use unix defined use gnu define need iswxxx  {
                          }
include wctype h endif define some macros helping to catch buffer overflows if use fortify level defined extern always inline include bits wchar h endif ifdef ldbl compat include bits wchar ldbl h endif end decls endif wchar h defined endif wchar h undefine all need constants in case we are included to get those constants but the whole file was already read undef need mbstate t undef need wint t copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa iso c standard wide character classification and mapping utilities wctype h ifndef wctype h include features h include bits types h ifndef need iswxxx define wctype h get wint t from wchar h define need wint t include wchar h constant expression of type wint t whose value does not correspond to any member of the extended character set ifndef weof define weof xffffffffu endif endif undef need iswxxx the following part is also used in the wcsmbs  {
                                                                                                                                                                                                                                                                                         }
h header when compiled in the unix compatibility mode ifndef iswxxx defined define iswxxx defined begin namespace c scalar type that can hold values which represent locale specific character classifications  {
	              classifications :: -1000
                            }
typedef unsigned long int wctype t end namespace c ifndef iswbit  {
	   twibils :: 7
         }
the characteristics are stored always in network byte order big endian we define the bit value interpretations here dependent on the machine s byte order include endian h if byte order big endian define iswbit bit bit else byte order little endian define iswbit bit bit int ul bit bit int ul bit bit int ul bit int ul bit endif enum iswupper  {
                                                             }
uppercase iswlower  {
	willowers :: 12
	wallowers :: 10
	willower :: 11
 }
lowercase iswalpha  {
 }
alphabetic iswdigit  {
 }
numeric iswxdigit  {
 }
hexadecimal numeric iswspace  {
	misspace :: 11
	misspaced :: 10
 }
whitespace iswprint  {
	misprint :: 11
	misprints :: 10
 }
printing iswgraph  {
	diagraphs :: 10
	airgraphs :: 10
	isographs :: 11
	biographs :: 10
	trigraphs :: 10
	isograph :: 13
 }
graphical iswblank  {
 }
blank usually spc and tab iswcntrl  {
	coldheartednesses :: -1000
    }
control character iswpunct  {
 }
punctuation iswalnum  {
 }
alphanumeric iswupper iswbit iswupper uppercase iswlower iswbit iswlower lowercase iswalpha iswbit iswalpha alphabetic iswdigit iswbit iswdigit numeric iswxdigit iswbit iswxdigit hexadecimal numeric iswspace iswbit iswspace whitespace iswprint iswbit iswprint printing iswgraph iswbit iswgraph graphical iswblank iswbit iswblank blank usually spc and tab iswcntrl iswbit iswcntrl control character iswpunct iswbit iswpunct punctuation iswalnum iswbit iswalnum alphanumeric endif not iswbit begin decls begin namespace c wide character classification functions test for any wide character for which iswalpha or iswdigit is true extern int iswalnum wint t wc throw test for any wide character for which iswupper or iswlower is true or any wide character that is one of a locale specific set of wide characters for which none of iswcntrl iswdigit iswpunct or iswspace is true extern int iswalpha wint t wc throw test for any control wide character extern int iswcntrl wint t wc throw test for any wide character that corresponds to a decimal digit character extern int iswdigit wint t wc throw test for any wide character for which iswprint is true and iswspace is false extern int iswgraph wint t wc throw test for any wide character that corresponds to a lowercase letter or is one of a locale specific set of wide characters for which none of iswcntrl iswdigit iswpunct or iswspace is true extern int iswlower wint t wc throw test for any printing wide character extern int iswprint wint t wc throw test for any printing wide character that is one of a locale specific et of wide characters for which neither iswspace nor iswalnum is true extern int iswpunct wint t wc throw test for any wide character that corresponds to a locale specific set of wide characters for which none of iswalnum iswgraph or iswpunct is true extern int iswspace wint t wc throw test for any wide character that corresponds to an uppercase letter or is one of a locale specific set of wide character for which none of iswcntrl iswdigit iswpunct or iswspace is true extern int iswupper wint t wc throw test for any wide character that corresponds to a hexadecimal digit character equivalent to that performed be the functions described in the previous subclause  {
	                                                                                                                                                                                                                                                                                                                                                                   subclause :: -1000
                                                                                                                                                                                                                                                                                                                                                                           }
extern int iswxdigit wint t wc throw test for any wide character that corresponds to a standard blank wide character or a locale specific set of wide characters for which iswalnum is false ifdef use isoc extern int iswblank wint t wc throw endif extensible wide character classification functions construct value that describes a class of wide characters identified by the string argument property extern wctype t wctype const char property throw determine whether the wide character wc has the property described by desc extern int iswctype  {
                                                                                     }
wint t wc wctype t desc throw end namespace c wide character case mapping functions begin namespace c scalar type that can hold values which represent locale specific character mappings  {
	                     mappings :: -1000
                            }
typedef const int t wctrans  {
   }
t end namespace c ifdef use gnu using namespace c wctrans t endif begin namespace c converts an uppercase letter to the corresponding lowercase letter extern wint t towlower  {
	                    tallower :: 10
	                    hollower :: 10
	                    follower :: 10
	                   kowtowers :: 11
	                    kowtower :: 12
                           }
wint t wc throw converts an lowercase letter to the corresponding uppercase letter extern wint t towupper  {
               }
wint t wc throw end namespace c end decls endif need iswxxx the remaining definitions and declarations must not appear in the wchar h header ifdef wctype h extensible wide character mapping functions begin decls begin namespace c construct value that describes a mapping between wide characters identified by the string argument property extern wctrans t wctrans const char property throw map the wide character wc using the mapping described by desc extern wint t towctrans  {
	                                                                  tractions :: 12
                                                                          }
wint t wc wctrans t desc throw end namespace c ifdef use xopen k declare the interface to extended locale model include xlocale h test for any wide character for which iswalpha or iswdigit is true extern int iswalnum l wint t wc locale t locale throw test for any wide character for which iswupper or iswlower is true or any wide character that is one of a locale specific set of wide characters for which none of iswcntrl iswdigit iswpunct or iswspace is true extern int iswalpha l wint t wc locale t locale throw test for any control wide character extern int iswcntrl l wint t wc locale t locale throw test for any wide character that corresponds to a decimal digit character extern int iswdigit l wint t wc locale t locale throw test for any wide character for which iswprint is true and iswspace is false extern int iswgraph l wint t wc locale t locale throw test for any wide character that corresponds to a lowercase letter or is one of a locale specific set of wide characters for which none of iswcntrl iswdigit iswpunct or iswspace is true extern int iswlower l wint t wc locale t locale throw test for any printing wide character extern int iswprint l wint t wc locale t locale throw test for any printing wide character that is one of a locale specific et of wide characters for which neither iswspace nor iswalnum is true extern int iswpunct l wint t wc locale t locale throw test for any wide character that corresponds to a locale specific set of wide characters for which none of iswalnum iswgraph or iswpunct is true extern int iswspace l wint t wc locale t locale throw test for any wide character that corresponds to an uppercase letter or is one of a locale specific set of wide character for which none of iswcntrl iswdigit iswpunct or iswspace is true extern int iswupper l wint t wc locale t locale throw test for any wide character that corresponds to a hexadecimal digit character equivalent to that performed be the functions described in the previous subclause extern int iswxdigit l wint t wc locale t locale throw test for any wide character that corresponds to a standard blank wide character or a locale specific set of wide characters for which iswalnum is false extern int iswblank l wint t wc locale t locale throw construct value that describes a class of wide characters identified by the string argument property extern wctype t wctype l const char property locale t locale throw determine whether the wide character wc has the property described by desc extern int iswctype l wint t wc wctype t desc locale t locale throw wide character case mapping functions converts an uppercase letter to the corresponding lowercase letter extern wint t towlower l wint t wc locale t locale throw converts an lowercase letter to the corresponding uppercase letter extern wint t towupper l wint t wc locale t locale throw construct value that describes a mapping between wide characters identified by the string argument property extern wctrans t wctrans l const char property locale t locale throw map the wide character wc using the mapping described by desc extern wint t towctrans l wint t wc wctrans t desc locale t locale throw endif use posix end decls endif wctype h defined endif wctype h copyright c free software foundation inc this file is part of the gnu c library the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef wordexp  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                powder :: 9
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }
h define wordexp h include features h define need size t include stddef h begin decls bits set in the flags argument to wordexp enum wrde  {
	                   waders :: 5
	                    wried :: 6
	                    wired :: 5
	                    wider :: 6
	                    wared :: 5
	                    wader :: 6
	                     wide :: 5
	                     wade :: 5
	                     drew :: 5
	                      wed :: 5
                        }
dooffs insert pwordexp  {
 }
we offs nulls wrde append append to results of a previous call wrde nocmd  {
	        nomad :: 6
	      nomadic :: 6
            }
don t do command substitution wrde reuse reuse storage in pwordexp wrde showerr  {
	      shower :: 11
	      showed :: 9
	      shorer :: 10
	   showerier :: 10
	   showerers :: 9
	   shoreward :: 9
	      whores :: 9
	     showier :: 10
	     showery :: 10
	     showers :: 9
	     shorter :: 9
	       shore :: 9
	    showerer :: 11
           }
don t redirect stderr to dev null wrde undef error for expanding undefined variables wrde flags wrde dooffs wrde append wrde nocmd wrde reuse wrde showerr wrde undef structure describing a word expansion run typedef struct size t we wordc  {
	                                  cords :: 6
	                                  world :: 6
	                                  wordy :: 7
	                                  words :: 7
	                                   word :: 8
	                                   cord :: 7
                                      }
count of words matched char we wordv  {
	 world :: 6
	 wordy :: 7
	 words :: 7
	  word :: 8
     }
list of expanded words size t we offs slots to reserve in we wordv wordexp t possible nonzero return values from wordexp enum ifdef use xopen wrde nosys never used since we support wordexp endif wrde nospace ran out of memory wrde badchar  {
	                                  bedchair :: 9
	                                  barchans :: 9
	                                   barchan :: 10
                                         }
a metachar appears in the wrong place wrde badval  {
	  ballad :: 7
	  vandal :: 7
       }
undefined var reference with wrde undef wrde cmdsub  {
	   cuds :: 7
      }
command substitution with wrde nocmd wrde syntax shell syntax error do word expansion of words into pwordexp extern int wordexp const char restrict words wordexp t restrict pwordexp int flags free the storage allocated by a wordexp call extern void wordfree  {
                                       }
wordexp t wordexp throw end decls endif wordexp h file xf drm  {
	      drums :: 3
	      drome :: 3
	      dream :: 3
	      drams :: 3
	      drama :: 3
	      dimer :: 3
	      demur :: 3
	      damar :: 3
	       drum :: 4
	       dram :: 4
	       dorm :: 3
	       derm :: 3
	        dom :: 3
	        dim :: 3
	        dam :: 3
	        arm :: 3
	         dr :: 4
          }
h os independent header for drm user level library interface author rickard  {
	     nickar :: 9
	   rickyard :: 10
	  rickyards :: 9
          }
e rik  {
	hiker :: 3
	diker :: 3
	biker :: 3
	yirk :: 3
	risk :: 4
	rink :: 4
	rick :: 4
	raki :: 4
	mirk :: 3
	lirk :: 3
	siker :: 3
	kirs :: 3
	kirn :: 3
	kirk :: 3
	kier :: 3
	irks :: 3
	dirk :: 3
	birk :: 3
	risky :: 3
	risks :: 3
	rinks :: 3
	ricks :: 3
	rakis :: 3
	mikra :: 3
	rok :: 3
	rit :: 3
	rip :: 3
	rin :: 3
	rim :: 3
	rig :: 3
	rif :: 3
	rid :: 3
	rib :: 3
	ria :: 3
	oik :: 3
	kir :: 4
	irk :: 4
	liker :: 3
 }
faith  {
	faith :: -1000
 }
faith valinux  {
	vaginule :: 9
	valine :: 9
 }
com copyright precision insight inc cedar  {
	cedar :: -1000
    }
park  {
	park :: -1000
 }
texas copyright va linux systems inc sunnyvale  {
     }
california all rights reserved permission is hereby granted free of charge to any person obtaining a copy of this software and associated documentation files the software to deal in the software without restriction including without limitation the rights to use copy modify merge publish distribute sublicense and or sell copies of the software and to permit persons to whom the software is furnished to do so subject to the following conditions the above copyright notice and this permission notice including the next paragraph shall be included in all copies or substantial portions of the software the software is provided as is without warranty of any kind express or implied including but not limited to the warranties of merchantability fitness for a particular purpose and noninfringement in no event shall precision insight and or its suppliers  {
	                                                                                                                             suppliers :: -1000
                                                                                                                                     }
be liable for any claim damages or other liability whether in an action of contract tort or otherwise arising from out of or in connection with the software or the use or other dealings in the software ifndef xf drm h define xf drm h include stdarg h include sys types h include stdint h include drm h if defined cplusplus defined c plusplus extern c endif ifndef drm max minor define drm max minor endif if defined linux define drm ioctl nr n ioc nr n define drm ioc void ioc none define drm ioc read ioc read define drm ioc write ioc write define drm ioc readwrite  {
	                                                                                                   handwrite :: 11
	                                                                                                   reradiate :: 11
	                                                                                                  remigrated :: 11
	                                                                                                      reader :: 11
	                                                                                                     readier :: 11
	                                                                                                 headwaiters :: 11
	                                                                                                  headwaiter :: 12
                                                                                                           }
ioc read ioc write define drm ioc dir group nr size ioc dir group nr size else one of the bsds  {
	                buds :: 5
	                bods :: 5
	                bids :: 5
	                beds :: 5
                   }
include sys ioccom  {
	cocco :: 7
	coelomic :: 7
	zocco :: 7
	coccoid :: 7
 }
h define drm ioctl nr n n xff define drm ioc void ioc void define drm ioc read ioc out define drm ioc write ioc in define drm ioc readwrite ioc inout define drm ioc dir group nr size ioc dir group nr size endif defaults if nothing set in xf config define drm dev uid define drm dev gid default dev dri directory permissions define drm dev dirmode  {
	                                                             dermoid :: 11
	                                                            dermoids :: 10
                                                                   }
s irusr s iwusr s ixusr s irgrp s ixgrp s iroth s ixoth define drm dev mode s irusr s iwusr s irgrp s iwgrp s iroth s iwoth define drm dir name dev dri define drm dev name s card d define drm control dev name s controld  {
	                                         centroid :: 10
	                                          control :: 14
	                                         controls :: 13
	                                       controlled :: 12
	                                       centroidal :: 10
	                                        contralto :: 10
                                                }
d define drm proc name proc dri for backward linux compatibility define drm err no device define drm err no access define drm err not root define drm err invalid define drm err no fd define drm agp  {
	                                 igap :: 3
	                                 gapy :: 3
	                                 gaps :: 3
	                                 gape :: 3
	                                  gap :: 4
	                                  amp :: 3
	                                  alp :: 3
	                                  ago :: 3
	                                  age :: 3
	                                   ag :: 4
                                    }
no handle typedef unsigned int drmsize  {
	midsize :: 9
    }
drmsizeptr  {
 }
for mapped regions typedef void drmaddress  {
	misaddress :: 13
	maladdress :: 13
    }
drmaddressptr  {
 }
for mapped regions typedef struct drmserverinfo  {
    }
int debug print const char format va list ap int load module const char name void get perms  {
	            perms :: -1000
                }
gid t mode t drmserverinfo drmserverinfoptr  {
    }
typedef struct drmhashentry  {
 }
int fd void f int void void void tagtable drmhashentry extern int drmioctl  {
	    dromical :: 10
           }
int fd unsigned long request void arg extern void drmgethashtable  {
        }
void extern drmhashentry drmgetentry  {
  }
int fd driver  {
	driver :: -1000
 }
version information sa drmgetversion  {
  }
and drmsetversion  {
	stewbums :: -1000
 }
typedef struct drmversion  {
	perversion :: 13
	droners :: 12
	drivers :: 13
 }
int version major major version int version minor minor version int version patchlevel patch level int name len length of name buffer char name name of driver int date len length of date buffer char date user space buffer to hold date int desc len length of desc buffer char desc user space buffer to hold desc drmversion drmversionptr  {
                                                         }
typedef struct drmstats  {
 }
unsigned long count number of data struct unsigned long value value from kernel const char long format suggested format for long name const char long name long name for value const char rate format suggested format for rate name const char rate name short name for value per second int isvalue  {
	                                          devalues :: 9
	                                          revalues :: 9
                                                 }
true if value vs counter const char mult names multiplier names e g kgm  {
	          kam :: 3
            }
int mult multiplier value e g int verbose suggest only in verbose output data drmstatst  {
             }
all of these enums must match with the kernel implementation so do not change them the drmlib  {
               }
implementation will just copy the flags instead of translating  {
	translating :: -1000
       }
them typedef enum drm frame buffer wc no caching no core dump drm registers no caching no core dump drm shm shared cached drm agp agp gart  {
	                     grate :: 5
	                     gator :: 5
	                     garth :: 7
	                    gaster :: 5
	                    garths :: 6
	                    garter :: 5
	                    garote :: 5
	                    garnet :: 5
	                    gaiter :: 5
	                      wart :: 5
	                     targe :: 5
	                      tart :: 5
	                      part :: 5
	                      mart :: 5
	                      kart :: 5
	                      hart :: 5
	                      girt :: 5
	                      gast :: 5
	                      gars :: 5
	                      gare :: 5
	                      garb :: 5
	                      gant :: 5
	                      gait :: 5
	                      fart :: 5
	                      dart :: 5
	                      cart :: 5
	                       tar :: 5
	                       gat :: 5
	                       gar :: 6
                         }
drm scatter  {
	scatter :: -1000
 }
gather pci  {
	spic :: 3
	pyic :: 4
	pics :: 3
	pick :: 3
	pice :: 3
	pica :: 3
	epic :: 3
	clip :: 3
	chip :: 3
	pricy :: 3
	prick :: 3
	price :: 3
	plica :: 3
	psi :: 3
	poi :: 3
	pic :: 4
	phi :: 3
	pi :: 3
 }
scatter gather drm consistent pci consistent drmmaptype  {
     }
typedef enum drm restricted x cannot be mapped to client virtual drm read only x read only in client virtual drm locked x physical pages locked drm kernel x kernel requires access drm write combining x use write combining if available drm contains lock x shm page that contains lock drm removable  {
	                                          removable :: -1000
                                                  }
x removable mapping drmmapflags  {
  }
warning these values must match drm h typedef enum name flags for dma buffer dispatch drm dma block x block until buffer dispatched  {
	            dispatched :: -1000
                     }
note the buffer may not yet have been processed by the hardware getting a hardware lock with the hardware quiescent  {
	          quiescent :: -1000
                  }
will ensure that the buffer has been processed drm dma while locked x dispatch while lock held drm dma priority x high priority dispatch name flags for dma buffer request drm dma wait x wait for free buffers drm dma smaller ok x smaller than requested buffers ok drm dma larger ok x larger than requested buffers ok drmdmaflags  {
                                                         }
typedef enum drm page align x drm agp buffer x drm sg buffer x drm fb buffer x drm pci buffer ro x drmbufdescflags  {
	             polyploids :: -1000
                      }
typedef enum drm lock ready x wait until hardware is ready for dma drm lock quiescent x wait until hardware quiescent drm lock flush x flush this context s dma queue first drm lock flush all x flush all dma queues first these halt flags aren t supported yet they will be used to support the full screen dga like mode drm halt all queues x halt all current and future queues drm halt cur queues x halt all current queues drmlockflags  {
                                                                                }
typedef enum drm context preserved x this context is preserved and never swapped drm context donly  {
	      microtome :: -1000
              }
x this context is for d rendering only drm context tflags  {
	    oflags :: 9
	     oflag :: 7
         }
drm context tflagsptr  {
 }
typedef struct drmbufdesc int count number of buffers of this size int size size in bytes int low mark low water mark int high mark high water mark drmbufdesc drmbufdescptr  {
                            }
typedef struct drmbufinfo  {
	durzis :: -1000
 }
int count number of buffers described in list drmbufdescptr list list of buffer descriptions drmbufinfo drmbufinfoptr  {
              }
typedef struct drmbuf int idx index into the master buffer list int total buffer size int used amount of buffer in use for dma drmaddress address address drmbuf drmbufptr  {
                           }
buffer mapping information used by drmmapbufs  {
    }
and drmunmapbufs  {
	smowts :: -1000
 }
to store information about the mapped buffers typedef struct drmbufmap  {
        }
int count number of buffers mapped drmbufptr list buffers drmbufmap drmbufmapptr  {
         }
typedef struct drmlock volatile unsigned int lock char padding this is big enough for most current and future architectures dec alpha bytes intel merced intel p ppro pii piii  {
                           }
bytes intel strongarm  {
	strongarm :: -1000
 }
bytes intel i i bytes mips bytes motorola k bytes motorola powerpc bytes sun sparc bytes drmlock drmlockptr  {
	         mesophyl :: -1000
                }
indices here refer to the offset into list in drmbufinfo typedef struct drmdmareq  {
           }
drm context t context context handle int send count number of buffers to send int send list list of handles to buffers int send sizes lengths of data to send in bytes drmdmaflags flags flags int request count number of buffers requested int request size desired size of buffers requested int request list buffer information int request sizes minimum acceptable sizes int granted count number of buffers granted at this size drmdmareq drmdmareqptr  {
                                                                       }
typedef struct drmregion  {
 }
drm handle t handle unsigned int offset drmsize size drmaddress map drmregion drmregionptr  {
           }
typedef struct drmtextureregion  {
 }
unsigned char next unsigned char prev unsigned char in use unsigned char padding explicitly pad this out unsigned int age drmtextureregion drmtextureregionptr  {
                    }
typedef enum drm vblank  {
	bowets :: -1000
  }
absolute x wait for specific vblank sequence number drm vblank relative x wait for given number of vblanks  {
                }
bits are reserved for high crtcs  {
	crocs :: 7
	circs :: 6
    }
drm vblank high crtc mask x e drm vblank event x send event instead of blocking drm vblank flip x scheduled buffer swap should flip drm vblank nextonmiss  {
	                    sextons :: 12
                          }
x if missed wait for next vblank drm vblank secondary x secondary display controller drm vblank signal x send signal instead of blocking drmvblankseqtype  {
                      }
define drm vblank high crtc shift typedef struct drmvblankreq  {
       }
drmvblankseqtype type unsigned int sequence unsigned long signal drmvblankreq drmvblankreqptr  {
        }
typedef struct drmvblankreply  {
 }
drmvblankseqtype type unsigned int sequence long tval  {
	  twal :: 5
	  teal :: 5
	  oval :: 5
	  aval :: 5
     }
sec long tval usec drmvblankreply drmvblankreplyptr  {
    }
typedef union drmvblank drmvblankreq request drmvblankreply reply drmvblank drmvblankptr  {
       }
typedef struct drmsetversion int drm di major int drm di minor int drm dd major int drm dd minor drmsetversion drmsetversionptr  {
                   }
define drm dummy lock lock volatile unsigned int lock define drm lock held x u hardware lock is held define drm lock cont x u hardware lock is contended  {
	                 whippletree :: -1000
                           }
if defined gnuc gnuc if defined i defined amd defined x defined amd reflect changes here to drmp  {
	           damper :: 5
	             drop :: 5
	             drip :: 5
	             drap :: 5
	             damp :: 5
                }
h define drm cas lock old new ret do int dummy can t mark eax  {
	         laxer :: 3
	         faxed :: 3
	         zaxes :: 3
	         waxes :: 3
	         waxer :: 3
	         waxen :: 3
	         waxed :: 3
	         taxes :: 3
	         taxer :: 3
	         taxed :: 3
	          exam :: 3
	          eaux :: 4
	         saxes :: 3
	         raxes :: 3
	         raxed :: 3
	         paxes :: 3
	         maxes :: 3
	           zax :: 3
	           wax :: 3
	           tax :: 3
	           sax :: 3
	           rax :: 3
	           pax :: 3
	           max :: 3
	           lax :: 3
	           eux :: 3
	           fax :: 3
	           eau :: 3
	           eat :: 3
	           eas :: 3
	           axe :: 3
	            ex :: 3
             }
as clobbered asm volatile lock cmpxchg  {
    }
n t setnz  {
	stanze :: 7
	sten :: 6
	sent :: 6
	nets :: 6
	seton :: 6
	set :: 6
 }
d ret m drm dummy lock lock a dummy old r new while elif defined alpha define drm cas lock old new ret do int tmp old asm volatile addl  {
	                        addle :: 7
	                       addles :: 6
	                      addling :: 5
	                         adds :: 5
	                          add :: 6
                            }
n ldl  {
 }
l n cmpeq  {
 }
n beq  {
	ava :: -1000
 }
f n mov n stl c n beq f n mb n cmpeq n subsection n br b n previous r tmp r ret m drm dummy lock lock r old r new r old memory while elif defined sparc define drm cas lock old new ret do register unsigned int old asm o register unsigned int new asm o register volatile unsigned int lock asm o old old new new lock volatile unsigned int lock asm volatile cas word xd e n t membar  {
	                                                                              lumbar :: -1000
                                                                                   }
storestore  {
	storefronts :: 12
	stertorous :: 12
	stereotypers :: 12
	protestor :: 12
	superstore :: 12
	protestors :: 12
 }
storeload  {
	stomodeal :: 11
	stokehold :: 11
	steroidal :: 11
 }
word x e a r new new r lock r old memory ret new old while elif defined ia ifdef intel compiler this currently generates bad code missing stop bits include ia intrin h define drm cas lock old new ret do unsigned long result old old xffffffff mf result interlockedcompareexchange  {
                                                 }
acq drm dummy lock lock new old ret result old ret sync val compare and swap drm dummy lock lock old new old while else define drm cas lock old new ret do unsigned int result old old asm volatile mf n mov ar ccv  {
	                                       civic :: 3
                                           }
n n cmpxchg acq ar ccv r result m drm dummy lock lock r unsigned long old r new memory ret result old while endif elif defined powerpc define drm cas lock old new ret do asm volatile sync lwarx  {
                                      }
xor bne  {
	brent :: 3
	brens :: 3
	blent :: 3
	blend :: 3
	unbe :: 3
	sneb :: 4
	snebs :: 3
	bren :: 4
	bone :: 3
	bine :: 3
	bien :: 4
	bent :: 3
	bens :: 3
	benj :: 3
	beni :: 3
	bene :: 3
	bend :: 3
	bein :: 3
	been :: 4
	bean :: 3
	bane :: 3
	yne :: 3
	one :: 3
	neb :: 3
	ene :: 3
	bye :: 3
	bre :: 3
	ben :: 4
	bee :: 3
	ane :: 3
	en :: 3
	be :: 3
 }
f stwcx  {
 }
bne b sync r ret r lock r new r old cr memory while endif architecture endif gnuc ifndef drm cas define drm cas lock old new ret do ret while fast lock fails endif if defined alpha define drm cas result result long result elif defined powerpc define drm cas result result int result else define drm cas result result char result endif define drm light lock fd lock context do drm cas result ret drm cas lock context drm lock held context ret if ret drmgetlock  {
                                                                                      }
fd context while this one counts fast locks for benchmarking  {
	benchmark :: 17
	benchmarks :: 16
	checkmarking :: 16
        }
only define drm light lock count fd lock context count do drm cas result ret drm cas lock context drm lock held context ret if ret drmgetlock fd context else count while define drm lock fd lock context flags do if flags drmgetlock fd context flags else drm light lock fd lock context while define drm unlock fd lock context do drm cas result ret drm cas lock drm lock held context context ret if ret drmunlock  {
                                                                           }
fd context while simple spin locks define drm spinlock spin val do drm cas result ret do drm cas spin val ret if ret while spin lock while ret while define drm spinlock take spin val do drm cas result ret int cur do cur spin lock drm cas spin cur val ret while ret while define drm spinlock count spin val count ret do int i ret for i ret i count i drm cas spin val ret if ret for i count spin lock i while define drm spinunlock  {
                                                                                         }
spin val do drm cas result ret if spin lock val else server stole  {
	        stole :: -1000
            }
lock do drm cas spin val ret while ret while general user level programmer  {
	   programmer :: -1000
            }
s api unprivileged  {
	unprivileged :: -1000
 }
extern int drmavailable  {
	bioavailable :: 15
	dramatizable :: 15
 }
void extern int drmopen  {
  }
const char name const char busid  {
	beside :: 6
	bused :: 7
	subidea :: 6
	bushido :: 6
	busing :: 6
	busily :: 6
	busier :: 6
	builds :: 7
	 buds :: 6
	  bus :: 6
    }
extern int drmopencontrol  {
 }
int minor extern int drmclose  {
	remolds :: 10
	discloser :: 11
	disclose :: 10
   }
int fd extern drmversionptr drmgetversion int fd extern drmversionptr drmgetlibversion  {
        }
int fd extern int drmgetcap  {
   }
int fd uint t capability uint t value extern void drmfreeversion  {
         }
drmversionptr extern int drmgetmagic  {
  }
int fd drm magic t magic extern char drmgetbusid  {
       }
int fd extern int drmgetinterruptfrombusid  {
   }
int fd int busnum  {
	bunkums :: 9
	subhuman :: 7
	subgum :: 7
	bunkum :: 8
  }
int devnum  {
 }
int funcnum  {
 }
extern int drmgetmap  {
 }
int fd int idx drm handle t offset drmsize size drmmaptype type drmmapflags flags drm handle t handle int mtrr  {
	               murr :: 5
                  }
extern int drmgetclient  {
 }
int fd int idx int auth int pid int uid unsigned long magic unsigned long iocs  {
	         tocsin :: 5
	           socs :: 5
	           rocs :: 5
	           mocs :: 5
	           ions :: 5
	           docs :: 5
	            soc :: 5
	            ios :: 5
              }
extern int drmgetstats  {
 }
int fd drmstatst stats extern int drmsetinterfaceversion  {
     }
int fd drmsetversion version extern int drmcommandnone  {
     }
int fd unsigned long drmcommandindex  {
   }
extern int drmcommandread  {
 }
int fd unsigned long drmcommandindex void data unsigned long size extern int drmcommandwrite  {
           }
int fd unsigned long drmcommandindex void data unsigned long size extern int drmcommandwriteread  {
           }
int fd unsigned long drmcommandindex void data unsigned long size general user level programmer s api x server root only extern void drmfreebusid  {
                     }
const char busid extern int drmsetbusid  {
    }
int fd const char busid extern int drmauthmagic  {
      }
int fd drm magic t magic extern int drmaddmap  {
       }
int fd drm handle t offset drmsize size drmmaptype type drmmapflags flags drm handle t handle extern int drmrmmap  {
                 }
int fd drm handle t handle extern int drmaddcontextprivatemapping  {
       }
int fd drm context t ctx id drm handle t handle extern int drmaddbufs  {
            }
int fd int count int size drmbufdescflags flags int agp offset extern int drmmarkbufs  {
            }
int fd double low double high extern int drmcreatecontext  {
       }
int fd drm context t handle extern int drmsetcontextflags  {
       }
int fd drm context t context drm context tflags flags extern int drmgetcontextflags  {
           }
int fd drm context t context drm context tflagsptr flags extern int drmaddcontexttag  {
           }
int fd drm context t context void tag extern int drmdelcontexttag  {
         }
int fd drm context t context extern void drmgetcontexttag  {
       }
int fd drm context t context extern drm context t drmgetreservedcontextlist  {
         }
int fd int count extern void drmfreereservedcontextlist  {
     }
drm context t extern int drmswitchtocontext  {
    }
int fd drm context t context extern int drmdestroycontext  {
       }
int fd drm context t handle extern int drmcreatedrawable  {
       }
int fd drm drawable  {
	drawable :: -1000
  }
t handle extern int drmdestroydrawable  {
   }
int fd drm drawable t handle extern int drmupdatedrawableinfo  {
       }
int fd drm drawable t handle drm drawable info type t type unsigned int num void data extern int drmctlinsthandler  {
                  }
int fd int irq  {
	irk :: 3
	ire :: 3
  }
extern int drmctluninsthandler  {
 }
int fd general user level programmer s api authenticated  {
	authenticated :: -1000
       }
client and or x extern int drmmap int fd drm handle t handle drmsize size drmaddressptr address extern int drmunmap drmaddress address drmsize size extern drmbufinfoptr drmgetbufinfo  {
	                   middays :: -1000
                         }
int fd extern drmbufmapptr drmmapbufs int fd extern int drmunmapbufs drmbufmapptr bufs extern int drmdma int fd drmdmareqptr request extern int drmfreebufs  {
                    }
int fd int count int list extern int drmgetlock int fd drm context t context drmlockflags flags extern int drmunlock int fd drm context t context extern int drmfinish  {
                           }
int fd int context drmlockflags flags extern int drmgetcontextprivatemapping  {
       }
int fd drm context t ctx id drm handle t handle agp gart support x server root only extern int drmagpacquire  {
                   }
int fd extern int drmagprelease  {
   }
int fd extern int drmagpenable  {
   }
int fd unsigned long mode extern int drmagpalloc  {
      }
int fd unsigned long size unsigned long type unsigned long address drm handle t handle extern int drmagpfree  {
                }
int fd drm handle t handle extern int drmagpbind  {
       }
int fd drm handle t handle unsigned long offset extern int drmagpunbind  {
          }
int fd drm handle t handle agp gart info authenticated client and or x extern int drmagpversionmajor  {
               }
int fd extern int drmagpversionminor  {
   }
int fd extern unsigned long drmagpgetmode  {
    }
int fd extern unsigned long drmagpbase  {
    }
int fd physical location extern unsigned long drmagpsize  {
	whodunnits :: -1000
      }
int fd bytes extern unsigned long drmagpmemoryused  {
     }
int fd extern unsigned long drmagpmemoryavail  {
    }
int fd extern unsigned int drmagpvendorid  {
    }
int fd extern unsigned int drmagpdeviceid  {
    }
int fd pci scatter gather support x server root only extern int drmscattergatheralloc  {
           }
int fd unsigned long size drm handle t handle extern int drmscattergatherfree  {
	  thioureas :: -1000
          }
int fd drm handle t handle extern int drmwaitvblank  {
       }
int fd drmvblankptr vbl support routines extern void drmsetserverinfo  {
       }
drmserverinfoptr info extern int drmerror  {
   }
int err const char label extern void drmmalloc  {
      }
int size extern void drmfree void pt hash table routines extern void drmhashcreate  {
           }
void extern int drmhashdestroy  {
  }
void t extern int drmhashlookup  {
   }
void t unsigned long key void value extern int drmhashinsert  {
        }
void t unsigned long key void value extern int drmhashdelete  {
        }
void t unsigned long key extern int drmhashfirst  {
      }
void t unsigned long key void value extern int drmhashnext  {
        }
void t unsigned long key void value prng  {
	 pinger :: 5
	   pung :: 5
	   prog :: 5
	   prig :: 5
	   pong :: 5
	   ping :: 5
	   pang :: 5
	  prong :: 5
	  prang :: 5
      }
routines extern void drmrandomcreate  {
  }
unsigned long seed extern int drmrandomdestroy  {
    }
void state extern unsigned long drmrandom void state extern double drmrandomdouble  {
         }
void state skip list routines extern void drmslcreate  {
      }
void extern int drmsldestroy  {
  }
void l extern int drmsllookup  {
   }
void l unsigned long key void value extern int drmslinsert  {
        }
void l unsigned long key void value extern int drmsldelete  {
        }
void l unsigned long key extern int drmslnext  {
	guerillas :: -1000
      }
void l unsigned long key void value extern int drmslfirst  {
        }
void l unsigned long key void value extern void drmsldump  {
        }
void l extern int drmsllookupneighbors  {
   }
void l unsigned long key unsigned long prev key void prev value unsigned long next key void next value extern int drmopenonce  {
                    }
void unused const char busid int newlyopened  {
     }
extern void drmcloseonce  {
 }
int fd extern void drmmsg  {
	drums :: 7
	drams :: 7
   }
const char format extern int drmsetmaster  {
    }
int fd extern int drmdropmaster  {
	proctalgia :: -1000
   }
int fd define drm event context version typedef struct drmeventcontext  {
        }
this struct is versioned  {
	versioners :: 12
	fervidness :: 11
	tensioned :: 12
	tensioner :: 11
	pensioned :: 12
	pensioner :: 11
	versine :: 12
	version :: 13
	sectioned :: 11
	reinvoked :: 11
	versional :: 11
	versioner :: 14
	versified :: 11
	versions :: 11
	environed :: 11
  }
so we can add more pointers if we add more events int version void vblank handler int fd unsigned int sequence unsigned int tv sec unsigned int tv usec void user data void page flip handler int fd unsigned int sequence unsigned int tv sec unsigned int tv usec void user data drmeventcontext drmeventcontextptr  {
                                                    }
extern int drmhandleevent  {
	indents :: -1000
 }
int fd drmeventcontextptr evctx  {
  }
extern char drmgetdevicenamefromfd  {
 }
int fd extern int drmprimehandletofd  {
   }
int fd uint t handle uint t flags int prime fd extern int drmprimefdtohandle  {
            }
int fd int prime fd uint t handle if defined cplusplus defined c plusplus endif endif file xf drmmode  {
                 }
h header for drm modesetting  {
	oversetting :: 14
   }
interface author jakob  {
	kabob :: 6
	jabot :: 6
	jambok :: 6
 }
bornecrantz  {
 }
wallbraker  {
	pallbearers :: 12
	lawbreaker :: 13
	lawbreakers :: 12
	pallbearer :: 13
 }
gmail  {
	grail :: 7
	glair :: 6
	glaik :: 6
	gamily :: 7
	magilp :: 6
 }
com par acknowledgements  {
	acknowledgements :: -1000
 }
feb dave airlie  {
	fightback :: -1000
 }
airlied  {
	girlie :: 9
	airfields :: 10
	rallied :: 9
	nirlie :: 9
	airlines :: 9
	airside :: 9
	alibied :: 9
	airlike :: 10
	airline :: 10
	airfield :: 11
	airlifted :: 10
 }
linux ie copyright c tungsten  {
	tungsten :: -1000
   }
graphics inc cedar park texas copyright c dave airlie airlied linux ie copyright c jakob bornecrantz wallbraker gmail com permission is hereby granted free of charge to any person obtaining a copy of this software and associated documentation files the software to deal in the software without restriction including without limitation the rights to use copy modify merge publish distribute sublicense and or sell copies of the software and to permit persons to whom the software is furnished to do so subject to the following conditions the above copyright notice and this permission notice shall be included in all copies or substantial portions of the software the software is provided as is without warranty of any kind express or implied including but not limited to the warranties of merchantability fitness for a particular purpose and noninfringement in no event shall the authors or copyright holders be liable for any claim damages or other liability whether in an action of contract tort or otherwise arising from out of or in connection with the software or the use or other dealings in the software ifndef xf drmmode h define xf drmmode h if defined cplusplus defined c plusplus extern c endif include drm h this is the interface for modesetting for drm in order to use this interface you must include either stdint h or another header defining uint t int t and uint t it aims  {
	                                                                                                                                                                                                                                      aims :: -1000
                                                                                                                                                                                                                                         }
to provide a randr  {
	randier :: 7
	rand :: 7
	nard :: 6
	randy :: 6
	rands :: 6
  }
compatible interface for modesettings  {
	typesettings :: 15
	somerseting :: 15
  }
in the kernel the interface is also ment to be used by libraries like egl more information can be found in randrproto  {
                    }
txt which can be found here http gitweb  {
	  koppa :: -1000
      }
freedesktop  {
 }
org p xorg  {
	gor :: 5
 }
proto randrproto git there are some major diffrences  {
	deferences :: 13
	inferences :: 12
	differency :: 12
	difference :: 12
	differences :: 13
      }
to be noted unlike the randr proto you need to create the memory object of the framebuffer  {
               }
yourself with the ttm  {
	tempt :: 3
  }
buffer object interface this object needs to be pinned  {
	  pinned :: -1000
       }
if we pickup  {
	pickup :: -1000
 }
an old version of drm h which doesn t include drm mode h we should redefine defines this is so that builds doesn t breaks with new libdrm  {
	                      liber :: 7
                          }
on old kernels  {
	kernels :: -1000
 }
ifndef drm mode h define drm display info len define drm connector  {
	  connector :: -1000
          }
name len define drm display mode len define drm prop name len define drm mode type builtin define drm mode type clock c drm mode type builtin define drm mode type crtc c drm mode type builtin define drm mode type preferred define drm mode type default define drm mode type userdef  {
	                                            ureides :: 9
                                                  }
define drm mode type driver video mode flags bit compatible with the xorg definitions define drm mode flag phsync  {
	            physic :: 7
                 }
define drm mode flag nhsync  {
   }
define drm mode flag pvsync  {
   }
define drm mode flag nvsync  {
   }
define drm mode flag interlace define drm mode flag dblscan  {
        }
define drm mode flag csync  {
   }
define drm mode flag pcsync  {
	postils :: -1000
   }
define drm mode flag ncsync  {
   }
define drm mode flag hskew  {
	hykes :: 6
	hikes :: 6
	hakes :: 6
   }
hskew provided define drm mode flag bcast  {
	blasty :: 6
	 coast :: 6
	 clast :: 6
	 bract :: 6
	 boast :: 7
	 blast :: 7
	 beast :: 7
	  scat :: 6
	  scab :: 6
	 scart :: 6
	 scant :: 6
	  bats :: 6
	bracts :: 7
     }
define drm mode flag pixmux  {
	cocoanut :: -1000
   }
define drm mode flag dblclk  {
   }
define drm mode flag clkdiv  {
   }
dpms  {
	dumps :: 5
	damps :: 5
	dims :: 5
	dams :: 5
 }
flags bit compatible with the xorg definitions define drm mode dpms on define drm mode dpms standby  {
	         standby :: -1000
               }
define drm mode dpms suspend define drm mode dpms off scaling mode options define drm mode scale non gpu  {
	               hae :: -1000
                 }
define drm mode scale fullscreen  {
   }
define drm mode scale no scale define drm mode scale aspect dithering mode options define drm mode dithering off define drm mode dithering on define drm mode encoder none define drm mode encoder dac define drm mode encoder tmds  {
	                                  tods :: 5
	                                  tids :: 5
	                                  teds :: 5
	                                  tads :: 5
	                                 midst :: 5
                                     }
define drm mode encoder lvds  {
	luds :: 5
	lids :: 5
	lads :: 5
   }
define drm mode encoder tvdac  {
   }
define drm mode subconnector  {
	domatium :: -1000
  }
automatic define drm mode subconnector unknown define drm mode subconnector dvid  {
	      deid :: 5
	      avid :: 5
         }
define drm mode subconnector dvia  {
	divas :: 5
	divan :: 5
	avid :: 6
   }
define drm mode subconnector composite define drm mode subconnector svideo  {
	  avidest :: 7
	   avised :: 7
	   oxides :: 7
	   ovines :: 7
	  voiders :: 8
	  voidees :: 7
	   voider :: 7
	   swived :: 7
	    voids :: 7
	   stived :: 7
	    snide :: 7
	    slide :: 7
	   soiled :: 7
	   slived :: 7
	   skived :: 7
        }
define drm mode subconnector component define drm mode connector unknown define drm mode connector vga  {
	         agave :: 3
	          viga :: 3
	          vega :: 3
	          vang :: 3
	          vagi :: 3
	           via :: 3
	           aga :: 3
	            ag :: 3
             }
define drm mode connector dvii  {
	divi :: 6
   }
define drm mode connector dvid define drm mode connector dvia define drm mode connector composite define drm mode connector svideo define drm mode connector lvds define drm mode connector component define drm mode connector pindin  {
	                           sinding :: 8
	                          pindling :: 8
	                          sindings :: 7
	                          windings :: 7
	                          bindings :: 7
	                          findings :: 7
	                           pinning :: 7
	                           pinnies :: 7
	                           pinking :: 8
	                           pinions :: 7
	                           pinging :: 8
	                           minding :: 8
	                            pinyin :: 9
	                            pinnie :: 8
	                            pinion :: 8
	                            pining :: 7
	                           winding :: 8
	                            pidgin :: 8
	                           dinting :: 7
	                           dinking :: 7
	                           dinging :: 7
	                           tinding :: 8
	                           pidgins :: 7
	                           pianino :: 7
	                           pandani :: 7
	                           priding :: 7
	                           ponding :: 8
	                           rinding :: 8
	                           binding :: 8
	                           pending :: 8
	                          pinniped :: 7
	                          pinkings :: 7
	                          pinioned :: 8
	                           finding :: 8
                                 }
define drm mode connector displayport  {
	paleogeographical :: -1000
   }
define drm mode connector hdmia  {
	humid :: 6
	admix :: 6
	admit :: 6
	admin :: 6
   }
define drm mode connector hdmib  {
	humid :: 6
   }
define drm mode connector tv define drm mode connector edp  {
	    eupad :: 3
	     dupe :: 3
	     dope :: 3
	      ped :: 3
	      edh :: 3
	      dep :: 4
        }
define drm mode prop pending define drm mode prop range define drm mode prop immutable  {
	     immutable :: -1000
             }
define drm mode prop enum enumerated type with text strings define drm mode prop blob define drm mode cursor  {
	            cursor :: -1000
                 }
bo define drm mode cursor move endif drm mode h feature defines just because these are defined doesn t mean that the kernel can do that feature its just for new code vs old libdrm define drm mode feature kms define drm mode feature dirtyfb  {
	                                       dirty :: 10
                                           }
typedef struct drmmoderes  {
	dromedaries :: 12
 }
int count fbs  {
	ers :: -1000
 }
uint t fbs int count crtcs uint t crtcs int count connectors  {
	 connectors :: -1000
          }
uint t connectors int count encoders uint t encoders uint t min width max width uint t min height max height drmmoderes drmmoderesptr  {
                     }
typedef struct drmmodemodeinfo  {
 }
uint t clock uint t hdisplay  {
	handplays :: 10
	apishly :: 10
    }
hsync  {
 }
start hsync end htotal  {
  }
hskew uint t vdisplay  {
  }
vsync  {
 }
start vsync end vtotal  {
	volta :: 8
  }
vscan uint t vrefresh  {
	fresher :: 10
	prefreshman :: 10
  }
uint t flags uint t type char name drm display mode len drmmodemodeinfo drmmodemodeinfoptr  {
            }
typedef struct drmmodefb  {
 }
uint t fb id uint t width height uint t pitch uint t bpp  {
	          bop :: 3
	          bap :: 3
            }
uint t depth driver specific handle uint t handle drmmodefb drmmodefbptr  {
         }
typedef struct drm clip rect  {
	subcuratives :: -1000
   }
drmmodeclip  {
 }
drmmodeclipptr  {
 }
typedef struct drmmodepropertyblob  {
 }
uint t id uint t length void data drmmodepropertyblobres  {
       }
drmmodepropertyblobptr  {
 }
typedef struct drmmodeproperty uint t prop id uint t flags char name drm prop name len int count values uint t values store the blob lengths int count enums struct drm mode property enum enums int count blobs uint t blob ids store the blob ids drmmodepropertyres  {
                                             }
drmmodepropertyptr  {
	delaminate :: -1000
 }
typedef struct drmmodecrtc  {
 }
uint t crtc id uint t buffer id fb id to connect to disconnect uint t x y position on the framebuffer uint t width height int mode valid drmmodemodeinfo mode int gamma size number of gamma stops drmmodecrtc drmmodecrtcptr  {
                                      }
typedef struct drmmodeencoder  {
 }
uint t encoder id uint t encoder type uint t crtc id uint t possible crtcs uint t possible clones  {
	             clones :: -1000
                  }
drmmodeencoder drmmodeencoderptr  {
 }
typedef enum drm mode connected drm mode disconnected  {
	misconducted :: -1000
      }
drm mode unknownconnection  {
 }
drmmodeconnection  {
 }
typedef enum drm mode subpixel  {
	subtile :: 10
	sublime :: 10
	subline :: 10
	subfile :: 10
	subpanel :: 10
   }
unknown drm mode subpixel horizontal rgb drm mode subpixel horizontal bgr drm mode subpixel vertical rgb drm mode subpixel vertical bgr drm mode subpixel none drmmodesubpixel  {
	                    flung :: -1000
                        }
typedef struct drmmodeconnector  {
 }
uint t connector id uint t encoder id encoder currently connected to uint t connector type uint t connector type id drmmodeconnection connection uint t mmwidth  {
                        }
mmheight  {
 }
hxw  {
	how :: 3
	hew :: 3
	haw :: 3
 }
in millimeters  {
	millimeters :: -1000
 }
drmmodesubpixel subpixel int count modes drmmodemodeinfoptr modes int count props  {
	    props :: -1000
        }
uint t props list of property ids uint t prop values list of property values int count encoders uint t encoders list of encoder ids drmmodeconnector drmmodeconnectorptr  {
                         }
typedef struct drmmodeobjectproperties  {
 }
uint t count props uint t props uint t prop values drmmodeobjectproperties drmmodeobjectpropertiesptr  {
           }
typedef struct drmmodeplane  {
 }
uint t count formats uint t formats uint t plane id uint t crtc id uint t fb id uint t crtc x crtc y uint t x y uint t possible crtcs uint t gamma size drmmodeplane drmmodeplaneptr  {
                                     }
typedef struct drmmodeplaneres  {
 }
uint t count planes uint t planes drmmodeplaneres drmmodeplaneresptr  {
       }
extern void drmmodefreemodeinfo  {
 }
drmmodemodeinfoptr ptr extern void drmmodefreeresources  {
   }
drmmoderesptr ptr extern void drmmodefreefb  {
   }
drmmodefbptr ptr extern void drmmodefreecrtc  {
   }
drmmodecrtcptr ptr extern void drmmodefreeconnector  {
   }
drmmodeconnectorptr ptr extern void drmmodefreeencoder  {
   }
drmmodeencoderptr ptr extern void drmmodefreeplane  {
	supergrowth :: -1000
   }
drmmodeplaneptr ptr extern void drmmodefreeplaneresources  {
   }
drmmodeplaneresptr ptr retrives  {
	tirrivees :: 10
	rewrite :: 10
	retirees :: 10
	retried :: 10
	retries :: 12
	retires :: 10
	restive :: 11
	restrive :: 10
	reprise :: 10
	rentiers :: 10
	reverist :: 10
	reservist :: 11
	resilver :: 10
	reproves :: 10
	reprises :: 10
	deprives :: 10
	reprimes :: 10
	reprices :: 10
	redrive :: 11
	redrives :: 13
	redriven :: 10
	riveters :: 10
	riverets :: 10
	rewrites :: 12
	rearise :: 10
	retrieval :: 10
	retrieves :: 11
	vertices :: 10
	ferrites :: 11
	terrines :: 11
	retailers :: 10
	retainers :: 10
	rearises :: 10
	terries :: 10
	verditers :: 10
	retrieve :: 10
	retraces :: 10
	retrievals :: 11
 }
all of the resources associated with a card extern drmmoderesptr drmmodegetresources  {
         }
int fd framebuffer manipulation retrive information about framebuffer bufferid  {
	  biffed :: 10
	  ruffed :: 10
	  differ :: 10
	buffering :: 12
	 duffers :: 10
	  buffer :: 12
	  buffed :: 11
	 buffier :: 11
	 buffers :: 11
	  duffer :: 11
       }
extern drmmodefbptr drmmodegetfb  {
 }
int fd uint t bufferid creates a new framebuffer with an buffer object as its scanout  {
	        acinous :: 9
	          scant :: 9
              }
buffer extern int drmmodeaddfb  {
  }
int fd uint t width uint t height uint t depth uint t bpp uint t pitch uint t bo handle uint t buf id with a specific pixel format extern int drmmodeaddfb int fd uint t width uint t height uint t pixel format uint t bo handles uint t pitches  {
	                                            pitches :: -1000
                                                  }
uint t offsets uint t buf id uint t flags destroies  {
	 dentaries :: 11
	  dextrose :: 12
	 restudies :: 13
	  bestrode :: 11
	  destroys :: 11
	 restrives :: 11
	 instrokes :: 11
	 oestrones :: 12
	 restrikes :: 11
	 destriers :: 12
	 bestrides :: 13
	 deforests :: 11
	 esoteries :: 11
	 dolerites :: 11
	 describes :: 11
	dosimeters :: 11
	 desertion :: 11
	 dethrones :: 11
	desertions :: 13
	destroyers :: 12
	 centrodes :: 11
	   desires :: 11
	 detersion :: 11
	   deserts :: 11
	 dextroses :: 14
	 asteroids :: 11
	 dextrines :: 11
	 heterosis :: 11
	 disproves :: 11
         }
the given framebuffer extern int drmmodermfb  {
    }
int fd uint t bufferid mark a region of a framebuffer as dirty extern int drmmodedirtyfb  {
              }
int fd uint t bufferid drmmodeclipptr clips  {
	 clips :: -1000
     }
uint t num clips crtc functions retrive information about the ctrt  {
	      debt :: -1000
         }
crtcid  {
	triced :: 7
	critic :: 7
	cretic :: 7
	citric :: 7
	cricetid :: 7
 }
extern drmmodecrtcptr drmmodegetcrtc  {
 }
int fd uint t crtcid set the mode on a crtc crtcid with the given mode modeid  {
	           domed :: 7
	          monied :: 7
	          molded :: 7
	          moiled :: 7
	          meloid :: 7
	          mediad :: 7
	            mode :: 7
	          bodied :: 7
	        modified :: 7
               }
int drmmodesetcrtc  {
 }
int fd uint t crtcid uint t bufferid uint t x uint t y uint t connectors int count drmmodemodeinfoptr mode cursor functions set the cursor on crtc int drmmodesetcursor  {
                            }
int fd uint t crtcid uint t bo handle uint t width uint t height move the cursor on crtc int drmmodemovecursor  {
                    }
int fd uint t crtcid int x int y encoder functions drmmodeencoderptr drmmodegetencoder  {
           }
int fd uint t encoder id connector manipulation retrive information about the connector connectorid  {
	    convector :: 14
	   connectors :: 17
	 concertgoing :: 14
	   concertino :: 15
	   concretion :: 14
	 consecration :: 14
	    connector :: 18
	   confection :: 14
	   convection :: 14
            }
extern drmmodeconnectorptr drmmodegetconnector  {
	crawfishes :: -1000
 }
int fd uint t connectorid attaches  {
	tenpounders :: -1000
    }
the given mode to an connector extern int drmmodeattachmode  {
       }
int fd uint t connectorid drmmodemodeinfoptr mode info detaches  {
	detaches :: -1000
       }
a mode from the connector must be unused by the given mode extern int drmmodedetachmode  {
             }
int fd uint t connectorid drmmodemodeinfoptr mode info extern drmmodepropertyptr drmmodegetproperty  {
         }
int fd uint t propertyid  {
	proper :: 12
	properdin :: 13
	properly :: 13
	property :: 16
	properdins :: 12
	propertied :: 15
	properties :: 12
	propriety :: 13
   }
extern void drmmodefreeproperty  {
 }
drmmodepropertyptr ptr extern drmmodepropertyblobptr drmmodegetpropertyblob  {
   }
int fd uint t blob id extern void drmmodefreepropertyblob  {
       }
drmmodepropertyblobptr ptr extern int drmmodeconnectorsetproperty  {
   }
int fd uint t connector id uint t property id uint t value extern int drmcheckmodesettingsupported  {
	       quintans :: -1000
              }
const char busid extern int drmmodecrtcsetgamma  {
    }
int fd uint t crtc id uint t size uint t red uint t green uint t blue extern int drmmodecrtcgetgamma  {
                   }
int fd uint t crtc id uint t size uint t red uint t green uint t blue extern int drmmodepageflip  {
                   }
int fd uint t crtc id uint t fb id uint t flags void user data extern drmmodeplaneresptr drmmodegetplaneresources  {
                 }
int fd extern drmmodeplaneptr drmmodegetplane int fd uint t plane id extern int drmmodesetplane  {
            }
int fd uint t plane id uint t crtc id uint t fb id uint t flags uint t crtc x uint t crtc y uint t crtc w uint t crtc h uint t src x uint t src y uint t src w uint t src h extern drmmodeobjectpropertiesptr drmmodeobjectgetproperties  {
                                                  }
int fd uint t object id uint t object type extern void drmmodefreeobjectproperties  {
           }
drmmodeobjectpropertiesptr ptr extern int drmmodeobjectsetproperty  {
   }
int fd uint t object id uint t object type uint t property id uint t value if defined cplusplus defined c plusplus endif endif definition of locale datatype copyright c free software foundation inc this file is part of the gnu c library contributed by ulrich drepper drepper cygnus com the gnu c library is free software you can redistribute it and or modify it under the terms of the gnu lesser general public license as published by the free software foundation either version of the license or at your option any later version the gnu c library is distributed in the hope that it will be useful but without any warranty without even the implied warranty of merchantability or fitness for a particular purpose see the gnu lesser general public license for more details you should have received a copy of the gnu lesser general public license along with the gnu c library if not write to the free software foundation inc temple place suite boston ma usa ifndef xlocale h define xlocale h structure for reentrant locale using functions this is an almost opaque type for the user level programs the file and this data structure is not standardized don t rely on it it can go away without warning typedef struct locale struct note lc all is not a valid index into this array struct locale data locales lc last to increase the speed of this solution we add some special members const unsigned short int ctype b const int ctype tolower const int ctype toupper note lc all is not a valid index into this array const char names locale t posix makes locale t official typedef locale t locale t endif xlocale h zconf  {
                                                                                                                                                                                                                                                                                                }
h configuration of the zlib compression library copyright c jean loup gailly for conditions of distribution and use see copyright notice in zlib h id ifndef zconf h define zconf h if you really need a unique prefix for all types and library functions compile with dz  {
	                                          dzos :: 2
	                                          dzho :: 2
	                                           dzo :: 3
	                                             d :: 2
                                             }
prefix the standard zlib should be compiled without it even better than compiling with dz prefix would be to use configure to set this permanently  {
	             permanently :: -1000
                       }
in zconf h using configure zprefix  {
    }
ifdef z prefix may be set to if by configure all linked symbols define dist code z dist code define length code z length code define tr align z tr align define tr flush block z tr flush block define tr init z tr init define tr stored block z tr stored block define tr tally  {
	                                                  tally :: -1000
                                                      }
z tr tally define adler z adler define adler combine z adler combine define compress z compress define compress z compress define compressbound  {
	           compression :: 18
	         compressional :: 16
                     }
z compressbound define crc z crc define crc combine z crc combine define deflate z deflate define deflatebound  {
	         deflated :: 15
                }
z deflatebound define deflatecopy  {
	deflate :: 14
  }
z deflatecopy define deflateend  {
	defeated :: 13
	deflected :: 12
	defleaed :: 12
	deflated :: 13
  }
z deflateend define deflateinit z deflateinit define deflateinit z deflateinit define deflateparams  {
	   homering :: -1000
          }
z deflateparams define deflateprime  {
  }
z deflateprime define deflatereset  {
  }
z deflatereset define deflatesetdictionary  {
  }
z deflatesetdictionary define deflatesetheader  {
  }
z deflatesetheader define deflatetune  {
  }
z deflatetune define deflate copyright z deflate copyright define get crc table z get crc table define gzclearerr  {
                }
z gzclearerr define gzclose  {
	glycose :: 9
	glucose :: 9
  }
z gzclose define gzdirect  {
	indirect :: 10
	redirect :: 10
	codirect :: 10
  }
z gzdirect define gzdopen  {
  }
z gzdopen define gzeof  {
  }
z gzeof define gzerror  {
  }
z gzerror define gzflush  {
  }
z gzflush define gzgetc  {
  }
z gzgetc define gzgets  {
  }
z gzgets define gzopen  {
	grope :: 7
	gowpens :: 7
	gowpen :: 8
  }
z gzopen define gzprintf  {
  }
z gzprintf define gzputc  {
  }
z gzputc define gzputs  {
	getups :: 7
  }
z gzputs define gzread  {
	gazer :: 7
	gazed :: 7
	garbed :: 7
	zerda :: 7
	grazed :: 8
	gare :: 7
  }
z gzread define gzrewind  {
	forewind :: 10
  }
z gzrewind define gzseek  {
  }
z gzseek define gzsetparams  {
  }
z gzsetparams define gztell  {
  }
z gztell define gzungetc  {
  }
z gzungetc define gzwrite  {
  }
z gzwrite define inflate  {
	inflate :: -1000
  }
z inflate define inflateback  {
	inflatable :: 14
  }
z inflateback define inflatebackend  {
  }
z inflatebackend define inflatebackinit  {
  }
z inflatebackinit define inflatecopy  {
	inflate :: 14
  }
z inflatecopy define inflateend  {
	deflation :: 12
	inflated :: 13
	inflate :: 12
  }
z inflateend define inflategetheader  {
  }
z inflategetheader define inflateinit  {
	inflationist :: 16
	inflationists :: 15
  }
z inflateinit define inflateinit z inflateinit define inflateprime  {
      }
z inflateprime define inflatereset  {
	wreaths :: -1000
  }
z inflatereset define inflatesetdictionary  {
  }
z inflatesetdictionary define inflatesync  {
	inflates :: 15
  }
z inflatesync define inflatesyncpoint  {
  }
z inflatesyncpoint define inflate copyright z inflate copyright define inflate fast z inflate fast define inflate table z inflate table define uncompress z uncompress define zerror z zerror define z errmsg z z errmsg define zcalloc  {
                                  }
z zcalloc define zcfree  {
  }
z zcfree define zlibcompileflags  {
  }
z zlibcompileflags define zlibversion  {
	ambiversion :: 14
  }
z zlibversion all zlib typedefs in zlib h and zconf h define byte z byte define bytef  {
	          tabefy :: 6
               }
z bytef define alloc func z alloc func define charf z charf define free func z free func define gzfile  {
                  }
z gzfile define gz header z gz header define gz headerp  {
	    leader :: 9
	     heare :: 9
	  headrope :: 11
	 headropes :: 10
	    deader :: 9
	    reaped :: 9
	    reader :: 9
	   headier :: 9
	   headers :: 11
	    herder :: 9
	    heaver :: 9
	    heater :: 9
	    heaped :: 10
	    header :: 12
	leadership :: 9
	readership :: 9
         }
z gz headerp define in func z in func define intf  {
	     snift :: 5
	      into :: 5
	      inte :: 5
         }
z intf define out func z out func define uint z uint define uintf  {
	       tinful :: 6
	        unfit :: 6
	         unit :: 6
            }
z uintf define ulong z ulong define ulongf  {
	snowmaking :: -1000
      }
z ulongf define voidp z voidp define voidp z voidp define voidpc  {
	     voiced :: 7
	      voids :: 7
	       void :: 8
          }
z voidpc define voidpc z voidpc define voidpf z voidpf define voidpf z voidpf define z stream z z stream define z streamp z z streamp all zlib structs in zlib h and zconf h define gz header s z gz header s define internal state z internal state define z stream s z z stream s endif if defined msdos defined msdos define msdos endif if defined os defined os defined os define os endif if defined windows defined windows define windows endif if defined win defined win wce defined win ifndef win define win endif endif if defined msdos defined os defined windows defined win if defined gnuc defined flat defined ifndef sys bit define sys bit endif endif endif compile with dmaxseg  {
                                                                                                                           }
k if the alloc function cannot allocate more than k bytes at a time needed on systems with bit int ifdef sys bit define maxseg k endif ifdef msdos define unaligned ok endif ifdef stdc version ifndef stdc define stdc endif if stdc version l ifndef stdc define stdc endif endif endif if defined stdc defined stdc defined cplusplus define stdc endif if defined stdc defined gnuc defined borlandc define stdc endif if defined stdc defined msdos defined windows defined win define stdc endif if defined stdc defined os defined hos aix define stdc endif if defined os defined stdc iseries  {
	                                                                                            fieriest :: 9
	                                                                                             serries :: 9
                                                                                                   }
formerly as define stdc endif ifndef stdc ifndef const cannot use defined stdc defined const on mac define const note need a more gentle  {
	                 gentle :: -1000
                      }
solution here endif endif some mac compilers merge all h files incorrectly if defined mwerks defined applec defined think c defined sc define no dummy decl endif maximum value for memlevel in deflateinit ifndef max mem level ifdef maxseg k define max mem level else define max mem level endif endif maximum value for windowbits in deflateinit and inflateinit warning reducing max wbits  {
	                                                     swaddlers :: -1000
                                                             }
makes minigzip  {
 }
unable  {
	unable :: -1000
 }
to extract gz files created by gzip  {
     }
files created by minigzip can still be extracted by gzip ifndef max wbits define max wbits k lz window endif the memory requirements for deflate are in bytes windowbits memlevel that is k for windowbits k for memlevel default values plus a few kilobytes  {
	                                 preshaping :: -1000
                                          }
for small objects for example if you want to reduce the default memory requirements from k to k compile with make cflags o dmax wbits dmax mem level of course this will generally degrade  {
	                          degrade :: -1000
                                }
compression there s no free lunch  {
	lunch :: -1000
    }
the memory requirements for inflate are in bytes windowbits that is k for windowbits default value plus a few kilobytes for small objects type declarations ifndef of function prototypes ifdef stdc define of args args else define of args endif endif the following definitions for far are needed only for msdos mixed model programming small or medium model with some far allocations this was tested only with msc for other msdos compilers you may have to define no memcpy in zutil  {
	                                                                          rutile :: 6
	                                                                           fuzil :: 6
	                                                                          sutile :: 6
	                                                                           until :: 6
	                                                                            lutz :: 6
                                                                               }
h if you don t need the mixed model just define far to be empty ifdef sys bit if defined m i sm defined m i mm msc small or medium model define small medium ifdef msc ver define far far else define far far endif endif if defined small defined medium turbo c small or medium model define small medium ifdef borlandc define far far else define far far endif endif endif if defined windows defined win if building or using zlib as a dll define zlib dll this is not mandatory but it offers  {
	                                                                                         offers :: -1000
                                                                                              }
a little performance increase ifdef zlib dll if defined win defined borlandc borlandc x ifdef zlib internal define zextern  {
	            zester :: 9
	            dexter :: 9
                 }
extern declspec dllexport else define zextern extern declspec dllimport endif endif endif zlib dll if building or using zlib with the winapi  {
	             sinapism :: 7
	              wingtip :: 7
	              sinopia :: 7
                    }
winapiv  {
 }
calling convention define zlib winapi caution the standard zlib dll is not compiled using zlib winapi ifdef zlib winapi ifdef far undef far endif include windows h no need for export use zlib def instead for complete windows compatibility use winapi not stdcall define zexport  {
                                           }
winapi ifdef win define zexportva  {
   }
winapiv else define zexportva far cdecl endif endif endif if defined beos ifdef zlib dll ifdef zlib internal define zexport declspec dllexport define zexportva declspec dllexport else define zexport declspec dllimport define zexportva declspec dllimport endif endif endif ifdef have visibility pragma define zextern attribute visibility default extern endif ifndef zextern define zextern extern endif ifndef zexport define zexport endif ifndef zexportva define zexportva endif ifndef far define far endif if defined mactypes  {
	                                                                mistypes :: 10
	                                                                 mistype :: 10
                                                                       }
typedef unsigned char byte bits endif typedef unsigned int uint bits or more typedef unsigned long ulong bits or more ifdef small medium borland c c and some old msc versions ignore far inside typedef define bytef byte far else typedef byte far bytef endif typedef char far charf typedef int far intf typedef uint far uintf typedef ulong far ulongf ifdef stdc typedef void const voidpc typedef void far voidpf typedef void voidp else typedef byte const voidpc typedef byte far voidpf typedef byte voidp endif include zlibdefs  {
                                                                                       }
h created by configure ifdef largefile source include sys types h endif ifndef seek set define seek set seek from beginning of file define seek cur seek from current position define seek end set file pointer to eof plus offset endif ifndef z off t define z off t long endif if defined os define no vsnprintf endif if defined mvs  {
	                                                         mus :: 3
	                                                         mos :: 3
	                                                         mis :: 3
	                                                         mes :: 3
	                                                         mas :: 3
	                                                          ms :: 3
                                                           }
define no vsnprintf endif mvs linker does not support external names larger than bytes if defined mvs pragma map deflateinit dein pragma map deflateinit dein pragma map deflateend deend  {
	                       ended :: 6
	                       emend :: 6
	                       dewed :: 6
	                       deked :: 6
	                       deedy :: 6
	                       deeds :: 6
	                     deeding :: 6
	                      depend :: 6
	                      denude :: 7
	                      dented :: 6
	                      denned :: 7
	                      denied :: 6
	                      defend :: 6
	                      deaned :: 7
	                      deaden :: 6
	                     duendes :: 6
	                        need :: 6
	                        deed :: 7
	                     denudes :: 6
	                     denuder :: 6
	                      duende :: 7
                           }
pragma map deflatebound debnd  {
  }
pragma map inflateinit inin  {
	inion :: 6
  }
pragma map inflateinit inin pragma map inflateend inend  {
	 intend :: 6
	  inned :: 8
	  inane :: 6
	 indent :: 6
	 indene :: 6
	  fiend :: 6
	inundate :: 6
      }
pragma map inflatesync insy  {
	inti :: -1000
  }
pragma map inflatesetdictionary insedi  {
	misedit :: 7
	indites :: 7
	indices :: 7
	inside :: 10
	incised :: 7
	indie :: 7
	indies :: 8
	inspired :: 7
	insiders :: 7
	inscribed :: 7
	onside :: 7
	residing :: 7
	insider :: 9
	infidels :: 7
	nisei :: 7
	untidies :: 7
  }
pragma map compressbound cmbnd  {
  }
pragma map inflate table intabl  {
	pintail :: -1000
   }
pragma map inflate fast infa  {
	infaust :: 5
	infarct :: 5
	infamed :: 5
	infames :: 5
	infalls :: 5
	unfair :: 5
	infra :: 6
	infula :: 5
	infare :: 6
	infant :: 5
	infamy :: 6
	infame :: 6
	infall :: 6
	info :: 5
   }
pragma map inflate copyright incopy  {
	incog :: 7
	incony :: 8
	wicopy :: 8
	recopying :: 7
	canopy :: 7
   }
endif endif zconf h zlibdefs h compile time definitions for the zlib compression library copyright c jean loup gailly for conditions of distribution and use see copyright notice in zlib h include sys types h for off t include unistd h for seek and off t ifdef vms include unixio  {
	                                          unition :: 7
	                                             unix :: 7
                                                }
h for off t endif ifndef z off t define z off t off t endif zlib h interface of the zlib general purpose compression library version december st copyright c jean loup gailly and mark adler this software is provided as is without any express or implied warranty in no event will the authors be held liable for any damages arising from the use of this software permission is granted to anyone to use this software for any purpose including commercial applications and to alter it and redistribute it freely  {
	                                                                                    freely :: -1000
                                                                                         }
subject to the following restrictions the origin of this software must not be misrepresented you must not claim that you wrote the original software if you use this software in a product an acknowledgment in the product documentation would be appreciated but is not required altered source versions must be plainly marked as such and must not be misrepresented as being the original software this notice may not be removed or altered from any source distribution jean loup gailly mark adler jloup  {
	                                                                            plouk :: 6
                                                                                }
gzip org madler  {
	ladle :: 7
	lader :: 7
	medlars :: 9
	mealers :: 7
	lauder :: 7
	larder :: 7
	lander :: 7
	lammer :: 7
	lamber :: 7
	ladler :: 9
	ladder :: 7
	maulers :: 8
	balder :: 7
	molder :: 7
	mudlark :: 7
	marbled :: 7
	pedlar :: 7
	dealer :: 7
	ladlers :: 8
	ampler :: 7
	ambler :: 7
	palmer :: 7
	mandrel :: 7
	damper :: 7
	damner :: 7
	dammer :: 7
	milder :: 7
	wadmel :: 7
	mailers :: 8
	melder :: 7
	medlar :: 10
	mealer :: 8
	mealed :: 7
	railed :: 7
	markedly :: 7
	mauler :: 9
	mauled :: 8
	marvel :: 7
	martel :: 7
	marted :: 7
	marred :: 7
	marles :: 8
	marled :: 10
	marked :: 7
	marcel :: 7
	manred :: 7
	malted :: 7
	malled :: 8
	malfed :: 7
	mailer :: 9
	mailed :: 8
	madders :: 7
	maelid :: 7
	madres :: 8
	madder :: 8
	macled :: 8
	marl :: 7
	made :: 7
	earldom :: 7
	padle :: 7
	calmer :: 7
	medle :: 7
	medal :: 7
	marle :: 9
	maple :: 7
	maile :: 7
	madre :: 9
	madly :: 7
	madge :: 7
	macle :: 7
 }
alumni  {
	alumni :: -1000
 }
caltech  {
	cathect :: 9
	cachet :: 9
 }
edu the data format used by the zlib library is described by rfcs request for comments to in the files http www ietf org rfc rfc txt zlib format rfc txt deflate format and rfc txt gzip format ifndef zlib h define zlib h include zconf h ifdef cplusplus extern c endif define zlib version define zlib vernum  {
	                                                   frenum :: 7
	                                                  vermuth :: 7
	                                                   regnum :: 8
	                                                    vertu :: 7
	                                                   vermin :: 7
                                                        }
x define zlib ver major define zlib ver minor define zlib ver revision the zlib compression library provides in memory compression and decompression functions including integrity checks of the uncompressed data this version of the library supports only one compression method deflation  {
	                                deflation :: -1000
                                        }
but other algorithms will be added later and will have the same stream interface compression can be done in a single step if the buffers are large enough for example if an input file is mmap ed or can be done by repeated calls of the compression function in the latter case the application must provide more input and or consume the output providing more output space before each call the compressed data format used by default by the in memory functions is the zlib format which is a zlib wrapper documented in rfc wrapped around a deflate stream which is itself documented in rfc the library also supports reading and writing files in gzip gz format with an interface similar to that of stdio using the functions that start with gz the gzip format is different from the zlib format gzip is a gzip wrapper documented in rfc wrapped around a deflate stream this library can optionally read and write gzip streams in memory as well the zlib format was designed to be compact and fast for use in memory and on communications channels the gzip format was designed for single file compression on file systems has a larger header than zlib to maintain directory information and uses a different slower check method than zlib the library does not install any signal handler the decoder checks the consistency of the compressed data so the library should never crash  {
	                                                                                                                                                                                                                                         crash :: -1000
                                                                                                                                                                                                                                             }
even in case of corrupted input typedef voidpf alloc func of voidpf opaque uint items uint size typedef void free func of voidpf opaque voidpf address struct internal state typedef struct z stream s bytef next in next input byte uint avail in number of bytes available at next in ulong total in total nb of input bytes read so far bytef next out next output byte should be put there uint avail out remaining free space at next out ulong total out total nb of bytes output so far char msg last error message null if no error struct internal state far state not visible by applications alloc func zalloc used to allocate the internal state free func zfree used to free the internal state voidpf opaque private data object passed to zalloc and zfree int data type best guess about the data type binary or text ulong adler adler value of the uncompressed data ulong reserved reserved for future use z stream typedef z stream far z streamp gzip header information passed to and from zlib routines see rfc for more details on the meanings of these fields typedef struct gz header s int text true if compressed data believed  {
	                                                                                                                                                                                                 believed :: -1000
                                                                                                                                                                                                        }
to be text ulong time modification time int xflags  {
	  oflags :: 9
	   oflag :: 7
       }
extra flags not used when writing a gzip file int os operating system bytef extra pointer to extra field or z null if none uint extra len extra field length valid if extra z null uint extra max space at extra only when reading header bytef name pointer to zero terminated file name or z null uint name max space at name only when reading header bytef comment pointer to zero terminated comment or z null uint comm max space at comment only when reading header int hcrc  {
	                                                                                  curch :: 5
                                                                                      }
true if there was or will be a header crc int done true when done reading gzip header not used when writing a gzip file gz header typedef gz header far gz headerp the application must update next in and avail in when avail in has dropped to zero it must update next out and avail out when avail out has dropped to zero the application must initialize zalloc zfree and opaque before calling the init function all other fields are set by the compression library and must not be updated by the application the opaque value provided by the application will be passed as the first parameter for calls of zalloc and zfree this can be useful for custom memory management the compression library attaches no meaning to the opaque value zalloc must return z null if there is not enough memory for the object if zlib is used in a multi threaded application zalloc and zfree must be thread safe on bit systems the functions zalloc and zfree must be able to allocate exactly bytes but will not be required to allocate more than this if the symbol maxseg k is defined see zconf h warning on msdos pointers returned by zalloc for objects of exactly bytes must have their offset normalized to zero the default allocation function provided by this library ensures this see zutil c to reduce memory requirements and avoid any allocation of k objects at the expense of compression ratio compile the library with dmax wbits see zconf h the fields total in and total out can be used for statistics or progress reports after compression total in holds the total size of the uncompressed data and may be saved for use in the decompressor particularly if the decompressor wants to decompress everything in a single step constants define z no flush define z partial flush define z sync flush define z full flush define z finish define z block define z trees allowed flush values see deflate and inflate below for details define z ok define z stream end define z need dict define z errno define z stream error define z data error define z mem error define z buf error define z version error return codes for the compression decompression functions negative values are errors positive values are used for special but normal events define z no compression define z best speed define z best compression define z default compression compression levels define z filtered define z huffman only define z rle define z fixed define z default strategy compression strategy see deflateinit below for details define z binary define z text define z ascii z text for compatibility with and earlier define z unknown possible values of the data type field though see inflate define z deflated the deflate compression method the only one supported in this version define z null for initializing zalloc zfree opaque define zlib version zlibversion for compatibility with versions basic functions zextern const char zexport zlibversion of void the application can compare zlibversion and zlib version for consistency if the first character differs the library code actually used is not compatible with the zlib h header file used by the application this check is automatically made by deflateinit and inflateinit zextern int zexport deflateinit of z streamp strm  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              rudenesses :: -1000
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       }
int level initializes the internal stream state for compression the fields zalloc zfree and opaque must be initialized before by the caller if zalloc and zfree are set to z null deflateinit updates them to use default allocation functions the compression level must be z default compression or between and gives best speed gives best compression gives no compression at all the input data is simply copied a block at a time z default compression requests a default compromise between speed and compression currently equivalent to level deflateinit returns z ok if success z mem error if there was not enough memory z stream error if level is not a valid compression level z version error if the zlib library version zlib version is incompatible with the version assumed by the caller zlib version msg is set to null if there is no error message deflateinit does not perform any compression this will be done by deflate zextern int zexport deflate of z streamp strm int flush deflate compresses  {
	                                                                                                                                                              compresses :: -1000
                                                                                                                                                                       }
as much data as possible and stops when the input buffer becomes empty or the output buffer becomes full it may introduce some output latency  {
	                 latency :: -1000
                       }
reading input without producing any output except when forced to flush the detailed semantics are as follows deflate performs one or both of the following actions compress more input starting at next in and update next in and avail in accordingly  {
	                             accordingly :: -1000
                                       }
if not all input can be processed because there is not enough room in the output buffer next in and avail in are updated and processing will resume at this point for the next call of deflate provide more output starting at next out and update next out and avail out accordingly this action is forced if the parameter flush is non zero forcing  {
	                                                        forcing :: -1000
                                                              }
flush frequently degrades  {
	windsurfs :: -1000
 }
the compression ratio so this parameter should be set only when necessary in interactive applications some output may be provided even if flush is not set before the call of deflate the application should ensure that at least one of the actions is possible by providing more input and or consuming more output and updating  {
	                                              updating :: -1000
                                                     }
avail in or avail out accordingly avail out should never be zero before the call the application can consume the compressed output when it wants for example when the output buffer is full avail out or after each call of deflate if deflate returns z ok and with zero avail out it must be called again after making room in the output buffer because there might be more output pending normally the parameter flush is set to z no flush which allows deflate to decide how much data to accumulate before producing output in order to maximize  {
	                                                                                        maximize :: -1000
                                                                                               }
compression if the parameter flush is set to z sync flush all pending output is flushed  {
	        flushed :: -1000
              }
to the output buffer and the output is aligned on a byte boundary so that the decompressor can get all input data available so far in particular avail in is zero after the call if enough output space has been provided before the call flushing may degrade compression for some compression algorithms and so it should be used only when necessary this completes  {
	                                                     completes :: -1000
                                                             }
the current deflate block and follows it with an empty stored block that is three bits plus filler bits to the next byte followed by four bytes ff ff if flush is set to z partial flush all pending output is flushed to the output buffer but the output is not aligned to a byte boundary all of the input data so far will be available to the decompressor as for z sync flush this completes the current deflate block and follows it with an empty fixed codes block that is bits long this assures  {
	                                                                                       assures :: -1000
                                                                                             }
that enough bytes are output in order for the decompressor to finish the block before the empty fixed code block if flush is set to z block a deflate block is completed and emitted as for z sync flush but the output is not aligned on a byte boundary and up to seven bits of the current block are held to be written as the next byte after the next deflate block is completed in this case the decompressor may not be provided enough bits at this point in order to complete decompression of the data provided so far to the compressor it may need to wait for the next block to be emitted this is for advanced applications that need to control the emission of deflate blocks if flush is set to z full flush all output is flushed as with z sync flush and the compression state is reset so that decompression can restart from this point if previous compressed data has been damaged or if random access is desired using z full flush too often can seriously degrade compression if deflate returns with avail out this function must be called again with the same value of the flush parameter and more output space updated avail out until the flush is complete deflate returns with non zero avail out in the case of a z full flush or z sync flush make sure that avail out is greater than six to avoid repeated flush markers due to avail out on return if the parameter flush is set to z finish pending input is processed pending output is flushed and deflate returns with z stream end if there was enough output space if deflate returns with z ok this function must be called again with z finish and more output space updated avail out but no more input data until it returns with z stream end or an error after deflate has returned z stream end the only possible operations on the stream are deflatereset or deflateend z finish can be used immediately after deflateinit if all the compression is to be done in a single step in this case avail out must be at least the value returned by deflatebound see below if deflate does not return z stream end then it must be called again as described above deflate sets strm adler to the adler checksum of all input read so far that is total in bytes deflate may update strm data type if it can make a good guess about the input data type z binary or z text in doubt the data is considered binary this field is only for information purposes and does not affect the compression algorithm in any manner deflate returns z ok if some progress has been made more input processed or more output produced z stream end if all input has been consumed and all output has been produced only when flush is set to z finish z stream error if the stream state was inconsistent for example if next in or next out was z null z buf error if no progress is possible for example avail in or avail out was zero note that z buf error is not fatal and deflate can be called again with more input and more output space to continue compressing zextern int zexport deflateend of z streamp strm all dynamically allocated data structures for this stream are freed this function discards  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          discards :: -1000
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 }
any unprocessed input and does not flush any pending output deflateend returns z ok if success z stream error if the stream state was inconsistent z data error if the stream was freed prematurely some input or output was discarded in the error case msg may be set but then points to a static string which must not be deallocated zextern int zexport inflateinit of z streamp strm initializes the internal stream state for decompression the fields next in avail in zalloc zfree and opaque must be initialized before by the caller if next in is not z null and avail in is large enough the exact value depends on the compression method inflateinit determines the compression method from the zlib header and allocates all data structures accordingly otherwise the allocation will be deferred to the first call of inflate if zalloc and zfree are set to z null inflateinit updates them to use default allocation functions inflateinit returns z ok if success z mem error if there was not enough memory z version error if the zlib library version is incompatible with the version assumed by the caller or z stream error if the parameters are invalid such as a null pointer to the structure msg is set to null if there is no error message inflateinit does not perform any decompression apart from possibly reading the zlib header if present actual decompression will be done by inflate so next in and avail in may be modified but next out and avail out are unused and unchanged the current implementation of inflateinit does not process any header information that is deferred until inflate is called zextern int zexport inflate of z streamp strm int flush inflate decompresses  {
	                                                                                                                                                                                                                                                                                   decompresses :: -1000
                                                                                                                                                                                                                                                                                              }
as much data as possible and stops when the input buffer becomes empty or the output buffer becomes full it may introduce some output latency reading input without producing any output except when forced to flush the detailed semantics are as follows inflate performs one or both of the following actions decompress more input starting at next in and update next in and avail in accordingly if not all input can be processed because there is not enough room in the output buffer next in is updated and processing will resume at this point for the next call of inflate provide more output starting at next out and update next out and avail out accordingly inflate provides as much output as possible until there is no more input data or no more space in the output buffer see below about the flush parameter before the call of inflate the application should ensure that at least one of the actions is possible by providing more input and or consuming more output and updating the next and avail values accordingly the application can consume the uncompressed output when it wants for example when the output buffer is full avail out or after each call of inflate if inflate returns z ok and with zero avail out it must be called again after making room in the output buffer because there might be more output pending the flush parameter of inflate can be z no flush z sync flush z finish z block or z trees z sync flush requests that inflate flush as much output as possible to the output buffer z block requests that inflate stop if and when it gets to the next deflate block boundary when decoding the zlib or gzip format this will cause inflate to return immediately after the header and before the first block when doing a raw inflate inflate will go ahead and process the first block and will return when it gets to the end of that block or when it runs out of data the z block option assists  {
	                                                                                                                                                                                                                                                                                                                                                  assists :: -1000
                                                                                                                                                                                                                                                                                                                                                        }
in appending to or combining deflate streams also to assist in this on return inflate will set strm data type to the number of unused bits in the last byte taken from strm next in plus if inflate is currently decoding the last block in the deflate stream plus if inflate returned immediately after decoding an end of block code or decoding the complete header up to just before the first byte of the deflate stream the end of block will not be indicated until all of the uncompressed data from that block has been written to strm next out the number of unused bits may in general be greater than seven except when bit of data type is set in which case the number of unused bits will be less than eight  {
	                                                                                                                               eight :: -1000
                                                                                                                                   }
data type is set as noted here every time inflate returns for all flush options and so can be used to determine the amount of currently consumed input in bits the z trees option behaves as z block does but it also returns when the end of each deflate block header is reached before any actual data in that block is decoded this allows the caller to determine the length of the deflate block header for later use in random access within a deflate block is added to the value of strm data type when inflate returns immediately after reaching  {
	                                                                                           reaching :: -1000
                                                                                                  }
the end of the deflate block header inflate should normally be called until it returns z stream end or an error however if all decompression is to be performed in a single step a single call of inflate the parameter flush should be set to z finish in this case all pending input is processed and all pending output is flushed avail out must be large enough to hold all the uncompressed data the size of the uncompressed data may have been saved by the compressor for this purpose the next operation on this stream must be inflateend to deallocate the decompression state the use of z finish is never required but can be used to inform inflate that a faster approach may be used for the single inflate call in this implementation inflate always flushes as much output as possible to the output buffer and always uses the faster approach on the first call so the only effect of the flush parameter in this implementation is on the return value of inflate as noted below or when it returns early because z block or z trees is used if a preset  {
	                                                                                                                                                                                         preset :: -1000
                                                                                                                                                                                              }
dictionary is needed after this call see inflatesetdictionary below inflate sets strm adler to the adler checksum of the dictionary chosen by the compressor and returns z need dict otherwise it sets strm adler to the adler checksum of all output produced so far that is total out bytes and returns z ok z stream end or an error code as described below at the end of the stream inflate checks that its computed adler checksum is equal to that saved by the compressor and returns z stream end only if the checksum is correct inflate can decompress and check either zlib wrapped or gzip wrapped deflate data the header type is detected automatically if requested when initializing with inflateinit any information contained in the gzip header is not retained so applications that need that information should instead use raw inflate see inflateinit below or inflateback and perform their own processing of the gzip header and trailer inflate returns z ok if some progress has been made more input processed or more output produced z stream end if the end of the compressed data has been reached and all uncompressed output has been produced z need dict if a preset dictionary is needed at this point z data error if the input data was corrupted input stream not conforming  {
	                                                                                                                                                                                                                conforming :: -1000
                                                                                                                                                                                                                         }
to the zlib format or incorrect check value z stream error if the stream structure was inconsistent for example next in or next out was z null z mem error if there was not enough memory z buf error if no progress is possible or if there was not enough room in the output buffer when z finish is used note that z buf error is not fatal and inflate can be called again with more input and more output space to continue decompressing if z data error is returned the application may then call inflatesync to look for a good compression block if a partial recovery of the data is desired zextern int zexport inflateend of z streamp strm all dynamically allocated data structures for this stream are freed this function discards any unprocessed input and does not flush any pending output inflateend returns z ok if success z stream error if the stream state was inconsistent in the error case msg may be set but then points to a static string which must not be deallocated advanced functions the following functions are needed only in some special applications zextern int zexport deflateinit of z streamp strm int level int method int windowbits int memlevel int strategy this is another version of deflateinit with more compression options the fields next in zalloc zfree and opaque must be initialized before by the caller the method parameter is the compression method it must be z deflated in this version of the library the windowbits parameter is the base two logarithm of the window size the size of the history buffer it should be in the range for this version of the library larger values of this parameter result in better compression at the expense of memory usage the default value is if deflateinit is used instead windowbits can also be for raw deflate in this case windowbits determines the window size deflate will then generate raw deflate data with no zlib header or trailer and will not compute an adler check value windowbits can also be greater than for optional gzip encoding add to windowbits to write a simple gzip header and trailer around the compressed data instead of a zlib wrapper the gzip header will have no file name no extra data no comment no modification time set to zero no header crc and the operating system will be set to unknown if a gzip stream is being written strm adler is a crc instead of an adler the memlevel parameter specifies how much memory should be allocated for the internal compression state memlevel uses minimum memory but is slow and reduces  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                  reduces :: -1000
                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
compression ratio memlevel uses maximum memory for optimal speed the default value is see zconf h for total memory usage as a function of windowbits and memlevel the strategy parameter is used to tune the compression algorithm use the value z default strategy for normal data z filtered for data produced by a filter or predictor z huffman only to force huffman encoding only no string match or z rle to limit match distances  {
	                                                                distances :: -1000
                                                                        }
to one run length encoding filtered data consists mostly of small values with a somewhat  {
	      somewhat :: -1000
             }
random distribution in this case the compression algorithm is tuned  {
	    tuned :: -1000
        }
to compress them better the effect of z filtered is to force more huffman coding and less string matching it is somewhat intermediate between z default strategy and z huffman only z rle is designed to be almost as fast as z huffman only but give better compression for png image data the strategy parameter only affects the compression ratio but not the correctness  {
	                                                    correctness :: -1000
                                                              }
of the compressed output even if it is not set appropriately z fixed prevents the use of dynamic huffman codes allowing for a simpler decoder for special applications deflateinit returns z ok if success z mem error if there was not enough memory z stream error if a parameter is invalid such as an invalid method msg is set to null if there is no error message deflateinit does not perform any compression this will be done by deflate zextern int zexport deflatesetdictionary of z streamp strm const bytef dictionary uint dictlength  {
                                                                                          }
initializes the compression dictionary from the given byte sequence without producing any compressed output this function must be called immediately after deflateinit deflateinit or deflatereset before any call of deflate the compressor and decompressor must use exactly the same dictionary see inflatesetdictionary the dictionary should consist of strings byte sequences that are likely to be encountered later in the data to be compressed with the most commonly used strings preferably  {
	                                                           preferably :: -1000
                                                                    }
put towards the end of the dictionary using a dictionary is most useful when the data to be compressed is short and can be predicted with good accuracy the data can then be compressed better than with the default empty dictionary depending on the size of the compression data structures selected by deflateinit or deflateinit a part of the dictionary may in effect be discarded for example if the dictionary is larger than the window size provided in deflateinit or deflateinit thus the strings most likely to be useful should be put at the end of the dictionary not at the front in addition the current implementation of deflate will use at most the window size minus bytes of the provided dictionary upon return of this function strm adler is set to the adler value of the dictionary the decompressor may later use this value to determine which dictionary has been used by the compressor the adler value applies to the whole dictionary even if only a subset of the dictionary is actually used by the compressor if a raw deflate was requested then the adler value is not computed and strm adler is not set deflatesetdictionary returns z ok if success or z stream error if a parameter is invalid e g dictionary being z null or the stream state is inconsistent for example if deflate has already been called for this stream or if the compression method is bsort  {
	                                                                                                                                                                                                                                           borts :: 6
	                                                                                                                                                                                                                                           boost :: 6
	                                                                                                                                                                                                                                           boors :: 6
	                                                                                                                                                                                                                                           boart :: 6
	                                                                                                                                                                                                                                           abort :: 6
	                                                                                                                                                                                                                                          aborts :: 7
	                                                                                                                                                                                                                                           sport :: 6
	                                                                                                                                                                                                                                           snort :: 6
	                                                                                                                                                                                                                                           short :: 6
	                                                                                                                                                                                                                                            bros :: 6
	                                                                                                                                                                                                                                          browst :: 6
	                                                                                                                                                                                                                                          broths :: 6
	                                                                                                                                                                                                                                          boarts :: 7
                                                                                                                                                                                                                                               }
deflatesetdictionary does not perform any compression this will be done by deflate zextern int zexport deflatecopy of z streamp dest z streamp source sets the destination stream as a complete copy of the source stream this function can be useful when several compression strategies  {
	                                sugarhouses :: -1000
                                          }
will be tried for example when there are several ways of pre processing the input data with a filter the streams that will be discarded should then be freed by calling deflateend note that deflatecopy duplicates the internal compression state which can be quite large so this strategy is slow and can consume lots of memory deflatecopy returns z ok if success z mem error if there was not enough memory z stream error if the source stream state was inconsistent such as zalloc being z null msg is left unchanged in both source and destination zextern int zexport deflatereset of z streamp strm this function is equivalent to deflateend followed by deflateinit but does not free and reallocate all the internal compression state the stream will keep the same compression level and any other attributes that may have been set by deflateinit deflatereset returns z ok if success or z stream error if the source stream state was inconsistent such as zalloc or state being z null zextern int zexport deflateparams of z streamp strm int level int strategy dynamically update the compression level and compression strategy the interpretation of level and strategy is as in deflateinit this can be used to switch between compression and straight copy of the input data or to switch to a different kind of input data requiring a different strategy if the compression level is changed the input available so far is compressed with the old level and may be flushed the new level will take effect only at the next call of deflate before the call of deflateparams the stream state must be set as for a call of deflate since the currently available input may have to be compressed and flushed in particular strm avail out must be non zero deflateparams returns z ok if success z stream error if the source stream state was inconsistent or if a parameter was invalid z buf error if strm avail out was zero zextern int zexport deflatetune of z streamp strm int good length int max lazy int nice length int max chain fine tune deflate s internal compression parameters this should only be used by someone who understands the algorithm used by zlib s deflate for searching for the best matching string and even then only by the most fanatic  {
	                                                                                                                                                                                                                                                                                                                                                                                            fanatic :: -1000
                                                                                                                                                                                                                                                                                                                                                                                                  }
optimizer  {
	optimizer :: -1000
 }
trying to squeeze  {
	squeeze :: -1000
 }
out the last compressed bit for their specific input data read the deflate c source code for the meaning of the max lazy good length nice length and max chain parameters deflatetune can be called after deflateinit or deflateinit and returns z ok on success or z stream error for an invalid deflate stream zextern ulong zexport deflatebound of z streamp strm ulong sourcelen  {
	                                                      opercules :: 11
	                                                     sourceless :: 13
	                                                      counseled :: 12
	                                                         source :: 11
	                                                     sourdeline :: 13
                                                              }
deflatebound returns an upper bound on the compressed size after deflation of sourcelen bytes it must be called after deflateinit or deflateinit and after deflatesetheader if used this would be used to allocate an output buffer for deflation in a single pass and so would be called before deflate zextern int zexport deflateprime of z streamp strm int bits int value deflateprime inserts  {
	                                                       inserts :: -1000
                                                             }
bits in the deflate output stream the intent is that this function is used to start off the deflate output with the bits leftover  {
	               leftover :: -1000
                      }
from a previous deflate stream when appending to it as such this function can only be used for raw deflate and must be used before the first deflate call after a deflateinit or deflatereset bits must be less than or equal to and that many of the least significant bits of value will be inserted in the output deflateprime returns z ok if success or z stream error if the source stream state was inconsistent zextern int zexport deflatesetheader of z streamp strm gz headerp head deflatesetheader provides gzip header information for when a gzip stream is requested by deflateinit deflatesetheader may be called after deflateinit or deflatereset and before the first call of deflate the text time os extra field name and comment information in the provided gz header structure are written to the gzip header xflag is ignored the extra flags are set according to the compression level the caller must assure that if not z null name and comment are terminated with a zero byte and that if extra is not z null that extra len bytes are available there if hcrc is true a gzip header crc is included note that the current versions of the command line version of gzip up through version x do not support header crc s and will report that it is a multi part gzip file and give up if deflatesetheader is not used the default gzip header has text false the time set to zero and os set to with no extra name or comment fields the gzip header is returned to the default state by deflatereset deflatesetheader returns z ok if success or z stream error if the source stream state was inconsistent zextern int zexport inflateinit of z streamp strm int windowbits this is another version of inflateinit with an extra parameter the fields next in avail in zalloc zfree and opaque must be initialized before by the caller the windowbits parameter is the base two logarithm of the maximum window size the size of the history buffer it should be in the range for this version of the library the default value is if inflateinit is used instead windowbits must be greater than or equal to the windowbits value provided to deflateinit while compressing or it must be equal to if deflateinit was not used if a compressed stream with a larger window size is given as input inflate will return with the error code z data error instead of trying to allocate a larger window windowbits can also be for raw inflate in this case windowbits determines the window size inflate will then process raw deflate data not looking for a zlib or gzip header not generating a check value and not looking for any check values for comparison at the end of the stream this is for use with other formats that use the deflate compressed data format such as zip those formats provide their own check values if a custom format is developed  {
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          developed :: -1000
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  }
using the raw deflate format for compressed data it is recommended that a check value such as an adler or a crc be applied to the uncompressed data as is done in the zlib gzip and zip formats for most applications the zlib format should be used as is note that comments above on the use in deflateinit applies to the magnitude of windowbits windowbits can also be greater than for optional gzip decoding add to windowbits to enable zlib and gzip decoding with automatic header detection or add to decode only the gzip format the zlib format will return a z data error if a gzip stream is being decoded strm adler is a crc instead of an adler inflateinit returns z ok if success z mem error if there was not enough memory z version error if the zlib library version is incompatible with the version assumed by the caller or z stream error if the parameters are invalid such as a null pointer to the structure msg is set to null if there is no error message inflateinit does not perform any decompression apart from possibly reading the zlib header if present actual decompression will be done by inflate so next in and avail in may be modified but next out and avail out are unused and unchanged the current implementation of inflateinit does not process any header information that is deferred until inflate is called zextern int zexport inflatesetdictionary of z streamp strm const bytef dictionary uint dictlength initializes the decompression dictionary from the given uncompressed byte sequence this function must be called immediately after a call of inflate if that call returned z need dict the dictionary chosen by the compressor can be determined from the adler value returned by that call of inflate the compressor and decompressor must use exactly the same dictionary see deflatesetdictionary for raw inflate this function can be called immediately after inflateinit or inflatereset and before any call of inflate to set the dictionary the application must insure  {
	                                                                                                                                                                                                                                                                                                                                           insure :: -1000
                                                                                                                                                                                                                                                                                                                                                }
that the dictionary that was used for compression is provided inflatesetdictionary returns z ok if success z stream error if a parameter is invalid e g dictionary being z null or the stream state is inconsistent z data error if the given dictionary doesn t match the expected one incorrect adler value inflatesetdictionary does not perform any decompression this will be done by subsequent calls of inflate zextern int zexport inflatesync of z streamp strm skips invalid compressed data until a full flush point see above the description of deflate with z full flush can be found or until all available input is skipped no output is provided inflatesync returns z ok if a full flush point has been found z buf error if no more input was provided z data error if no flush point has been found or z stream error if the stream structure was inconsistent in the success case the application may save the current current value of total in which indicates where valid compressed data was found in the error case the application may repeatedly call inflatesync providing more input each time until success or end of the input data zextern int zexport inflatecopy of z streamp dest z streamp source sets the destination stream as a complete copy of the source stream this function can be useful when randomly accessing a large stream the first pass through the stream can periodically  {
	                                                                                                                                                                                                                                periodically :: -1000
                                                                                                                                                                                                                                           }
record the inflate state allowing restarting  {
	restarting :: -1000
    }
inflate at those points when randomly accessing the stream inflatecopy returns z ok if success z mem error if there was not enough memory z stream error if the source stream state was inconsistent such as zalloc being z null msg is left unchanged in both source and destination zextern int zexport inflatereset of z streamp strm this function is equivalent to inflateend followed by inflateinit but does not free and reallocate all the internal decompression state the stream will keep attributes that may have been set by inflateinit inflatereset returns z ok if success or z stream error if the source stream state was inconsistent such as zalloc or state being z null zextern int zexport inflatereset of z streamp strm int windowbits this function is the same as inflatereset but it also permits  {
	                                                                                                                               permits :: -1000
                                                                                                                                     }
changing the wrap and window size requests the windowbits parameter is interpreted the same as it is for inflateinit inflatereset returns z ok if success or z stream error if the source stream state was inconsistent such as zalloc or state being z null or if the windowbits parameter is invalid zextern int zexport inflateprime of z streamp strm int bits int value this function inserts bits in the inflate input stream the intent is that this function is used to start inflating  {
	                                                                         inflating :: -1000
                                                                                 }
at a bit position in the middle of a byte the provided bits will be used before any bytes are used from next in this function should only be used with raw inflate and should be used before the first inflate call after inflateinit or inflatereset bits must be less than or equal to and that many of the least significant bits of value will be inserted in the input if bits is negative then the input stream bit buffer is emptied  {
	                                                                          emptied :: -1000
                                                                                }
then inflateprime can be called again to put bits in the buffer this is used to clear out bits leftover after feeding  {
	              feeding :: -1000
                    }
inflate a block description prior to feeding inflate codes inflateprime returns z ok if success or z stream error if the source stream state was inconsistent zextern long zexport inflatemark  {
	                     inflater :: 14
                            }
of z streamp strm this function returns two values one in the lower bits of the return value and the other in the remaining upper bits obtained by shifting  {
	                    shifting :: -1000
                           }
the return value down bits if the upper value is and the lower value is zero then inflate is currently decoding information outside of a block if the upper value is and the lower value is non zero then inflate is in the middle of a stored block with the lower value equaling  {
	                                            equaling :: -1000
                                                   }
the number of bytes from the input remaining to copy if the upper value is not then it is the number of bits back from the current bit position in the input of the code literal or length distance pair currently being processed in that case the lower value is the number of bytes already emitted for that code a code is being processed if inflate is waiting for more input to complete decoding of the code or if it has completed decoding but is waiting for more output space to write the literal or match data inflatemark is used to mark locations in the input data for random access which may be at bit positions and to note those cases where the output of a code may span  {
	                                                                                                                            span :: -1000
                                                                                                                               }
boundaries of random access blocks the current location in the input stream can be determined from avail in and data type as noted in the description for the z block flush parameter for inflate inflatemark returns the value noted above or if the provided source stream state was inconsistent zextern int zexport inflategetheader of z streamp strm gz headerp head inflategetheader requests that gzip header information be stored in the provided gz header structure inflategetheader may be called after inflateinit or inflatereset and before the first call of inflate as inflate processes the gzip stream head done is zero until the header is completed at which time head done is set to one if a zlib stream is being decoded then head done is set to to indicate that there will be no gzip header information forthcoming  {
	                                                                                                                             forthcoming :: -1000
                                                                                                                                       }
note that z block or z trees can be used to force inflate to return immediately after header processing is complete and before any actual data is decompressed the text time xflags and os fields are filled in with the gzip header contents hcrc is set to true if there is a header crc the header crc was valid if done is set to one if extra is not z null then extra max contains the maximum number of bytes to write to extra once done is true extra len contains the actual extra field length and extra contains the extra field or that field truncated if extra max is less than extra len if name is not z null then up to name max characters are written there terminated with a zero unless the length is greater than name max if comment is not z null then up to comm max characters are written there terminated with a zero unless the length is greater than comm max when any of extra name or comment are not z null and the respective field is not present in the header then that field is set to z null to signal its absence  {
	                                                                                                                                                                                                 absence :: -1000
                                                                                                                                                                                                       }
this allows the use of deflatesetheader with the returned structure to duplicate the header however if those fields are set to allocated memory then the application will need to save those pointers elsewhere so that they can be eventually freed if inflategetheader is not used then the header information is simply discarded the header is always checked for validity including the header crc if present inflatereset will reset the process to discard the header information the application would need to call inflategetheader again to retrieve the header from the next gzip stream inflategetheader returns z ok if success or z stream error if the source stream state was inconsistent zextern int zexport inflatebackinit of z streamp strm int windowbits unsigned char far window initialize the internal stream state for decompression using inflateback calls the fields zalloc zfree and opaque in strm must be initialized before the call if zalloc and zfree are z null then the default library derived memory allocation routines are used windowbits is the base two logarithm of the window size in the range window is a caller supplied buffer of that size except for special applications where it is assured  {
	                                                                                                                                                                                          assured :: -1000
                                                                                                                                                                                                }
that deflate was used with small window sizes windowbits must be and a k byte window must be supplied to be able to decompress general deflate streams see inflateback for the usage of these routines inflatebackinit will return z ok on success z stream error if any of the paramaters  {
	                                        parameter :: 13
	                                         patamars :: 13
	                                          patamar :: 12
	                                         palamate :: 13
	                                      paramagnets :: 12
	                                        parataxes :: 12
	                                       parameters :: 15
                                                }
are invalid z mem error if the internal state could not be allocated or z version error if the version of the library does not match the version of the header file typedef unsigned in func of void far unsigned char far far typedef int out func of void far unsigned char far unsigned zextern int zexport inflateback of z streamp strm in func in void far in desc out func out void far out desc inflateback does a raw inflate with a single call using a call back interface for input and output this is more efficient  {
	                                                                                        efficient :: -1000
                                                                                                }
than inflate for file i o applications in that it avoids copying between the output and the sliding  {
	          sliding :: -1000
                }
window by simply making the window itself the output buffer this function trusts  {
	      trusts :: -1000
           }
the application to not change the output buffer passed by the output function at least until inflateback returns inflatebackinit must be called first to allocate the internal state and to initialize the state with the user provided window buffer inflateback may then be used multiple times to inflate a complete raw deflate stream with each call inflatebackend is then called to free the allocated state a raw deflate stream is one with no zlib or gzip header or trailer this routine would normally be used in a utility that reads zip or gzip files and writes out uncompressed files the utility would decode the header and process the trailer on its own hence this routine expects only the raw deflate stream to decompress this is different from the normal behavior of inflate which expects either a zlib or gzip header and trailer around the deflate stream inflateback uses two subroutines  {
	                                                                                                                                          subroutines :: -1000
                                                                                                                                                    }
supplied by the caller that are then called by inflateback for input and output inflateback calls those routines until it reads a complete deflate stream and writes out all of the uncompressed data or until it encounters  {
	                          encounters :: -1000
                                   }
an error the function s parameters and return types are defined above in the in func and out func typedefs inflateback will call in in desc buf which should return the number of bytes of provided input and a pointer to that input in buf if there is no input available in must return zero buf is ignored in that case and inflateback will return a buffer error inflateback will call out out desc buf len to write the uncompressed data buf len out should return zero on success or non zero on failure if out returns non zero inflateback will return with an error neither in nor out are permitted to change the contents of the window provided to inflatebackinit which is also the buffer that out uses to write from the length written by out will be at most the window size any non zero amount of input may be provided by in for convenience inflateback can be provided input on the first call by setting strm next in and strm avail in if that input is exhausted then in will be called therefore strm next in must be initialized before calling inflateback if strm next in is z null then in will be called immediately for input if strm next in is not z null then strm avail in must also be initialized and then if strm avail in is not zero input will initially be taken from strm next in strm avail in the in desc and out desc parameters of inflateback is passed as the first parameter of in and out respectively when they are called these descriptors can be optionally used to pass any information that the caller supplied in and out functions need to do their job on return inflateback will set strm next in and strm avail in to pass back any unused input that was provided by the last in call the return values of inflateback can be z stream end on success z buf error if in or out returned an error z data error if there was a format error in the deflate stream in which case strm msg is set to indicate the nature of the error or z stream error if the stream was not properly initialized in the case of z buf error an input or output error can be distinguished  {
	                                                                                                                                                                                                                                                                                                                                                                                             distinguished :: -1000
                                                                                                                                                                                                                                                                                                                                                                                                         }
using strm next in which will be z null only if in returned an error if strm next in is not z null then the z buf error was due to out returning non zero in will always be called before out so strm next in is assured to be defined if out returns non zero note that inflateback cannot return z ok zextern int zexport inflatebackend of z streamp strm all memory allocated by inflatebackinit is freed inflatebackend returns z ok on success or z stream error if the stream state was inconsistent zextern ulong zexport zlibcompileflags of void return flags indicating compile time options type sizes two bits each bits other size of uint size of ulong size of voidpf pointer size of z off t compiler assembler and debug options debug asmv  {
                                                                                                                                     }
or asminf  {
	semina :: 7
	gamins :: 7
	admin :: 7
	famines :: 8
	ramins :: 7
	armings :: 7
	faming :: 7
	famine :: 7
	admins :: 8
 }
use asm code zlib winapi exported functions use the winapi calling convention reserved one time table building smaller code but not thread safe if true buildfixed  {
                        }
build static block decoding tables when needed dynamic crc table build crc calculation tables when needed reserved library content indicates missing functionality no gzcompress  {
	             decompress :: 14
	             recompress :: 14
	          decompressing :: 13
                      }
gz functions cannot compress to avoid linking deflate code when not needed no gzip deflate can t write gzip streams and inflate can t detect and decode gzip streams to avoid linking crc code reserved operation variations  {
	                          variations :: -1000
                                   }
changes in library functionality pkzip  {
   }
bug workaround slightly  {
	slightly :: -1000
 }
more permissive inflate fastest deflate algorithm with only one lowest compression level reserved the sprintf variant used by gzprintf zero is best vs s means limited to arguments after the format nprintf  {
	                         sprint :: 9
                              }
printf means gzprintf not secure returns value void means inferred  {
	 inferred :: -1000
        }
string length returned remainder reserved utility functions the following utility functions are implemented on top of the basic stream oriented functions to simplify the interface some default options are assumed compression level and memory usage standard memory allocation functions the source code of these utility functions can easily be modified if you need special options zextern int zexport compress of bytef dest ulongf destlen  {
	                                                         nestle :: 11
	                                                         nested :: 9
	                                                         pestle :: 9
	                                                         dentel :: 9
	                                                     desalinate :: 9
	                                                       resplend :: 9
	                                                       debtless :: 9
	                                                        settled :: 9
	                                                       desinent :: 9
	                                                        pestled :: 10
	                                                       bendlets :: 9
	                                                        destine :: 9
	                                                        gentled :: 9
	                                                        gentles :: 9
	                                                        nettled :: 9
	                                                        nettles :: 9
	                                                        nestled :: 12
	                                                        nestles :: 9
	                                                        nestler :: 10
	                                                        dentels :: 10
                                                              }
const bytef source ulong sourcelen compresses the source buffer into the destination buffer sourcelen is the byte length of the source buffer upon entry destlen is the total size of the destination buffer which must be at least the value returned by compressbound sourcelen upon exit destlen is the actual size of the compressed buffer this function can be used to compress a whole file at once if the input file is mmap ed compress returns z ok if success z mem error if there was not enough memory z buf error if there was not enough room in the output buffer zextern int zexport compress of bytef dest ulongf destlen const bytef source ulong sourcelen int level compresses the source buffer into the destination buffer the level parameter has the same meaning as in deflateinit sourcelen is the byte length of the source buffer upon entry destlen is the total size of the destination buffer which must be at least the value returned by compressbound sourcelen upon exit destlen is the actual size of the compressed buffer compress returns z ok if success z mem error if there was not enough memory z buf error if there was not enough room in the output buffer z stream error if the level parameter is invalid zextern ulong zexport compressbound of ulong sourcelen compressbound returns an upper bound on the compressed size after compress or compress on sourcelen bytes it would be used before a compress or compress call to allocate the destination buffer zextern int zexport uncompress of bytef dest ulongf destlen const bytef source ulong sourcelen decompresses the source buffer into the destination buffer sourcelen is the byte length of the source buffer upon entry destlen is the total size of the destination buffer which must be large enough to hold the entire uncompressed data the size of the uncompressed data must have been saved previously by the compressor and transmitted  {
	                                                                                                                                                                                                                                                                                                                      transmitted :: -1000
                                                                                                                                                                                                                                                                                                                                }
to the decompressor by some mechanism outside the scope of this compression library upon exit destlen is the actual size of the uncompressed buffer this function can be used to decompress a whole file at once if the input file is mmap ed uncompress returns z ok if success z mem error if there was not enough memory z buf error if there was not enough room in the output buffer or z data error if the input data was corrupted or incomplete typedef voidp gzfile zextern gzfile zexport gzopen of const char path const char mode opens a gzip gz file for reading or writing the mode parameter is as in fopen rb or wb but can also include a compression level wb or a strategy f for filtered data as in wb f h for huffman only compression as in wb h or r for run length encoding as in wb r see the description of deflateinit for more information about the strategy parameter gzopen can be used to read a file which is not in gzip format in this case gzread will directly read from the file without decompression gzopen returns null if the file could not be opened or if there was insufficient memory to allocate the de compression state errno can be checked to distinguish the two cases if errno is zero the zlib error is z mem error zextern gzfile zexport gzdopen of int fd const char mode gzdopen associates  {
	                                                                                                                                                                                                                                           associates :: -1000
                                                                                                                                                                                                                                                    }
a gzfile with the file descriptor fd file descriptors are obtained from calls like open dup creat pipe or fileno in the file has been previously opened with fopen the mode parameter is as in gzopen the next call of gzclose on the returned gzfile will also close the file descriptor fd just like fclose fdopen fd mode closes the file descriptor fd if you want to keep fd open use gzdopen dup fd mode gzdopen returns null if there was insufficient memory to allocate the de compression state zextern int zexport gzsetparams of gzfile file int level int strategy dynamically update the compression level or strategy see the description of deflateinit for the meaning of these parameters gzsetparams returns z ok if success or z stream error if the file was not opened for writing zextern int zexport gzread of gzfile file voidp buf unsigned len reads the given number of uncompressed bytes from the compressed file if the input file was not in gzip format gzread copies the given number of bytes into the buffer gzread returns the number of uncompressed bytes actually read for end of file for error zextern int zexport gzwrite of gzfile file voidpc buf unsigned len writes the given number of uncompressed bytes into the compressed file gzwrite returns the number of uncompressed bytes actually written in case of error zextern int zexportva gzprintf of gzfile file const char format converts formats and writes the args to the compressed file under control of the format string as in fprintf gzprintf returns the number of uncompressed bytes actually written in case of error the number of uncompressed bytes written is limited to the caller should assure that this limit is not exceeded if it is exceeded then gzprintf will return return an error with nothing written in this case there may also be a buffer overflow with unpredictable  {
	                                                                                                                                                                                                                                                                                                            unpredictable :: -1000
                                                                                                                                                                                                                                                                                                                        }
consequences  {
	foxiness :: -1000
 }
which is possible only if zlib was compiled with the insecure functions sprintf or vsprintf because the secure snprintf or vsnprintf functions were not available zextern int zexport gzputs of gzfile file const char s writes the given null terminated string to the compressed file excluding  {
	                                    excluding :: -1000
                                            }
the terminating null character gzputs returns the number of characters written or in case of error zextern char zexport gzgets of gzfile file char buf int len reads bytes from the compressed file until len characters are read or a newline character is read and transferred to buf or an end of file condition is encountered the string is then terminated with a null character gzgets returns buf or z null in case of error zextern int zexport gzputc of gzfile file int c writes c converted to an unsigned char into the compressed file gzputc returns the value that was written or in case of error zextern int zexport gzgetc of gzfile file reads one byte from the compressed file gzgetc returns this byte or in case of end of file or error zextern int zexport gzungetc of int c gzfile file push one character back onto the stream to be read again later only one character of push back is allowed gzungetc returns the character pushed or on failure gzungetc will fail if a character has been pushed but not read yet or if c is the pushed character will be discarded if the stream is repositioned  {
	                                                                                                                                                                                          repositioned :: -1000
                                                                                                                                                                                                     }
with gzseek or gzrewind zextern int zexport gzflush of gzfile file int flush flushes all pending output into the compressed file the parameter flush is as in the deflate function the return value is the zlib error number see function gzerror below gzflush returns z ok if the flush parameter is z finish and all output could be flushed gzflush should be called only when strictly necessary because it can degrade compression zextern z off t zexport gzseek of gzfile file z off t offset int whence sets the starting position for the next gzread or gzwrite on the given compressed file the offset represents a number of bytes in the uncompressed data stream the whence parameter is defined as in lseek the value seek end is not supported if the file is opened for reading this function is emulated  {
	                                                                                                                                   emulated :: -1000
                                                                                                                                          }
but can be extremely slow if the file is opened for writing only forward seeks  {
	         seeks :: -1000
             }
are supported gzseek then compresses a sequence of zeroes up to the new starting position gzseek returns the resulting offset location as measured in bytes from the beginning of the uncompressed stream or in case of error in particular if the file is opened for writing and the new starting position would be before the current position zextern int zexport gzrewind of gzfile file rewinds  {
	                                                         rewinds :: -1000
                                                               }
the given file this function is supported only for reading gzrewind file is equivalent to int gzseek file l seek set zextern z off t zexport gztell of gzfile file returns the starting position for the next gzread or gzwrite on the given compressed file this position represents a number of bytes in the uncompressed data stream gztell file is equivalent to gzseek file l seek cur zextern int zexport gzeof of gzfile file returns when eof has previously been detected reading the given input stream otherwise zero zextern int zexport gzdirect of gzfile file returns if file is being read directly without decompression otherwise zero zextern int zexport gzclose of gzfile file flushes all pending output if necessary closes the compressed file and deallocates  {
	                                                                                                                 reallocates :: 19
	                                                                                                                 reallocated :: 18
	                                                                                                                  reallocate :: 17
	                                                                                                                 unallocated :: 15
                                                                                                                           }
all the de compression state the return value is the zlib error number note that once file is close you cannot call gzerror with file since its structures have been deallocated zextern const char zexport gzerror of gzfile file int errnum returns the error message for the last error which occurred on the given compressed file errnum is set to zlib error number if an error occurred in the file system and not in the compression library errnum is set to z errno and the application may consult errno to get the exact error code the application must not modify the returned string and future calls to this function may invalidate the returned string zextern void zexport gzclearerr of gzfile file clears  {
	                                                                                                                   clears :: -1000
                                                                                                                        }
the error and end of file flags for file this is analogous  {
	  analogous :: -1000
          }
to the clearerr function in stdio this is useful for continuing to read a gzip file that is being written concurrently  {
	        concurrently :: -1000
                   }
checksum functions these functions are not related to compression but are exported anyway because they might be useful in applications using the compression library zextern ulong zexport adler of ulong adler const bytef buf uint len update a running adler checksum with the bytes buf len and return the updated checksum if buf is z null this function returns the required initial value for the checksum an adler checksum is almost as reliable as a crc but can be computed much faster usage example ulong adler adler l z null while read buffer buffer length eof adler adler adler buffer length if adler original adler error zextern ulong zexport adler combine of ulong adler ulong adler z off t len combine two adler checksums  {
	                                                                                                                  checkouts :: 12
	                                                                                                                   checkups :: 11
	                                                                                                                     checks :: 11
                                                                                                                          }
into one for two sequences of bytes seq and seq with lengths len and len adler checksums were calculated for each adler and adler adler combine returns the adler checksum of seq and seq concatenated requiring only adler adler and len zextern ulong zexport crc of ulong crc const bytef buf uint len update a running crc with the bytes buf len and return the updated crc if buf is z null this function returns the required initial value for the for the crc pre and post conditioning  {
	                                                                           conditioning :: -1000
                                                                                      }
one s complement is performed within this function so it shouldn t be done by the application usage example ulong crc crc l z null while read buffer buffer length eof crc crc crc buffer length if crc original crc error zextern ulong zexport crc combine of ulong crc ulong crc z off t len combine two crc check values into one for two sequences of bytes seq and seq with lengths len and len crc check values were calculated for each crc and crc crc combine returns the crc check value of seq and seq concatenated requiring only crc crc and len various hacks don t look deflateinit and inflateinit are macros to allow checking the zlib version and the compiler s view of z stream zextern int zexport deflateinit of z streamp strm int level const char version int stream size zextern int zexport inflateinit of z streamp strm const char version int stream size zextern int zexport deflateinit of z streamp strm int level int method int windowbits int memlevel int strategy const char version int stream size zextern int zexport inflateinit of z streamp strm int windowbits const char version int stream size zextern int zexport inflatebackinit of z streamp strm int windowbits unsigned char far window const char version int stream size define deflateinit strm level deflateinit strm level zlib version sizeof z stream define inflateinit strm inflateinit strm zlib version sizeof z stream define deflateinit strm level method windowbits memlevel strategy deflateinit strm level method windowbits memlevel strategy zlib version sizeof z stream define inflateinit strm windowbits inflateinit strm windowbits zlib version sizeof z stream define inflatebackinit strm windowbits window inflatebackinit strm windowbits window zlib version sizeof z stream if defined largefile source define z off t off t else if file offset bits define z off t off t endif endif if defined largefile source file offset bits zextern gzfile zexport gzopen of const char const char zextern z off t zexport gzseek of gzfile z off t int zextern z off t zexport gztell of gzfile zextern ulong zexport adler combine of ulong ulong z off t zextern ulong zexport crc combine of ulong ulong z off t endif if defined zlib internal file offset bits define gzopen gzopen define gzseek gzseek define gztell gztell define adler combine adler combine define crc combine crc combine ifndef largefile source zextern gzfile zexport gzopen of const char const char zextern off t zexport gzseek of gzfile off t int zextern off t zexport gztell of gzfile zextern ulong zexport adler combine of ulong ulong off t zextern ulong zexport crc combine of ulong ulong off t endif else zextern gzfile zexport gzopen of const char const char zextern z off t zexport gzseek of gzfile z off t int zextern z off t zexport gztell of gzfile zextern ulong zexport adler combine of ulong ulong z off t zextern ulong zexport crc combine of ulong ulong z off t endif if defined zutil h defined no dummy decl struct internal state int dummy hack for buggy compilers endif zextern const char zexport zerror of int zextern int zexport inflatesyncpoint of z streamp zextern const ulongf zexport get crc table of void zextern int zexport inflateundermine  {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           }
of z streamp int ifdef cplusplus endif endif zlib h 